### SQL №1

> **Дано**: Две таблицы с данными о заданиях, которые выполняли пользователи. Пользователи могли получить оплату за выполненные задания и дополнительное вознаграждение за эти задания в виде бонусов.

> **SQL-запрос для вывода списка, содержащего id пользователя, который получил максимальное вознаграждение, и сумму этого вознаграждения. Сгруппируйте данные по дням.**

Подробное описание решения внизу. Здесь итоговый запрос и результаты выборки.

#### Запрос
Для каждого пользователя высчитать его суммарный дневной заработок (оплата за задания + все бонусы), и для каждого дня выбрать пользователя, заработавшего больше всех.

```sql
SELECT * FROM (
  -- В этом (внутреннем) `SELECT`-е производится агрегация и суммирование заработка
  SELECT
    -- Т.к. используется `FULL JOIN`, нужно везде использовать `coalesce`
    worker_id, day, coalesce(m.total, 0) + coalesce(b.total, 0) AS total,
    -- Оконная функция для вычисления ранга пользователя за каждый день
    dense_rank() OVER (
      PARTITION BY day ORDER BY coalesce(m.total, 0) + coalesce(b.total, 0) DESC
    ) AS rank
  FROM (
    -- `to_timestamp(m.timestamp)::date` - так PostgreSQL получает день из unix-таймстемпа
    SELECT worker_id, to_timestamp(timestamp)::date AS day, sum(money) AS total
    FROM money GROUP BY worker_id, day
  -- `FULL JOIN` нужен т.к. в некоторые дни пользователь мог получать
  -- оплату за задания, но не бонусы. И наоборот
  ) AS m FULL JOIN (
    SELECT worker_id, to_timestamp(timestamp)::date AS day, sum(money) AS total
    FROM bonus GROUP BY worker_id, day
  ) AS b USING(worker_id, day)
-- В этом (внешнем) `SELECT`-е выбираем пользователя с максимальным суммарным заработком за день
) AS sub WHERE rank = 1 ORDER BY day;
```

Я использовал PostgreSQL, но большинство средств SQL есть и в других СУБД.

#### Результаты
```
 worker_id |    day     | total
-----------+------------+------
 user_3    | 2019-01-01 | 26.56
 user_3    | 2019-01-02 |    34
 user_3    | 2019-01-03 | 32.46
 user_1    | 2019-01-04 | 24.84
 user_3    | 2019-01-05 | 29.91
 user_3    | 2019-01-06 | 31.18
 user_6    | 2019-01-07 | 22.37
 user_2    | 2019-01-08 | 20.28
 user_3    | 2019-01-09 | 24.86
 user_3    | 2019-01-10 | 36.75
 user_3    | 2019-01-11 | 29.31
 user_3    | 2019-01-12 | 29.12
 user_4    | 2019-01-13 | 17.92
 user_6    | 2019-01-14 | 20.68
 user_6    | 2019-01-15 | 21.52
 user_7    | 2019-01-16 | 22.74
 user_7    | 2019-01-17 | 13.87
 user_6    | 2019-01-18 | 23.81
 user_6    | 2019-01-19 | 21.67
 user_2    | 2019-01-20 |  16.8
 user_8    | 2019-01-21 | 20.95
 user_8    | 2019-01-22 | 20.32
 user_2    | 2019-01-23 | 20.99
 user_6    | 2019-01-24 | 19.09
 user_6    | 2019-01-25 | 20.76
 user_7    | 2019-01-26 | 19.82
 user_2    | 2019-01-27 |  21.4
 user_5    | 2019-01-28 | 25.27
 user_5    | 2019-01-29 | 21.91
 user_8    | 2019-01-30 | 17.54
 user_7    | 2019-01-31 | 24.47
 user_5    | 2019-02-01 | 21.04
 user_7    | 2019-02-02 | 23.03
 user_1    | 2019-02-03 | 18.56
 user_7    | 2019-02-04 | 24.32
 user_5    | 2019-02-05 | 27.65
 user_8    | 2019-02-06 | 21.91
 user_8    | 2019-02-07 | 22.37
 user_1    | 2019-02-08 | 17.27
 user_8    | 2019-02-09 | 18.47
 user_8    | 2019-02-10 | 21.34
 user_1    | 2019-02-11 | 21.15
 user_6    | 2019-02-12 |  23.6
 user_7    | 2019-02-13 | 24.42
 user_3    | 2019-02-14 | 20.41
 user_2    | 2019-02-15 | 23.25
 user_7    | 2019-02-16 | 23.23
 user_3    | 2019-02-17 | 26.36
 user_8    | 2019-02-18 | 20.83
 user_4    | 2019-02-19 | 29.93
 user_7    | 2019-02-20 | 23.54
 user_1    | 2019-02-21 | 27.13
 user_5    | 2019-02-22 | 21.45
 user_3    | 2019-02-23 | 25.05
 user_1    | 2019-02-24 | 20.07
 user_1    | 2019-02-25 | 22.32
 user_6    | 2019-02-26 | 25.71
 user_6    | 2019-02-27 | 22.85
 user_1    | 2019-02-28 | 16.69
 user_1    | 2019-03-01 |  18.9
 user_2    | 2019-03-02 |  19.3
 user_5    | 2019-03-03 | 23.79
 user_4    | 2019-03-04 | 55.67
 user_4    | 2019-03-05 | 47.88
 user_4    | 2019-03-06 | 52.18
 user_4    | 2019-03-07 | 67.25
 user_4    | 2019-03-08 | 56.59
 user_4    | 2019-03-09 |  51.6
 user_4    | 2019-03-10 |  53.5
 user_8    | 2019-03-11 | 24.29
 user_4    | 2019-03-12 | 17.31
 user_1    | 2019-03-13 | 21.93
 user_5    | 2019-03-14 | 25.64
 user_2    | 2019-03-15 | 23.94
 user_5    | 2019-03-16 | 18.04
 user_6    | 2019-03-17 | 18.62
 user_7    | 2019-03-17 | 18.62
 user_2    | 2019-03-18 |  21.4
 user_2    | 2019-03-19 | 19.33
 user_7    | 2019-03-20 | 22.75
 user_8    | 2019-03-21 | 20.96
 user_7    | 2019-03-22 | 21.59
 user_7    | 2019-03-23 | 19.94
 user_1    | 2019-03-24 | 22.83
 user_1    | 2019-03-25 | 24.31
 user_8    | 2019-03-26 | 28.57
 user_4    | 2019-03-27 | 22.45
 user_1    | 2019-03-28 | 23.91
 user_7    | 2019-03-29 | 21.65
 user_2    | 2019-03-30 | 25.31
 user_2    | 2019-03-31 | 25.25
 user_8    | 2019-04-01 |  4.73
(92 rows)
```

#### Ход решения

Создаем две таблицы:

```sql
CREATE TABLE money ("task_id" int, "timestamp" bigint, "money" real, "worker_id" int);
CREATE TABLE bonus ("timestamp" bigint, "money" real, "worker_id" int);
```

Скачиваем файлы и заливаем данные через командную строку. Для упрощения `JOIN`-ов и экономии места подготавливаем данные: обрезаем префиксы у ID пользователей и тасков. Отбрасываем также строку заголовка:

```bash
sed -E '1d;s/\b(task|user)_//g' ./sql_money_tbl\ \(1\).tsv | psql -d test -c 'COPY money FROM stdin'
sed -E '1d;s/\buser_//g' ./sql_bonus_tbl.tsv | psql -d test -c 'COPY bonus FROM stdin'
```

Делаем запросы к созданным и заполненным таблицам. Наиболее простым и очевидным будет суммирование вознаграждений за задания и бонусов по дням:

```sql
SELECT worker_id, to_timestamp(timestamp)::date AS day, sum(money) FROM money GROUP BY worker_id, day;
SELECT worker_id, to_timestamp(timestamp)::date AS day, sum(money) FROM bonus GROUP BY worker_id, day;
```

Здесь `to_timestamp(timestamp)::date` - то, как PostgreSQL вычленяет день (дату) из unix-таймстемпов. Другие диалекты SQL будут иметь свой способ.

Суммарное вознаграждения пользователя за день складывается из оплаты за задания и бонусов. Нужно учитывать, что пользователь может получать бонусы в дни, когда не выполняет задания, и выполнять задания, не получая бонусов. Это условие потребует `FULL JOIN`-а, чтобы не потерять ни оплату за задания, ни бонусы. Так как при `FULL JOIN`-е столбцы могут получать значение `NULL`, в выборе приходится использовать функцию `coalesce(,)`, возвращающую ненулевой аргумент.

Сам `JOIN` делаем по условию равенства ID пользователей и совпадению дней:

```sql
SELECT m.total + b.total
FROM      (SELECT FROM money ...) AS m
FULL JOIN (SELECT FROM bonus ...) AS b
USING (worker_id, ...::date);
```

В тех диалектах SQL, где `FULL JOIN`-а нет (например, MySQL) его можно сэмулировать через `UNION`.

Получаем такую выборку (пример для трех ID):

```
worker_id |    day     | total
-----------+------------+------
         0 | 2019-01-01 |  1.23
         1 | 2019-01-01 | 11.95
         2 | 2019-01-01 | 10.41
-------------------------------
         0 | 2019-01-02 |  2.96
         1 | 2019-01-02 |  9.28
         2 | 2019-01-02 | 17.92
-------------------------------
         0 | 2019-01-03 |  1.25
         1 | 2019-01-03 | 17.44
         2 | 2019-01-03 |  20.8
-------------------------------
         0 | 2019-01-04 |  0.88
         1 | 2019-01-04 | 24.84
         2 | 2019-01-04 | 13.28
```

Нужно выбрать `worker_id` с максимальной суммой в каждой группе (partition-е). В YQL (Yandex Query Language) для этого есть очень удобная функция `max_by()`. К сожалению, в стандарте SQL она недоступна, и нам придется использовать другой метод - *оконные функции*, а именно `dense_rank()`:

```sql
dense_rank() OVER (PARTITION BY day ORDER BY total DESC) AS rank
```

Разделяя выбранные записи по дням (`PARTITION BY`), и упорядочивая их по суммарному заработку (`ORDER BY DESC` - от большего к меньшему) мы сможем, таким образом, присвоить каждой записи ранг:

```
 rank | worker_id |    day     | total
------+-----------+------------+------
    3 |         0 | 2019-01-01 |  1.23
    1 |         1 | 2019-01-01 | 11.95
    2 |         2 | 2019-01-01 | 10.41
--------------------------------------
    3 |         0 | 2019-01-02 |  2.96
    2 |         1 | 2019-01-02 |  9.28
    1 |         2 | 2019-01-02 | 17.92
--------------------------------------
    3 |         0 | 2019-01-03 |  1.25
    2 |         1 | 2019-01-03 | 17.44
    1 |         2 | 2019-01-03 |  20.8
--------------------------------------
    3 |         0 | 2019-01-04 |  0.88
    1 |         1 | 2019-01-04 | 24.84
    2 |         2 | 2019-01-04 | 13.28

```

Остается обернуть этот запрос в еще один `SELECT` и отфильтровать по рангу:

```sql
SELECT * FROM (SELECT ... FULL JOIN ...) WHERE rank = 1;
```

Пользователь с рангом 1 и будет тем, чей суммарный заработок в день максимален:

```
 rank | worker_id |    day     | total
------+-----------+------------+------
    1 |         1 | 2019-01-01 | 11.95
--------------------------------------
    1 |         2 | 2019-01-02 | 17.92
--------------------------------------
    1 |         2 | 2019-01-03 |  20.8
--------------------------------------
    1 |         1 | 2019-01-04 | 24.84
```

Плюсом является то, что при такой выборке, если будет несколько пользователей с одинаковым максимальным заработком, всем им будет присвоен ранг 1, и все они будут отобраны в топ (пример - '2019-03-17', юзеры 6 и 7).
