# Списки команд

Plumbing:

- `[pi]` = `plumbinginterrogators`
- `[pm]` = `plumbingmanipulators`
- `[ph]` = `purehelpers`
- `[sh]` = `synchelpers`
- `[sr]` = `synchingrepositories`

Porcelain:

- `[ai]` = `ancillaryinterrogators`
- `[am]` = `ancillarymanipulators`
- `[mp]` = `mainporcelain`
- `[fi]` = `foreignscminterface`

Misc:

- `ls -la /usr/share/doc/git-doc/cmds-*` - все списки
- `git --list-cmds=list-<list>` - получение списка
- `git config --global alias.list-mp '--list-cmds=list-mainporcelain'` - добавление алиаса
- `ls -la /usr/lib/git-core/` - папка с бинарниками

# Материалы

## Онлайн-ресурсы

- оф. сайт: <https://git-scm.com>
- репозиторий: <https://github.com/git/git>
- Git Developer Pages: <https://git.github.io>
- GitHub (+ твиттер): <https://github.com> (<https://twitter.com/github>)
- BitBucket (+ твиттер): <https://bitbucket.org/product/> (<https://twitter.com/bitbucket>)

## Книги

ProGit:

- en: <https://git-scm.com/book/en/v2>
- ru: <https://git-scm.com/book/ru/v2>
- ru (полный перевод): <https://www.piter.com/collection/all/product/git-dlya-professionalnogo-programmista-2>
- исходники: <https://github.com/progit/progit2>

Другие: <https://git-scm.com/doc/ext>, + сеть.

## Внутренняя документация

Спец. разделы (ссылки есть в секции "Further documentation" в `git help git`):

- Git User Manual ([/usr/share/doc/git-doc/user-manual.html][um])
- Git Howto Index ([git-doc/howto-index.html][hti] -> [git-doc/howto/][ht])
- Git API Documents ([git-doc/technical/api-index.html][api] -> [git-doc/technical/][ap])

[um]:  file:///usr/share/doc/git-doc/user-manual.html
[ht]:  file:///usr/share/doc/git-doc/howto/
[hti]: file:///usr/share/doc/git-doc/howto-index.html
[ap]:  file:///usr/share/doc/git-doc/technical/
[api]: file:///usr/share/doc/git-doc/technical/api-index.html

Папка документации: `ls -la /usr/share/doc/git-doc/`.

`<!-- Разобрать содержимое полностью -->`

Онлайн: <https://git-scm.com/docs>

## Чит-листы (cheat sheets)

- интерактивный (en): <http://ndpsoftware.com/git-cheatsheet.html>
- от GitHub-а (ru): <https://github.github.com/training-kit/downloads/ru/github-git-cheat-sheet/>

## Прочее

- справочные материалы от ГитХаба: <http://try.github.io>
- вики на kernel.org: <http://git.wiki.kernel.org>
- мейл-листы разработчиков и irc-каналы, ссылки есть на <https://git-scm.com/community>

## [ai] help

Показ справки по команде или гайдлайна.

- `git help [ --web | --man ] <command|guide>` - страница справки
- `git help --guides | -g` - список гайдов

Включение просмотра через браузер: `git config --global help.format web` (+ есть выбор браузера, `web.browser firefox`). Интересные случаи:

- `git help git`
- `git help help`

# Объектная база

## Объекты в репозитории

Все четыре типа хранятся в `.git/objects/[a-z0-9]{2}/`. Формат:

- объект: `object = "<type> <size-in-bytes>\0<content>"`
- имя файла: `sha1(<object>)`
- содержимое файла: `zip(<object>)`

Контент (`git cat-file -p`):

- блобы

      <content>

- деревья

      <mode> {tree|blob} <sha1> <file-name>
      <mode> {tree|blob} <sha1> <file-name>
      ...

- аннотированные теги

      object <sha1>
      type <blob|tree|commit|tag>
      tag <tag-name>
      tagger John Doe <tagger@example.com> 1559945764 +0400

      <tag-message>
      <multi-line-signature>

  На легковесном теге и `[pi] cat-file` и `[mp] show` выдают содержимое коммита.

- коммиты

      tree <sha1>
      parent <sha1>
      parent <sha1>
      ...
      author John Doe <author@example.com> 1565198977 -0700
      committer Jane Doe <committer@example.com> 1565198977 -0700

      <commit-message>
      <multi-line-signature>

Git поддерживает механизм "альтернатив" - файлы `./git/objects/info/alternates` и `.git/objects/info/http-alternates`. В них можно построчно перечислить пути (урлы) к другим объектным базам, в которых будет вестись поиск в случае если в текущей базе нужного хеша нет. Используются всеми локальными утилитами и HTTP-фетчером при сетевых операциях.

## [pm] hash-object

Хеш по файлу или строке. Получает на вход *контент*, и выводит хеш *объекта* в stdout:

- `git hash-file [-w] <file-path>`
- `echo "<content>" | git hash-file [-w]`

Нужно помнить, что `hash-object` дает SHA1 не самого контента, а объекта (заголовка `<type> <size-in-bytes>\0` + контент). Опция `-w` (дополнительно) физически пишет зипованный объект в базу.

## [pi] cat-file

Просмотр содержимого объекта:

- `git cat-file -p <revision>`

Разжимает файл и отбрасывает заголовок; выводит только контент. Результат для различных типов объектов показан в списке выше.

## [mp] show

Просмотр содержимого объекта, без внутренней структуры:

- `git show [ --show-signature ] [ --no-patch | -s ] <revision>`

В отличии от `[pi] cat-file` (см. список выше) не выводит внутренние подробности строения объектов. Дата выводится в человеко-читаемом формате:

- блобы

      <content>

- деревья (= `git ls-tree --name-only`)

      <file-name>
      <file-name>
      ...

- аннотированные теги

      tag <tag-name>
      Tagger: John Doe <tagger@example.com>
      Date: Sat Jun 8 02:16:04 2019 +0400

      <tag-message>
      <multi-line-signature>

      <commit>

- коммиты (= `git log -p`)

      commit <sha1> [<tags-refering>]
      <multi-line-info-about-signature>
      [Merge: <short-sha1> <short-sha2> ...]
      Author: John Doe <author@example.com>
      Date: Sat Jun 8 02:16:04 2019 +0400

      <commit-message>
      <multiline-diff>

Для форматирования патчей, команда принимают все опции `[mp] diff`. Для показа коммитов принимает некоторые опции `[mp] log`, такие как `--[no-]abbrev-commit`, `--pretty[=<format>]`, `--oneline` и т.д. В мане к команде есть об использовании кодировок в путях файлов и контенте объектов.

## [pi] ls-tree

Просмотр содержимого дерева. Корректно разыменовывает любые объекты (теги, коммиты, ссылки), приводящиеся к tree-ish. Вывод команды можно лимитировать через `<pattern>` (`-r` = recursive):

- `git ls-tree [-r] <tree-ish> [<pattern>]`

Формат вывода (размеры для блобов выводятся через `--long | -l`):

      <mode> <blob|tree> <sha1>[ <blob-size|->] <entry-name>
      <mode> <blob|tree> <sha1>[ <blob-size|->] <entry-name>
      ...

Это корректный входной формат для `git update-index --index-info --stdin`.

## [pi] unpack-file

Создает в текущей директории временный файл формата `.merge_file_\w+` (напр., `.merge_file_GIZzRz`) и пишет в него контент указанного блоба:

- `git unpack-file <sha1>`

Имя созданного файла выводится в stdout.

# Индекс и коммиты

## Формат индекса

Термины *index*, *stage* и *cache* равнозначны.

- [git-doc/technical/index-format.html][if]
- <https://mincong-h.github.io/2018/04/28/git-index/>

[if]: file:///usr/share/doc/git-doc/technical/index-format.html

Общий формат бинарного файла `.git/index`:

      Header (12 byte; "DIRC <index-version:(2|3|4)> <entries-number>")
      Entries list
      Extensions
      SHA-1 of the index file before this checksum (160 bit)

Entry, элемент списка (данные из системного вызова `stat()`):

- `ctime`, время последнего изменения метаданных файла (командами `chmod`/`chown`/`ln`)
- `mtime`, время последнего изменения содержимого файла
- `dev`, ID устройства, на котором расположен файл
- `ino`, номер индексного дескриптора файловой системы (inode)
- `object type`, тип объекта git: 1000 (regular file), 1010 (symbolic link) и 1110 (gitlink)
- `perm:(0755|0644)`, UNIX-права, только 2 возможных значения для файлов. Симлинки и git-линки имеют в этом поле `0`
- `uid`, ID владельца файла
- `gid`, ID группы владельца файла
- `file-size`, размер файла в байтах
- `sha1`, хеш объекта (160 бит)
- `flags`, флаги, зависят от версии
- `file-path`, относительно рабочей директории верхнего уровня. В v4 идет префиксное сжатие этого поля относительно предыдущего (видимо, нужно для паковки)

Элементы (entries) индекса сортируются сначала по полю `file-path`, рассматриваемому как строка беззнаковых битов (без локализации, учёта `/` и т.д.; это для `memcmp()`), а потом по `stage-level`.

Дополнительные флаги в версиях выше 2 читаются только тогда, когда `extended-flag=1`; во второй версии он всегда ноль и эти два флага игнорируются:

- v2: `assume-unchanged:(1|0)`, `extended-flag=0`, `stage-level:[0-3]`, `file-name-length`
- v3, v4: дополнительно `skip-worktree:(1|0)`, `intent-to-add:(1|0)`

Расширения и их сигнатуры:

- Cached tree (`TREE`). Содержит хеши деревьев, которые могут быть сгенерированы по индексу. Это ускоряет запись деревьев при коммите. При изменении какого-либо пути в индексе хеш соответствующего дерева инвалидируется
- Resolve undo (`REUC`). При разрешении конфликтов (напр., `git add <path>`) все вхождения со `stage-level` больше нуля удаляются из индекса. Это расширение сохраняет их, чтобы можно было воспроизвести конфликт с нуля (напр., через `git checkout -m`)
- Split index (`link`). Поддерживает режим *split index*, храня `sha1` "расщепленного" индекса. Сам файл такого индекса хранится в `.git/sharedindex.<sha1>`
- Untracked cache (`UNTR`). Хранит кеш неотслеживаемых файлов. Имеет довольно сложную структуру, учитывает файл `.git/info/exclude`
- File system monitor (`FSMN`). Поддерживает совместную работу гита с системным файловым монитором, хранит метаданные для взаимодействия с этим монитором
- Index entry offset table (`IEOT`). Помогает определить стоимость задействования многопоточности при загрузке индекса в память. Хранит количество элементов (entries) в блоках и смещения этих блоков в бинарном индексе
- End of index entry (`EOIE`). Ничего не делает, маркирует конец списка расширений. Хранит их сигнатуры и смещения в бинарном индексе

## [pi] ls-files

Просмотр индекса и/или рабочего дерева. Выводит списки файлов, рабочий каталог (`--others` - untracked files) + индекс:

- `git ls-files [ --stage | --debug ] <pattern>`

По умолчанию выводит просто список файлов, а со `--stage`:

      <mode> <sha1> <stage-level> <file-path>
      <mode> <sha1> <stage-level> <file-path>
      ...

Опция `--debug` выводит данные от `lstat()`. `<pattern>` лимитирует файлы по пути.

## [pm] update-index

Регистрация контента в индексе. Пишет хеш/пермишны/имя файла в индекс. Сбрасывает `stage`-биты в ноль (*fully merged state*). Для файла, если не указана опция `--info-only`, - физически пишет объект в базу. Команда по умолчанию игнорирует скрытые файлы (в том числе во вложенных директориях, `./file` и `dir/./file`) в общих паттернах; для их (файлов) добавления нужно указывать полные имена.

Две формы, через файл в рабочей директории и через контент в базе объектов:

- `git update-index [<file> ...]`
- `git update-index --cacheinfo <mode>,<object>,<file>`

Опции:

- `--add / --remove / --refresh`. По умолчанию команда только обновляет уже имеющиеся в индексе файлы. `--refresh` не обновляет хеши, только `stat`-информацию
- `--[no-]assume-unchanged` (см. флаги индекса). Не переписывает хеш файла с указанным именем, а только выставляет бит. После этого файл начинает считаться git-ом неизмененным (напр., при мерджах). Бывает полезно на системах с медленным `lstat` (можно маркировать неменяющиеся директории и файлы)
- ` --[no-]skip-worktree` (см. флаги индекса). То же. Похож на предыдущий, но предназначен для другого (?). С этим битом Git считает файл в рабочей директории неизменным, и читает содержимое из индекса, не из рабочей папки (?)
- `--[no-]fsmonitor-valid` (см. флаги индекса). То же.
- `--[no-]split-index`, `--[no-]untracked-cache`, `--[no-]fsmonitor` включают/выключают расширения в индексе (см. выше)
- `--index-info` для скриптов и чтения из stdin. Корректно принимает данные от `git ls-tree` и `git ls-files --stage`

## [pm] write-tree

Создание по индексу объекта-дерева и запись его в базу. Выводит в stdout хеш созданного дерева. Индекс должен быть в полностью слитом состоянии:

- `git write-tree [--missing-ok] [--prefix=<prefix>/]`

Опция `--prefix` пишет поддерево из индекса, а `--missing-ok` игнорирует отсутствующие в базе хеши из индекса (всё равно создает дерево).

## [pm] mktree

Создание объекта-дерева по результату `[pi] ls-tree` и запись его в базу. Читает из stdin выхлоп нерекурсивного `[pi] ls-tree` и создает в базе объект-дерево. Выводит его полный хеш:

- `git ls-tree <tree-ish> | git mktree`

## [pm] commit-tree

Создание коммита по дереву. Пишет созданный объект коммита в базу и выводит его `sha1` в stdin. Команда низкоуровневая, и сама по себе ветки не двигает:

- `git commit-tree [-p <parent> ...] [-m <message> ] <tree>`

Данные об авторе и коммитере берутся из env-переменных `GIT_AUTHOR_*` и `GIT_COMMITTER_*`, а если они не заданы - из конфига гита (`user.name`, `user.email`).

## [pm] read-tree

Чтение дерева из базы в индекс и (опционально) слияние. Не изменяет никакие объекты в базе. С префиксом вычитывает в указанный подкаталог, с `--empty` просто очищает индекс. С опцией `-m` также выполняет слияние, а дополнительно с `-u`, - еще и обновление рабочего каталога после слияния:

- `git read-tree [--prefix=<prefix>] <tree-ish>`
- `git read-tree --empty`
- `git read-tree [-m [-u]] <tree-ish1> [<tree-ish2> [<tree-ish3>]]`

Команда низкоуровневая, и выполняет лишь более простые слияния, чем porcelain; если что-то не может - оставляет файлы в неслитом состоянии. Опция `--trivial` еще упрощает - запрещает любые слияния уровня файлов, `--aggressive` же наоборот разрешает немного более сложные.

При слиянии (опция `-m`) играет роль количество деревьев в аргументах команды. Одно - как без опции `-m`, два - перемотка (fast-forward) и три - трехстороннее слияния (3-way merge). В man-странице к команде подробно описаны алгоритмы всех таких слияний.

Включив опцию конфига `core.sparseCheckout` и заполнив файл `.git/info/sparse-checkout` (синтаксис аналогичен `.gitignore`) можно использовать т.н. "разреженный" checkout (*sparse checkout*). `git read-tree` и остальные команды, использующие слияния (`[mp] merge`, `[mp] checkout`, ...) начнут по паттернам в этом файле выставлять путям в индексе `skip-worktree`-бит (см. выше).

## [pm] checkout-index

Копирование файлов из индекса в рабочий каталог. Без аргументов не делает ничего (это для того, чтобы читаемые из stdin пустые команды в pipeline-ах игнорировались). `<file-path>` фильтрует индекс по паттерну:

- `git checkout-index [--force] --all`
- `git checkout-index [--force] <file-path>`

Опция `--force` перезапишет существующие файлы (по умолчанию их не трогает). Опции `--temp` и `--stage=<number> | all` позволяют чекаутить временные файлы (это для `[am] mergetool`).

## Три дерева

`ls -la / tree`  |       | `ls-files` |       | `ls-tree`    |       |`Commit`
---------------- | ----- | -----------| ----- | ------------ | ----- | -------------
`update-index`   | `-->` |            | `<--` | `read-tree`  |       |
`checkout-index` | `<--` |            | `-->` | `write-tree` | `-->` | `commit-tree`

## [pm] mktag

Как и вторая `mk*`-команда, читает из stdin контент объекта-тега, и пишет новый объект в базу. Выводит хеш созданного тега:

- `echo "object <sha1>\ntype <typename>\ntag <tagname>\ntagger <tagger>\n\n<message>" | git mktag`

## [mp] tag

Управление тегами: просмотр, создание, удаление, верификация. Создает ссылку в `refs/tags/`, а для аннотированного тега - еще и объект в базе:

- `git tag [ --list | -l ] <pattern>` - без аргументов или с `-l` выводит все теги (`<pattern>` лимитирует)
- `git tag [ -a | -s ] <tagname> [ <commit> | <object> | HEAD ]` - создает тег
- `git tag [ --verify | -v ] <tagname>` - верифицирует GPG-сигнатуру тега
- `git tag [ --delete | -d ] <tagname>` - удаление

Три опции создают аннотированные теги: `--annotate | -a` - неподписанный, `-local-user= | -u <keyid>` - с указанным PGP-ключом, и `--sign | -s` - с дефолтным ключом (из конфига гита, а если не задан - по email-адресу автора). Опции `--message= | -m <msg>` и `--file= | -f <file>` неявно подразумевают `-a`, но не открывают редактор. Опция `--[no-]create-reflog` и переменная конфига `core.logAllRefUpdates` управляют записью в рефлог.

Аннотированные теги предназначены для релизов, тогда как легковесные - для внутреннего и временного использования. Поэтому некоторые команды, напр., `[mp] describe`, игнорируют легковесные теги по умолчанию.

Опция `--force | -f` позволяет переписать существующий тег. Делать это на уже запушаных в публичный репозиторий тегах категорически не рекомендуется. Ман-страница команды рекомендует при ошибочной маркировке релиза просто давать новое имя и создавать новый тег. Для переписывания же нужно рассылать всем пользователям сообщения, чтобы они вручную удаляли старый тег (`git tag -d X`), вытягивали новый (`git fetch origin tag X`) и проверяли его (`git rev-parse X` should return 012345).

## [mp] add

Porcelain-версия `[pm] update-index`. Без `-f` не добавляет игнорируемые файлы:

- `git add [ [--] <file> ... ]`

Некоторые опции:

- `--verbose | -v` и `--dry-run | -n` - стандартные
- `-A | --all | --no-ignore-removal` - не игнорировать удаленные, приводить индекс к рабочему каталогу
- `--interactive | -i` - запуск интерактивного режима
- `--patch | -p` - переход сразу к п. `5: patch` в интерактивном режиме, для добавления по частям
- `--edit | -e` - запуск редактора diff-а, для добавления по частям
- `--intent-to-add | -N` - аналог `--info-only` для `[pm] update-index`, не пишет объект в базу
- `--chmod=(+|-)x` - изменяет (только в индексе) пермишн файла

Интерактивный режим. Можно переключаться цифрами или первыми буквами (или целыми словами). В меню с `>>` можно указывать больше одного выбора, через пробел/запятую или диапазоном, через дефис: `"2-5 7,9"` = `2,3,4,5,7,9`. Диапазон с одной границей: `5-`. Выбор всего: `*`. Удаление ранее выбранного: `-2`. Enter на пустой строке выходит из `>>`-меню.

1. **s**tatus - показывает краткую сводку `staged / unstaged / path`, аналог `[pm] status`
2. **u**pdate - собственно добавление, переход в новое меню и выбор (цифрами) файлов из списка `1. status`
3. **r**evert - отменить добавление в индекс, аналог `git reset HEAD <file>`
4. **a**dd untracked - в списке `1. status` нет неотслеживаемых, добавлять через `2. update` нельзя, только здесь
5. **p**atch - добавление по частям, выбор файла -> выбор hunk-а -> выбор (буквами `[y,n,q,a,d,e,?]`) действия
6. **d**iff - выбор файла из списка `1. status` и просмотр его диффа
7. **q**uit
8. **h**elp

Редактирование патчей, `--edit` или `e` на hunk-е в интерактивном режиме. Подсказки есть прямо в редакторе, в комментариях:

- `+` - добавить строку. Удаление всей строки предотвращает добавление
- `-` - удалить строку. Замена минуса на пробел предотвращает удаление
- `+\n-` - изменить строку. Предотвращение - замена "`-`" на "` `" и убрать `+`-строки. Частичное редактирование может вызвать конфликты в индексе
- остальные модификации патча (добавление/удаление/модификация контекстных строк, добавление несуществующих `+/-`-строк и т.д.) приведут к тому, что индекс перестанет совпадать с рабочим деревом (в рабочем каталоге будет показываться отмена изменений), или патч не наложится совсем

## [mp] rm

Porcelain-версия `[pm] update-index` + (опционально) `rm`. Удаляет файлы из индекса и (опционально) из рабочего каталога:

- `git rm [ --force | -f ] [ --cached ] <file>`

Файл в рабочем каталоге не должен быть изменен, чтобы `rm` не удалила несохраненные изменения. С `--cached` он может иметь изменения, но тогда контент в индексе должен совпадать с `HEAD:<file>`. Опция `--force` позволяет обойти проверки в обоих случаях.

`git rm --cached -- X` - не то же самое, что `git reset HEAD -- X`. Первая удаляет файл из индекса, и он ен войдет в следующий коммит. Вторая же лишь возвращает файл в индексе в исходное состояния (revert).

Команда не сработает, если файлов нет в рабочем каталоге. В мане к команде приводится три способа удаления из индекса несуществующих в рабочем дереве файлов:

- `git commit -a`
- `git add -A`
- `git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached`

## [mp] mv

Переименовывает (перемещает) файл в индексе и в рабочем каталоге:

- `git mv <source> <destination>`

Грубый эквивалент: `mv X Y; git rm X; git add Y`.

## [mp] commit

Запись коммита в базу:

- `git [ --message=<msg> | -m <msg> ] commit` - файлы должны быть предварительно добавлены/удалены в индексе через `[mp] add`/`[mp] rm`
- `git commit [--] <files> ...` - коммитает только указанные файлы. Текущий индекс не затрагивается (остается неизменным после коммита), деревья формируются в отдельном файле `index.lock` (так ли это?)
- `git commit -a` - автоматически добавляет в индекс все измененные/удаленные файлы рабочего каталога, но только отслеживаемые. Игнорирует неотслеживаемые файлы
- `git commit [ --interactive | --patch ]` - вызывает интерактивное меню `[pm] add`, а потом редактор с сообщением коммита

Некоторые опции:

- `--template=<file> | -t <file>` - запуск редактора с содержимым указанного файла. Обычно вместо этой опции используется переменная конфига `commit.template`
- `--amend` = `git reset --soft HEAD^; git commit -c ORIG_HEAD` - "исправляет" последний коммит. Фактически, создает новый коммит с `@~`-родителем, используя текущий индекс
- `--no-verify | -n` обходит `pre-commit`- и `commit-msg`-хуки, а `--no-post-rewrite` - соответственно `post-rewrite`-хук
- `--author=<author>` и `--date=<date>` задают имя+почту и дату для поля "автор коммита"
- `--gpg-sign[=<keyid>] | -S[<keyid>]` - подписывает коммит, `--no-gpg-sign` отменяет опцию конфига `commit.gpgSign`
- `--signoff | -s` - добавляет `Signed-off-by`-строку в конец сообщения <!-- TODO: разобрать -->

Редактор сообщения выбирается по переменным среды и конфига, в порядке `GIT_EDITOR` -> `core.editor` -> `VISUAL` -> `EDITOR`. Символ `#` в сообщениях является комментарием, и строки за ним в итоговый текст не попадут. В процессе редактирования сообщение хранится в `.git/COMMIT_EDITMSG`.

Если сразу после коммита были найдены ошибки, то его можно безопасно откатить через `[mp] reset`.

## [mp] clean

Удаляет неотслеживаемые файлы из рабочего каталога (`<path>` лимитирует удаления):

- `git clean { --force | -f } [-x | -X] [--] <path>` - без `-f` команда не будет удалять файлы
- `git clean { --interactive | -i } ...` - интерактивный режим
- `git clean { --dry-run | -n } ...` - тест, ничего не удаляет

Опции `-x`/`-X` управляют игнорируемыми файлам. `-x` удаляет и их тоже (бывает полезно для чистки директорий сборок, типа `./build/`), а `-X` удаляет только игнорируемые (для примера с `build` оставляет, таким образом, созданные вручную файлы).

Интерактивный режим:

1. **c**lean - собственно удаление
2. **f**ilter by pattern - перебрасывает в `>>`-меню, где можно задавать паттерны, которые исключают файлы из списка на удаление
3. **s**elect by numbers - перебрасывает в `>>`-меню со списком файлов/каталогов под номерами. Выбираешь, какие удалять
4. **a**sk each - запускает интерактивное удаление, спрашивает про каждый файл
5. **q**uit
6. **h**elp

## [mp] status

Показывает состояние рабочего дерева - разницу между рабочим каталогом и индексом и неотслеживаемые файлы ("то, что вы могли бы закоммитать", *could*), и индексом и `HEAD` ("то, что вы закоммитаете", *would*):

- `git status [<options> ...] [--] [<pathspec> ...]`

`<pathspec>` лимитирует пути, для которых выводится информация. Некоторые опции:

- `--short | -s` - короткий формат. С `--branch | -b` покажет еще и разницу между веткой и апстримом
- `--porcelain[=<version>]` - тот же короткий формат, но для скриптов, без цветов и не меняющийся между версиями
- `--show-stash` - показывать заначки
- `--verbose | -v` - показывать диффы для уже добавленного в индекс. Повторенная дважды, опция покажет диффы и для недобавленного
- `--untracked-files[=<mode>] | -u[<mode>]` - режим отображения неотслеживаемых файлов:
  * `no` - не показывать
  * `normal` - файлы и (только) директории. Опция по умолчанию, если `-u` не указана совсем
  * `all` - показывать еще и файлы в неотслеживаемых каталогах. Опция по умолчанию, если `-u` указана, но без параметра

  Опция имеет значение для очень больших рабочих деревьев. Вместо `no` для них также можно использовать такие фичи `[pm] update-index` как `--untracked-cache` и/или `-split-index`.
- `--ignored[=<mode>]` - режим отображения игнорируемых файлов:
  * `traditional` - показывать, файлы и папки, а если `--untracked-files=all` задана, то еще и файлы в игнорируемых папках
  * `no` - не показывать
  * `matching` - показывать только совпадающие с паттернами в `.gitignore` и прочих (если совпадает имя папки, то показывать только папку, если файлы в папке совпадают, то только их, но не сам каталог)
- `--[no-]ahead-behind` - показывает/скрывает строку `Your branch is up to date with 'origin/master'.`
- `--[no-]renames` и `--find-renames[=<n>]` в(ы)ключают детект переименований. Опции аналогичны одноименным в `[mp] diff`

По умолчанию вывод команды идет в формате `--long`. Это человеко-читаемый формат с подсказками, предназначенный для вставки как подсказка в сообщение коммита. Для скриптов есть короткий формат:

      XY PATH
      XY ORIG_PATH -> PATH

`X` показывает статус файла в индексе, `Y` - в рабочем каталоге. Для файлов с конфликтами слияния `XY` показывают состояние обоих сторон мерджа. Для неотслеживаемых файлов `XY` = `??`. Остальные статусы: `' '` = unmodified, `M` = modified, `A` = added, `D` = deleted, `R` = renamed, `C` = copied, `U` = updated but unmerged. В мане к команде есть таблица с комбинациями статусов.

Существует еще очень подробный формат для парсинга в скриптах `--porcelain=2`, с ветками, процентами изменений в каждом файле, и еще много чем. Описан в мане к команде.

# Ссылки и ветвление

## Ссылки в репозитории

Все типы хранятся в `.git/refs/`, все являются просто файлом. Имя файла = имя ссылки, контент - полный хеш ревизии. Разделитель директорий `/` является, таким образом, и разделителем пространств имен.

Символическая ссылка - это файл, содержащий `ref: <[refs/]path>`. Когда-то были настоящими soft-линками файловой системы, но для совместимости переделаны в plaintext-файлы. Их список:

- `HEAD` - указатель на текущую ветку (в папку `refs/heads`) или на полный хеш ревизии (т.н. *detached head*)
- `.git` (т.н. *gitfile*) - указатель на директорию `.git/`. Формат: `gitdir: <path>`
- ?? посмотреть `*_HEAD`, но вряд ли

Типы ссылок (одноименные подпапки `.git/refs/`):

- `heads`, ветки
- `remotes`, удаленные ветки
- `tags`, теги
- `replace`, объекты-заместители (см. `git replace`); схожи с `.git/info/grafts` (?), могут передаваться между репозиториями
- `notes` (?)
- `bisect` (?)
- `worktree` (?)

`<!-- TODO: продолжить список -->`

Git поддерживает "упаковку" ссылок в единый файл (`.git/packed-refs`) для повышения производительности. См. `[am] pack-refs`

## [pi] show-ref

Список ссылок. Использование этой команды предпочтительнее простого листинга директории `.git/[refs/]` (в том числе из-за `.git/packed-refs`).

- `git show-ref [ --hash[=<n>] | -s ] [<pattern>]`

Выводит пары `<sha1> ref/<type>/<name>`. Может разыменовывать теги (`--dereference | -d` добавляет `^{}` к именам аннотированных тегов). Опция `-s` выводит только хеши, без имен ссылок. `<pattern>` проверяет совпадения с конца пути ссылки, и только целые части (разделитель - `/`).

Посмотреть содержимое файла ссылки можно обычным `cat`-ом, командой `git rev-parse <ref-name>` (предпочтительно) или через `git show-ref -s <full-ref-path>`.

## [pm] update-ref

Создание/обновление/удаление ссылки. Всегда разыменовывает символические ссылки (это отключается через `--no-deref`). При обновлении/удалении `<old-value>` сравнивается с существующим значением, предотвращая действие при несовпадении. Можно задать 40 `0` или `""` для создания (проверка, что ссылка не существует). Рефлог обновляется если указана опция команды или опция конфига `core.logAllRefUpdates`.

- `git update-ref [--create-reflog] <ref> <new-value> [<old-value>]`
- `git update-ref -d <ref> [<old-value>]`

Использование этой команды предпочтительнее прямой записи в файлы в `.git/refs/`: из-за разыменования символических ссылок и чего-то муторного с невозможностью записи в другое дерево (?).

## [pm] symbolic-ref

Чтение/запись/удаление символических ссылок:

- `git symbolic-ref [--short] <ref>`
- `git symbolic-ref [-m <reason>] <ref> <new-value>`
- `git symbolic-ref --delete <ref>`

Опция `-m` пишет в рефлог причину создания/обновления ссылки. `--short` дает короткий вариант (напр., просто `master` вместо `refs/heads/master`).

## Рефлог

Логгирование изменения ссылок управляется опцией конфига `core.logAllRefUpdates`, выполняется командой `[pm] update-ref` и porcelain-командами. Запись идет в файлы `.git/logs/<ref-name>`. Пишутся изменения `HEAD`, `refs/heads`, `refs/remotes` и `refs/notes` (?). Формат логов - многострочный файл, одна строка на коммит:

      <sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
      <sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
      ...

## [am] reflog

Управление рефлогом. Выводит список коротких `<sha1-new>` + ссылку в формате `<ref-name>@{N}` и сообщения коммитов (т.е. о сути часть содержимого файлов из `log/`). По дефолту (стандартно) выводит историю для `HEAD`. Т.к. идет управление рефлогом в целом (а не только вывод истории), поддерживается система подкоманд:

- `git reflog <subcommand|show> <options> [<ref>|HEAD]`

Список подкоманд:

- `show` - по умолчанию, можно не указывать. Показывает историю. Принимает любую опцию команды `[mp] log` (!)
- `expire` - удаляет старые записи. Напрямую обычно не используется, только через porcelain `[mp] gc`
- `delete` - удаляет одиночные (указанные) записи. Обычно тоже не используется юзерами напрямую
- `exists` - проверяет существование записи

## [pi] for-each-ref

Выводит в stdout информацию обо всех ссылках, удовлетворяющих опциональному `<pattern>`-у. Форматирует и сортирует вывод:

- `git for-each-ref [ --sort=<key> ] [ --format=<format> ] [ <pattern> ]`

Формат вывода:

      <sha1> <commit|tag> <ref/path>
      <sha1> <commit|tag> <ref/path>
      ...

Т.е. дефолтный формат вывода: `%(objectname) SPC %(objecttype) TAB %(refname)`. В опции `--format` на эти поля можно ссылаться, и формировать свой порядок. В строке формата поддерживается еще очень много чего (вплоть до операторов), в скриптах позволяет выбирать и форматировать ссылки произвольным образом. См. ман к команде.

## [ph] check-ref-format

Проверяет имя ссылки и выходит с ненулевым статусом, если формат неверный:

- `git check-ref-format <refname>; echo $?`
- `git check-ref-format --branch <branchname-shorthand>`

Список правил именования ссылок из 10 пунктов есть в мане к команде (напр., ссылка не может содержать `\s^:~?*[\`, `..`, `.lock$`, кончаться/начинаться со слешей или точек, и т.д.). Использование двоеточий, тильд, циркумфлексов, двух точек и прочего запрещено потому, что они в втречаются в расширенном SHA1-синтаксисе ревизий, и могут возникнуть трудности с парсингом.

С опцией `--branch` проверка короткого имени ветки более строгая (напр., оно не может начинаться с `-`). Это для возможности использовать его без конфликтов во всех porcelain-командах. И что-то там про "previous checkout syntax" `@{-n}` (?).

## Notes

Предназначены для добавления информации к коммитам без модификации истории. Показываются в выводе `[mp] log` и `[mp] show` по умолчанию (`notes.displayRef`), после сообщений коммита. Могут быть добавлены в патч (`git format-patch --notes`).

По умолчанию `core.notesRef` = `refs/notes/commits` - отдельная orphan-ветка, коммиты в которой создаются каждый раз, когда нота добавляется/изменяется. Таким образом, можно просматривать историю этой ветки и даже чекаутить ее:

- `git log notes/commits`
- `git checkout notes/commits`

Коммиты ссылаются на дерево блобов, хранящих текст заметок. Имя блоба в дереве - <sha1> коммита, для которого сделана заметка. Т.е. можно вручную (а не через `git notes add`) добавлять заметки, после чекаута на эту ветку:

- `echo "Note text" > 056ca11c01b47e2bfe1e51178b65c80bbd`
- `git commit -a -m "Note added by me"`
- `git update-ref refs/notes/commits <new-commit-sha1>`

При добавлении через `git notes add` сообщение коммита будет `"Notes added by 'git notes add'"`. Команда `update-ref` нужна т.к. переход на эту псевдо-ветку (`git checkout notes/commits`) почему-то приводит в detached HEAD state.

По умолчанию заметки не вытягиваются из удаленных репозиториев, нужно добавлять строку `fetch = +refs/notes/*:refs/notes/*` в секцию `[remote "<repo|origin>"]`. В статье еще что-то про привязку произвольных бинарников к произвольным объектам (типа тегов) (?): <http://alblue.bandlem.com/2011/11/git-tip-of-week-git-notes.html>

## [mp] notes

Управление заметками. Имеет систему подкоманд:

- `[list [<object>]]` - дефолтная, показывает список уже заданных в формате `<note-object-sha1> <annotated-object-sha1>`
- `add [-f] [-m <msg>] [<object>]` - добавит или переписать (`-f`)
- `copy [-f] ( --stdin | <from-object> <to-object> )` - копировать из одного объекта в другой
- `append [-m <msg>] [<object>]` - добавляет в блоб существующей заметки `\n<msg>`
- `edit [<object>]` - запускает редактор с содержимым блоба заметки
- `merge <notes-ref>` - слияние ветвей заметок (?)
- `remove [<object>]` - удаление
- `prune` - сборка мусора, удаление всех недостижимых объектов заметок
- `get-ref` - выводит полное имя ветки заметок (переменная конфига `core.notesRef` = `refs/notes/commits`)

# Сравнение

## Общий формат plumbing diff-а

Формат общий для трех команд ниже и для `git diff --raw`, построчный для всех путей в дереве:

      :<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
      :<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
      ...

Хеш нового "файла" состоит из всех нулей если файл новый, при удалении и для неотслеживаемых файлов. Статусы: `A` = added, `C<N>` = copy into a new one, `D` = deleted, `M[<N>]` = modified (content or mode), `R<N>` = renamed, `T` = type changed, `U` = unmerged, `X` = "unknown" change type (most probably a bug). Числа после некоторых статусов показывают процент изменения файла.

Формат патчей:

- заголовок: `diff --git a/file b/file`
- модификации уровня файла (`{old|new} mode <mode>`, `rename {from|to} <path>`, `copy {from|to} <path>`, `[dis]similarity index <number>`, `{deleted|new} file mode <mode>`)
- `index <sha1-before>..<sha1-after> <mode-if-not-changed>`

Комбинированный формат патчей (combined diff format) использует для каждой строки уже трехсторонние диффы (`++` вместо просто `+`, три строки изменений вместо двух и т.д.).

Общее для трех команд plumbing diff-а:

- последний параметр - `<path-pattern>` - лимитирует сравниваемые файлы/каталоги
- принимают все опции `[mp] diff`
- опция `--patch | -p | -u` выводит стандартные диффы
- опции `-c` и `--cc` используются для мерджей и добавляют доп. `<mode>` и `<sha1>` в вывод. Аббревиатура статуса при этом состоит из буквы для каждого родителя

## Diffstat

Формат diffstat-а см. в мане к системной утилите.

## [pi] diff-files

Сравнение файлов рабочего каталога с индексом:

- `git diff-files [<path>]`

## [pi] diff-index

Сравнение объекта-дерева с рабочим каталогом или с индексом. Опция `--cached` сравнивает дерево с индексом, без нее сравнение идет с рабочим каталогом:

- `git-diff-index [--cached] <tree-ish> [<path>]`

## [pi] diff-tree

Сравнение двух объектов-деревьев:

- `git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<path>]`

## Опции

- `--[no-]patch` - показывает/скрывает различия в файлах; `-p | -u` = `--patch`
- `--raw` - plumbing format, опция по умолчанию для низкоуровневых команд, но не для `git diff`
- алгоритмы генерации диффа: `--minimal`, `--patience`, `--histogram`, `--anchored=<text>`, `--diff-algorithm={patience|minimal|histogram|myers=default}`. Также опция конфига `diff.algorithm`
- т.н. *diffstat*: `--stat[=<width>[,<name-width>[,<count>]]]`. Опциональные поля задают ширину столбцов вывода и кол-во строк-файлов
- частичные diffstat-ы: `--numstat` (только кол-во добавленных/удаленных строк), `--shortstat` (только последнюю линию `--stat`), `--dirstat[=<param1,param2,...>]` (статистика по поддиректориям) и т.д.
- `--word-diff[=<mode>]` (и `--word-diff-regex=<regex>`, для определения границ слова) - диффы по слову, не по строке
- `--check` проверяет на маркеры конфликта (`>>> <<<`) и ошибки пробельных символов, выходит в таком случае с ненулевым статусом. `--exit-code` же выходит с ненулевым кодом если есть изменения, и с нулем иначе
- `--binary` генерирует диффы бинарных файлов, которые потом можно скормить `[mp] apply`
- `--abbrev[=<n>]` контролирует длины хешей в списке файлов, а `--full-index` - в патчах (`index <sha1-before>..<sha1-after> ...`)
- `--find-renames|-M[=<n>]`, `--break-rewrites|B[=[<n>][/<m>]]`, `--find-copies|C[=<n>]` управляют поиском переименований, копий и модификаций (?)
- фильтрация диффа по статусу - `--diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]]`
- `-S<string>` ищет изменения, которые изменяли число вхождений указанной строки. Полезно для `blame`-а, для поиска, когда блок кода появился/был удален. Если еще указать `--pickaxe-regex`, то `<string>` будет рассматриваться как регулярное выражение
- `-G<regex>` ищет патчи по паттерну. В отличие от `-S` ее не интересует изменение числа вхождений, только grep по регулярке
- `-O<orderfile>` перекрывает конфиг-опцию `diff.orderFile` (файл со списком паттернов, порядок которых определяет порядок сортировки *имен файлов* в `git log` и `git diff[-*]`)
- `--relative[=<path>]` ограничивает diff текущей (или указанной) поддиректорией
- `--ignore-*` игнорирует разные виду ошибок, связанные с пробелами и пустыми строками
- `--[no-]ext-diff ` и `--[no-]textconv` работают с аттрибутами - в(ы)ключают внешние хелперы диффа и доп. фильтры для конвертации бинарных файлов
- `--{src|dst}-prefix=<prefix>`, `--no-prefix` управляют префиксами имен файлов в диффах (`a/file b/file`), `--line-prefix=<prefix>` добавляет префикс к каждой строке патча
- `-1 | --base`, `-2 | --ours` (default), `-3 | --theirs` используют для сравнения определенные stage-уровни в индексе
- `--ita-[in]visible-in-index` управляет отображением файлов, добавленных через `git add -N` и `git update-index --info-only`

# Слияние

## Основные алгоритмы

- 2-way merge (diff, простое сравнение; в гите это перемотка, fast-forward)
- 3-way merge - трехстороннее слияние, вспомнить слайд от Перфорс
- 3-way recursive merge - с рекурсивным слиянием/вычислением общего предка, если не существует единственного (уникального) общего предка
- fuzzy patch - ?
- weave merge - ?
- patch commutation - в гите это rebase

## Сводная таблица команд

 Команда              | Описание
--------------------- | ---------------------------------------------
`[pm] read-tree`      | вычитка дерева в индекс и тривиальные слияния
`[pm] merge-index`    | проход по индексу (после `read-tree`) с вызовом хелпера слияния
`[ph] merge-one-file` | стандартный хелпер слияния
`[pm] merge-file`     | трехстороннее слияния уровня файла (контента)
`[ph] fmt-merge-msg`  | генерация сообщения merge-коммита
`[pi] merge-base`     | поиск наилучшего предка для слияния
`[ai] merge-tree`     | трехстороннее слияния деревьев вне индекса
`[mp] merge`          | главная porcelain-команда слияния
`[am] mergetool`      | запуск утилиты разрешения конфликтов

## Механизм слияния в индексе

Первым шагом в plumbing-слиянии идет вычитка деревьев сливаемых ревизий в индекс: `git read-tree -m`. Результат зависит от количества деревьев, указанных в аргументах команды.

Если дерево только одно, идет простое обновление индекса, как и без опции `-m` (за исключением того, что `lstat()`-информация в индексе для совпадающих путей не инвалидируется).

Два дерева - это ситуация fast-forward-слияния (перемотки): `git read-tree -m $H $M`, где `$H` - текущий HEAD-коммит, а `$M` - дерево коммита впереди текущего. В этом случае команда учитывает состояния еще двух "деревьев" - рабочего каталога (это для опции `-u`) и текущего индекса, ведь они могут отличаться от `$H` (иметь незакоммитанные изменения, которые нужно сохранить). Команда может завершиться ошибкой, может заменить в индексе хеш файла/каталога на значение из `$M`, или сохранить текущее значение хеша (при совпадении с `$H`). Таблица кейсов из 21 пункта есть в мане к `[pm] read-tree`. При таком слиянии (перемотке) команда не меняет stage-биты у путей в индексе, лишь завершается с ошибкой в случае конфликта.

Полноценный 3-way merge на уровне вхождений (entries) индекса: `git read-tree -m <merge-base> <current-branch> <other-branch>`. Порядок деревьев важен. После слияния пути из каждого дерева пишутся в индекс со своими stage-состояниями:

- `0` = merged
- `1` = merge-base (common ancestor)
- `2` = current-branch
- `3` = other-branch

Идет классическое трехстороннее слияние (вспомнить слайд от Перфорс). Если конфликта на уровне путей/хешей нет, нужный вариант хеша (`2` или `3`, тот который не совпадает с базой) пишется в индекс в слитом состоянии (`0`). Иначе в индекс пишется три вхождения "хеш-путь", каждый со своим stage-битом. Результирующий индекс находится в не полностью слитом состоянии, и команда `[pm] write-tree` на нем не сработает.

В случае уже заполненного файла индекса команда при двух- и трехсторонних слияниях завершится с ошибкой, если вхождение в индексе отличается от вхождения в "текущем" сливаемом дереве (`$H` или `<current-branch>`). Это для предотвращения потери незакоммитанных изменений. Как-то еще проверяются изменения в рабочем каталоге, не добавленные в индекс, и тоже предотвращается их случайное уничтожение (?).

Т.к. команда `[pm] read-tree` низкоуровневая, она не производит слияний уровня файла, только уровня "хеш-путь". Это сделано для возможности выбора в высокоуровневых командах т.н. *porcelain policy* - решения, как удалять из индекса stage-биты старше нуля и какую версию файла писать в нулевой стейдж. Для скриптов, после `read-tree`, для удаления старших stage-состояний и записи слитых версий можно использовать `[pm] merge-index` с `[ph] merge-one-file`.

## [pm] merge-index

Проход по индексу с вызовом хелпера слияния. Проходится только по файлам, требующим слияния. Фильтрует пути в индексе по паттерну `<file>` или выбирает все (`-a`):

- `git merge-index [-o] <merge-program> (-a | [--] <file>*)`

Останавливается если хелпер вернул ненулевой код выхода (или обрабатывает всё даже если есть ошибки, опция `-o`). Стандартный хелпер слияния `[ph] merge-one-file` входит в пакет гита.

## [ph] merge-one-file

Простой хелпер слияния уровня файла. Шелл-скрипт, обрабатывающий простые случаи трехстороннего слияния:

- Deleted in both or deleted in one and unchanged in the other: `git update-index --remove`
- Added in one: `git update-index --add --cacheinfo`
- Added in both, identically (check for same permissions): `git update-index --add --cacheinfo`
- Modified in both, but differently: `git merge-file $(git unpack-file) && git update-index`

Хелпер также обновляет рабочий каталог по индексу после слияния ( вызывает в конце `git checkout-index -u -f`) (?).

## [pm] merge-file

Трехстороннее слияния уровня файла. Полноценный 3-way-merge по контенту. Работает с файлами (не с объектами или индексом). Результат слияния пишет в файл (`<current-file>`) либо в stdout (если указана опция `-p`):

- `git merge-file [-p] <current-file> <base-file> <other-file>`

В случае конфликтов добавляет маркеры `<<<<<<<`/`>>>>>>>` в результат. Если указана одна из опций `--ours`/`--theirs`/`--union`, то конфликтов не генерирует, а вставляет строки из указанного файла (или обоих (?)).

## [ai] merge-tree

Трехстороннее слияния деревьев вне индекса. Похожа на `git read-tree -m`, но не затрагивает файл индекса (проводит слияния вне него, и пишет результат в stdout):

- `git merge-tree <base-tree> <branch1> <branch2>`

## [ph] fmt-merge-msg

Генерация сообщения merge-коммита. Читает из stdin список коммитов для слияния, и генерирует по ним стандартное сообщение для `[mp] merge` (`Merge branch 'master' of github.com:...`):

- `[git fetch && ] git fmt-merge-msg --log < .git/FETCH_HEAD`

Опция `--file|-F <file>` читает объекты из файла вместо stdin, а `--[no-]log` добавляет в сообщения summary коммитов в сливаемой ветке.

## [pi] merge-base

Поиск наилучшего предка для слияния. Получает на вход два коммита и ищет их наиболее близкого общего предка. Таких предком может быть больше одного (опция `--all` выводит всех, не только первого):

- `git merge-base <commit1> <commit2>`
- `git merge-base --octopus <commit> ...`
- `git merge-base --is-ancestor <commit1> <commit2>`

Второй вариант ищет лучшего предка для всех указанных коммитов (n-way merge), это аналог `git show-branch --merge-base`. В третьем варианте команда выходит с нулевым статусом если `<commit1>` явлвется предком `<commit2>`, и с ненулевым иначе.

Опция `--fork-point` использует также reflog для поиска базы слияния, что может пригодится при rebase-е (?). Подробный разбор этого есть в мане к команде.

## [am] mergetool

Запуск утилиты разрешения конфликтов. Запускается, как правило, после (неудачного) выполнения `git merge`. Если не указан `<file>`, то запускается на всех файлах с конфликтами:

- `git mergetool [--tool=<tool>] [-y | --[no-]prompt] [<file>...]`

Опция `--tool|-t=<tool>` определяет, какая утилита запустится. Список доступных: `git mergetool --tool-help`. Варианты: `emerge`,`gvimdiff`, `kdiff3`, `meld`, `vimdiff`, `tortoisemerge`. Если эта опция не указана, смотрит в конфиг `merge.tool`. Если и там пусто, то выбирает что придется ("suitable default"). Возможна гибкая настройка через конфиг гита (путь к утилите, имя и т.д.). Опция `--gui|-g` вызовет то, что записано в `merge.guitool`.

Команда создает `*.orig`-файлы бекапа. Их удаление после заверешения сессии контролируется опцией конфига `mergetool.keepBackup`.

# История

## Ревизии

Это ссылки на отдельный коммит либо на граф коммитов (как в `[mp] log`, все коммиты, достижимые из указанного). Также можно ссылаться на другие объекты (теги, блобы, деревья).

Т.н. *расширенный SHA1-синтаксис* (extended SHA1 syntax):

- полный или частичный хеш
- вывод команды `[mp] describe` - ближайший тег + число коммитов после + `g` + короткий хеш (напр., `v1.7.4.2-679-g3bee7fb`)
- имя ветки. Короткое имя ищется в глубину, в папке `.git/`. Подпапки перебираются в порядке `./ -> refs/ -> refs/tags/ -> refs/heads/ -> refs/remotes/`. В случае неоднозначности берется первое совпадение
- имена специальных ссылок: `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, `CHERRY_PICK_HEAD`
- `@` в одиночку = `HEAD`
- `<refname>@{<date>}`, с датой в свободном формате (`5 minutes ago`, `1979-02-26 18:30:00` etc.) - локально состояние ветки в момент времени, берется по рефлогу
- `<refname>@{<n>}` - состояние ветки `<n>` коммитов назад
- без имени ссылки - `@{<n>}` - работает с текущей веткой. При отрицательном `<n>` перебирает не коммиты в ветке, а коммиты (ветки), которые были отчекаутены
- `[<branch>]@{upstream}` = `[<branch>]@{u}` - отслеживаемая ветка (параметр конфига `branch.<name>.merge`). Если `<branch>` опущена, то берется текущая ветка (`HEAD`)
- аналогично с `@{push}`. Как правило равна `@{u}`
- `<rev>^[<n>]` - n-ный предок "в ширину", `<rev>~[<n>]` - n-ный предок "в глубину". В `git help revisions` есть иллюстрация с графом и разными случаями
- `<rev>^{<type>}` - рекурсивное разыменование коммита до указанного типа объекта
- `<tag>^{}` - разыменование тега до того, как встретится не-тег
- `<rev>^{/[!-]<regexp>}` и `:/[!-]<regexp>` - ищет самый новый коммит, чье сообщение фиксации проходит `<regexp>`. Коммит может быть достижим из любой ревизии во втором варианте и только из указанной в первом. `!-` - отрицание паттерна, ищет первое несовпадающее сообщение
- `<rev>:<path>` - доступ к блобу или дереву в коммите
- `[:<stage-level>]:<path>` - доступ к блобу в индексе

Диапазоны:

- `<rev>` - достижимые из `<rev>`, `^<rev>` - недостижимые
- `<rev1>..<rev2>` - достижимые из 2, но не из 1. При отсутствие любой ревизии в записи на ее место подставляется `HEAD`
- `<rev1>...<rev2>` - xor, только достижимые из любого, но не из обоих разом. Для `HEAD` правило то же
- `<rev>^@` - все предки (всё, что достижимо из предков коммита), но не сам коммит
- `<rev>^!` - сам коммит и исключение всех его предков (?)
- `<rev>^-[<n>]` = `<rev>^<n>..<rev>`, где `<n>` по дефолту равно 1

## [pi] name-rev

Символическое имя по хешу. Для указанного коммита выводит его "отношения" к локальным ссылкам, в формате `<sha1> <ref>~<n>`, где `<n>` - число коммитов до:

- `git name-rev [--tags] [--refs=<pattern>] <commit-ish> ...`
- `git name-rev --all`
- `git name-rev --stdin`

Может выводить все коммиты для всех ссылок (`--all`) или читать данные `[mp] log` из stdin.

## [pi] rev-list

Перечисление коммитов, в обратном хронологическом порядке. Plumbing log, `HEAD` автоматом не подставляется. `[mp] log` принимает все опции этой команды (+ все опции plumbing diff-ов (`[pi] diff-*`). Опций очень много. Набор коммитов в аргументах задает граф коммитов. `<paths>` выбирает только те коммиты, которые модифицировали указанный путь:

- `git rev-list [<options>] <commit> ... [ [--] <paths> ... ]`

Базовой формой задания графа коммитов является простое перечисление ревизий, с или без знака `^` (= `--not` перед ревизией): `A B ^C ...`. В таком графе есть коммиты, достижимые из `A` и `B`, и недостижимые из `C`. Поддерживаются также диапазоны коммитов (см. выше).

## Опции log-а

- `-<num> | -n <num> | --max-count=<num>` - ограничение числа выводимых коммитов
- `--skip=<num>` - пропустить `<num>` коммитов перед тем как начать вывод
- `--{since|after|until|before|{max|min}-age}=<date>` - лимитирование по дате
- `--{author|committer}=<pattern>` - по имени
- `--grep[-reflog]=<pattern>` - grep сообщений коммитов (или рефлога)
- `--all-match` - если задано несколько `--grep`
- несколько модификаторов регекспа, такие как `-i` или `--extended-regexp`
- `--{branches|tags|remotes|glob|exclude}[=<pattern>]` подставляет все ссылки указанного типа в аргументы (паттерн лимитирует). Для `glob` и `exclude` паттерн обязателен, там тип ссылок не учитывается, берутся все
- `--walk-reflogs | -g` проходится по рефлогу, не по предкам в графе коммитов. С этой опцией нельзя указывать `^`/`--not`
- `--bisect[|-vars|-all]` - хелперы бисекта, выводят только половину коммитов
- `--simplify-by-decoration` выводит только первый/последний коммиты ветки. Имеет несколько режимов (`--dense`/`--sparse`/etc.)
- `--{[author-]date|topo}-order`/`--reverse` - порядок вывода коммитов
- `--objects` и еще десяток похожих опций управляют показом хешей объектов (это для паковки)
- `--pretty[=<format>]`/`--format=<format>` управляют форматом вывода: `oneline`, `short`, `medium` (default), `full`, `fuller`, `email`, `raw`, `format:<string>`, `tformat:<string>`
- `--[no-]abbrev-commit` - короткие хеши в выводе
- `--oneline` = `--pretty=oneline --abbrev-commit`
- `--show-signature` - GPG-сигнатуры в выводе
- `--date=<format>` - управление форматом даты (напр., `---relative-date` == `--date=relative`)
- `--left-right` выводит "стороны" (символы `>`/`<`) если в качестве диапазона задана симметричная разность (`A...B`)
- `--graph` - выводит ASCII-граф истории

В строках формата для `--pretty`/`--format` используются плейсхолдеры (напр., `format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"`). Их несколько десятков, полный список в мане к `[pi] rev-list`.

## [pi] rev-parse

Разбор ревизий (и опций). Основное назначение - разбирать extended SHA1-формат ревизий (см. выше) для скриптов и porcelain-команд, выдавать хеш по символьной записи ревизии. Также может служить аналогом `getopt` для разбора опций и последующего их использования в `eval` в шелле (?).

В режиме `--parseopt` читает (из stdin) текстовые файлы спец. формата и преобразует описанные в них опции в формат, пригодный для использования в шелле.

- `git rev-parse [--verify] <commit-ish>`
- `eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"`

Имеет кучу опций, таких как вывод всех SHA1-хешей для тегов/веток/удаленных веток, парсинга дат гита из свободной формы (`--since=`/`--after=`/...), и вывода системной инфы о репозитории: `--local-env-vars`, `--git-dir`, `--is-inside-{git-dir/work-tree}`, `--is-{bare|shallow}-repository`, `--show-cdup` (и похожие, для относительных путей поддиректорий).

## [ai] show-branch

Вывод графа коммитов. Выводит сообщения коммитов с префиксами (`*`/`+`/`++`/`!`/etc.). Ревизия (`<rev>`) или паттерн имени в папке `.git/refs/` (`<glob>`) лимитируют вывод, иначе выводятся потомки всех ссылок:

- `git show-branch [ --remotes | --all ] [<rev|glob>]`

В выводе идет одна строка на коммит, сдвинутая на нужное (для формирования псевдо-графа) кол-во пробелов относительно начала. Префикс текущей ветки - `*`, остальных - `!`, коммитов - `+`, и слияний - `-`. Опция конфига `showbranch.default` определяет дефолтный параметр `<rev|glob>`.

# Конфиг

## Переменные среды

Способ запуска команды с изменением нужного параметра: `GIT_COMMITTER_DATE="2006-10-02 10:31" git tag -s v1.0.1`

## Формат файлов

Настройки vim-а: `:set noexpandtab` и `:set sts=2`.

# Репозиторий

## [pm] commit-graph

Новая фича с v2.18 для повышения производительности. Включается опцией ` core.commitGraph` (отключена по умолчанию). После этого, вместо обхода объектов в базе, начинает читать файл `.git/objects/info/commit-graph` (если есть), в котором хранится сериализованный граф коммитов. Это позволяет существенно ускорить такие команды как `git log --graph`, `git {tag|branch} --contains`, `git merge-base` и пр.

Кеш графа пишется в файл либо вручную (см. ниже) либо при вызове `[pm] gc` если включена опция `gc.writeCommitGraph` (отключена по умолчанию).

Сама команда `[pm] commit-graph` управляет кешированным графом и имеет три подкоманды: `read` (вывод основных сведений о кеше; для отладки), `verify` (сверка кеша с текущей объектной базой) и `write`. Последняя пишет граф вручную:

- `git commit-graph write` - по pack-файлам в `.git`
- `echo <pack-index> | git commit-graph write --stdin-packs` - по указанным индексам pack-файлов
- `git show-ref -s | git commit-graph write --stdin-commits` - начиная с указанных коммитов
- `git rev-parse HEAD | git commit-graph write --stdin-commits --append` - добавляет в существующий достижимые из `HEAD`

Статья лб этой фиче: <https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/>

# Scripting/other

## Подстановочные символы шелла и экранирование

Wildcard-ы гита отличаются от шелловских, поэтому их часто нужно экранировать. Напр., git будет искать рекурсивно в подкаталогах, а шелл нет: `git add Documentation/\*.txt` или `git add git-*.sh` (без экранирования не включает `subdir/git-foo.sh`).

## Поддержка опций команд

- `--dry-run | -n`

  * `[mp] add`
  * `[mp] rm`
  * `[mp] mv`
  * `[mp] commit`

- `--quiet | -q`
- `--verbose | -v`

# Хорошие практики

## Сообщения коммита

- первая строка не длиннее 50 символов, будет интерпретироваться как заголовок коммита
- потом пустая строка
- потом более подробное описание
- `[mp] format-patch` использует их как тему письма + тело письма
- можно использовать шаблон (`commit.template`) для показа подсказок для коммитеров, что и как писать в сообщениях
