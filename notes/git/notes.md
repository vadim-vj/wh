## Типы команд

- `[pi]` = `plumbinginterrogators`
- `[pm]` = `plumbingmanipulators`
- `[ai]` = `ancillaryinterrogators`
- `[am]` = `ancillarymanipulators`

`<!-- TODO: продолжить список -->`

Получение списка: `git --list-cmds=list-<list>`

## Объекты в репозитории

Все четыре типа хранятся в `.git/objects/[a-z0-9]{2}/`. Формат:

- объект: `object = "<type> <size-in-bytes>\0<content>"`
- имя файла: `sha1(<object>)`
- содержимое файла: `zip(<object>)`

Контент:

- деревья

      <mode> {tree|blob} <sha1> <file-name>
      <mode> {tree|blob} <sha1> <file-name>
      ...

- аннотированные теги

      object <sha1>
      type <blob|tree|commit|tag>
      tag <tag-name>
      tagger Vadim Sannikov <vsj.vadim@gmail.com> 1559945764 +0400
      gpgsig <multi-line-signature>

      <tag-message>

  Команда `git cat-file -p <tag>` на легковесном теге выдаст содержимое коммита

- коммиты

      tree <sha1>
      parent <sha1>
      parent <sha1>
      ...
      author Ben Straub <ben@straub.cc> 1565198977 -0700
      committer GitHub <noreply@github.com> 1565198977 -0700
      gpgsig <multi-line-signature>

      <commit-message>

## Хеш по файлу или строке, `[pm] hash-object`

Команда получает на вход *контент*, и выводит хеш *объекта* в `stdout`:

- `git hash-file [-w] <file-path>`
- `echo "<content>" | git hash-file [-w]`

Нужно помнить, что `[pm] hash-object` дает SHA1 не самого контента, а объекта (заголовка `<type> <size-in-bytes>\0` + контент). Опция `-w` (дополнительно) физически пишет зипованный объект в базу.

## Просмотр содержимого объекта, `[pi] cat-file`

- `git cat-file -p <revision>`

Разжимает файл и отбрасывает заголовок; выводит только контент.

## Просмотр содержимого дерева, `[pi] ls-tree`

Команда корректно разыменовывает любые объекты (теги, коммиты, ссылки), приводящиеся к tree-ish. Вывод команды можно лимитировать через `pattern` (`-r` = recursive):

- `git ls-tree [-r] <tree-ish> [<pattern>]`

Формат вывода: `<mode> <blob|tree> <sha1>[ <blob-size|->] <entry-name>` (размеры для блобов выводятся через `--long | -l`). Это корректный входной формат для `git update-index --index-info --stdin`.

## Ссылки

Все ? типа хранятся в `.git/refs/` (`heads`, `remotes`, `tags`, `<!-- TODO: продолжить список -->`; подпапки с теми же именами), все являются просто файлом. Имя файла = имя ссылки, контент - полный хеш ревизии. Разделитель директорий `/` является, таким образом, и разделителем пространств имен.

Символическая ссылка - это файл, содержащий `ref: <[refs/]path>`. Когда-то были настоящими soft-линками файловой системы, но для совместимости переделаны в plaintext-файлы. Их список:

- `HEAD` - указатель на текущую ветку (в папку `refs/heads`) или на полный хеш ревизии (т.н. *detached head*)
- `.git` (т.н. *gitfile*) - указатель на директорию `.git/`
- ?? посмотреть `*_HEAD`, но вряд ли

## Список ссылок, `[pi] show-ref`

Использование этой команды предпочтительнее простого листинга директории `.git/[refs/]` (в том числе из-за `.git/packed-refs`).

- `git show-ref [<pattern>]`

Выводит пары `<sha1> ref/<type>/<name>`. Может разыменовывать теги (`--dereference | -d` добавляет `^{}` к именам аннотированных тегов). `<pattern>` проверяет совпадения с конца пути ссылки, и только целые части (разделитель - `/`).

Посмотреть содержимое файла ссылки можно обычным `cat`-ом, командой `git rev-parse <ref-name>` (предпочтительно) или через `git show-ref -s <full-ref-path>`.

## Создание/обновление/удаление ссылки, `[pm] update-ref`

Всегда разыменовывает символические ссылки (это отключается через `--no-deref`). При обновлении/удалении `<old-value>` сравнивается с существующим значением, предотвращая действие при несовпадении. Можно задать 40 `0` или `""` для создания (проверка, что ссылка не существует). Рефлог обновляется если указана опция команды или опция конфига `core.logAllRefUpdates`.

- `git update-ref [--create-reflog] <ref> <new-value> [<old-value>]`
- `git update-ref -d <ref> [<old-value>]`

Использование этой команды предпочтительнее прямой записи в файлы в `.git/refs/`: из-за разыменования символических ссылок и чего-то муторного с невозможностью записи в другое дерево (?).

## Чтение/запись/удаление символических ссылок, `[pm] symbolic-ref`

- `git symbolic-ref [--short] <ref>`
- `git symbolic-ref [-m <reason>] <ref> <new-value>`
- `git symbolic-ref --delete <ref>`

Опция `-m` пишет в рефлог причину создания/обновления ссылки. `--short` дает короткий вариант (напр., просто `master` вместо `refs/heads/master`)

## Формат индекса

Термины *index*, *stage* и *cache* равнозначны.

- [file:///usr/share/doc/git-doc/technical/index-format.html](file:///usr/share/doc/git-doc/technical/index-format.html)
- https://mincong-h.github.io/2018/04/28/git-index/

```
Header (12 byte; "DIRC <index-version:(2|3|4)> <entries-number>")
Entries list
Extensions
SHA-1 of the index file before this checksum (160 bit)
```

Entry (данные из системного вызова `stat()`):

- `ctime`, время последнего изменения метаданных файла (командами `chmod`/`chown`/`ln`)
- `mtime`, время последнего изменения содержимого файла
- `dev`, ID устройства, на котором расположен файл
- `ino`, номер индексного дескриптора файловой системы (inode)
- `object type`, тип объекта git: 1000 (regular file), 1010 (symbolic link) и 1110 (gitlink)
- `perm:(0755|0644)`, UNIX-права, только 2 возможных значения для файлов. Симлинки и git-линки имеют в этом поле `0`
- `uid`, ID владельца файла
- `gid`, ID группы владельца файла
- `file-size`, размер файла в байтах
- `sha1`, хеш объекта (160 бит)
- `flags`, флаги, зависят от версии
- `file-path`, относительно рабочей директории верхнего уровня. В v4 идет префиксное сжатие этого поля относительно предыдущего (видимо, нужно для паковки)

Элементы (entries) индекса сортируются сначала по полю `file-path`, рассматриваемому как строка беззнаковых битов (без локализации, учёта `/` и т.д.; это для `memcmp()`), а потом по `stage-level`.

Дополнительные флаги в версиях выше 2 читаются только тогда, когда `extended-flag=1`; во второй версии он всегда ноль и эти два флага игнорируются:

- v2: `assume-unchanged:(1|0)`, `extended-flag=0`, `stage-level:[0-3]`, `file-name-length`
- v3, v4: дополнительно `skip-worktree:(1|0)`, `intent-to-add:(1|0)`

Расширения и их сигнатуры:

- Cached tree (`TREE`). Содержит хеши деревьев, которые могут быть сгенерированы по индексу. Это ускоряет запись деревьев при коммите. При изменении какого-либо пути в индексе хеш соответствующего дерева инвалидируется
- Resolve undo (`REUC`). При разрешении конфликтов (напр., `git add <path>`) все вхождения со `stage-level` больше нуля удаляются из индекса. Это расширение сохраняет их, чтобы можно было воспроизвести конфликт с нуля (напр., через `git checkout -m`)
- Split index (`link`). Поддерживает режим *split index*, храня `sha1` "расщепленного" индекса. Сам файл такого индекса хранится в `.git/sharedindex.<sha1>`
- Untracked cache (`UNTR`). Хранит кеш неотслеживаемых файлов. Имеет довольно сложную структуру, учитывает файл `.git/info/exclude`
- File system monitor (`FSMN`). Поддерживает совместную работу гита с системным файловым монитором, хранит метаданные для взаимодействия с этим монитором
- Index entry offset table (`IEOT`). Помогает определить стоимость задействования многопоточности при загрузке индекса в память. Хранит количество элементов (entries) в блоках и смещения этих блоков в бинарном индексе
- End of index entry (`EOIE`). Ничего не делает, маркирует конец списка расширений. Хранит их сигнатуры и смещения в бинарном индексе

## Просмотр индекса и/или рабочего дерева, `[pi] ls-files`

Выводит списки файлов, рабочий каталог (`--others` - ignored files) + индекс (`<pattern>` лимитирует):

- `git ls-files [ --stage | --debug ] <pattern>`

Выводит просто список файлов, а со `--stage`: "`<mode> <sha1> <stage-level> <file-path>`". Опция `--debug` выводит данные от `lstat()`.

## ??, `[pm] update-index`

## Создание по индексу объекта-дерева и запись его в базу, `[pm] write-tree`

Выводит в `stdout` хеш созданного дерева. Индекс должен быть в полностью слитом состоянии:

- `git write-tree [--missing-ok] [--prefix=<prefix>/]`

Опция `--prefix` пишет поддерево из индекса, а `--missing-ok` игнорирует отсутствующие в базе хеши из индекса (всё равно создает дерево).

## ??, `[pm] commit-tree`

## ??, `[pm] read-tree`

## Копирование файлов из индекса в рабочий каталог, `[pm] checkout-index`

Без аргументов не делает ничего (это для того, чтобы читаемые из `stdin` пустые команды в pipeline-ах игнорировались).

- `git checkout-index [--force] --all`
- `git checkout-index [--force] <file-path>`

Опция `--force` перезапишет существующие файлы (по умолчанию их не трогает). Опции `--temp` и `--stage=<number>|all` позволяют чекаутить временные файлы (это для `mergetool`).

## Три дерева

`ls -la / tree`  |       | `ls-files` |       | `ls-tree`    |       |`Commit`
---------------- | ----- | -----------| ----- | ------------ | ----- | -------------
`update-index`   | `-->` |            | `<--` | `read-tree`  |       |
`checkout-index` | `<--` |            | `-->` | `write-tree` | `-->` | `commit-tree`
