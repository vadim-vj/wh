## Типы команд

- `[pi]` = `plumbinginterrogators`
- `[pm]` = `plumbingmanipulators`
- `[ai]` = `ancillaryinterrogators`
- `[am]` = `ancillarymanipulators`
- `[ph]` = `purehelpers`
- `[sh]` = `synchelpers`

`<!-- TODO: продолжить список -->`

Все списки: `ls -la /usr/share/doc/git-doc/cmds-*`. Получение списка команд: `git --list-cmds=list-<list>`

Некоторые общие для части команд опции:

- `--quiet | -q` уменьшает объем вывода команды или отключает его совсем
- `--dry-run | -n` тестовый запуск, не выполняет реальных действий

## Объекты в репозитории

Все четыре типа хранятся в `.git/objects/[a-z0-9]{2}/`. Формат:

- объект: `object = "<type> <size-in-bytes>\0<content>"`
- имя файла: `sha1(<object>)`
- содержимое файла: `zip(<object>)`

Контент:

- деревья

      <mode> {tree|blob} <sha1> <file-name>
      <mode> {tree|blob} <sha1> <file-name>
      ...

- аннотированные теги

      object <sha1>
      type <blob|tree|commit|tag>
      tag <tag-name>
      tagger Vadim Sannikov <vsj.vadim@gmail.com> 1559945764 +0400
      gpgsig <multi-line-signature>

      <tag-message>

  Команда `git cat-file -p <tag>` на легковесном теге выдаст содержимое коммита

- коммиты

      tree <sha1>
      parent <sha1>
      parent <sha1>
      ...
      author Ben Straub <ben@straub.cc> 1565198977 -0700
      committer GitHub <noreply@github.com> 1565198977 -0700
      gpgsig <multi-line-signature>

      <commit-message>

Git поддерживает механизм "альтернатив" - файлы `./git/objects/info/alternates` и `.git/objects/info/http-alternates`. В них можно построчно перечислить пути (урлы) к другим объектным базам, в которых будет вестись поиск в случае если в текущей базе нужного хеша нет. Используются всеми локальными утилитами и HTTP-фетчером при сетевых операциях.

## `[pm] hash-object`, хеш по файлу или строке

Команда получает на вход *контент*, и выводит хеш *объекта* в `stdout`:

- `git hash-file [-w] <file-path>`
- `echo "<content>" | git hash-file [-w]`

Нужно помнить, что `[pm] hash-object` дает SHA1 не самого контента, а объекта (заголовка `<type> <size-in-bytes>\0` + контент). Опция `-w` (дополнительно) физически пишет зипованный объект в базу.

## `[pi] cat-file`, просмотр содержимого объекта

- `git cat-file -p <revision>`

Разжимает файл и отбрасывает заголовок; выводит только контент.

## `[pi] ls-tree`, просмотр содержимого дерева

Команда корректно разыменовывает любые объекты (теги, коммиты, ссылки), приводящиеся к tree-ish. Вывод команды можно лимитировать через `pattern` (`-r` = recursive):

- `git ls-tree [-r] <tree-ish> [<pattern>]`

Формат вывода: `<mode> <blob|tree> <sha1>[ <blob-size|->] <entry-name>` (размеры для блобов выводятся через `--long | -l`). Это корректный входной формат для `git update-index --index-info --stdin`.

## Формат индекса

Термины *index*, *stage* и *cache* равнозначны.

- [file:///usr/share/doc/git-doc/technical/index-format.html](file:///usr/share/doc/git-doc/technical/index-format.html)
- https://mincong-h.github.io/2018/04/28/git-index/

```
Header (12 byte; "DIRC <index-version:(2|3|4)> <entries-number>")
Entries list
Extensions
SHA-1 of the index file before this checksum (160 bit)
```

Entry (данные из системного вызова `stat()`):

- `ctime`, время последнего изменения метаданных файла (командами `chmod`/`chown`/`ln`)
- `mtime`, время последнего изменения содержимого файла
- `dev`, ID устройства, на котором расположен файл
- `ino`, номер индексного дескриптора файловой системы (inode)
- `object type`, тип объекта git: 1000 (regular file), 1010 (symbolic link) и 1110 (gitlink)
- `perm:(0755|0644)`, UNIX-права, только 2 возможных значения для файлов. Симлинки и git-линки имеют в этом поле `0`
- `uid`, ID владельца файла
- `gid`, ID группы владельца файла
- `file-size`, размер файла в байтах
- `sha1`, хеш объекта (160 бит)
- `flags`, флаги, зависят от версии
- `file-path`, относительно рабочей директории верхнего уровня. В v4 идет префиксное сжатие этого поля относительно предыдущего (видимо, нужно для паковки)

Элементы (entries) индекса сортируются сначала по полю `file-path`, рассматриваемому как строка беззнаковых битов (без локализации, учёта `/` и т.д.; это для `memcmp()`), а потом по `stage-level`.

Дополнительные флаги в версиях выше 2 читаются только тогда, когда `extended-flag=1`; во второй версии он всегда ноль и эти два флага игнорируются:

- v2: `assume-unchanged:(1|0)`, `extended-flag=0`, `stage-level:[0-3]`, `file-name-length`
- v3, v4: дополнительно `skip-worktree:(1|0)`, `intent-to-add:(1|0)`

Расширения и их сигнатуры:

- Cached tree (`TREE`). Содержит хеши деревьев, которые могут быть сгенерированы по индексу. Это ускоряет запись деревьев при коммите. При изменении какого-либо пути в индексе хеш соответствующего дерева инвалидируется
- Resolve undo (`REUC`). При разрешении конфликтов (напр., `git add <path>`) все вхождения со `stage-level` больше нуля удаляются из индекса. Это расширение сохраняет их, чтобы можно было воспроизвести конфликт с нуля (напр., через `git checkout -m`)
- Split index (`link`). Поддерживает режим *split index*, храня `sha1` "расщепленного" индекса. Сам файл такого индекса хранится в `.git/sharedindex.<sha1>`
- Untracked cache (`UNTR`). Хранит кеш неотслеживаемых файлов. Имеет довольно сложную структуру, учитывает файл `.git/info/exclude`
- File system monitor (`FSMN`). Поддерживает совместную работу гита с системным файловым монитором, хранит метаданные для взаимодействия с этим монитором
- Index entry offset table (`IEOT`). Помогает определить стоимость задействования многопоточности при загрузке индекса в память. Хранит количество элементов (entries) в блоках и смещения этих блоков в бинарном индексе
- End of index entry (`EOIE`). Ничего не делает, маркирует конец списка расширений. Хранит их сигнатуры и смещения в бинарном индексе

## `[pi] ls-files`, просмотр индекса и/или рабочего дерева

Выводит списки файлов, рабочий каталог (`--others` - ignored files) + индекс (`<pattern>` лимитирует):

- `git ls-files [ --stage | --debug ] <pattern>`

Выводит просто список файлов, а со `--stage`: "`<mode> <sha1> <stage-level> <file-path>`". Опция `--debug` выводит данные от `lstat()`.

## `[pm] update-index`, регистрация контента в индексе

Пишет хеш/пермишны/имя файла в индекс. Сбрасывает `stage`-биты в ноль (*fully merged state*). Для файла, если не указана опция `--info-only`, - физически пишет объект в базу. Команда по умолчанию игнорирует скрытые файлы (в том числе во вложенных директориях, `./file` и `dir/./file`) в общих паттернах; для их (файлов) добавления нужно указывать полные имена.

Две формы, через файл в рабочей директории и через контент в базе объектов:

- `git update-index [<file> ...]`
- `git update-index --cacheinfo <mode>,<object>,<file>`

Опции:

- `--add / --remove / --refresh`. По умолчанию команда только обновляет уже имеющиеся в индексе файлы. `--refresh` не обновляет хеши, только `stat`-информацию
- `--[no-]assume-unchanged` (см. флаги индекса). Не переписывает хеш файла с указанным именем, а только выставляет бит. После этого файл начинает считаться git-ом неизмененным (напр., при мерджах). Бывает полезно на системах с медленным `lstat` (можно маркировать неменяющиеся директории и файлы)
- ` --[no-]skip-worktree` (см. флаги индекса). То же. Похож на предыдущий, но предназначен для другого (?). С этим битом Git считает файл в рабочей директории неизменным, и читает содержимое из индекса, не из рабочей папки (?)
- `--[no-]fsmonitor-valid` (см. флаги индекса). То же.
- `--[no-]split-index`, `--[no-]untracked-cache`, `--[no-]fsmonitor` включают/выключают расширения в индексе (см. выше)
- `--index-info` для скриптов и чтения из `stdin`. Корректно принимает данные от `git ls-tree` и `git ls-files --stage`

## `[pm] write-tree`, создание по индексу объекта-дерева и запись его в базу

Выводит в `stdout` хеш созданного дерева. Индекс должен быть в полностью слитом состоянии:

- `git write-tree [--missing-ok] [--prefix=<prefix>/]`

Опция `--prefix` пишет поддерево из индекса, а `--missing-ok` игнорирует отсутствующие в базе хеши из индекса (всё равно создает дерево).

## `[pm] commit-tree`, создание коммита по дереву

Пишет созданный объект коммита в базу и выводит его `sha1` в `stdin`. Команда низкоуровневая, и сама по себе ветки не двигает:

- `git commit-tree [-p <parent> ...] [-m <message> ] <tree>`

Данные об авторе и коммитере берутся из env-переменных `GIT_AUTHOR_*` и `GIT_COMMITTER_*`, а если они не заданы - из конфига гита (`user.name`, `user.email`).

## `[pm] read-tree`, чтение дерева из базы в индекс

Обновляет индекс по указанному дереву. С префиксом вычитывает в указанный подкаталог, с `--empty` просто очищает индекс. С опцией `-m` также выполняет слияние, а дополнительно с `-u`, - еще и обновление рабочего каталога после слияния:

- `git read-tree [--prefix=<prefix>] <tree-ish>`
- `git read-tree --empty`
- `git read-tree [-m [-u]] <tree-ish1> [<tree-ish2> [<tree-ish3>]]`

Команда низкоуровневая, и выполняет лишь более простые слияния, чем porcelain; если что-то не может - оставляет файлы в неслитом состоянии. Опция `--trivial` еще упрощает - запрещает любые слияния уровня файлов, `--aggressive` же наоборот разрешает немного более сложные.

При слиянии (опция `-m`) играет роль количество деревьев в аргументах команды. Одно - как без опции `-m`, два - перемотка (fast-forward) и три - трехстороннее слияния (3-way merge). В man-странице к команде подробно описаны алгоритмы всех таких слияний.

Включив опцию конфига `core.sparseCheckout` и заполнив файл `.git/info/sparse-checkout` (синтаксис аналогичен `.gitignore`) можно использовать т.н. "разреженный" checkout (*sparse checkout*). `git read-tree` и остальные команды, использующие слияния (`git merge`, `git checkout`, ...) начнут по паттернам в этом файле выставлять путям в индексе `skip-worktree`-бит (см. выше).

## `[pm] checkout-index`, копирование файлов из индекса в рабочий каталог

Без аргументов не делает ничего (это для того, чтобы читаемые из `stdin` пустые команды в pipeline-ах игнорировались). `<file-path>` фильтрует индекс по паттерну:

- `git checkout-index [--force] --all`
- `git checkout-index [--force] <file-path>`

Опция `--force` перезапишет существующие файлы (по умолчанию их не трогает). Опции `--temp` и `--stage=<number>|all` позволяют чекаутить временные файлы (это для `mergetool`).

## Три дерева

`ls -la / tree`  |       | `ls-files` |       | `ls-tree`    |       |`Commit`
---------------- | ----- | -----------| ----- | ------------ | ----- | -------------
`update-index`   | `-->` |            | `<--` | `read-tree`  |       |
`checkout-index` | `<--` |            | `-->` | `write-tree` | `-->` | `commit-tree`

## Ссылки

Все типы хранятся в `.git/refs/`, все являются просто файлом. Имя файла = имя ссылки, контент - полный хеш ревизии. Разделитель директорий `/` является, таким образом, и разделителем пространств имен.

Символическая ссылка - это файл, содержащий `ref: <[refs/]path>`. Когда-то были настоящими soft-линками файловой системы, но для совместимости переделаны в plaintext-файлы. Их список:

- `HEAD` - указатель на текущую ветку (в папку `refs/heads`) или на полный хеш ревизии (т.н. *detached head*)
- `.git` (т.н. *gitfile*) - указатель на директорию `.git/`. Формат: `gitdir: <path>`
- ?? посмотреть `*_HEAD`, но вряд ли

Типы ссылок (одноименные подпапки `.git/refs/`):

- `heads`, ветки
- `remotes`, удаленные ветки
- `tags`, теги
- `replace`, объекты-заместители (см. `git replace`); схожи с `.git/info/grafts` (?), могут передаваться между репозиториями
- `notes` (?)
- `bisect` (?)
- `worktree` (?)

`<!-- TODO: продолжить список -->`

Git поддерживает "упаковку" ссылок в единый файл (`.git/packed-refs`) для повышения производительности. См. `git pack-refs`

## `[pi] show-ref`, список ссылок

Использование этой команды предпочтительнее простого листинга директории `.git/[refs/]` (в том числе из-за `.git/packed-refs`).

- `git show-ref [<pattern>]`

Выводит пары `<sha1> ref/<type>/<name>`. Может разыменовывать теги (`--dereference | -d` добавляет `^{}` к именам аннотированных тегов). `<pattern>` проверяет совпадения с конца пути ссылки, и только целые части (разделитель - `/`).

Посмотреть содержимое файла ссылки можно обычным `cat`-ом, командой `git rev-parse <ref-name>` (предпочтительно) или через `git show-ref -s <full-ref-path>`.

## `[pm] update-ref`, создание/обновление/удаление ссылки

Всегда разыменовывает символические ссылки (это отключается через `--no-deref`). При обновлении/удалении `<old-value>` сравнивается с существующим значением, предотвращая действие при несовпадении. Можно задать 40 `0` или `""` для создания (проверка, что ссылка не существует). Рефлог обновляется если указана опция команды или опция конфига `core.logAllRefUpdates`.

- `git update-ref [--create-reflog] <ref> <new-value> [<old-value>]`
- `git update-ref -d <ref> [<old-value>]`

Использование этой команды предпочтительнее прямой записи в файлы в `.git/refs/`: из-за разыменования символических ссылок и чего-то муторного с невозможностью записи в другое дерево (?).

## `[pm] symbolic-ref`, чтение/запись/удаление символических ссылок

- `git symbolic-ref [--short] <ref>`
- `git symbolic-ref [-m <reason>] <ref> <new-value>`
- `git symbolic-ref --delete <ref>`

Опция `-m` пишет в рефлог причину создания/обновления ссылки. `--short` дает короткий вариант (напр., просто `master` вместо `refs/heads/master`).

## Рефлог

Логгирование изменения ссылок управляется опцией конфига `core.logAllRefUpdates`, выполняется командой `git update-ref` и porcelain-командами. Запись идет в файлы `.git/logs/<ref-name>`. Пишутся изменения `HEAD`, `refs/heads`, `refs/remotes` и `refs/notes` (?). Формат логов - многострочный файл, одна строка на коммит:

```
<sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
<sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
...
```

## `[am] reflog`, управление рефлогом

Выводит список коротких `<sha1-new>` + ссылку в формате `<ref-name>@{N}` и сообщения коммитов (т.е. о сути часть содержимого файлов из `log/`). По дефолту (стандартно) выводит историю для `HEAD`. Т.к. идет управление рефлогом в целом (а не только вывод истории), поддерживается система подкоманд:

- `git reflog <subcommand|show> <options> [<ref>|HEAD]`

Список подкоманд:

- `show` - по умолчанию, можно не указывать. Показывает историю. Принимает любую опцию команды `git log` (!)
- `expire` - удаляет старые записи. Напрямую обычно не используется, только через porcelain `git gc`
- `delete` - удаляет одиночные (указанные) записи. Обычно тоже не используется юзерами напрямую
- `exists` - проверяет существование записи

## Общий формат plumbing diff-а

Формат общий для трех команд ниже и для `git diff --raw`, построчный для всех путей в дереве:

```
:<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
:<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
...
```

Хеш нового "файла" состоит из всех нулей если файл новый, при удалении и для неотслеживаемых файлов. Статусы: `A` = added, `C<N>` = copy into a new one, `D` = deleted, `M[<N>]` = modified (content or mode), `R<N>` = renamed, `T` = type changed, `U` = unmerged, `X` = "unknown" change type (most probably a bug). Числа после некоторых статусов показывают процент изменения файла.

Формат diffstat-а см. в мане к системной утилите.

Формат патчей:

- заголовок: `diff --git a/file b/file`
- модификации уровня файла (`{old|new} mode <mode>`, `rename {from|to} <path>`, `copy {from|to} <path>`, `[dis]similarity index <number>`, `{deleted|new} file mode <mode>`)
- `index <sha1-before>..<sha1-after> <mode-if-not-changed>`

Комбинированный формат патчей (combined diff format) использует для каждой строки уже трехстронние диффы (`++` вместо просто `+`, три строки изменений вместо двух и т.д.).

Общее для трех команд plumbing diff-а:

- последний параметр - `<path-pattern>` - лимитирует сравниваемые файлы/каталоги
- принимают все опции `git diff`
- опция `--patch | -p | -u` выводит стандартные диффы
- опции `-c` и `--cc` используются для мерджей и добавляют доп. `<mode>` и `<sha1>` в вывод. Аббревиатура статуса при этом состоит из буквы для каждого родителя

## `[pi] diff-files`, сравнение файлов рабочего каталога с индексом

- `git diff-files [<path>]`

## `[pi] diff-index`, сравнение объекта-дерева с рабочим каталогом или с индексом

Опция `--cached` сравнивает дерево с индексом, без нее сравнение идет с рабочим каталогом:

- `git-diff-index [--cached] <tree-ish> [<path>]`

## `[pi] diff-tree`, сравнение двух объектов-деревьев

- `git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<path>]`

## Опции `diff`-а

- `--[no-]patch` - показывает/скрывает различия в файлах; `-p | -u` = `--patch`
- `--raw` - plumbing format, опция по умолчанию для низкоуровневых команд, но не для `git diff`
- алгоритмы генерации диффа: `--minimal`, `--patience`, `--histogram`, `--anchored=<text>`, `--diff-algorithm={patience|minimal|histogram|myers=default}`. Также опция конфига `diff.algorithm`
- т.н. *diffstat*: `--stat[=<width>[,<name-width>[,<count>]]]`. Опциональные поля задают ширину столбцов вывода и кол-во строк-файлов
- частичные diffstat-ы: `--numstat` (только кол-во добавленных/удаленных строк), `--shortstat` (только последнюю линию `--stat`), `--dirstat[=<param1,param2,...>]` (статистика по поддиректориям) и т.д.
- `--word-diff[=<mode>]` (и `--word-diff-regex=<regex>`, для определения границ слова) - диффы по слову, не по строке
- `--check` проверяет на маркеры конфликта (`>>> <<<`) и ошибки пробельных символов, выходит в таком случае с ненулевым статусом. `--exit-code` же выходит с ненулевым кодом если есть изменения, и с нулем иначе
- `--binary` генерирует диффы бинарных файлов, которые потом можно скормить `git apply`
- `--abbrev[=<n>]` контролирует длины хешей в списке файлов, а `--full-index` - в патчах (`index <sha1-before>..<sha1-after> ...`)
- `--find-renames|-M[=<n>]`, `--break-rewrites|B[=[<n>][/<m>]]`, `--find-copies|C[=<n>]` управляют поиском переименований, копий и модификаций (?)
- фильтрация диффа по статусу - `--diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]]`
- `-S<string>` ищет изменения, которые изменяли число вхождений указанной строки. Полезно для `blame`-а, для поиска, когда блок кода появился/был удален. Если еще указать `--pickaxe-regex`, то `<string>` будет рассматриваться как регулярное выражение
- `-G<regex>` ищет патчи по паттерну. В отличие от `-S` ее не интересует изменение числа вхождений, только grep по регулярке
- `-O<orderfile>` перекрывает конфиг-опцию `diff.orderFile` (файл со списком паттернов, порядок которых определяет порядок сортировки *имен файлов* в `git log` и `git diff[-*]`)
- `--relative[=<path>]` ограничивает diff текущей (или указанной) поддиректорией
- `--ignore-*` игнорирует разные виду ошибок, связанные с пробелами и пустыми строками
- `--[no-]ext-diff ` и `--[no-]textconv` работают с аттрибутами - в(ы)ключают внешние хелперы диффа и доп. фильтры для конвертации бинарных файлов
- `--{src|dst}-prefix=<prefix>`, `--no-prefix` управляют префиксами имен файлов в диффах (`a/file b/file`), `--line-prefix=<prefix>` добавляет префикс к каждой строке патча
- `-1 | --base`, `-2 | --ours` (default), `-3 | --theirs` используют для сравнения определенные stage-уровни в индексе
- `--ita-[in]visible-in-index` управляет отображением файлов, добавленных через `git add -N` и `git update-index --info-only`
