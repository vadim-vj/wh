## Типы команд

- `[pi]` = `plumbinginterrogators`
- `[pm]` = `plumbingmanipulators`
- `[ai]` = `ancillaryinterrogators`
- `[am]` = `ancillarymanipulators`
- `[ph]` = `purehelpers`
- `[sh]` = `synchelpers`
- `[sr]` = `synchingrepositories`
- `[fi]` = `foreignscminterface`
- `[mp]` = `mainporcelain`

Все списки: `ls -la /usr/share/doc/git-doc/cmds-*`. Получение списка команд: `git --list-cmds=list-<list>`. Добавление алиаса: `git config --global alias.list-mp '--list-cmds=list-mainporcelain'`.

Некоторые общие для части команд опции:

- `--quiet | -q` уменьшает объем вывода команды или отключает его совсем
- `--dry-run | -n` тестовый запуск, не выполняет реальных действий

## Объекты в репозитории

Все четыре типа хранятся в `.git/objects/[a-z0-9]{2}/`. Формат:

- объект: `object = "<type> <size-in-bytes>\0<content>"`
- имя файла: `sha1(<object>)`
- содержимое файла: `zip(<object>)`

Контент:

- деревья

      <mode> {tree|blob} <sha1> <file-name>
      <mode> {tree|blob} <sha1> <file-name>
      ...

- аннотированные теги

      object <sha1>
      type <blob|tree|commit|tag>
      tag <tag-name>
      tagger Vadim Sannikov <vsj.vadim@gmail.com> 1559945764 +0400
      gpgsig <multi-line-signature>

      <tag-message>

  Команда `git cat-file -p <tag>` на легковесном теге выдаст содержимое коммита

- коммиты

      tree <sha1>
      parent <sha1>
      parent <sha1>
      ...
      author Ben Straub <ben@straub.cc> 1565198977 -0700
      committer GitHub <noreply@github.com> 1565198977 -0700
      gpgsig <multi-line-signature>

      <commit-message>

Git поддерживает механизм "альтернатив" - файлы `./git/objects/info/alternates` и `.git/objects/info/http-alternates`. В них можно построчно перечислить пути (урлы) к другим объектным базам, в которых будет вестись поиск в случае если в текущей базе нужного хеша нет. Используются всеми локальными утилитами и HTTP-фетчером при сетевых операциях.

## `[pm] hash-object`, хеш по файлу или строке

Команда получает на вход *контент*, и выводит хеш *объекта* в `stdout`:

- `git hash-file [-w] <file-path>`
- `echo "<content>" | git hash-file [-w]`

Нужно помнить, что `[pm] hash-object` дает SHA1 не самого контента, а объекта (заголовка `<type> <size-in-bytes>\0` + контент). Опция `-w` (дополнительно) физически пишет зипованный объект в базу.

## `[pi] cat-file`, просмотр содержимого объекта

- `git cat-file -p <revision>`

Разжимает файл и отбрасывает заголовок; выводит только контент.

## `[pi] ls-tree`, просмотр содержимого дерева

Команда корректно разыменовывает любые объекты (теги, коммиты, ссылки), приводящиеся к tree-ish. Вывод команды можно лимитировать через `pattern` (`-r` = recursive):

- `git ls-tree [-r] <tree-ish> [<pattern>]`

Формат вывода: `<mode> <blob|tree> <sha1>[ <blob-size|->] <entry-name>` (размеры для блобов выводятся через `--long | -l`). Это корректный входной формат для `git update-index --index-info --stdin`.

## Формат индекса

Термины *index*, *stage* и *cache* равнозначны.

- [file:///usr/share/doc/git-doc/technical/index-format.html](file:///usr/share/doc/git-doc/technical/index-format.html)
- https://mincong-h.github.io/2018/04/28/git-index/

```
Header (12 byte; "DIRC <index-version:(2|3|4)> <entries-number>")
Entries list
Extensions
SHA-1 of the index file before this checksum (160 bit)
```

Entry (данные из системного вызова `stat()`):

- `ctime`, время последнего изменения метаданных файла (командами `chmod`/`chown`/`ln`)
- `mtime`, время последнего изменения содержимого файла
- `dev`, ID устройства, на котором расположен файл
- `ino`, номер индексного дескриптора файловой системы (inode)
- `object type`, тип объекта git: 1000 (regular file), 1010 (symbolic link) и 1110 (gitlink)
- `perm:(0755|0644)`, UNIX-права, только 2 возможных значения для файлов. Симлинки и git-линки имеют в этом поле `0`
- `uid`, ID владельца файла
- `gid`, ID группы владельца файла
- `file-size`, размер файла в байтах
- `sha1`, хеш объекта (160 бит)
- `flags`, флаги, зависят от версии
- `file-path`, относительно рабочей директории верхнего уровня. В v4 идет префиксное сжатие этого поля относительно предыдущего (видимо, нужно для паковки)

Элементы (entries) индекса сортируются сначала по полю `file-path`, рассматриваемому как строка беззнаковых битов (без локализации, учёта `/` и т.д.; это для `memcmp()`), а потом по `stage-level`.

Дополнительные флаги в версиях выше 2 читаются только тогда, когда `extended-flag=1`; во второй версии он всегда ноль и эти два флага игнорируются:

- v2: `assume-unchanged:(1|0)`, `extended-flag=0`, `stage-level:[0-3]`, `file-name-length`
- v3, v4: дополнительно `skip-worktree:(1|0)`, `intent-to-add:(1|0)`

Расширения и их сигнатуры:

- Cached tree (`TREE`). Содержит хеши деревьев, которые могут быть сгенерированы по индексу. Это ускоряет запись деревьев при коммите. При изменении какого-либо пути в индексе хеш соответствующего дерева инвалидируется
- Resolve undo (`REUC`). При разрешении конфликтов (напр., `git add <path>`) все вхождения со `stage-level` больше нуля удаляются из индекса. Это расширение сохраняет их, чтобы можно было воспроизвести конфликт с нуля (напр., через `git checkout -m`)
- Split index (`link`). Поддерживает режим *split index*, храня `sha1` "расщепленного" индекса. Сам файл такого индекса хранится в `.git/sharedindex.<sha1>`
- Untracked cache (`UNTR`). Хранит кеш неотслеживаемых файлов. Имеет довольно сложную структуру, учитывает файл `.git/info/exclude`
- File system monitor (`FSMN`). Поддерживает совместную работу гита с системным файловым монитором, хранит метаданные для взаимодействия с этим монитором
- Index entry offset table (`IEOT`). Помогает определить стоимость задействования многопоточности при загрузке индекса в память. Хранит количество элементов (entries) в блоках и смещения этих блоков в бинарном индексе
- End of index entry (`EOIE`). Ничего не делает, маркирует конец списка расширений. Хранит их сигнатуры и смещения в бинарном индексе

## `[pi] ls-files`, просмотр индекса и/или рабочего дерева

Выводит списки файлов, рабочий каталог (`--others` - ignored files) + индекс (`<pattern>` лимитирует):

- `git ls-files [ --stage | --debug ] <pattern>`

Выводит просто список файлов, а со `--stage`: "`<mode> <sha1> <stage-level> <file-path>`". Опция `--debug` выводит данные от `lstat()`.

## `[pm] update-index`, регистрация контента в индексе

Пишет хеш/пермишны/имя файла в индекс. Сбрасывает `stage`-биты в ноль (*fully merged state*). Для файла, если не указана опция `--info-only`, - физически пишет объект в базу. Команда по умолчанию игнорирует скрытые файлы (в том числе во вложенных директориях, `./file` и `dir/./file`) в общих паттернах; для их (файлов) добавления нужно указывать полные имена.

Две формы, через файл в рабочей директории и через контент в базе объектов:

- `git update-index [<file> ...]`
- `git update-index --cacheinfo <mode>,<object>,<file>`

Опции:

- `--add / --remove / --refresh`. По умолчанию команда только обновляет уже имеющиеся в индексе файлы. `--refresh` не обновляет хеши, только `stat`-информацию
- `--[no-]assume-unchanged` (см. флаги индекса). Не переписывает хеш файла с указанным именем, а только выставляет бит. После этого файл начинает считаться git-ом неизмененным (напр., при мерджах). Бывает полезно на системах с медленным `lstat` (можно маркировать неменяющиеся директории и файлы)
- ` --[no-]skip-worktree` (см. флаги индекса). То же. Похож на предыдущий, но предназначен для другого (?). С этим битом Git считает файл в рабочей директории неизменным, и читает содержимое из индекса, не из рабочей папки (?)
- `--[no-]fsmonitor-valid` (см. флаги индекса). То же.
- `--[no-]split-index`, `--[no-]untracked-cache`, `--[no-]fsmonitor` включают/выключают расширения в индексе (см. выше)
- `--index-info` для скриптов и чтения из `stdin`. Корректно принимает данные от `git ls-tree` и `git ls-files --stage`

## `[pm] write-tree`, создание по индексу объекта-дерева и запись его в базу

Выводит в `stdout` хеш созданного дерева. Индекс должен быть в полностью слитом состоянии:

- `git write-tree [--missing-ok] [--prefix=<prefix>/]`

Опция `--prefix` пишет поддерево из индекса, а `--missing-ok` игнорирует отсутствующие в базе хеши из индекса (всё равно создает дерево).

## `[pm] mktree`, создание объекта-дерева по результату `[pi] ls-tree` и запись его в базу

Читает из `stdin` выхлоп нерекурсивного `[pi] ls-tree` и создает в базе объект-дерево. Выводит его полный хеш.

## `[pm] commit-tree`, создание коммита по дереву

Пишет созданный объект коммита в базу и выводит его `sha1` в `stdin`. Команда низкоуровневая, и сама по себе ветки не двигает:

- `git commit-tree [-p <parent> ...] [-m <message> ] <tree>`

Данные об авторе и коммитере берутся из env-переменных `GIT_AUTHOR_*` и `GIT_COMMITTER_*`, а если они не заданы - из конфига гита (`user.name`, `user.email`).

## `[pm] read-tree`, чтение дерева из базы в индекс и (опционально) слияние

Обновляет индекс по указанному дереву. Не изменяет никакие объекты в базе. С префиксом вычитывает в указанный подкаталог, с `--empty` просто очищает индекс. С опцией `-m` также выполняет слияние, а дополнительно с `-u`, - еще и обновление рабочего каталога после слияния:

- `git read-tree [--prefix=<prefix>] <tree-ish>`
- `git read-tree --empty`
- `git read-tree [-m [-u]] <tree-ish1> [<tree-ish2> [<tree-ish3>]]`

Команда низкоуровневая, и выполняет лишь более простые слияния, чем porcelain; если что-то не может - оставляет файлы в неслитом состоянии. Опция `--trivial` еще упрощает - запрещает любые слияния уровня файлов, `--aggressive` же наоборот разрешает немного более сложные.

При слиянии (опция `-m`) играет роль количество деревьев в аргументах команды. Одно - как без опции `-m`, два - перемотка (fast-forward) и три - трехстороннее слияния (3-way merge). В man-странице к команде подробно описаны алгоритмы всех таких слияний.

Включив опцию конфига `core.sparseCheckout` и заполнив файл `.git/info/sparse-checkout` (синтаксис аналогичен `.gitignore`) можно использовать т.н. "разреженный" checkout (*sparse checkout*). `git read-tree` и остальные команды, использующие слияния (`git merge`, `git checkout`, ...) начнут по паттернам в этом файле выставлять путям в индексе `skip-worktree`-бит (см. выше).

## `[pm] checkout-index`, копирование файлов из индекса в рабочий каталог

Без аргументов не делает ничего (это для того, чтобы читаемые из `stdin` пустые команды в pipeline-ах игнорировались). `<file-path>` фильтрует индекс по паттерну:

- `git checkout-index [--force] --all`
- `git checkout-index [--force] <file-path>`

Опция `--force` перезапишет существующие файлы (по умолчанию их не трогает). Опции `--temp` и `--stage=<number>|all` позволяют чекаутить временные файлы (это для `mergetool`).

## Три дерева

`ls -la / tree`  |       | `ls-files` |       | `ls-tree`    |       |`Commit`
---------------- | ----- | -----------| ----- | ------------ | ----- | -------------
`update-index`   | `-->` |            | `<--` | `read-tree`  |       |
`checkout-index` | `<--` |            | `-->` | `write-tree` | `-->` | `commit-tree`

## Ссылки

Все типы хранятся в `.git/refs/`, все являются просто файлом. Имя файла = имя ссылки, контент - полный хеш ревизии. Разделитель директорий `/` является, таким образом, и разделителем пространств имен.

Символическая ссылка - это файл, содержащий `ref: <[refs/]path>`. Когда-то были настоящими soft-линками файловой системы, но для совместимости переделаны в plaintext-файлы. Их список:

- `HEAD` - указатель на текущую ветку (в папку `refs/heads`) или на полный хеш ревизии (т.н. *detached head*)
- `.git` (т.н. *gitfile*) - указатель на директорию `.git/`. Формат: `gitdir: <path>`
- ?? посмотреть `*_HEAD`, но вряд ли

Типы ссылок (одноименные подпапки `.git/refs/`):

- `heads`, ветки
- `remotes`, удаленные ветки
- `tags`, теги
- `replace`, объекты-заместители (см. `git replace`); схожи с `.git/info/grafts` (?), могут передаваться между репозиториями
- `notes` (?)
- `bisect` (?)
- `worktree` (?)

`<!-- TODO: продолжить список -->`

Git поддерживает "упаковку" ссылок в единый файл (`.git/packed-refs`) для повышения производительности. См. `git pack-refs`

## `[pi] show-ref`, список ссылок

Использование этой команды предпочтительнее простого листинга директории `.git/[refs/]` (в том числе из-за `.git/packed-refs`).

- `git show-ref [<pattern>]`

Выводит пары `<sha1> ref/<type>/<name>`. Может разыменовывать теги (`--dereference | -d` добавляет `^{}` к именам аннотированных тегов). `<pattern>` проверяет совпадения с конца пути ссылки, и только целые части (разделитель - `/`).

Посмотреть содержимое файла ссылки можно обычным `cat`-ом, командой `git rev-parse <ref-name>` (предпочтительно) или через `git show-ref -s <full-ref-path>`.

## `[pm] update-ref`, создание/обновление/удаление ссылки

Всегда разыменовывает символические ссылки (это отключается через `--no-deref`). При обновлении/удалении `<old-value>` сравнивается с существующим значением, предотвращая действие при несовпадении. Можно задать 40 `0` или `""` для создания (проверка, что ссылка не существует). Рефлог обновляется если указана опция команды или опция конфига `core.logAllRefUpdates`.

- `git update-ref [--create-reflog] <ref> <new-value> [<old-value>]`
- `git update-ref -d <ref> [<old-value>]`

Использование этой команды предпочтительнее прямой записи в файлы в `.git/refs/`: из-за разыменования символических ссылок и чего-то муторного с невозможностью записи в другое дерево (?).

## `[pm] symbolic-ref`, чтение/запись/удаление символических ссылок

- `git symbolic-ref [--short] <ref>`
- `git symbolic-ref [-m <reason>] <ref> <new-value>`
- `git symbolic-ref --delete <ref>`

Опция `-m` пишет в рефлог причину создания/обновления ссылки. `--short` дает короткий вариант (напр., просто `master` вместо `refs/heads/master`).

## Рефлог

Логгирование изменения ссылок управляется опцией конфига `core.logAllRefUpdates`, выполняется командой `git update-ref` и porcelain-командами. Запись идет в файлы `.git/logs/<ref-name>`. Пишутся изменения `HEAD`, `refs/heads`, `refs/remotes` и `refs/notes` (?). Формат логов - многострочный файл, одна строка на коммит:

```
<sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
<sha1-old> <sha1-new> <commiter-name> <commiter-email> <date> commit: <message>
...
```

## `[am] reflog`, управление рефлогом

Выводит список коротких `<sha1-new>` + ссылку в формате `<ref-name>@{N}` и сообщения коммитов (т.е. о сути часть содержимого файлов из `log/`). По дефолту (стандартно) выводит историю для `HEAD`. Т.к. идет управление рефлогом в целом (а не только вывод истории), поддерживается система подкоманд:

- `git reflog <subcommand|show> <options> [<ref>|HEAD]`

Список подкоманд:

- `show` - по умолчанию, можно не указывать. Показывает историю. Принимает любую опцию команды `git log` (!)
- `expire` - удаляет старые записи. Напрямую обычно не используется, только через porcelain `git gc`
- `delete` - удаляет одиночные (указанные) записи. Обычно тоже не используется юзерами напрямую
- `exists` - проверяет существование записи

## Общий формат plumbing diff-а

Формат общий для трех команд ниже и для `git diff --raw`, построчный для всех путей в дереве:

```
:<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
:<mode-old> <mode-new> <sha1-old> <sha1-new> <status> <file> [<file-new>]
...
```

Хеш нового "файла" состоит из всех нулей если файл новый, при удалении и для неотслеживаемых файлов. Статусы: `A` = added, `C<N>` = copy into a new one, `D` = deleted, `M[<N>]` = modified (content or mode), `R<N>` = renamed, `T` = type changed, `U` = unmerged, `X` = "unknown" change type (most probably a bug). Числа после некоторых статусов показывают процент изменения файла.

Формат diffstat-а см. в мане к системной утилите.

Формат патчей:

- заголовок: `diff --git a/file b/file`
- модификации уровня файла (`{old|new} mode <mode>`, `rename {from|to} <path>`, `copy {from|to} <path>`, `[dis]similarity index <number>`, `{deleted|new} file mode <mode>`)
- `index <sha1-before>..<sha1-after> <mode-if-not-changed>`

Комбинированный формат патчей (combined diff format) использует для каждой строки уже трехсторонние диффы (`++` вместо просто `+`, три строки изменений вместо двух и т.д.).

Общее для трех команд plumbing diff-а:

- последний параметр - `<path-pattern>` - лимитирует сравниваемые файлы/каталоги
- принимают все опции `git diff`
- опция `--patch | -p | -u` выводит стандартные диффы
- опции `-c` и `--cc` используются для мерджей и добавляют доп. `<mode>` и `<sha1>` в вывод. Аббревиатура статуса при этом состоит из буквы для каждого родителя

## `[pi] diff-files`, сравнение файлов рабочего каталога с индексом

- `git diff-files [<path>]`

## `[pi] diff-index`, сравнение объекта-дерева с рабочим каталогом или с индексом

Опция `--cached` сравнивает дерево с индексом, без нее сравнение идет с рабочим каталогом:

- `git-diff-index [--cached] <tree-ish> [<path>]`

## `[pi] diff-tree`, сравнение двух объектов-деревьев

- `git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<path>]`

## Опции `diff`-а

- `--[no-]patch` - показывает/скрывает различия в файлах; `-p | -u` = `--patch`
- `--raw` - plumbing format, опция по умолчанию для низкоуровневых команд, но не для `git diff`
- алгоритмы генерации диффа: `--minimal`, `--patience`, `--histogram`, `--anchored=<text>`, `--diff-algorithm={patience|minimal|histogram|myers=default}`. Также опция конфига `diff.algorithm`
- т.н. *diffstat*: `--stat[=<width>[,<name-width>[,<count>]]]`. Опциональные поля задают ширину столбцов вывода и кол-во строк-файлов
- частичные diffstat-ы: `--numstat` (только кол-во добавленных/удаленных строк), `--shortstat` (только последнюю линию `--stat`), `--dirstat[=<param1,param2,...>]` (статистика по поддиректориям) и т.д.
- `--word-diff[=<mode>]` (и `--word-diff-regex=<regex>`, для определения границ слова) - диффы по слову, не по строке
- `--check` проверяет на маркеры конфликта (`>>> <<<`) и ошибки пробельных символов, выходит в таком случае с ненулевым статусом. `--exit-code` же выходит с ненулевым кодом если есть изменения, и с нулем иначе
- `--binary` генерирует диффы бинарных файлов, которые потом можно скормить `git apply`
- `--abbrev[=<n>]` контролирует длины хешей в списке файлов, а `--full-index` - в патчах (`index <sha1-before>..<sha1-after> ...`)
- `--find-renames|-M[=<n>]`, `--break-rewrites|B[=[<n>][/<m>]]`, `--find-copies|C[=<n>]` управляют поиском переименований, копий и модификаций (?)
- фильтрация диффа по статусу - `--diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]]`
- `-S<string>` ищет изменения, которые изменяли число вхождений указанной строки. Полезно для `blame`-а, для поиска, когда блок кода появился/был удален. Если еще указать `--pickaxe-regex`, то `<string>` будет рассматриваться как регулярное выражение
- `-G<regex>` ищет патчи по паттерну. В отличие от `-S` ее не интересует изменение числа вхождений, только grep по регулярке
- `-O<orderfile>` перекрывает конфиг-опцию `diff.orderFile` (файл со списком паттернов, порядок которых определяет порядок сортировки *имен файлов* в `git log` и `git diff[-*]`)
- `--relative[=<path>]` ограничивает diff текущей (или указанной) поддиректорией
- `--ignore-*` игнорирует разные виду ошибок, связанные с пробелами и пустыми строками
- `--[no-]ext-diff ` и `--[no-]textconv` работают с аттрибутами - в(ы)ключают внешние хелперы диффа и доп. фильтры для конвертации бинарных файлов
- `--{src|dst}-prefix=<prefix>`, `--no-prefix` управляют префиксами имен файлов в диффах (`a/file b/file`), `--line-prefix=<prefix>` добавляет префикс к каждой строке патча
- `-1 | --base`, `-2 | --ours` (default), `-3 | --theirs` используют для сравнения определенные stage-уровни в индексе
- `--ita-[in]visible-in-index` управляет отображением файлов, добавленных через `git add -N` и `git update-index --info-only`

## Основные алгоритмы слияния:

- 2-way merge (diff, простое сравнение; в гите это перемотка, fast-forward)
- 3-way merge - трехстороннее слияние, вспомнить слайд от Перфорс
- 3-way recursive merge - с рекурсивным слиянием/вычислением общего предка, если не существует единственного (уникального) общего предка
- fuzzy patch - ?
- weave merge - ?
- patch commutation - в гите это rebase

## Сводная таблица команд слияния

 Команда              | Описание
--------------------- | ---------------------------------------------
`[pm] read-tree`      | вычитка дерева в индекс и тривиальные слияния
`[pm] merge-index`    | проход по индексу (после `read-tree`) с вызовом хелпера слияния
`[ph] merge-one-file` | стандартный хелпер слияния
`[pm] merge-file`     | трехстороннее слияния уровня файла (контента)
`[ph] fmt-merge-msg`  | генерация сообщения merge-коммита
`[pi] merge-base`     | поиск наилучшего предка для слияния
`[ai] merge-tree`     | трехстороннее слияния деревьев вне индекса
`[mp] merge`          | главная porcelain-команда слияния
`[am] mergetool`      | запуск утилиты разрешения конфликтов

## Механизм слияния в индексе

Первым шагом в plumbing-слиянии идет вычитка деревьев сливаемых ревизий в индекс: `git read-tree -m`. Результат зависит от количества деревьев, указанных в аргументах команды.

Если дерево только одно, идет простое обновление индекса, как и без опции `-m` (за исключением того, что `lstat()`-информация в индексе для совпадающих путей не инвалидируется).

Два дерева - это ситуация fast-forward-слияния (перемотки): `git read-tree -m $H $M`, где `$H` - текущий HEAD-коммит, а `$M` - дерево коммита впереди текущего. В этом случае команда учитывает состояния еще двух "деревьев" - рабочего каталога (это для опции `-u`) и текущего индекса, ведь они могут отличаться от `$H` (иметь незакоммитанные изменения, которые нужно сохранить). Команда может завершиться ошибкой, может заменить в индексе хеш файла/каталога на значение из `$M`, или сохранить текущее значение хеша (при совпадении с `$H`). Таблица кейсов из 21 пункта есть в мане к `[pm] read-tree`. При таком слиянии (перемотке) команда не меняет stage-биты у путей в индексе, лишь завершается с ошибкой в случае конфликта.

Полноценный 3-way merge на уровне вхождений (entries) индекса: `git read-tree -m <merge-base> <current-branch> <other-branch>`. Порядок деревьев важен. После слияния пути из каждого дерева пишутся в индекс со своими stage-состояниями:

- `0` = merged
- `1` = merge-base (common ancestor)
- `2` = current-branch
- `3` = other-branch

Идет классическое трехстороннее слияние (вспомнить слайд от Перфорс). Если конфликта на уровне путей/хешей нет, нужный вариант хеша (`2` или `3`, тот который не совпадает с базой) пишется в индекс в слитом состоянии (`0`). Иначе в индекс пишется три вхождения "хеш-путь", каждый со своим stage-битом. Результирующий индекс находится в не полностью слитом состоянии, и команда `[pm] write-tree` на нем не сработает.

В случае уже заполненного файла индекса команда при двух- и трехсторонних слияниях завершится с ошибкой, если вхождение в индексе отличается от вхождения в "текущем" сливаемом дереве (`$H` или `<current-branch>`). Это для предотвращения потери незакоммитанных изменений. Как-то еще проверяются изменения в рабочем каталоге, не добавленные в индекс, и тоже предотвращается их случайное уничтожение (?).

Т.к. команда `[pm] read-tree` низкоуровневая, она не производит слияний уровня файла, только уровня "хеш-путь". Это сделано для возможности выбора в высокоуровневых командах т.н. *porcelain policy* - решения, как удалять из индекса stage-биты старше нуля и какую версию файла писать в нулевой стейдж. Для скриптов, после `read-tree`, для удаления старших stage-состояний и записи слитых версий можно использовать `[pm] merge-index` с `[ph] merge-one-file`.

## `[pm] merge-index`, проход по индексу с вызовом хелпера слияния

Проходится только по файлам, требующим слияния. Фильтрует пути в индексе по паттерну `<file>` или выбирает все (`-a`):

- `git merge-index [-o] <merge-program> (-a | [--] <file>*)`

Останавливается если хелпер вернул ненулевой код выхода (или обрабатывает всё даже если есть ошибки, опция `-o`). Стандартный хелпер слияния `[ph] merge-one-file` входит в пакет гита.

## `[ph] merge-one-file`, простой хелпер слияния уровня файла

Шелл-скрипт, обрабатывающий простые случаи трехстороннего слияния:

- Deleted in both or deleted in one and unchanged in the other: `git update-index --remove`
- Added in one: `git update-index --add --cacheinfo`
- Added in both, identically (check for same permissions): `git update-index --add --cacheinfo`
- Modified in both, but differently: `git merge-file $(git unpack-file) && git update-index`

Хелпер также обновляет рабочий каталог по индексу после слияния ( вызывает в конце `git checkout-index -u -f`) (?).

## `[pm] merge-file`, трехстороннее слияния уровня файла

Полноценный 3-way-merge по контенту. Работает с файлами (не с объектами или индексом). Результат слияния пишет в файл (`<current-file>`) либо в `stdout` (если указана опция `-p`):

- `git merge-file [-p] <current-file> <base-file> <other-file>`

В случае конфликтов добавляет маркеры `<<<<<<<`/`>>>>>>>` в результат. Если указана одна из опций `--ours`/`--theirs`/`--union`, то конфликтов не генерирует, а вставляет строки из указанного файла (или обоих (?)).

## `[ai] merge-tree`, трехстороннее слияния деревьев вне индекса

Похожа на `git read-tree -m`, но не затрагивает файл индекса (проводит слияния вне него, и пишет результат в `stdout`):

- `git merge-tree <base-tree> <branch1> <branch2>`

## `[ph] fmt-merge-msg`, генерация сообщения merge-коммита

Читает из `stdin` список коммитов для слияния, и генерирует по ним стандартное сообщение для `[mp] merge` (`Merge branch 'master' of github.com:...`):

- `[git fetch && ] git fmt-merge-msg --log < .git/FETCH_HEAD`

Опция `--file|-F <file>` читает объекты из файла вместо `stdin`, а `--[no-]log` добавляет в сообщения summary коммитов в сливаемой ветке.

## `[pi] merge-base`, поиск наилучшего предка для слияния

Получает на вход два коммита и ищет их наиболее близкого общего предка. Таких предком может быть больше одного (опция `--all` выводит всех, не только первого):

- `git merge-base <commit1> <commit2>`
- `git merge-base --octopus <commit> ...`
- `git merge-base --is-ancestor <commit1> <commit2>`

Второй вариант ищет лучшего предка для всех указанных коммитов (n-way merge), это аналог `git show-branch --merge-base`. В третьем варианте команда выходит с нулевым статусом если `<commit1>` явлвется предком `<commit2>`, и с ненулевым иначе.

Опция `--fork-point` использует также reflog для поиска базы слияния, что может пригодится при rebase-е (?). Подробный разбор этого есть в мане к команде.

## `[am] mergetool`, запуск утилиты разрешения конфликтов

Запускается, как правило, после (неудачного) выполнения `git merge`. Если не указан `<file>`, то запускается на всех файлах с конфликтами:

- `git mergetool [--tool=<tool>] [-y | --[no-]prompt] [<file>...]`

Опция `--tool|-t=<tool>` определяет, какая утилита запустится. Список доступных: `git mergetool --tool-help`. Варианты: `emerge`,`gvimdiff`, `kdiff3`, `meld`, `vimdiff`, `tortoisemerge`. Если эта опция не указана, смотрит в конфиг `merge.tool`. Если и там пусто, то выбирает что придется ("suitable default"). Возможна гибкая настройка через конфиг гита (путь к утилите, имя и т.д.). Опция `--gui|-g` вызовет то, что записано в `merge.guitool`.

Команда создает `*.orig`-файлы бекапа. Их удаление после заверешения сессии контролируется опцией конфига `mergetool.keepBackup`.

## Ревизии

Это ссылки на отдельный коммит либо на граф коммитов (как в `git log`, все коммиты, достижимые из указанного). Также можно ссылаться на другие объекты (теги, блобы, деревья).

Т.н. *расширенный SHA1-синтаксис* (extended SHA1 syntax):

- полный или частичный хеш
- вывод команды `git describe` - ближайший тег + число коммитов после + `g` + короткий хеш (напр., `v1.7.4.2-679-g3bee7fb`)
- имя ветки. Короткое имя ищется в глубину, в папке `.git/`. Подпапки перебираются в порядке `./ -> refs/ -> refs/tags/ -> refs/heads/ -> refs/remotes/`. В случае неоднозначности берется первое совпадение
- имена специальных ссылок: `HEAD`, `FETCH_HEAD`, `ORIG_HEAD`, `MERGE_HEAD`, `CHERRY_PICK_HEAD`
- `@` в одиночку = `HEAD`
- `<refname>@{<date>}`, с датой в свободном формате (`5 minutes ago`, `1979-02-26 18:30:00` etc.) - локально состояние ветки в момент времени, берется по рефлогу
- `<refname>@{<n>}` - состояние ветки `<n>` коммитов назад
- без имени ссылки - `@{<n>}` - работает с текущей веткой. При отрицательном `<n>` перебирает не коммиты в ветке, а коммиты (ветки), которые были отчекаутены
- `[<branch>]@{upstream}` = `[<branch>]@{u}` - отслеживаемая ветка (параметр конфига `branch.<name>.merge`). Если `<branch>` опущена, то берется текущая ветка
- аналогично с `@{push}`. Как правило равна `@{u}`
- `<rev>^[<n>]` - n-ный предок "в ширину", `<rev>~[<n>]` - n-ный предок "в глубину". В `git help revisions` есть иллюстрация с графом и разными случаями
- `<rev>^{<type>}` - рекурсивное разыменование коммита до указанного типа объекта
- `<tag>^{}` - разыменование тега до того, как встретится не-тег
- `<rev>^{/[!-]<regexp>}` и `:/[!-]<regexp>` - ищет самый новый коммит, чье сообщение фиксации проходит `<regexp>`. Коммит может быть достижим из любой ревизии во втором варианте и только из указанной в первом. `!-` - отрицание паттерна, ищет первое несовпадающее сообщение
- `<rev>:<path>` - доступ к блобу или дереву в коммите
- `[:<stage-level>]:<path>` - доступ к блобу в индексе

Диапазоны:

- `<rev>` - достижимые из `<rev>`, `^<rev>` - недостижимые
- `<rev1>..<rev2>` - достижимые из 2, но не из 1. При отсутствие любой ревизии в записи на ее место подставляется `HEAD`
- `<rev1>...<rev2>` - xor, только достижимые из любого, но не из обоих разом. Для `HEAD` правило то же
- `<rev>^@` - все предки (всё, что достижимо из предков коммита), но не сам коммит
- `<rev>^!` - сам коммит и исключение всех его предков (?)
- `<rev>^-[<n>]` = `<rev>^<n>..<rev>`, где `<n>` по дефолту равно 1

## `[pi] name-rev`, символическое имя по хешу

Для указанного коммита выводит его "отношения" к локальным ссылкам, в формате `<sha1> <ref>~<n>`, где `<n>` - число коммитов до:

- `git name-rev [--tags] [--refs=<pattern>] <commit-ish> ...`
- `git name-rev --all`
- `git name-rev --stdin`

Может выводить все коммиты для всех ссылок (`--all`) или читать данные `git log` из `stdin`.

## `[pi] rev-list`, перечисление коммитов

В обратном хронологическом порядке. Plumbing log, `HEAD` автоматом не подставляется. `git log` принимает все опции этой команды (+ все опции plumbing diff-ов (`git diff-*`). Опций очень много. Набор коммитов в аргументах задает граф коммитов. `<paths>` выбирает только те коммиты, которые модифицировали указанный путь:

- `git rev-list [<options>] <commit> ... [ -- <paths> ... ]`

Базовой формой задания графа коммитов является простое перечисление ревизий, с или без знака `^` (= `--not` перед ревизией): `A B ^C ...`. В таком графе есть коммиты, достижимые из `A` и `B`, и недостижимые из `C`. Поддерживаются также диапазоны коммитов (см. выше).

`<!-- FOR_PR in man -->`

## Опции `log`-а

- `-<num> | -n <num> | --max-count=<num>` - ограничение числа выводимых коммитов
- `--skip=<num>` - пропустить `<num>` коммитов перед тем как начать вывод
- `--{since|after|until|before|{max|min}-age}=<date>` - лимитирование по дате
- `--{author|committer}=<pattern>` - по имени
- `--grep[-reflog]=<pattern>` - grep сообщений коммитов (или рефлога)
- `--all-match` - если задано несколько `--grep`
- несколько модификаторов регекспа, такие как `-i` или `--extended-regexp`
- `--{branches|tags|remotes|glob|exclude}[=<pattern>]` подставляет все ссылки указанного типа в аргументы (паттерн лимитирует). Для `glob` и `exclude` паттерн обязателен, там тип ссылок не учитывается, берутся все
- `--walk-reflogs | -g` проходится по рефлогу, не по предкам в графе коммитов. С этой опцией нельзя указывать `^`/`--not`
- `--bisect[|-vars|-all]` - хелперы бисекта, выводят только половину коммитов
- `--simplify-by-decoration` выводит только первый/последний коммиты ветки. Имеет несколько режимов (`--dense`/`--sparse`/etc.)
- `--{[author-]date|topo}-order`/`--reverse` - порядок вывода коммитов
- `--objects` и еще десяток похожих опций управляют показом хешей объектов (это для паковки)
- `--pretty[=<format>]`/`--format=<format>` управляют форматом вывода: `oneline`, `short`, `medium` (default), `full`, `fuller`, `email`, `raw`, `format:<string>`, `tformat:<string>`
- `--[no-]abbrev-commit` - короткие хеши в выводе
- `--oneline` = `--pretty=oneline --abbrev-commit`
- `--show-signature` - GPG-сигнатуры в выводе
- `--date=<format>` - управление форматом даты (напр., `---relative-date` == `--date=relative`)
- `--left-right` выводит "стороны" (символы `>`/`<`) если в качестве диапазона задана симметричная разность (`A...B`)
- `--graph` - выводит ASCII-граф истории

В строках формата для `--pretty`/`--format` используются плейсхолдеры (напр., `format:"The author of %h was %an, %ar%nThe title was >>%s<<%n"`). Их несколько десятков, полный список в мане к `[pi] rev-list`.

## `[pi] rev-parse`, разбор ревизий (и опций)

Основное назначение - разбирать extended SHA1-формат ревизий (см. выше) для скриптов и porcelain-команд, выдавать хеш по символьной записи ревизии. Также может служить аналогом `getopt` для разбора опций и последующего их использования в `eval` в шелле (?).

В режиме `--parseopt` читает (из `stdin`) текстовые файлы спец. формата и преобразует описанные в них опции в формат, пригодный для использования в шелле.

- `git rev-parse [--verify] <commit-ish>`
- `eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"`

Имеет кучу опций, таких как вывод всех SHA1-хешей для тегов/веток/удаленных веток, парсинга дат гита из свободной формы (`--since=`/`--after=`/...), и вывода системной инфы о репозитории: `--local-env-vars`, `--git-dir`, `--is-inside-{git-dir/work-tree}`, `--is-{bare|shallow}-repository`, `--show-cdup` (и похожие, для относительных путей поддиректорий).

## `[ai] show-branch`, вывод графа коммитов

Выводит сообщения коммитов с префиксами (`*`/`+`/`++`/`!`/etc.). Ревизия (`<rev>`) или паттерн имени в папке `.git/refs/` (`<glob>`) лимитируют вывод, иначе выводятся потомки всех ссылок:

- `git show-branch [ --remotes | --all ] [<rev|glob>]`

В выводе идет одна строка на коммит, сдвинутая на нужное (для формирования псевдо-графа) кол-во пробелов относительно начала. Префикс текущей ветки - `*`, остальных - `!`, коммитов - `+`, и слияний - `-`. Опция конфига `showbranch.default` определяет дефолтный параметр `<rev|glob>`.
