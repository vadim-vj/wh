 Git

# Disclaimer

# Почему мне вообще нужен Git

## Бекап

### Введение в ГитХаб: - про ядро Линукс - как он популяризировал Гит - скрины, примеры, почему удобен

## Резюме

### Зачем он нужен в проф. разработке, стабильная версия, работа в команде

### Начальный уровень, ссылки на ресурсы, disclaimer

### Продвинутый уровень, обучение снизу
 (see:Отдельная "глава" про помощь: команды, ресурсы, ссылки)
# Отдельная "глава" про помощь: команды, ресурсы, ссылки

# Немного истории, про ядро Линукс, патчи по мылу и ГитХаб. Здесь же наверное про консоль (что она нужна только для разбора internals)

# Git Internals

## Введение

### Disclaimer (мне думается, что лучше начать с них). Изучать концепции через internals труднее, но понимание глубже

### Видимо будет самый большой раздел, здесь все концепции и команды

### Про дешевые жесткие диски, трекинг состояний репы вместо отдельных файлов

### Про коммерческую разработку, откат состояний, работу команды, поиск ошибок. Тут можно графов/рисунков добавить, про ветки и снимки (идея стабильной ветки и веток разработчиков)

### Краткое пояснение про команды - нужно для продолжения
 (see:Немного истории, про ядро Линукс, патчи по мылу и ГитХаб. Здесь же наверное про консоль (что она нужна только для разбора internals))
#### Не очень краткое получится

#### Нужно рассказать про консоль, Линукс-подобные системы

#### И структуру команды Гита

#### plumbing/porcelain

#### Про скрипты, разрозенность, нелогичность, немного истории

## КАФС

### Про повтор файлов в снимках, необходимости экономии места

### Концепция контентной адресуемости

#### Что такое хэш, (pm) hash-object

#### Как она экономит место

#### Как она поддерживает целостность

### Объекты-папки, независимость от файловой системы, про целостность

## Снимки/коммиты

### Понятие рабочей директории и human readable-привязки - коммита, ссылки на родителя. Если дерево (снимок) - этот состояние проекта, то коммит - это привязка этого состояния ко времени, элемент истории

### Всё это со схемами, рисунками и всем таким

### Представление графа файл-директория в виде файлов в папке objects, краткое описание папки .git

### Общая идея виртуального мирка версий, (pi) cat-file

### Формат объектов, сжатие, немного о ручном создании

## Именование

### О неудобстве хэшей, идея именования коммитов

### Тему именования нужно пока затрагивать без связи с ветвлением, для линейных коммитов

### 

### О параллельной разработке и "говорящем" именовании веток

### Концепция sticky tag, движения ветки

### 

#### это к ветвлению, придется говорить, что вернемся к теме позже

### stupid git, файл HEAD, ветка master, папка ref/, концепция символической ссылки ("ref: refs/", и примеры, типа gitfile). Краткая история символических ссылок гита есть в хелпе к (pm) symbolic-ref

#### (pm) update-ref

#### (pm) symbolic-ref

### Про теги здесь наверное говорить пока не стоит, чтобы не усложнять

## Индекс/создание коммита

### Необходимость индекса, его концепция, структура, (pi) ls-files

#### Необходимость быстрой проверки изменений в файлах, lstat

#### Ручной набор коммита

#### Трудность формирования деревьев вручную

### Необходимость всегда держать индекс в уме, невозможность перескока через дерево

### Формат индекса, подробный и сложный

### Три дерева

#### (pi) ls-tree -r HEAD

#### (pi) ls-files -s --debug

#### ls -la / tree

### 

### Модификация индекса, (pm) update-index

### Создание коммита, (pm) write-tree, commit-tree

### Чекаут коммита, (pm) read-tree, checkout-index

### 

#### процесс создания снимка и перехода на него - основа работы. Описание через "зачем нужно", не забыть. И описание в целом, с охватом процесса нужно
 (see:Про коммерческую разработку, откат состояний, работу команды, поиск ошибок. Тут можно графов/рисунков добавить, про ветки и снимки (идея стабильной ветки и веток разработчиков))
## Ветвление

### Об идее параллельной разработки

### О создании состояний, отходящих от стабильного состояния
 (see:Про коммерческую разработку, откат состояний, работу команды, поиск ошибок. Тут можно графов/рисунков добавить, про ветки и снимки (идея стабильной ветки и веток разработчиков))
### Идея веток

### Папки: refs/heads/, refs/remotes/, refs/notes/ (?)

### (pi) show-ref

### Всё со схемами и раскрашенными графами

### reflog

## Работа

### (pi) diff-*

## Слияние

### Концепция 3-way merge

## Remotes

### (pi) ls-remote

# Porcelain

## Всё страшное позади, впереди только простое

## Понятие высокоуровневых команд

## Сравнение workflows

# Разное

## i18n

## Группировка команд и автодополнение

# Commands

## Общее

### Указание пути (<path> в командах как правило лимитирует вывод/действие только этим путем

### Нужно для всех приводить кратко: ситуацию когда нужна и основную форму (обощенный пример использования)

## pi

### Общее

#### Параметр <path> в командах это просто список паттернов, лимитирующих вывод, не обязательно реально существующие пути

### cat-file

#### -p = pretty print

#### -t = type

#### -s = size

#### и куча других для обработки stdin-а: filters, textconvs, path и т.д.

### ls-files

#### только 2 дерева: индекс и рабочий каталог

#### выводит только имена файлов

#### Выводит сначала индекс, а потом файлы рабочего каталога

#### Можно указать последним аргументом файл/папку/паттерн, тогда выведет только относящееся к ним

#### в отличии от cat-file все опции имеют длинные альтернативы

#### Файлы рабочей папки: -m -d -o -i -k выводят только такие файлы, не все

#### без опций = -c - все в индексе

#### -s | --stage показывает stage-биты. Неявно включает -c (показать весь индекс). вывод: <mode> SP <sha1> SP <stage> TAB <file>, сделан таким для передачи по конвейеру в update-index --index-info --stdin

#### --debug еще и остальные поля индекса

#### -u | --unmerged - только неслитые (stage-бит > 0 ?). Неявно включает -s

#### -t - интересная опция, но уже почти deprecated

#### дофигища всяких опций по include/exclude с паттернами

#### Тут должна быть ссылка на read-tree и merge (концепция stage-битов в индексе)
 (see:Тут должна быть ссылка на read-tree и merge (концепция stage-битов в индексе))
### ls-tree

#### некий аналог ls -la

#### обязательно <treeish> и опционально <path>

#### если путь указан, лимитирует вывод им

#### вывод идет в предположении что <treeish> - это дерево корневой директории, а <path> - ее подкатолог. Не нужно указывать дерево текущей сабдиректории, иначе вложенность станет больше нужной

#### вывод: <mode> SP <type> SP <object> TAB <file>, сделан таким для передачи по конвейеру в update-index --index-info --stdin (типа аналог read-tree?)
 (see:-s | --stage показывает stage-биты. Неявно включает -c (показать весь индекс). вывод: <mode> SP <sha1> SP <stage> TAB <file>, сделан таким для передачи по конвейеру в update-index --index-info --stdin)
#### -d -t -r - рекурсивный/нерекурсивный обход

#### -l - показывать размеры блобов

#### еще всякое про формат отображения имен/хешей

### show-ref

#### выводит ссылки в локальной репе

#### формат вывода: <commit-id> <ref>

#### по умолчанию выводятся: tags, heads, remote refs

#### использование этой утилиты поощряется, вместо листинга каталога ref/

#### --head выводит еще и HEAD (с дереференсом до sha)

#### --tags, --heads - типы объектов

#### -d | --dereference - дереф. теги, к ним добавятся ^{}

#### --verify - проверка ссылки

#### --quiet для скриптов (не печатать ошибку, а выходит с ненулевым статусом)

#### последний аргумент команды - фильтр имен (<pattern>)

### diff-files

### diff-tree

### diff-index

### ls-remote

## pm

### hash-object

#### может принимать имя файла последним аргументом

#### выводит хеш в stdout

#### -t <type> - тип объекта, по умолчанию blob

#### -w - запись в базу

#### --stdin - читать из потока

#### и еще пара опций про пути и фильтры

### update-index

#### важная команда, куча опций и применений

#### два варианта указания данных

##### <file> в конце

##### --cacheinfo <mode>,<object>,<path>, нужно для слияний без чекаута (без физических файлов, забираяя данные прямо из объектной базы). Устаревший формат - с пробелами вместо запятых

##### оба могут быть вычитаны из stdin, опция --index-info. Поддерживает 2 формата: вывод ls-tree и ls-files -s

#### опции --add/--remove

##### --replace позволяет замещать дерево файлом и файл деревом, замещение однотипных объектов идет без опции

#### --info-only не пишет блобы/деревья в базу, а только вычисляет хеши и добавляет их в индекс. Она ка-то еще использовалась, и что-то там типа про add --dry-run было
 (see:--cacheinfo <mode>,<object>,<path>, нужно для слияний без чекаута (без физических файлов, забираяя данные прямо из объектной базы). Устаревший формат - с пробелами вместо запятых)
#### --refresh, ту не совсем понял. Не обновляет пути в индексе, не пишет ничего в базу. Вроде как только обновляет stat-инфу для файлов. Это бывает нужно, например, после read-tree. Опция --ignore-missing позволяет не вылетать с ошибкой в процессе. Может вызываться без <file> или --cacheinfo

#### --[no]-assume-unchanged помечает (устанавливает бит) обновляемый путь, и lstat на нем вызваться не будет. Это для тех ФС, где lstat медленный. И для чего-то еще оно было, если мне не кажется. Этот бит в индексе можно посмотреть через ls-files -v. --refresh будет его тоже учитывать, поэтому есть еще --really-refresh
 (see:--info-only не пишет блобы/деревья в базу, а только вычисляет хеши и добавляет их в индекс. Она ка-то еще использовалась, и что-то там типа про add --dry-run было)
#### похожий бит --[no-]skip-worktree, имеет преимущество над assume unchanged. Пишут, что у него другие цели (какие?)

#### Split Index. Для очень больших индексов и репозиториев. Помимо файла index (собственно split index) появляются еще и sharedindex.<SHA-1> (т.н shared indexes). В split index накапливаются изменения, когда их становится много, переносятся в hsared index. Периодически создаются новые shared index, а старые удаляются. Размером split index и временем устаревания shared index управляют 2 конф. переменные. Тут нужно разбираться в алгоритме

#### для ускорения работы команды status в индексе можно хранить кэш неотслеживаемых файлов. Проверка поддержки: update-index --test-untracked-cache. Добавление/обновление: --[no-|force-]untracked-cache. Конф. переменная - core.untrackedCache

#### еще ускорить можно с фичей File System Monitor. Git начинает работать совместно с системным файловым монитором, и lstat становится не нужен. Опция --[no-]fsmonitor, конф. var - core.fsmonitor

#### у команды есть еще много опций и конф. переменных про пермишны (учитывать ли exec-биты), про симлинки, mtime/ltime и прочее, для работы с разными FS

### write-tree

#### Записывает в базу все деревья по текущему индексу

#### Индекс должен быть в fully-merged состоянии

#### Выводит в stdout хэш корневого дерева

#### --missing-ok игнорирует отсутствующие в базе вхождения из создаваемых деревьев

#### --prefix=<prefix>/ записывает в базу указанное поддерево в индексе

### commit-tree

#### Общая форма: write-tree <tree> -p <parent-hash>

#### Родителей может не быть или быть больше одного

#### Сообщение коммита читается из файла (-F), из опции (-m) или из stdin-а

#### Почта, имена и даты коммитера и автора берутся из переменных среды ил (если не установлены) из конфига гита

#### Подпись: -S[key-id] | --[no-]gpg-sign[=<key-id>]

#### HEAD она вроде не обновляет

#### И что-то там про кодировки путей файлов и сообщений коммита

### read-tree

#### Вычитывает дерево в индекс или производит слияние деревьев

#### Перед слиянием индекс должен быть в unmerged state, но это можно и проигнорировать с --reset

#### Выполняются только тривиальные слияния, различные стратегии оставляются для porcelain-команд

#### Поведение команды зависит от того, сколько деревьев указано

##### 1. Вычитка в индекс, заменяются только пути с несовпадающим контентом

##### 2. Fast forward, 2-way merge. Таблица правил замены

##### 3. 3-way merge. Тоже всё сложно. В 2 и 3 еще участвует рабочая директория

#### -u обновляет файлы в рабочем каталоге после слияния (checkout)

#### --empty - очистить индекс. Последним параметром <tree> можно не передавать

#### --prefix=<prefix> - вычитать в подкаталог (только в новый)

#### --index-output=<index> - вычитать в произвольный файл

#### и еще что-то там про сабмодули и sparse checkout

### checkout-index

#### c -a или <file> последним аргументом скопирует все (указанные) файлы файлы в рабочий каталог

#### -f еще и перепишет существующие (по умолчанию нет)

#### --prefix=<dir> - чекаут в подкаталог

#### без аргументов не делает ничего (такое поведение нужно для скриптов

#### --temp или --stage=all чекаутит весь индекс во временные файлы и выводит в stdput соответствия между элементом индекса и таким временным файлом. Нужно для создания external merge tools

#### (пример) вычитать всё: checkout-index -f -n -a

### updaate-ref

#### формат: update-ref <ref> <new-val> [<oldvalue>]

#### отличается от простой записи безопасностью

##### следует символическим git-ссылкам

##### че-то там с настоящими симлинками и папкой ref/

##### разворачивает короткие хэши

#### всегда дереференсит <ref> (проверяет, что файл начинается с "ref:"). Есть и опция --no-deref

#### третий параметр делает обновление безопасным: обновляется только при совпадении старого значения с ним (указание 40ка нулей или пустой строки, таким образом, сделает проверку на существование (только добавление, не обновление))

#### -d удаляет ссылку

#### --stdin читает команды. Свой язык, 5 команд (update, verify etc.)

#### пишет в reflog (так в книге). Есть опция --create-reflog (тогда зачем она?)

#### core.logAllRefUpdates пишет в какой-то свой рефлог (для каждой ссылки)

### symbolic-ref

#### с одним аргументом выводит куда ведет ссылка

#### --delete удаляетс саму ссылку

#### с двумя аргументами обновляет

#### выдает ошибку в detached head (или выходит с non-zero status если опция -q). Как же тогда обновлять?

#### --short печатает короткие имена (refs/heads/master -> master)

#### -m <message> задает сообщение для рефлога

## ai

## am

### reflog

# Всегда держать в уме, что нужно не описание, а ответ на вопрос "Зачем?"

# Если вопрос и ответ не следуют естественно, жульничать не надо - надо искать инфу
