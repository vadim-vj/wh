# Groovy language (local)

## Общие заметки
- язык чувствителен к регистру, как и Java

## Style guide
<a href="https://groovy-lang.org/style-guide.html" target="_blank">https://groovy-lang.org/style-guide.html</a>
- не ставить `;`
- не использовать `return` по возможности
- не использовать `def` с типом: ~~`def String name = ...`~~
- `def` в параметрах методов и в объявлении конструкторов лишний, не нужно там его использовать
- но лучше использовать явное указание типа (для IDE, самодокументируемого кода и проверок на этапе компиляции)
- общее правило: использовать явную типизацию в публичных интерфейсах, контрактах и API. В приватном коде, во внутренних методах, можно использовать `def`
- не использовать модификатор доступа `public`: он и так по дефолту
- опускать скобки когда возможно (`println "Hello"`, `method a, b` (вызов метода), `list.each  { println it }` etc.)
- опускать суффикс `.class`: объекты первого класса (`ResourcesResponse` вместо `ResourcesResponse.class`)
- не объявлять и не использовать геттеры/сеттеры: `.name = "something"` вместо `.setName("something")` (а boilerplate code генерируется автоматически)
- не объявлять дефолтный конструктор и не инициализировать поля явно, вместо этого использовать сгенерерированный дефолтный конструктор (`def server = new Server(name: "Obelix", cluster: aCluster)`)
- использовать `with()` и `tap()` чтобы не повторять имя объекта и не вычитывать его во временную переменную
- использовать `==` вместо `equals()` (заодно это позволяет избежать проверки на `null`)
- строки:
  * предпочитать interpolated strings (строки в стиле Groovy) обычной конкатенации (`+`)
  * предпочитать (dollar) slashy string для регулярных выражений
  * но при этом предпочитать строки в одинарных кавычках для констант
- использовать синтаксис Groovy (не Java) для списков, карт, паттернов и диапазонов
- использовать методы Groovy для итерации по коллекциям (`each{}`, `find{}`, `findAll{}`, `every{}`, `collect{}`, `inject{}`; см. GDK)
- по максимуму использовать возможности `switch` (возможность использовать в `case`-ах произвольные типы, поддерживающие `.isCase()`)
- использовать псевдонимы импорта для исключения дублирования (`import java.util.List as UtilList`, `import java.awt.List as AwtList`)
- использовать в `if`, `while` etc. неявную проверку на истинность ("Groovy truth") вместо явных (`if (name) { ... }` вместо `if (name != null && name.length > 0) { ... }`), либо даже переопределять `.asBoolean()` у классов для возможности такой проверки
- использовать оператор безопасного доступа `?.` вместо явных проверок
- использовать `assert`
- использовать короткий тернарный оператор `?:` (т.н. "Elvis operator")
- не указывать тип перехватываемого исключения в блоке `catch`, если нужно ловить всё

## Комменты
- 4 вида: `//`, `/* */`, многострочные `/** */` (groovy-doc) и т.н. shebang line (`#!/usr/bin/env groovy`)
- groovy doc для аннотаций, но может быть везде, где и обычный multiline, хоть в середине конструкции
- groovy doc может иметь звездочки в новых строках
- shebang line: исполняемый `./test.sh` запустит скрипт

## Ключевые слова
<a href="http://docs.groovy-lang.org/docs/groovy-3.0.0-beta-2/html/documentation/#_keywords" target="_blank">http://docs.groovy-lang.org/docs/groovy-3.0.0-beta-2/html/documentation/#_keywords</a>

## Имена переменных
- могут начинаться с `[a-zA-z_$]` (и буквы юникода), не могут начинаться с цифры
- закавыченные могут использовать любой из шести типов строк и даже без квадратных скобок: `x.$/blah-blah-blah/$`
- в закавыченных первой идет подстановка: `map."Simpson-${firstname}" == map.'Simpson-Homer'`

## Строки
- шесть типов (`java.lang.String` если нет переменных, и `groovy.lang.GString` (т.н. "interpolated strings") если есть):
  * `'single quote'` - всегда `java.lang.String`
  * `"double quote"`
  * `'''triple single quote'''` - всегда `java.lang.String`
  * `"""triple double quote"""`
  * `/slashy string/` - нужно эскейпить только прямой слеш (multiline; для регулярок и паттернов)
  * `$/dollar slashy string/$` - не нужно эскейпить ни доллар (но подстановки идут), ни прямой слеш (multiline; паттерны со слешами, символ эскейпа - `$`)
- тройные - heredoc; помнить про перенос строки в начале и возможность его стрипа (`'''\`)
- ни `'` ни `"` не нужно эскейпить внутри тройных кавычек
- и `'` и `"` *можно* эскейпить в другом типе кавычек, но не обязательно (зачем это?)
- во *всех* кроме одинарных кавычек (interpolated strings) разворачиваются переменные
- вообще говоря, содержимое `${...}` по умолчанию анонимной функцией не является, только если есть стрелка внутри. Если нет - то строка вычисляется один раз, в момент объявления
- если же там замыкание - строка вычисляется каждый раз в момент использования (например, учитывает изменившееся значение внешних переменных)
- такие замыкания могут иметь 0 или 1 пераметр, иначе `groovy.lang.GroovyRuntimeException`. В замыкание передается экземпляр `org.apache.groovy.io.StringBuilderWriter` - собственно обрабатываемая строка. Добавлять в нее контент можно оператором `<<` (типа как в потоки?)
- `${...}`, без фигурных скобок допустимы только поля: `$map.x` (по пробелу?), иначе исключение (`groovy.lang.MissingPropertyException`): `$map.toString()` (`== ${number.toString}()`)
- т.н. dotted expression недопустимы еще и когда первая переменная - не объект: `$thing.x != ${thing}.x`
- подставлять можно хоть константы: `"The message is ${'hello'}"`
- хэши GString не совпадают с результатом подстановки: `assert "one: ${1}".hashCode() != "one: 1".hashCode()`. Поэтому нужно избегать использования interpolated strings в качестве ключей карты (`def m = ["${key}": "letter ${key}"]`): неизвестно как потом обращаться к ним, даже если результат подстановки известен
- в slashy strings (`/blah blah/`) действуют какие-то другие правила эскейпа (типа `"$()"` или `"$5"` дают ошибку, а `/$()/` `/$5/` нет), но эти правила нигде не описаны. Пустую строка задать ими нельзя (неразличима с комментарием, `assert '' == //`)
- для эскейпа плейсхолдера достаточно эскейпить только доллар: `'${name}' == "\${name}"`
- конкатенация - плюсом: `assert 'ab' == 'a' + 'b'`
- эскейп так же - обратным слешем
- спецсимволы те же (`\t`, `\n` etc.)
- символы юникода: `'The Euro currency symbol: \u20AC'`
- для переноса строк можно использовать не только тройные кавычки, но и обратный слеш
- передача GString в метод с яным параметром `java.lang.String` вызовет подстановку (`toString()`)
- Groovy не имеет отдельного класса для символов, но можно привести тремя способами (`char c1 = 'A'`, `def c2 = 'B' as char`, `def c3 = (char)'C'`: all to `Character`)
---
- вызов методов возможен напрямую на литералах: `"one: ${1}".hashCode()`
- нужны списки функций (`stripIndent`, `stripMargin`, `startsWith`, `hashCode` etc.)

## Числа
- 6 целочисленных типов (в скобках суффиксы литералов): `byte`, `char`, `short`, `int` -> `Integer` (`I`/`i`), `long` -> `Long` (`L`/`l`) и `java.lang.BigInteger` (`G`/`g`); через `def` выводятся только последние 3
- 3 вещественных типа (в скобках суффиксы литералов): `float` -> `Float` (`F`/`f`), `double` -> `Double` (`D`/`d`) и `java.lang.BigDecimal` (`G`/`g`); через `def` выводится только последний
- 3 префикса: `0b` (binary), `0` (octal) и `0x` (hexadecimal)
- вещественные литералы могут использовать степень: `2E4`, `3e+1`, `4E-2` etc.
- цифры в литералах можно группировать через подчеркивание, произвольным образом: `12_345_132.12`, `1234_5678_9012_3456L` etc.
- операции:
  * целые + дробные = дробное
  * `/` или `/=` = всегда дробное, для целочисленного деления нужно использовать `.intdiv()`
  * есть таблица типа результатов
  * `**` - возведение в степень, если можно представить результат в целом типе, то использует его, иначе дробный

## Boolean
- тип `boolean`/`java.lang.Boolean`
- стандартные литералы `true`/`false`

## Коллекции
- класс `java.util.ArrayList`, интерфейс `java.util.List` - гетерогенные списки переменного размера. Дефолтный тип, задаваемый литералом `[]`: `def letters = ['a', 'b', 'c', 'd']`
- `<Type>[]` (напр., `String[] arr = ['test']`, `def arr = [1, 2, 3] as int[]` или `def matrix3 = new Integer[3][3]`) - типизированные массивы фиксированного размера
- оба имеют метод `.size()`
- оператор `<<` ("левый сдвиг") используется для вставки элемента в конец (`letters << 'e'`)
- в обоих обращение к элементам идет через оператор `[]` и целочисленные индексы
- отрицательные индексы начинают отсчет с конца: `assert letters[-1] == 'd'`
- можно получать/присваивать части списков, через перечисление (`assert letters[1, 3] == ['b', 'd']`) или диапазоны (`assert letters[2..4] == ['C', 'd', 'e']`)
- многомерные списки: `def multi = [[0, 1], [2, 3]]; assert multi[1][0] == 2`
- пустой список: `[]`

## Карты
- в других языках могут называться словарями или ассоциативными массивами
- синтаксис литералов как у объектов в JS, только скобки квадратные: `def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']`
- обращение к полям как у объектов в JS: `assert colors.unknown == null`, `colors['pink'] = '#FF00FF'`
- тип `java.util.LinkedHashMap`
- возможны ключи произвольных типов: `def numbers = [1: 'one', 2: 'two']`
- ключ из переменной - через круглые скобки: `person = [(key): 'Guillaume']`
- пустая карта: `[:]`

## Операторы
- всё те же (`%=` - остаток от деления, `**=` - возведение в степень)
- оператор сравнения только один - `==` (и `!=`) (метод `a.equal(b)`), тройной заменяется `a.is(b)`
- приоритеты стандартные, вычисление по короткой цепи
- тернарный в двух формах, короткой ("Elvis operator") и полной
- логические операторы возвращают `boolean`, а не свои операнды, как в JS. Короткие выражения писать не получится
- оператор безопасного доступа `?.` возвращает поле или `null`
- оператор прямого доступа к полю `.@` возращает значение в обход геттера
- оператор получения указателя на метод `.&` возвращает `groovy.lang.Closure`, так что результат можно сохранять в переменной/передавать всюду, где требуются замыкания. С v3 может вызываться и на классе, не только на объекте (но первым аргументом должен получать объект: `assert String.&toUpperCase('foo') == 'FOO'`). С v3 можно получать указатель на конструктор: `assert BigInteger.&new('42') == 42G`
- с v3 доступен оператор расширения области видимости `::`. В динамическом Groovy (что это?) - просто псевдоним предыдушего, но есть какие-то отличия для статических методов классов

## Регулярные выражения

## Типы
- различать `String` (`java.lang.String`) и `GString` (`groovy.lang.GString`)
- приведение типов через оператор `as`: `def linkedList = [2, 3, 4] as LinkedList`

## I/O
- `println /blah blah/` почему-то не работает
