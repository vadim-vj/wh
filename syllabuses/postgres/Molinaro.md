# 1. Извлечение записей

- выборка, проекция
- `AS` для псевдонимов не обязателен
- в `WHERE` по псевдониму к столбцу обращаться нельзя: `SELECT` выполняется позже. Можно подставить в `FROM` подзапрос, тогда алиасы из него доступны
- конкатенация через `||` или `concat()`. `'a' || NULL = NULL`, `concat('a', NULL) = 'a'`: функция игнорирует `NULL` а оператор нет
- вывод "флага"/"статуса" в `SELECT` - через `CASE` (обычно с псевдонимом). Его синтаксис
- лимит выполняется *после сортировки*. В `ORDER BY` можно указывать целое число - номер столбца, и это не то же самое, что вызов там функции
- возврат пяти произвольных строк - `ORDER BY random() LIMIT 5` (здесь `random()` вычисляется для каждой строки, поэтому сортировка и возможна). Функция `random()` возвращает число от `0` до `1`
- поиск неопределенных значений - `IS [NOT] NULL`, сравнивать через `[!]=` нельзя: `NULL` не равен сам себе. Представление `NULL` в каком-либо виде: `coalesce(col, <some-val>)` или `CASE WHEN col IS NULL THEN <some-val> ELSE col END`
- поиск по шаблону: `WHERE col LIKE '%some_'`. Шаблоны привязаны к началу/концу строки

# 2. Сортировка результатов запроса

- `ORDER BY`, `ASC`/`DESC`, дефолтное направление (`ASC`), сортировка по нескольким столбцам одновременно
- сортировка по произвольным выражениям, например, по части строки: `ORDER BY substr(job, length(job)-2)`. Строковые функции `length()`, `substr[ing]()` (у второй разный синтаксис)
- создание представлений: `CREATE VIEW v AS SELECT ...`, создание смешанных буквенно-цифровых полей, сортировка по ним (заменой символов): `ORDER BY replace(translate(data, '0123456789', '##########'), '#', '')`. Строковые функции `replace()` (замена подстрок) и `translate()` (замена символов из подстрок)
- расположение `NULL`-значений в начале/конце. Решение (через подзапрос с маркировкой через `CASE`) неактуально. В Postgres по дефолту: `ASC NULLS LAST`, `DESC NULLS FIRST` + можно явно указывать свои
- условная сортировка (внутри групп): `ORDER BY CASE WHEN <cnd> THEN col1 ELSE col2 END`

# 3. Работа с несколькими таблицами

- `UNION [ALL]`, типы столбцов должны совпадать. Без `ALL` проседает производится сортировка и производительность
- экви-соединение через `FROM` + `WHERE` или через `INNER JOIN`
- `INTERSECT [ALL]`. С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `min(m, n)` раз
- использование набора столбцов в `IN`: `WHERE (ename, job, sal) IN (<select>)`
- `EXCEPT [ALL]`. С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `max(m-n, 0)` раз
- анти-соединение - выборка строк, которым нет соответствия во второй таблице: `FROM l LEFT JOIN r ON l.key = r.key WHERE r.key IS NULL`
- имитация внешнего соединения через кореллированный скалярный подзапрос
