# Общее, `[common]`

- остальные консольные утилиты кратко

---
> *База данных*

Это некоторый набор перманентных (постоянно хранимых) данных, систематизированных таким образом, чтобы эти материалы могли быть найдены и обработаны с помощью компьютера.

---
> *Модель данных*

Способ организации данных и основные методы доступа к ним. Примеры: (устаревшие) сетевая и иерархическая модели. В *реляционной* модели данные воспринимаются пользователем как таблицы, а СУБД автоматически управляет связями между ними (каскадирование; большой плюс).

Реляционная теория базируется на теории множеств и исчислении предикатов.

---
> *СУБД*

Комплекс ПО, с помощью которого можно создавать базы данных и проводить над ними различные операции: обновлять, удалять, выбирать, редактировать и т.д. СУБД как правило многопользовательские.

*РСУБД* - управляет реляционной базой данных

---
> Краткое описание PostgreSQL

Это *реляционная СУБД* с открытым исходным кодом. Распространяется свободно. Кроссплатформенная. Поддерживает многие из возможностей стандарта SQL:2011. Разработана в академической среде, имеет большое комьюнити.

Сильными сторонами PostgreSQL считаются:

- высокопроизводительные и надёжные механизмы транзакций и репликации
- встроенная поддержка языков вроде PL/pgSQL
- встроенная поддержка слабоструктурированных данных (JSON, массивы, xml, геометрические объекты, и т.д.)
- расширяемость (возможность создавать новые типы данных, индексы, модули и т.д.)
- хорошая поддержка параллельных вычислений

---
> Краткая история PostgreSQL

Разработка начата в 1985 году, профессором Калифорнийского университета в Беркли Майклом Стоунбрейкером (Michael Stonebraker), как переосмысление проекта INGRES ("Post Ingres"). В 1993м, на v4.2, проект был закрыт.

Выпускники Беркли Эндрю Ю и Джоли Чен в 1994 году выпустили Postgres95, воспользовавшись открытым кодом и BSD-лицензией исходной разработки. Они заменили язык запросов POSTQUEL на ставший к тому времени общепринятым SQL, а проект назвали Postgres95.

В 1996м году, когда стало ясно, что название Postgres95 не выдержит испытание временем. Новое название отражает связь и с оригинальным проектом POSTGRES, и с переходом на SQL в предыдущей версии. Новая версия стартовала как 6.0, продолжая исходную нумерацию.

---
> Архитектура PostrgreSQL

Клиент-сервер. Процесс сервера называется `postgres`, выполняется от одноименного пользователя - это и есть СУБД. Клиентские программы могут быть самыми разнообразными. Для каждой создается отдельный процесс-подключение. Таким образом, главный серверный процесс всегда работает и ожидает подключения клиентов, принимая которые, он организует взаимодействие клиента и отдельного серверного процесса.

Клиент и сервер могут располагаться на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP.

---
> Консольный клиент

Утилита командной строки `psql`. Основными опциями являются `-u` - указание пользователя, и `-d` - указание базы данных. При запуске утилита переходит в интерактивный режим. Может читать команды из `stdin`.

В этом режиме взаимодействие ведется при помощи т.н. *backslash-команд*, вроде `\d` - отображения всех таблиц, `\l` - отображения всех баз, или `\c` - подключения к БД. Запрос завершается `;`/`\g`. Вывод справки - `\?`/`\h`. Выход - `\q`.

---
> Прочие консольные утилиты

- `createdb`/`dropdb` - создание/удаление базы
- `pg_dump[all]`, `pg_restore` - дамп, восстановление
- графический интерфейс - `pgAdmin`.

---

# Язык SQL, `[sql]`

---
> *SQL*

Декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных. Декларативность означает, что для получения результата достаточно лишь указать, *что* нужно получить, но не требуется предписывать способ получения результата, т.е. *как* его получить.

---
> Подмножества SQL

- *DDL* (Data Definition Language, язык описания данных) - позволяет выполнять различные операции с базой данных, такие как `CREATE` (создание), `ALTER` (изменение) и `DROP` (удаление объектов)
- *DML* (Data Manipulation Language, язык управления данными) - позволяет получать доступ к данным и манипулировать ими, например, вставлять (`INSERT`), обновлять (`UPDATE`), удалять (`DELETE`) и извлекать (`SELECT`) данные из базы данных
- *DCL* (Data Control Language, язык контроля данных) - позволяет контролировать доступ к базе данных. Пример - `GRANT` (предоставить права), `REVOKE` (отозвать права)

---
> Две основные операции языка

Это *выборка* и *проекция*:

- выборка - возврат части кортежей. В языке реализуется через `SELECT` + `WHERE`
- проекция - возврат части атрибутов. В языке реализуется через ограничение списка столбцов в `SELECT`

---
> Операции над множествами

Реляционная модель тесно связана с теорией множеств, и в SQL реализованы некоторые операции оттуда. Для использования выборок в них, их (выборок) типы столбцов должны совпадать:

- `UNION` - объединение
- `INTERSECT` - пересечение
- `EXCEPT` - вычитание

По умолчанию после каждого из этих ключевых слов подразумевается `DISTINCT` - удалить дубликаты. Для сохранения дубликатов нужно явно указывать `ALL`

---

# SQL, лексическая структура языка, `[lexical-structure]`

---
> Регистр и идентификаторы

Язык не чувствителен к регистру, за исключением идентификаторов в двойных кавычках. Но, традиционно, ключевые слова пишут в верхнем регистре, а идентификаторы в нижнем: это формат вывода утилиты `pg_dump`.

Идентификатор может начинаться с буквы или подчеркивания, но не с цифры. Заключенный в двойные кавычки, он может содержать любые символы (кроме символа с кодом `0`), например, пробелы или амперсанды. Идентификатор в двойных кавычках может совпадать с ключевым словом: кавычки указывают, что это именно пользовательское имя.

Пробелы игнорируются и обязательны только чтобы избежать неоднозначности. Команды заканчиваются точкой с запятой (или `\g`).

---
> Литералы

- числовые стандартно. Ведущий и замыкающий нули могут быть опущены. Допустима научная нотация
- строковые (только) в одинарных кавычках, экранирование кавычки - другой кавычкой. Разделенные переносом строки автоматически соединяются в одну строку. Обратный слеш + символ не имеют специального смысла
- строковые, заключенные в доллары, с пустым или нет тегом. В таких строках не нужно экранировать ни кавычку, ни знак доллара. Могут быть многострочными, и, как правило, используются для написания функций
- строковые, со спецпоследовательностями в стиле C. Префикс `E` перед одинарной кавычкой. Обратный слеш + некоторые символы начинает означать спецпоследовательности

```sql
4., .001, 1.925e-3
'foo'
'bar' ~ `foobar`
$$Жанна д'Арк$$, $SomeTag$Жанна д'Арк$SomeTag$
E'fo\no'
```

---
> Три способа приведения типов

Константу обычного типа можно ввести одним из следующих способов:

```sql
type 'string'
'string'::type
CAST ( 'string' AS type )
```

Второй способ - нативный Postgres-овский, третий - по стандарту SQL, первый обобщение стандарта и может работать не для всех типов.

---
> Приоритет операторов

От самых приоритетных к менее:

- `.` - получение имени столбца
- `::` - приведение типов
- математические операторы
- <любой другой>
- `< > = <= >= <>` - сравнения
- `NOT`
- `AND`
- `OR`

---
> Комментарии

Два вида, блочный и однострочный:

```sql
/* block comment */
-- one line comment
```

---

# Реляционная модель данных, `[relational-model]`

- нужны SQL-команды для примеров
- отношения между сущностями расписать + примеры

---
> *Таблица* или *отношение*

Синонимы. Это совокупность логически связанных данных, хранящихся в структурированном виде в БД. Состоит из столбцов и строк.

Термин "таблица" менее строгий, и обычно подразумевает мультимножество - допускает дубликаты строк, в то время как "отношение" представляет собой множество (без повторов).

Набор таблиц составляет реляционную базу данных. Набор баз данных, управляемых одним экземпляром сервера, называется *кластером*.

---
> *Строка*, *запись* или *кортеж*

Синонимы. Составной элемент таблицы, объединяющий несколько полей. Строки могут иметь идентифицирующий их ключ.

Порядок строк в таблице не гарантирован по определению - они являются элементами множества, и потому не упорядочены.

---
> *Столбец*, *поле* или *атрибут*

Синонимы. Уникальный элемент отношения, составная часть записи. Характеризуется типом. Порядок столбцов в теории не определен, но в реальной СУБД фиксирован.

На пересечении строки и столбца находятся *ячейки* с атомарными значениями.

---
> Прочие термины реляционной модели

- *Заголовок отношения* - кортеж его атрибутов
- *Тело отношения* - множество его записей
- *Степень отношения* - количество его атрибутов
- *Кардинальное число* - количество записей в таблице

---
> *Потенциальный ключ*

Комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней. Должен удовлетворять требованиям уникальности и минимальности (несократимости - в его составе отсутствует меньшее подмножество атрибутов, удовлетворяющее условию уникальности).

Ключи делятся на *естественные* - состоящие из существующих полей, и *суррогатные* - введенные искусственно, и, как правило, представляющие из себя последовательности целых чисел. Суррогатные ключи выбирают по причинам эффективности, неизменяемости (нет необходимости в каскадных обновлениях), и гарантированной уникальности (не утратит уникальность со временем).

Пример естественных ключей:

- номер зачетной книжки идентифицирует студента (простой ключ)
- серия + номер документа идентифицируют человека (составной ключ)

---
> *Ограничения*

Условия, накладываемые на поле. Как правило, обусловлены спецификой конкретной предметной области.

Примерами могут служить, например, ограничение диапазона для числового поля, или требование уникальности для значений столбца (в последнем случае создается уникальный индекс, допускающий `NULL`-значения):

- серия документа состоит из четырех цифр и не может быть отрицательным числом
- оценка за экзамен может принимать значения `3`, `4`, `5`

В SQL задаются через ключевое слово `CHECK`, после столбца или в конце, после всех столбцов:

```sql
CREATE TABLE ... (
  col1 [CONSTRAINT some_check] CHECK(col1 > 0),
  ...
  [CONSTRAINT some_check] CHECK (col2 < 0)
);
```

При задании необязательного имени после `CONSTRAINT` это имя будет выводиться в сообщениях об ошибках, что может быть удобно.

---
> *Первичный ключ*

Один из потенциальных ключей отношения, выбранный в качестве основного ключа (или ключа по умолчанию). Остальные ключи называются *альтернативными*.

ПК в PostgreSQL состоит из двух ограничений (на практике они не совсем эквивалентны - внешние ключи могут ссылаться только на ключ):

```sql
PRIMARY KEY ~ UNIQUE NOT NULL
```

Ключ из одного столбца можно задать прямо после этого столбца, а из нескольких - только отдельно:

```sql
CREATE TABLE ... (
  pk1 [CONSTRAINT firstkey] PRIMARY KEY,
  ...
  [CONSTRAINT firstkey] PRIMARY KEY (pk1, pk2)
);
```

---
> *Внешний ключ*

Подмножество атрибутов одной таблицы, которое должно совпадать со значениями некоторого потенциального ключа другой таблицы.

Первая таблица (содержащая внешний ключ) называется *ссылающейся*, а вторая (с потенциальным ключом) - *ссылочной (целевой)*.

Примеры:

- таблица "Оценки за экзамен" ссылается на таблицу "Студенты"

---
> *Ссылочная целостность*

Корректность значений внешних ключей БД

---
> *Каскадирование*

Автоматическое обеспечение ссылочной целостности, обеспечиваемое СУБД. При модификации ссылочной таблицы автоматически изменяются ссылающиеся. Различают каскадные обновление и удаление. Они могут удалять все ссылающиеся записи при удалении основной, обновлять их, устанавливать внешний ключ в `NULL` и т.д.

---
> Три типа отношений между сущностями

- *Один к одному*
- *Один ко многим*
- *Многие ко многим*

---

# Нормальные формы, `[normal-forms]`

---

# Базовые типы данных, `[types-base]`

---
> Основные группы типов

- неопределенное значение `NULL`
- числовые: целые, с плавающей точкой, произвольной точности и последовательные
- символьные: фиксированной и нефиксированной длины
- дата, время, дата+время и интервалы
- логический тип
- перечисления
- денежные, географические, геометрические и пр.

---
> Неопределенное значение `NULL`

"Ничто", или отсутствие значения:

- любые сравнения с ним дают `NULL`, в том числе `IN (..., NULL)`
- единственные определенные выражения с ним - вычисляемые по короткой цепи: `true OR NULL`/`false AND NULL`
- допустим в уникальных индексах: два `NULL`-значения не равны друг другу
- в агрегатных функциях игнорируется, напр., `count(col)` будет считать только строки с не-`NULL` значением `col`
- при группировке, при сравнении строк, `NULL`-столбцы считаются равными
- при сортировке, по умолчанию `NULL`-значения располагаются в конце при `ASC`-порядке, и в начале при `DESC` (неопределенные значения больше любых других)

---
> Числовые типы

- три целочисленных: `smallint` (`int2`), `int[eger]` (`int4`), `bigint` (`int8`)
- два с плавающей точкой: `real` и `double precision`
- два (синонимы) с фиксированной точностью: `numeric|decimal(precision, scale)`, где `precision` - обзее число цифр, а `scale` - число цифр после десятичной точки
- последовательные: `smallserail` (`serial2`), `serial` (`serial4`), `bigserial` (`serial8`)

Последовательные типы - это просто синтаксический сахар создания последовательности:

```sql
CREATE SEQUENCE table_col_seq AS integer;
CREATE TABLE table (
  col integer NOT NULL DEFAULT nextval('table_col_seq')
);
```

---
> Символьные типы

- фиксированной длины: `char[acter](n)`, дополняются пробелами
- переменной длины с ограничением: `character varying|varchar(n)`
- без ограничения: `text`

Особенности:

- попытка сохранить более длинную строку в типе с ограничением приведет к ошибке, только если все лишние символы не являются пробелами (в этом случае они усекаются до максимально допустимой длины)
- при явном приведении к типу с ограничением строка усекается, ошибка не возникает
- при сравнении двух строк типа `char` незначащие пробелы игнорируются
- максимальная длина строки - 1Гб

---
> Дата и время

Конвертировать в эти типы можно из широкого диапазона строковых форматов:

- время с и без часового пояса: `time [(p)] [with[out] time zone]` (`timetz`)
- дата: `date`
- дата+время с и без часового пояса: `timestamp [(p)] [with[out] time zone]` (`timestamptz`)
- интервал: `interval [ поля ] [(p)]`

Использование времени с часовым поясом не рекомендовано: без даты нельзя определить время перехода на летнее/зимнее время.

Временная метка в `tz`-типах хранится в UTC, а часовой пояс добавляется только при выводе, и берется из системных настроек Postgres.

---
> Логический тип

`bool[ean]` принимает три значения, не два: `TRUE`, `FALSE` и `NULL`. Строки вида приводятся:

- `true`, `yes`, `on`, `1` - к истинному значению
- `false`, `no`, `off`, `0` - к ложному

Также приводятся и их уникальные префиксы (напр., `t`/`f`). Предпочтительным является использование `TRUE` и `FALSE`

---
> Перечисления

Этот тип требует предварительного объявления:

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
  name text,
  current_mood mood
);
```

Значения типа в дальнейшем указываются как строки, в одинарных кавычках:

```sql
INSERT INTO person VALUES ('Moe', 'happy');
```

Регистр имеет значение (!). Элементы перечисления можно сравнивать, те, что идут в объявлении типа раньше, считаются меньшими по значению.

---
> Прочие типы данных

- денежный тип `money` завязан на настройку `lc_monetary`
- геометрические типы, вроде `point`, `line`
- сетевые адреса, вроде `inet`

---

# Составные типы данных, `[types-compound]`

---

# DDL, создание и модификация таблиц, `[ddl-syntax]`

---
> Создание таблицы, базовый синтаксис

```sql
CREATE TABLE <table-name> (
  <col-name> <type> [<constrains>],
  ...
  [<constrains>],
  [<primary-key>],
  [<foreign-key>]
);
```

Примеры ограничений:

```sql
UNIQUE NOT NULL
CHECK (range > 0)
```

---
> Удаление таблицы, базовый синтаксис

```sql
DROP TABLE <table-name>
```

В отличие от `DELETE FROM`/`TRUNCATE`, это приводит к удалению самой таблицы, не только записей.

---

# `SELECT`, части и порядок выполнения, `[select]`

---

# Соединения таблиц, операции теории множеств, `[joins-sets]`

---
> Типы `JOIN`-ов

Ключевые слова `INNER`/`OUTER` везде опциональны:

- `[INNER] JOIN` - внутреннее соединение
- `LEFT|RIGHT [OUTER] JOIN` - левое/правое внешние, дополнение `NULL`-строками с противоположной стороны
- `CROSS JOIN` - декартово произведение, без условия
- `FULL [OUTER] JOIN` - полное внешнее соединение, дополнение `NULL`-строками с обоих сторон

`JOIN` связывает элементы сильнее, чем запятые, разделяющие элементы в списке `FROM`. Обработка таблиц - слева направо.

---
> Условия соединения

Записываются:

- в `ON <cnd>`
- в `USING (col1, col2, ...)` перечисляются столбцы
- указывается `NATURAL` без доп. деталей; ~ `USING` со списком одноименных в двух таблицах столбцов

---
> `[INNER] JOIN`

- условие соединения указывать обязательно
- эквивалентен `FROM t1, t2 WHERE t1.key = t2.key`

---
> `LEFT|RIGHT|FULL [OUTER] JOIN`

Возвращают все строки `INNER JOIN` + все строки левой/правой таблицы, которым не нашлось пары, дополненные `NULL`-значениями. Для `FULL JOIN` дополнение идет для обоих таблиц.

`RIGHT JOIN` введен исключительно для удобства записи (синтаксический сахар), так как его можно легко свести к `LEFT JOIN`, поменяв левую и правую таблицы местами.

Эмулировать внешнее соединение можно через скалярный коррелированный подзапрос в `SELECT`.

---
> `CROSS JOIN`

Полное декартово произведение:

- условие соединения указывать не нужно
- эквивалентен `FROM t1, t2 [WHERE TRUE]` или `FROM t1 INNER JOIN t2 ON TRUE`

---
> `UNION [DISTINCT | ALL]`

```sql
SELECT unnest(ARRAY[1,1,2]) UNION [ALL] SELECT unnest(ARRAY[1,3]);
```

Объединение двух выборок. Дубликаты при указании `ALL` сохраняются все. При указании `DISTINCT` результат сортируется, и слияние работает медленней.

```
(1, 1, 2) | (1, 3) = (1, 2, 3) -- DISTINCT
(1, 1, 2) | (1, 3) = (1, 1, 1, 2, 3) -- ALL
```

---
> `INTERSECT [DISTINCT | ALL]`

```sql
SELECT unnest(ARRAY[1,1,1,2]) INTERSECT [ALL] SELECT unnest(ARRAY[1,1,3]);
```

Пересечение двух выборок. С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `min(m,n)` раз.

```
(1, 1, 1, 2) & (1, 1, 3) = (1) -- DISTINCT
(1, 1, 1, 2) & (1, 1, 3) = (1, 1) -- ALL
```

---
> `EXCEPT [DISTINCT | ALL]`

```sql
SELECT unnest(ARRAY[1,1,2]) EXCEPT ALL SELECT unnest(ARRAY[1,3]);
```

"Вычитание" правой выборки из левой. Вычисляет набор строк, которые присутствуют в результате левого запроса `SELECT`, но отсутствуют в результате правого. С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `max(m-n,0)` раз.

```
(1, 1, 2) | (1, 3) = (2) -- DISTINCT
(1, 1, 2) | (1, 3) = (1, 2) -- ALL
```

---

# Группировка и агрегатные функции, `[aggr-functions]`

---

# Оконные функции, `[window-functions]`

- общий синтаксис определения
- синтаксис задания рамки
- оставшиеся оконные функции

---
> Определение *оконной функции*

Такие функции выполняют вычисления для набора строк, некоторым образом связанных с текущей строкой. Они схожи с агрегатными, но не группируют строки в одну, а оставляют их отдельными. Таким образом, оконные функции не изменяют выборку, а только добавляют некоторую дополнительную информацию о ней, новые поля.

```sql
SELECT salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

В этом примере выводится информация для каждого сотрудника ("все строки остаются отдельными сущностями"). При этом идет вычисление средней по отделу зарплаты функцией `avg()` (схожей с агрегатной; "вычисления для набора строк"), оперирующей над "разделом" - блоком строк, у которых отдел `depname` равен отделу сотрудника (полю `depname` текущей строки; "некоторым образом связанных с текущей строкой")

---
> Когда нужны оконные функции

- когда агрегатное значение должно присутствовать в каждой записи (сравнения)
- вычисление ранга (?)
- считать скользящие средние и кумулятивные суммы (?)
- отказ от `JOIN`-ов и подзапросов (?)

---
> Очередность вычисления оконных функций, подзапросы

Оконные функции выполняются в самом конце (но до `ORDER BY` основного запроса). Строки, обрабатываемые оконной функцией, представляют собой "виртуальные таблицы", созданные из предложения `FROM` и затем прошедшие через фильтрацию и группировку `WHERE` и `GROUP BY` и, возможно, условие `HAVING`. Например, строка, отфильтрованная из-за нарушения условия WHERE, не будет видна для оконных функций

Таким образом, оконные функции разрешается использовать в запросе только в списке `SELECT` и предложении `ORDER BY`. Если нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы можете использовать вложенный запрос

---
> Понятие *раздела*

Это множество строк, на которых вычисляется оконная функция. Раздел обязан быть задан явно инструкцией

```sql
OVER ()
```

хотя и может быть пустым (это редко встречается на практике)

---
> Понятие *оконного кадра (рамки)*

Многие оконные функции работают не со всеми строками раздела, а только с частью. Это часть и называется кадром/рамкой; задается явно или неявно

Если кадр не задан явно, то его размер зависит от того, есть ли в объявлении раздела инструкция `ORDER BY`:

- если нет, то кадр равен всему разделу
- если есть, то кадр включает все строки от начала раздела до значений критерия сортировки, равных текущей строке (включительно)

Все агрегатные функции, используемые в качестве оконных, всегда обрабатывают строки с учетом оконного кадра. Часть оконных функциё общего назначения использует рамку, а часть нет

---
> Синтаксис отдельного определения окна

В конце запроса, `WINDOW` + `AS` + `(...)`:

```sql
FROM table_name WINDOW w AS (ORDER BY val)
```

---
> Основные оконные функции #1

Инструкция `OVER(...)`, идущая после имени агрегатной функции, превращает ее в оконную. В качестве оконных можно использовать любые встроенные или пользовательские универсальные или статистические агрегатные функции

Все агрегатные функции, используемые в качестве оконных, всегда обрабатывают строки с учетом оконного кадра. Иногда это может быть нежелательно, и тогда кадр нужно задавать явно на весь раздел

---
> Основные оконные функции #2

Номера и ранги; оконный фрейм для них не важен (всё равно они упорядочивают строки):

```sql
SELECT row_number() OVER w, rank() OVER w, dense_rank() OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Номер строки, ранг с пропусками (номер первой строки в группе), ранг без пропусков:

```
val | row_number | rank | dense_rank
--- | ---------- | ---- | ----------
  1 |          1 |    1 |          1
  1 |          2 |    1 |          1
  2 |          3 |    3 |          2
  2 |          4 |    3 |          2
  3 |          5 |    5 |          3
  3 |          6 |    5 |          3
```

Обе функции рангов могут выполнятся и на окне без сортировки (`OVER ()`), но тогда они всегда возвращают `1`

---
> Основные оконные функции #3

Значение из первой, последней и `N`-ной строки:

```sql
SELECT first_value(val) OVER w, last_value(val) OVER w, nth_value(val, 2) OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Эти функции учитывают оконный кадр. И если для `first_value()` это не важно (она всегда дает первую строку раздела), то для `last_value()` это дает значение, всегда совпадающее с текущей строкой. Такое (не полезное) поведение может быть нежелательно и для `nth_value()`. В обоих случаях можно явно переопределить рамку.

```
val | first_value | last_value | nth_value
--- | ----------- | -----------| ---------
  1 |           1 |          1 |
  1 |           1 |          1 |
  2 |           1 |          2 |         2
  2 |           1 |          2 |         2
  3 |           1 |          3 |         2
  3 |           1 |          3 |         2
```

---
> Примеры использования оконных функций

Для каждого сотрудника выводится его зарплата + рядом средняя зарплата его (сотрудника) отдела:

```sql
SELECT salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

Для каждого сотрудника выводится его зарплата + рядом ранг (`1`, `2`, etc.) его зарплаты относительно остальных в отделе:

```sql
SELECT salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
```

---

# Представления, `[views]`

---

# Команды изменения данных, `UPSERT`, `COPY`, каскадные операции, `[mass-ops]`

---

# Общее понятие транзакции, ACID, `[transact-common]`

- точки восстановления, их синтаксис

---
> Определение *транзакции*

Это группа последовательных операций с базой, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, либо не выполнена вообще. В простейшем случае транзакция состоит из одной операции.

Примером транзакции могут служить каскадные операции (напр., уддаление), хотя атомарность их выполнения и берет на себя СУБД.

---
> Определение *ACID*

Это акроним, объединяющий четыре свойства-требования к транзакционной системе (например, к СУБД), обеспечивающих наиболее надёжную и предсказуемую её (СУБД) работу:

- Atomicity - Атомарность
- Consistency - Согласованность
- Isolation - Изолированность
- Durability - Стойкость

---
> *A* в ACID

Atomicity - Атомарность. Операция либо выполняется целиком, либо не выполняется вовсе; операция не может быть частично выполнена или частично не выполнена

Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие "отката" (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во "внешне исходное" состояние - со стороны будет казаться, что транзакции и не было

---
> *C* в ACID

Consistency - Согласованность. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных (?)

Свойство охватывает как физические ограничения ссылочной целостности, так и бизнес-логику. Пример - согласованность в списании/зачислении денег на счет

---
> *I* в ACID

Isolation - Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность - требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию

---
> *D* в ACID

Durability - Стойкость/Долговечность. После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев в работе системы

---
> SQL-синтаксис транзакций

```sql
START TRANSACTION [ ISOLATION LEVEL <level> ];
COMMIT;
```

или через `BEGIN` - расширение Postgres:

```sql
BEGIN [ ISOLATION LEVEL <level> ];
ROLLBACK;
```

где уровень изоляции:

```sql
SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED
```

---

# Феномены и уровни изоляции транзакций в Postgres, блокировки, `[transact]`

---
