# Оконные функции, `[window-functiions]`

---
> Определение *оконной функции*

Такие функции выполняют вычисления для набора строк, некоторым образом связанных с текущей строкой. Они схожи с агрегатными, но не группируют строки в одну, а оставляют их отдельными. Таким образом, оконные функции не изменяют выборку, а только добавляют некоторую дополнительную информацию о ней, новые поля.

```sql
SELECT salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

В этом примере выводится информация для каждого сотрудника ("все строки остаются отдельными сущностями"). При этом идет вычисление средней по отделу зарплаты функцией `avg()` (схожей с агрегатной; "вычисления для набора строк"), оперирующей над "разделом" - блоком строк, у которых отдел `depname` равен отделу сотрудника (полю `depname` текущей строки; "некоторым образом связанных с текущей строкой")

---
> Когда нужны оконные функции

- когда агрегатное значение должно присутствовать в каждой записи (сравнения)
- вычисление ранга (?)
- считать скользящие средние и кумулятивные суммы (?)
- отказ от `JOIN`-ов и подзапросов (?)

---
> Очередность вычисления оконных функций, подзапросы

Оконные функции выполняются в самом конце (но до `ORDER BY` основного запроса). Строки, обрабатываемые оконной функцией, представляют собой "виртуальные таблицы", созданные из предложения `FROM` и затем прошедшие через фильтрацию и группировку `WHERE` и `GROUP BY` и, возможно, условие `HAVING`. Например, строка, отфильтрованная из-за нарушения условия WHERE, не будет видна для оконных функций

Таким образом, оконные функции разрешается использовать в запросе только в списке `SELECT` и предложении `ORDER BY`. Если нужно отфильтровать или сгруппировать строки после вычисления оконных функций, вы можете использовать вложенный запрос

---
> Понятие *раздела*

Это множество строк, на которых вычисляется оконная функция. Раздел обязан быть задан явно инструкцией

```sql
OVER ()
```

хотя и может быть пустым (это редко встречается на практике)

---
> Понятие *оконного кадра (рамки)*

Многие оконные функции работают не со всеми строками раздела, а только с частью. Это часть и называется кадром/рамкой; задается явно или неявно

Если кадр не задан явно, то его размер зависит от того, есть ли в объявлении раздела инструкция `ORDER BY`:

- если нет, то кадр равен всему разделу
- если есть, то кадр включает все строки от начала раздела до значений критерия сортировки, равных текущей строке (включительно)

Все агрегатные функции, используемые в качестве оконных, всегда обрабатывают строки с учетом оконного кадра. Часть оконных функциё общего назначения использует рамку, а часть нет

---
> Синтаксис отдельного определения окна

В конце запроса, `WINDOW` + `AS` + `(...)`:

```sql
FROM table_name WINDOW w AS (ORDER BY val)
```

---
> Основные оконные функции #1

Инструкция `OVER(...)`, идущая после имени агрегатной функции, превращает ее в оконную. В качестве оконных можно использовать любые встроенные или пользовательские универсальные или статистические агрегатные функции

Все агрегатные функции, используемые в качестве оконных, всегда обрабатывают строки с учетом оконного кадра. Иногда это может быть нежелательно, и тогда кадр нужно задавать явно на весь раздел

---
> Основные оконные функции #2

Номера и ранги; оконный фрейм для них не важен (всё равно они упорядочивают строки):

```sql
SELECT row_number() OVER w, rank() OVER w, dense_rank() OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Номер строки, ранг с пропусками (номер первой строки в группе), ранг без пропусков:

```
val | row_number | rank | dense_rank
--- | ---------- | ---- | ----------
  1 |          1 |    1 |          1
  1 |          2 |    1 |          1
  2 |          3 |    3 |          2
  2 |          4 |    3 |          2
  3 |          5 |    5 |          3
  3 |          6 |    5 |          3
```

Обе функции рангов могут выполнятся и на окне без сортировки (`OVER ()`), но тогда они всегда возвращают `1`

---
> Основные оконные функции #3

Значение из первой, последней и `N`-ной строки:

```sql
SELECT first_value(val) OVER w, last_value(val) OVER w, nth_value(val, 2) OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Эти функции учитывают оконный кадр. И если для `first_value()` это не важно (она всегда дает первую строку раздела), то для `last_value()` это дает значение, всегда совпадающее с текущей строкой. Такое (не полезное) поведение может быть нежелательно и для `nth_value()`. В обоих случаях можно явно переопределить рамку.

```
val | first_value | last_value | nth_value
--- | ----------- | -----------| ---------
  1 |           1 |          1 |
  1 |           1 |          1 |
  2 |           1 |          2 |         2
  2 |           1 |          2 |         2
  3 |           1 |          3 |         2
  3 |           1 |          3 |         2
```

---
> Примеры использования оконных функций

Для каждого сотрудника выводится его зарплата + рядом средняя зарплата его (сотрудника) отдела:

```sql
SELECT salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

Для каждого сотрудника выводится его зарплата + рядом ранг (`1`, `2`, etc.) его зарплаты относительно остальных в отделе:

```sql
SELECT salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;
```
