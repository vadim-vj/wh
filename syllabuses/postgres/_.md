# Общее, `[common]`

---
> Что такое *база данных*?

Это некоторый набор перманентных (постоянно хранимых), логически связанных данных, систематизированных таким образом, чтобы эти материалы могли быть найдены и обработаны с помощью компьютера.

---
> Что такое *модель данных*?

Способ организации данных и основные методы доступа к ним. Примеры: сетевая и иерархическая модели. В *реляционной* модели данные воспринимаются пользователем как таблицы, а СУБД автоматически управляет связями между ними (каскадирование; большой плюс).

Реляционная теория базируется на теории множеств и исчислении предикатов.

---
> Что такое *(Р)СУБД*?

Программа (комплекс программ), управляющая базой данных. С помощью нее можно создавать базы данных и проводить над ними различные операции: обновлять, удалять, выбирать, редактировать и т.д. СУБД как правило многопользовательские.

*РСУБД* - управляет реляционной базой данных (в которой все данные, доступные пользователю, организованы в  виде таблиц).

---

# PostgreSQL и ее среда, `[env]`

---
> Дайте краткое описание PostgreSQL

Это *реляционная СУБД* с открытым исходным кодом. Распространяется свободно. Кроссплатформенная. Поддерживает многие из возможностей стандарта SQL:2011. Разработана в академической среде, имеет большое комьюнити.

---
> Какие сильные стороны у PostgreSQL?

- высокопроизводительные и надёжные механизмы транзакций и репликации
- встроенная поддержка языков вроде PL/pgSQL
- встроенная поддержка слабоструктурированных данных (JSON, массивы, xml, геометрические объекты, и т.д.)
- расширяемость (возможность создавать новые типы данных, индексы, модули и т.д.)
- хорошая поддержка параллельных вычислений

---
> Расскажите краткую историю PostgreSQL

Разработка начата в 1985 году, профессором Калифорнийского университета в Беркли Майклом Стоунбрейкером (Michael Stonebraker), как переосмысление проекта INGRES ("Post Ingres"). В 1993м, на v4.2, проект был закрыт.

Выпускники Беркли Эндрю Ю и Джоли Чен в 1994 году выпустили Postgres95, воспользовавшись открытым кодом и BSD-лицензией исходной разработки. Они заменили язык запросов POSTQUEL на ставший к тому времени общепринятым SQL, а проект назвали Postgres95.

В 1996м году, когда стало ясно, что название Postgres95 не выдержит испытание временем, проект был переименован в PostgreSQL. Новое название отражает связь и с оригинальным проектом POSTGRES, и с переходом на SQL в предыдущей версии. Новая версия стартовала как 6.0, продолжая исходную нумерацию.

---
> Какая архитектура у PostrgreSQL?

Клиент-сервер. Процесс сервера называется `postgres`, выполняется от одноименного пользователя - это и есть СУБД. Клиентские программы могут быть самыми разнообразными. Для каждой создается отдельный процесс-подключение. Таким образом, главный серверный процесс всегда работает и ожидает подключения клиентов, принимая которые, он организует взаимодействие клиента и отдельного серверного процесса.

Клиент и сервер могут располагаться на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP.

---
> Какой основной клиент у Postgres-а?

Утилита командной строки `psql`. Основными опциями являются `-u` - указание пользователя, и `-d` - указание базы данных. При запуске утилита переходит в интерактивный режим. Может читать команды из `stdin`.

---
> Опишите кратко работу в интерактивном терминале `psql`

В этом режиме взаимодействие ведется при помощи т.н. *backslash-команд*, вроде `\d` - отображения всех таблиц, `\l` - отображения всех баз, или `\c` - подключения к БД. Запрос завершается `;`/`\g`. Вывод справки - `\?`/`\h`. Выход - `\q`.

---
> Перечислите основные клиентские утилиты Postgres

- `psql` - основной клиент, интерактивный терминал
- `createdb`/`dropdb` - создание/удаление базы
- `createuser`/`dropuser` - то же для пользователя
- `pg_dump[all]`, `pg_restore` - дамп, восстановление
- `reindexdb`, `vacuumdb` - переиндексирование и очистка
- графический интерфейс - `pgAdmin` (устанавливается отдельно)

---
> Какая библиотека является системным драйвером PostgreSQL?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
libpq
```

Написана на C

---
> Как называется Python-модуль для соединения с Postgres-ом?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
psycopg2
```

Версия 2 поддерживает массовую многопоточность и асинхронность

---
> Как перманентно изменить значение конфигурационного параметра?

Отредактировать файл `/etc/postgresql/12/main/postgresql.conf` и перезагрузить настройки - например, выполнить от пользователя `postgres`

```sql
SELECT pg_reload_conf();
```

---
> Как узнать значение конфигурационного параметра?

Командой `SHOW`:

```sql
SHOW shared_buffers;
```

```
 shared_buffers
----------------
 128MB
```

---
> Как создать базу из дампа?

Перенаправить вывод (список SQL-команд) на вход клиента `psql`. Или воспользоваться его же опцией `-f`:

```shell
$ cat dump.sql | psql
$ psql < dump.sql
$ psql [-d <db-name>] -f dump.sql
```

---
> Как называются два основных файла настроек?

Основной конфигурационный и настройки доступа:

```
postgresql.conf
pg_hba.conf
```

Оба хранятся в папке `/etc/postgresql/12/main/` (версия, естественно, может меняться). Удаленный доступ до этих файлов запрещен.

---
> Где на файловой системе хранятся файлы баз данных?

В каталоге

```
/var/lib/postgresql/12/main/
```

И для самого каталога, и для файлов внутри, владельцем установлен юзер `postgres`. Служба вообще работает от него.

---
> Что такое *схема*?

Раздел базы данных, где создаются таблицы и прочие объекты. По сути - пространство имен

По дефолту используется схема `public`

---

# Реляционная модель данных + DLL, `[relational-model-ddl]`

---
> Что такое *таблица*/*отношение*?

Синонимы. Это совокупность логически связанных данных, хранящихся в структурированном виде в БД. Состоит из столбцов и строк.

Термин "таблица" менее строгий, и обычно подразумевает мультимножество - допускает дубликаты строк, в то время как "отношение" представляет собой множество (без повторов).

Набор таблиц составляет реляционную базу данных. Набор баз данных, управляемых одним экземпляром сервера, называется *кластером*.

---
> Как создать таблицу?

Командой `CREATE TABLE`. Базовый синтаксис:

```sql
CREATE TABLE <table-name> (
  <col-name> <type> [<constrains>],
  ...
  [<constrains>],
  [<primary-key>],
  [<foreign-key>]
);
```

Примеры ограничений:

```sql
UNIQUE NOT NULL
CHECK (range > 0)
```

---
> Как удалить таблицу?

```sql
DROP TABLE <table-name>
```

В отличие от `DELETE FROM`/`TRUNCATE`, это приводит к удалению самой таблицы, не только записей.

---
> Что такое *сущность*?

Объект предметной области, моделируемый в базе данных. Как правило, представляется отдельной таблицей. Примеры: "сотрудник", "отдел", "заказ".

---
> Что такое *строка*/*запись*/*кортеж*?

Синонимы. Составной элемент таблицы, объединяющий несколько полей. Строки могут иметь идентифицирующий их ключ.

Порядок строк в таблице не гарантирован по определению - они являются элементами множества, и потому не упорядочены.

---
> Как вставить/обновить/удалить строку?

DML-командами:

```sql
INSERT INTO <table-name>[(<columns>)] VALUES (...);
UPDATE      <table-name> SET col1 = ...;
DELETE FROM <table-name> [WHERE col1 = ...];
```

---
> Какой порядок у строк в таблице?

Неопределенный. Нельзя сказать, в каком порядке хранятся записи, или в каком они будут выведены.

Для упорядочивания нужно явно использовать команду `ORDER BY`.

---
> Что такое *столбец*/*поле*/*атрибут*?

Синонимы. Уникальный элемент отношения, составная часть записи. Характеризуется типом. Порядок столбцов в теории не определен, но в реальной СУБД фиксирован.

На пересечении строки и столбца находятся *ячейки* с атомарными значениями.

---
> Как добавить/изменить/удалить столбец в таблице?

Командой `ALTER TABLE`:

```sql
ALTER TABLE <table-name> ADD|ALTER|DROP [COLUMN] <column-name> ...;
```

---
> Перечислите прочие термины реляционной модели

- *Заголовок отношения* - кортеж его атрибутов
- *Тело отношения* - множество его записей
- *Степень отношения* - количество его атрибутов
- *Кардинальное число* - количество записей в таблице

---
> Что такое *потенциальный ключ*?

Комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней. Должен удовлетворять требованиям уникальности и минимальности (несократимости - в его составе отсутствует меньшее подмножество атрибутов, удовлетворяющее условию уникальности).

---
> Как задать уникальный ключ?

При создании/модификации таблицы, через ключевое слово `UNIQUE`:

```sql
CREATE TABLE <table-name> (
  col1 int UNIQUE,
  ...
);
ALTER TABLE <table-name> ADD UNIQUE(col1);
```

---
> Какие бывают типы ключей таблицы?

Ключи делятся на *естественные* - состоящие из существующих полей, и *суррогатные* - введенные искусственно, и, как правило, представляющие из себя последовательности целых чисел. Суррогатные ключи выбирают по причинам эффективности, неизменяемости (нет необходимости в каскадных обновлениях), и гарантированной уникальности (не утратит уникальность со временем).

Пример естественных ключей:

- номер зачетной книжки идентифицирует студента (простой ключ)
- серия + номер документа идентифицируют человека (составной ключ)

---
> Как задать суррогатный ключ последовательного типа?

Использовать тип `[small|big]serial` + `PRIMARY KEY`, в определении столбца или отдельно, на уровне таблицы:

```sql
CREATE TABLE <table-name> (
  col1 serial PRIMARY KEY,
  ...
);
CREATE TABLE <table-name> (
  col1 serial,
  ...,
  PRIMARY KEY (col1)
);
```

---
> Что такое *ограничения* столбца?

Условия, накладываемые на поле. Как правило, обусловлены спецификой конкретной предметной области.

Примерами могут служить, например, ограничение диапазона для числового поля, или требование уникальности для значений столбца (в последнем случае создается уникальный индекс, допускающий `NULL`-значения):

- серия документа состоит из четырех цифр и не может быть отрицательным числом
- оценка за экзамен может принимать значения `3`, `4`, `5`

---
> Как задаются общие ограничения столбца?

В SQL задаются через ключевое слово `CHECK`, после столбца или в конце, после всех столбцов:

```sql
CREATE TABLE ... (
  col1 [CONSTRAINT some_check] CHECK(col1 > 0),
  ...
  [CONSTRAINT some_check] CHECK (col2 < 0)
);
```

При задании необязательного имени после `CONSTRAINT` это имя будет выводиться в сообщениях об ошибках, что может быть удобно.

---
> Что такое *первичный ключ*?

Один из потенциальных ключей отношения, выбранный в качестве основного ключа (или ключа по умолчанию). Остальные ключи называются *альтернативными*.

ПК в PostgreSQL состоит из двух ограничений (на практике они не совсем эквивалентны - внешние ключи могут ссылаться только на ключ):

```sql
PRIMARY KEY ~ UNIQUE NOT NULL
```

---
> Может ли составной первичный ключ содержать `NULL`-значения в отдельных столбцах?

Нет, ограничение `NOT NULL` распространяется на любой компонент составного первичного ключа.

---
> Как задается первичный ключ?

Ключ из одного столбца можно задать прямо после этого столбца, а из нескольких - только отдельно:

```sql
CREATE TABLE ... (
  pk1 [CONSTRAINT first_key] PRIMARY KEY,
  ...
  [CONSTRAINT first_key] PRIMARY KEY (pk1, pk2)
);
```

---
> Что произойдет при попытке вставить запись с уже имеющимся первичным ключом?

```sql
INSERT INTO aircrafts_data VALUES ('SU9', '{"en":"Sukhoi SuperJet-100"}', 3000);
```

Выдаст ошибку нарушения уникальности:

```
ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
DETAIL:  Key (aircraft_code)=(SU9) already exists
```

---
> Что такое *внешний ключ*?

Подмножество атрибутов одной таблицы, которое должно совпадать со значениями некоторого потенциального ключа другой таблицы.

Первая таблица (содержащая внешний ключ) называется *ссылающейся*, а вторая (с потенциальным ключом) - *ссылочной (целевой)*.

---
> Приведите примеры внешних ключей

- таблица "Оценки за экзамен" ссылается на таблицу "Студенты". ID студента в (ссылающейся) таблице оценок - это внешний ключ, ссылающийся на первичный ключ (ссылочной) таблицы студентов
- таблица "Сотрудники" ссылается на таблицу "Отделы". ID отдела - внешний ключ ссылающейся таблице сотрудников - соответствует первичному ключу в таблице отделов

---
> Как задается внешний ключ?

Через ключевое слово `REFERENCES` в объявлении столбца, или отдельно, на уровне таблицы. Во втором случае обязательны ключевые слова `FOREIGN KEY`:

```sql
CREATE TABLE ... (
  fk1 [CONSTRAINT foreign_key] REFERENCES <some-table>,
  ...
  [CONSTRAINT foreign_key] FOREIGN KEY (fk1, fk2) REFERENCES <some-table>(fk1, fk2)
);
```

- задать внешний ключ из нескольких столбцов можно только вторым способом
- если список столбцов для ссылочной таблицы (`<some-table>`) не указан, то берется ее первичный ключ

---
> Сколько столбцов во внешнем ключе и в ключе, на который он ссылается?

Всегда одинаковое количество. Количество столбцов и их типы обязаны совпадать в ссылающейся и целевой таблицах.

---
> Что такое *ссылочная целостность*?

Корректность значений внешних ключей БД

---
> Что такое *каскадирование* операций?

Автоматическое обеспечение ссылочной целостности, обеспечиваемое СУБД. При модификации ссылочной таблицы автоматически изменяются ссылающиеся. Различают каскадные обновление и удаление. Они могут удалять все ссылающиеся записи при удалении основной, обновлять их, устанавливать внешний ключ в `NULL` и т.д.

---
> Как задать автоматическое удаление записей при удалении внешнего ключа?

Указать это в *ссылающейся* (там, где поле неуникально) таблице:

```sql
FOREIGN KEY (aircraft_code)
  REFERENCES aircrafts (aircraft_code)
  ON DELETE CASCADE
```

---
> Как в ссылающуюся таблицу вставить запись с внешним ключом, не существующим в основной таблице?

Никак, СУБД запретит это, выдаст ошибку. Например:

```sql
INSERT INTO seats VALUES ('123', '1A', 'Business');
```

```
ERROR:  insert or update on table "seats" violates foreign key ...
DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts_data"
```

---
> Назовите три основных типа отношений между сущностями

- *один к одному*. Пример: "человек-"документ", "отдел"-"начальник"
- *один ко многим*. Пример: "отдел"-"сотрудники", "покупатель"-"заказы"
- *многие ко многим*. Пример: "товар"-"категория" (товар может входить в несколько категорий)

Последнее отношение, как правило, реализуется через промежуточную таблицу

---
> Как по-английски будет звучать термин "отношение"?

Дело в том, что словом "отношение" на русский могут переводиться два разных термина реляционной модели:

- *relation* - это таблица, набор кортежей/атрибутов
- *relationship* - это логическая связь между сущностями (таблицами): один ко многим, многие ко многим, и т.д.

---

# Нормальные формы, `[normal-forms]`

---
> Что такое *аномалии* модификации данных? Какие бывают?

Это нежелательное поведение, возникающие при модификации БД ситуации, которые могут приводить к противоречивости данных или существенно усложнять их (данных) обработку.

Выделяют три основные аномалии (по числу основных DML-команд):

- вставки - в таблицу нельзя записать информацию об одной сущности, не записав при этом и информацию о связанной
- обновления - для изменения данных о сущности необходимость обновлять более одной строки таблицы
- удаления - из таблицы нельзя удалить информацию об одной сущности, не удалив при этом и информацию о связанной

---
> Приведите примеры аномалий манипулирования данными

Аномалии для не-нормализованной таблицы "сотрудник"-"отдел"-"начальник":

- вставки: нельзя вставить сотрудника без отдела, или отдел без сотрудников
- обновления: чтобы обновить название отдела или его начальника, нужно обновить строки таблицы для каждого сотрудника
- удаления: нельзя удалить последнего сотрудника отдела, не удалив сам отдел; или удалить отдел, не удалив всех сотрудников

---
> Что такое *нормализация* таблиц и зачем она нужна?

Это преобразование отношений (таблиц) к формам, лишенных некоторых недостатков: избыточности данных и аномалий вставки/обновления/удаления. Таким образом, нормализация предполагает разделение таблиц на части, каждая из которых относится к отдельной сущности.

Пример: разделение таблицы "сотрудник"-"отдел"-"начальник" на две - "сотрудник"-"отдел" и "отдел"-"начальник".

---
> Что такое *функциональная зависимость* атрибутов? Приведите примеры

Ситуация, когда по значению одного поля можно однозначно определить значение другого, по сути отношение "один к одному"/"многие к одному" внутри таблицы. Примеры:

- "город"-"индекс"
- "отдел"-"начальник"

---
> Что такое *нормальная форма*? Какие бывают (кратко)?

НФ - требование, предъявляемое к структуре таблиц для устранения избыточных функциональных зависимостей между атрибутами.

Основных форм четыре, они "вложенные" - находящееся в более высокой форме отношение находится также и во всех нижележащих:

- 1НФ, таблица с первичным ключом и столбцами атомарных типов
- 2НФ, без составного первичного ключа, от части которого зависят другие атрибуты
- 3НФ, без зависимости одних неключевых атрибутов от других
- НФ Бойса-Кодда (НФБК, BCNF), усиленная 3НФ
- 4НФ, без многозначных зависимостей

Более высокие нормальные формы представляют, в основном, лишь академический интерес.

---
> Когда таблица находится в *первой нормальной форме*?

- ячейки таблицы содержат только атомарные значения
- нет повторяющихся строк

Такая форма достигается введением первичного ключа (устраняет повторы), и отсутствием столбцов составных типов (массивы/JSON). Последнее всё же допускается, только если работа с этими составными типами ведется как с атомарными значениями: в SQL не используются операторы доступа до их внутренней структуры.

---
> Приведите примеры, когда таблица (не) находится в 1НФ

В реляционной теории любое отношение находится в 1НФ. В реальных базах данных обычно допускаются таблицы с повторяющимися строками (без первичных ключей), а также со столбцами композитных типов, используемых как не-атомарные (с доступом до их внутренней структуры, напр., `WHERE col1[1] = <some>`).

---
> Когда таблица находится во *второй нормальной форме*?

- не имеет составного (первичного) ключа
- или имеет, но все остальные (неключевые) атрибуты зависят от всего этого составного ключа целиком, не от его части

Такая форма, как правило, достигается введением суррогатного ключа (последовательного типа): он состоит из одного атрибута (не является составным), и автоматически переводит таблицу в 2НФ. Разделение же таблицы на части, как правило, переводит таблицу сразу в более высокую форму - 3НФ.

Отдельный случай - когда таблица не имеет неключевых атрибутов: любой столбец входит хотя бы в один из потенциальных ключей. Тогда выполняются условия и 2НФ, и 3НФ.

---
> Приведите примеры, когда таблица (не) находится во 2НФ

Любая таблица с суррогатным ключом (как правило это `id serial PRIMARY KEY`) находится в 2НФ. А вот, например, таблица "спортсмен"-"секция"-"плата", для которого ключом является пара "спортсмен"-"секция" (спортсмен может посещать несколько секций; плата - неуникальный атрибут), в 2НФ не находится: атрибут "плата за секцию" функционально зависит от части составного ключа, от поля "секция".

Другие примеры таблиц не в 2НФ (ключ - первая пара атрибутов):

- "товар"-"категория"-"название-категории" (название зависит от части ключа)
- "модель"-"бренд"-"скидка-на-бренд" (скидка привязана к бренду целиком, не к конкретному товару)

---
> Когда таблица находится в *третьей нормальной форме*?

- не имеет *транзитивных зависимостей*: зависимостей одного неключевого атрибута от другого

Нормализация до этой формы наиболее распространена, сводится к разделению таблицы на части, относящиеся каждая к отдельной сущности.

---
> Приведите примеры, когда таблица (не) находится в 3НФ

Если сотрудник может состоять только в одном отделе, то записи в таблице "сотрудник"-"отдел"-"начальник" идентифицируются ключом "сотрудник", а атрибуты "отдел" и "начальник" неключевые. При этом поле "начальник" функционально зависит от поля "отдел", и потому таблица не находится в 3НФ.

Разделение таблицы из примера выше на две устранит транзитивную зависимость между неключевыми атрибутами, и приведет обе получившиеся таблицы в 3НФ.

Другие примеры:

- "студент"-"общежитие"-"плата" - ключ "студент", во 2НФ, но не в третей. "Плата за общежитие" функционально зависит от неключевого атрибута "общежитие". Разделение на таблицы "студент"-"общежитие" и "общежитие"-"плата" приведет их обе к 3НФ
- "id-модели"-"модель"-"бренд"-"скидка-на-бренд" - (с суррогатным ключом) во 2НФ, но не в третей. Выделение в отдельную таблицу сущности "скидки брендов" приведет результирующие в 3НФ

---
> Когда таблица находится в *нормальной форме Бойса-Кодда*?

- каждый *детерминант* (поле, от которого зависит другое поле) сам является потенциальным ключом

Необходимость приведения к BCNF возникает когда:

- отношение имеет два или более *составных* потенциальных ключа
- эти ключи пересекаются, т.е. имеют хотя бы один общий атрибут
- от атрибутов из пересечения зависит другой *ключевой* атрибут

Таким образом, этот детерминант сам не является потенциальным ключом (он лишь часть составного), но от него зависит другой атрибут. Т.к. это зависимое поле само ключевое, то таблица удовлетворяет требованиям 2НФ и 3НФ.

---
> Приведите примеры, когда таблица (не) находится в 3НФ Бойса-Кодда

Таблица "программист"-"команда"-"тимлид". Разработчик может входить в одну или несколько команд одновременно. Поле "тимлид" содержит уникальные значения. Таким образом, имеем два пересекающихся потенциальных ключа: "программист"-"команда" и "программист"-"тимлид", любой из них однозначно идентифицирует строку. Неключевых атрибутов нет, таблица находится в 3НФ. Но при этом "тимлид" однозначно идентифицирует "команду" (и наоборот), сам ключом не являясь.

Разделение таблицы на две - "программист"-"команда" и "команда"-"тимлид" - приведет результаты к BCNF.

---
> Что такое *денормализация*, зачем она нужна?

Это намеренное приведение структуры БД в состояние, не соответствующее критериям нормализации. Обычно делается с целью ускорения операций чтения за счет добавления избыточных данных.

Нормализация приводит к разбиению данных на несколько таблиц, из-за чего SQL-запросы начинают требовать `JOIN`-ов, часто сильно влияющих на производительность. Если узкие места производительности нельзя обойти другими способами, таблицы можно вернуть обратно в не-нормализованный вид.

Денормализация иногда имеет и другие формы, например, вычисляемые поля. Согласованность таких данных нужно поддерживать вручную, например, триггерами

---
> Каковы преимущества нормализации и денормализации?

Преимущества:

- нормализация уменьшает размер хранимых данных, устраняет избыточность и аномалии вставки/обновления/удаления
- денормализация ускоряет выполнение запросов

Недостатки:

- нормализация добавляет требование ссылочной целостности, необходимость поддерживать согласованность внешних ключей
- нормализация замедляет выполнение сложных составных запросов, из-за появления `JOIN`-ов
- денормализация ведет к появлению аномалий, согласованность данных нужно поддерживать вручную, например, триггерами
- денормализация увеличивает размер хранимых данных, добавляет избыточность

---

# Язык SQL, общее, `[sql]`

---
> Что такое *SQL*?

Декларативный язык программирования (не тьюринг-полный), применяемый для создания, модификации и управления данными в *реляционной* базе данных. Декларативность означает, что для получения результата достаточно лишь указать, *что* нужно получить, но не требуется предписывать способ получения результата, т.е. *как* его получить.

---
> Какие у SQL есть подмножества?

- *DDL* (Data Definition Language, язык описания данных) - позволяет выполнять различные операции с базой данных, такие как `CREATE` (создание), `ALTER` (изменение) и `DROP` (удаление объектов)
- *DML* (Data Manipulation Language, язык управления данными) - позволяет получать доступ к данным и манипулировать ими, например, вставлять (`INSERT`), обновлять (`UPDATE`), удалять (`DELETE`) и извлекать (`SELECT`) данные из базы данных
- *DCL* (Data Control Language, язык контроля данных) - позволяет контролировать доступ к базе данных. Пример - `GRANT` (предоставить права), `REVOKE` (отозвать права)

---
> Назовите две основные обобщенные операции языка SQL

Это *выборка* и *проекция*:

- выборка - возврат части кортежей. В языке реализуется через `SELECT` + `WHERE`
- проекция - возврат части атрибутов. В языке реализуется через ограничение списка столбцов в `SELECT`

---
> Какие операции из теории множеств реализованы в языке SQL?

Типы столбцов в выборках должны совпадать:

- `UNION` - объединение
- `INTERSECT` - пересечение
- `EXCEPT` - вычитание

По умолчанию после каждого из этих ключевых слов подразумевается `DISTINCT` - удалить дубликаты. Для сохранения дубликатов нужно явно указывать `ALL`

---

# SQL, лексическая структура языка, `[sql-lexical-structure]`

---
> Учитывает ли SQL регистр символов?

Язык не чувствителен к регистру, за исключением идентификаторов в двойных кавычках. Но, традиционно, ключевые слова пишут в верхнем регистре, а идентификаторы в нижнем: это формат вывода утилиты `pg_dump`.

---
> Какие символы может содержать идентификатор?

Идентификатор может начинаться с буквы или подчеркивания, но не с цифры. Заключенный в двойные кавычки, он может содержать любые символы (кроме символа с кодом `0`), например, пробелы или амперсанды. Идентификатор в двойных кавычках может совпадать с ключевым словом: кавычки указывают, что это именно пользовательское имя.

Пробелы игнорируются и обязательны только чтобы избежать неоднозначности.

---
> Как записываются числовые и строковые литералы?

- числовые стандартно. Ведущий и замыкающий нули могут быть опущены. Допустима научная нотация
- строковые (только) в одинарных кавычках, экранирование кавычки - другой кавычкой. Разделенные переносом строки автоматически соединяются в одну строку. Обратный слеш + символ не имеют специального смысла

```sql
4., .001, 1.925e-3
'foo'
'bar' ~ `foobar`
```

---
> Какие в PostgreSQL есть специальные строковые литералы?

- заключенные в доллары, с пустым или нет тегом. В таких строках не нужно экранировать ни кавычку, ни знак доллара. Могут быть многострочными, и, как правило, используются для написания функций
- со спецпоследовательностями в стиле C. Префикс `E` перед одинарной кавычкой. Обратный слеш + некоторые символы означают спецпоследовательности

```
$$Жанна д'Арк$$, $SomeTag$Жанна д'Арк$SomeTag$
E'fo\no'
```

---
> Назовите три способа приведения типов

```sql
type 'string'
'string'::type
CAST ( 'string' AS type )
```

Второй способ - нативный Postgres-овский, третий - по стандарту SQL, первый обобщение стандарта и может работать не для всех типов.

---
> Приоритет операторов

От самых приоритетных к менее:

- `.` - получение имени столбца
- `::` - приведение типов
- математические операторы
- <любой другой>
- `< > = <= >= <>` - сравнения
- `NOT`
- `AND`
- `OR`

---
> Какие в SQL есть типы комментариев?

Два вида, блочный и однострочный:

```sql
/* block comment */
-- one line comment
```

---
> Какой синтаксис у операторов "равно" и "не равно"?

Одинарное "равно" и две формы для "не равно":

```sql
=, <>, !=
```

---

# Базовые типы данных, `[types-base]`

- форматы строк для конвертации в дату/время

---
> Перечислите основные группы типов данных в PostgreSQL

- неопределенное значение `NULL`
- числовые: целые, с плавающей точкой, произвольной точности и последовательные
- символьные: фиксированной и нефиксированной длины
- дата, время, дата+время и интервалы
- логический тип
- перечисления
- денежные, географические, геометрические и пр.

---
> Что такое неопределенное значение `NULL`?

"Ничто", или отсутствие значения. Элемент троичной логики `TRUE` - `FALSE` - `NULL`. Любые сравнения с ним дают `NULL`, в том числе некоторые варианты `IN (..., NULL)`.

---
> В каких случаях логические связки с `NULL` дают определенное значение?

Только два варианта, с любым порядком операндов:

- `true OR NULL` ~ `TRUE`
- `false AND NULL` ~ `FALSE`

Во всех остальных случаях результат не определен, `NULL`.

---
> Какие значения могут повторятся в уникальных индексах?

Неопределенные, `NULL`-значения. Два `NULL` считаются не равными друг другу, и потому уникальными.

---
> Как обрабатываются `NULL`-значения при группировке строк?

Здесь, в отличие от `UNIQUE`-столбцов, два `NULL`-значения считаются равными. `GROUP BY` при сравнении поместит строки с совпадающими `NULL`-столбцами в одну группу.

---
> Как агрегатные функции обрабатывают `NULL`-значения?

Игнорируют. Например, `count(col)` будет считать только строки с не-`NULL` значением `col`.

---
> Как `NULL`-значения интерпретируются при сортировке?

Как значения, большие любого другого. Таким образом, `NULL`-значения располагаются в конце при `ASC`-порядке (и при отсутствии явного указания), и в начале при `DESC`.

Это поведение по умолчанию. Его можно изменить, указав порядок явно, через `NULLS FIRST|LAST`:

```sql
ORDER BY comm NULLS FIRST
ORDER BY comm DESC NULLS LAST
```

---
> Что выведет этот код?
> 
> ```sql
> SELECT 2 + NULL;
> SELECT 2 <> NULL;
> ```

```sql
NULL
NULL
```

И арифметические операции, и операции сравнения, дают с `NULL` неопределенный результат.

---
> Что выведет этот код?
> 
> ```sql
> SELECT 3 IN (1, 2, NULL);
> ```

Не `FALSE`, а

```sql
NULL
```

Операция эквивалентна

```sql
SELECT 3 = 1 OR 3 = 2 OR 3 = NULL;
-- или
SELECT FALSE OR FALSE OR NULL;
```

что в троичной логике SQL дает `NULL`.

---
> Что выведет этот код?
> 
> ```sql
> SELECT 3 NOT IN (1, 2, NULL);
> ```

Не `TRUE`, а

```sql
NULL
```

Операция эквивалентна

```sql
SELECT 3 <> 1 AND 3 <> 2 AND 3 <> NULL;
-- или
SELECT TRUE AND TRUE AND NULL;
```

что в троичной логике SQL дает `NULL`.

---
> Перечислите числовые типы данных

- три целочисленных: `smallint`, `int[eger]`, `bigint`
- два с плавающей точкой: `real` и `double precision`
- два (синонимы) с фиксированной точностью: `numeric|decimal(precision, scale)`
- последовательные: `smallserail`, `serial`, `bigserial`

---
> Сколько байт занимает каждый целочисленный тип?

`2`, `4` и `8`, это отражено в именах их псевдонимов:

- `smallint` ~ `int2`
- `int[eger]` ~ `int4`
- `bigint` ~ `int8`

---
> На что обращать внимание при выборе целочисленного типа для поля?

На диапазона допустимых значений и затраты памяти на поле. Часто стандартный `integer` является оптимальным.

---
> Сколько байт занимает каждый из типов с плавающей точкой?

`4` и `8`, это отражено в именах их псевдонимов:

- `real` ~ `float4`
- `double precision` ~ `float8`

---
> Что означает тип `float[(n)]`?

Это псевдоним для типов с плавающей точкой, введенный для совместимости со стандартом SQL:

- при `1 <= n <= 24` эквивалентен `real`
- при `25 <= n <= 53` ~ `double precision`
- без указания `n` ~ `double precision`

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0.1::real * 10 = 1.0::real
> ```

`f` (= `false`), сравнивать числа с плавающей точкой напрямую нельзя.

---
> Какие специальные значения поддерживают типы чисел с плавающей точкой?

`Infinity`, `-Infinity`, `NaN` (не число).

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 1E+308 < 'Inf'::double precision;
> ```

```
 ?column?
----------
 t
```

`Inf` больше самого большого числа, представимого типом.

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0 * 'Inf'::real;
> ```

```
 ?column?
----------
      NaN
```

Ноль на бесконечность дает математическую неопределенность.

---
> Что означают цифры в объявлении типа `numeric|decimal`?

`numeric|decimal(precision, scale)`:

- `precision` - общее число цифр
- `scale` - число цифр после десятичной точки

---
> В чем преимущества и недостатки чисел с произвольной (фиксированной) точностью?

Тип `numeric`/`decimal` может хранить сотни тысяч цифр. Результаты арифметических операций с такими числами дают настолько большую точность, насколько это вообще возможно. Их рекомендуют использовать, например, для хранения и расчетов денежных сумм.

Недостаткам является значительно более низкая скорость работы, по сравнению с числами с плавающей точкой.

---
> Какое максимальное число можно записать в поле `numerc(N, M)`? В поле `numeric(N)`?

Если `M` опущено, то оно равно `0`, а общая длина целой части равна `N-M`. Таким образом, диапазон допустимых значений:

```
[-10^(N-M), +10^(N-M)]
```

Например, для `numeric(5, 2)` (= `numeric(3)`) допустимый диапазон `[-1000, 1000]`.

---
> Что выведет этот код?
> 
> ```sql
> CREATE TABLE test_numeric(
>   measurement numeric(5, 2),
>   description text
> );
> INSERT INTO test_numeric VALUES (999.9999, 'some');
> ```

Ошибку переполнения:

```
ERROR:  numeric field overflow
DETAIL:  A field with precision 5, scale 2 must round
  to an absolute value less than 10^3.
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT
>   'NaN'::numeric = 'NaN'::numeric,
>   'NaN'::numeric < 'NaN'::numeric,
>   1 < 'NaN'::numeric;
> ```

```
 ?column? | ?column? | ?column?
----------+----------+----------
 t        | f        | t
```

`NaN` в Postgres равен самому себе и больше любого другого числа.

---
> Что такое *последовательные типы* данных?

Это просто "синтаксический сахар", псевдоним для создания последовательности целых чисел, и прикрепления ее к оператору `DEFAULT` в объявлении столбца:

```sql
CREATE SEQUENCE table_col_seq AS integer;
CREATE TABLE table (
  col integer NOT NULL DEFAULT nextval('table_col_seq')
);
```

---
> Каким целочисленным типам соответствуют последовательные типы?

Три тех и тех, размеры отражены в именах псевдонимов:

- `smallserail` ~ `serial2` - `smallint`
- `serial` ~ `serial4` - `int[eger]`
- `bigserial` ~ `serial8` - `bigint`

---
> Перечислите символьные типы данных

- фиксированной длины: `char[acter](n)`, дополняются пробелами
- переменной длины с ограничением: `character varying|varchar(n)`
- без ограничения: `text`

---
> Какой максимальный размер строкового типа данных?

Как и для полей любого типа - 1Гб.

---
> Что произойдет при попытке сохранить в типе с ограничением (`[var]char(n)`) строку длиннее `n`?

- строка будет обрезана, если все лишние символы являются пробелами
- ошибка иначе

---
> Как соотносятся числа в объявлениях типов `character[ varying](N)` с длиной строк в многобайтовых (напр., UTF-8) кодировках?

`N` рассматривается как число символов, не число байт.

---
> Как в строковых литералах экранируются кавычки?

Строки задаются в одинарных кавычках. Одинарная кавычка внутри экранируется второй такой же кавычкой, не обратным слешем:

```sql
SELECT 'te''st';
```

Двойные кавычки внутри рассматриваются как обычные символы, их экранировать не нужно.

---
> Какой литерал у "сырых" строк?

Два символа доллара с каждой стороны. Никакие символы (`'`, `\`, `$`) внутри экранировать не нужно:

```pgsql
SELECT $$t\e's$t$$;
```

Это расширение Postgres, не часть стандарта SQL.

---
> Что такое строки в стиле C?

Строковые литералы, которые могут содержать escape-последовательности, вроде `\n`, `\t`. Такие строки нужно начинать с символа `E`:

```pgsql
SELECT E'PG\nDAY\'17';
```

Одинарная кавычка и обратный слеш в таких литералах экранируются одинаково - обратным слешем:

```
 ?column?
----------
 PG      +
 DAY'17
```

Это расширение Postgres, не часть стандарта SQL.

---
> Что выдаст этот код?
> 
> ```sql
> SELECT 'abcdef'::char(3), 'abcdef'::varchar(3);
> ```

В обоих случаях ошибки не будет:

```
 bpchar | varchar
--------+---------
 abc    | abc
```

В отличие от сохранения строк в более короткие поля с ограничениями (`[var]char(n)`), при явном приведении типов усечение происходит всегда, а не только с пробелами в конце строки.

---
> Что выдаст этот код?
> 
> ```sql
> SELECT 'abc'::char(5) = 'abc  '::char(5);
> ```

`TRUE`, тип `char(n)` всегда дополняет строки незначащими пробелами справа, что фактически приводит к сравнению с игнорированием правых пробелов. Тот же код с заменой `char(5)` на `varchar(5)` выдаст `FALSE`.

---
> Перечислите типы данных для даты и времени

- время с и без часового пояса: `time [(p)] [with[out] time zone]` (`timetz`)
- дата: `date`
- дата+время с и без часового пояса: `timestamp [(p)] [with[out] time zone]` (`timestamptz`)
- интервал: `interval [ <поля> ] [(p)]`

---
> Какой тип данных для времени рекомендовано использовать?

Без часового пояса, `timetz` не рекомендован, и существует в основном для обратной совместимости. Это связано с тем, что тип данных "время" не хранит информацию о дате, и значит нельзя узнать момент перехода на летнее/зимнее время.

---
> Как хранятся данные `tz`-типов?

Как временная метка в UTC, а часовой пояс добавляется только при выводе, и берется из системных настроек Postgres.

---
> Как можно получить текущие дату и время?

Функция `current_timestamp`, определенная в стандарте SQL, вызывается без круглых скобок. Аналогичная ей функция `now()` - это расширение PostgreSQL:

```sql
SELECT current_timestamp;
SELECT now();
```

Возвращают тип `timestamptz`:

```
              now
-------------------------------
 2020-06-14 06:16:56.282864+04
```

---
> Какие 3 функции возвращают текущие значения даты и времени? Как они вызываются?

Все три вызываются без круглых скобок:

```sql
SELECT current_date, current_time, current_timestamp;
```

```
 current_date |    current_time    |       current_timestamp
--------------+--------------------+-------------------------------
 2020-06-16   | 03:50:49.525199+04 | 2020-06-16 03:50:49.525199+04
```

---
> Как отформатировать дату?

Вызвать функцию `to_char()` с объектом типа `date`/`time[stamp]` и строкой формата. Она вернет тип `text`:

```sql
SELECT
  to_char(current_date, 'dd-mm-yyyy'),
  to_char(current_timestamp, 'mi:ss'),
  to_char(current_timestamp, 'dd');
```

```
  to_char   | to_char | to_char
------------+---------+---------
 30-06-2020 | 13:53   | 30
```

---
> Строковые литералы какого формата распознаются при приведении дат `::date`?

- `yyyy-mm-dd` (ISO 8601)
- `Mon dd, yyyy`

```sql
SELECT '2016-09-12'::date = 'Sep 12, 2016'::date;
```

---
> Строковые литералы какого формата распознаются при приведении времени `::time`?

```
hh:mm[:ss[ am|pm]]
```

```sql
'21:15'::time, '21:15:12'::time, '12:15:12 pm'::time
```

---
> Откуда функция `current_time` берет часовой пояс?

Из конфигурационного параметра `timezone`:

```sql
SHOW timezone;
```

Этот параметр (как и остальные) задается строкой в файле `/etc/postgresql/12/main/postgresql.conf`:

```
   TimeZone
---------------
 Europe/Samara
```

---
> Строковые литералы какого формата распознаются при приведении интервалов `::interval`?

- `'1 year 2 months[ ago]'` (где единицы измерения - от `microsecond` до `millennium`)
- `'P0001-02-03T04:05:06'` (дате и времени предшествуют буквы `P` и `T`; стандарт ISO 8601)

---
> Как можно получить значение типа `interval`?

- из строковой константы
- вычитая одну временную отметку из другой

```sql
SELECT '1 hour'::interval, '13:00'::time - '12:00'::time;
```

```
 interval | ?column?
----------+----------
 01:00:00 | 01:00:00
```

---
> Как усечь timestamp до нужной компоненты?

Функцией `date_trunc(text, timestamp)`:

```sql
SELECT date_trunc('hour', current_timestamp);
```

До границы часа, минуты/секунды станут нулями. Идет простое отбрасывание, не округление:

```
       date_trunc
------------------------
 2020-06-16 06:00:00+04
```

Первый параметр может быть от микросекунд до тысячелетий. Как правило, усечение просто заменяет всё справа нулями. Исключение - параметр `week`.

Функция всегда возвращает тип `timestamp[ without time zone]`, хотя принимать может не только таймстемпы, но и интервалы.

---
> Что выведет этот запрос?
> ```sql
> SELECT date_trunc('sec', '1:2:3.4'::time);
> ```

Компонента - первый параметр, - это граница, усекается по ней, а не она сама отбрасывается. В этом примере секунды остаются, но отбрасывается их дробная часть:

```
 date_trunc
------------
 01:02:03
```

---
> Как извлечь из timestamp-а нужную компоненту?

Функцией `extract(<field> from <timestamp>)`:

```sql
SELECT extract('mon' FROM timestamp '1999-11-27 12:34:56.123459');
```

Она всегда возвращает число (`double precision`):

```
 date_part
-----------
        11
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT extract('cent' FROM '1999-01-01'::date);
> ```

```
 date_part
-----------
        20
```

Иногда `extract()` не просто выбирает число из записи даты/времени/интервала, а еще и делает некоторые преобразования. `cent` ~ `century`, а 1999 год принадлежит двадцатому веку.

---
> Какой размер у типов `timestamp[ with time zone]` и `date`?

У первого 8 байт, а у даты 4 байта.

Несмотря на это, максимальное значение для `date` сильно больше, чем для таймстемпов: время ей хранить не надо.

---
> Что означают цифры в скобках после типов `timestamp`, `time` и `interval`?

*Точность* - количество десятичных цифр в поле секунд:

```sql
SELECT current_time::time, current_time::time(0), current_time::time(3);
```

```
  current_time   | current_time | current_time
-----------------+--------------+--------------
 22:41:11.777138 | 22:41:12     | 22:41:11.777
```

Для `date` такого параметра нет.

---
> Какой параметр управляет форматом даты? Какое у него значение по умолчанию?

```sql
SHOW datestyle;
```

Первый компонент управляет форматом вывода, а второй - форматом ввода, строки для преобразования в дату, "день"-"месяц"-"год" (`'18-05-2016'::date`):

```
 DateStyle
-----------
 ISO, DMY
```

---
> Каков *универсальный* формат строки для преобразования в дату?

"Год"-"месяц"-"число", `YYYY-MM-DD`:

```sql
SELECT '2016-05-18'::date;
```

Использовать этот формат для ввода дат можно всегда, независимо от второй компоненты параметра `datestyle`. Кроме того, это дефолтный формат вывода дат. Результат для примера выше:

```
    date
------------
 2016-05-18
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '05-18-2016'::date;
> ```

На дефолтных настройках - ошибку:

```
ERROR:  date/time field value out of range: "05-18-2016"
HINT:  Perhaps you need a different "datestyle" setting.
```

По умолчанию второй компонент параметра `datestyle`, отвечающий за формат вводимых дат, равен `DMY`. В нашем же примере во второй позиции стоит `18`, и как месяц оно интерпретироваться не может (в случае числа < 12 ошибки бы не было).

---
> Что выведет этот запрос?
> ```sql
> SELECT 'Feb 29, 2015'::date;
> ```

Ошибку:

```
ERROR:  date/time field value out of range: "Feb 29, 2015"
```

При парсинге дат выполняется много проверок, в том числе и на високосные года.

---
> Что выведет этот запрос?
> ```sql
> SELECT '21:15:16:22'::time;
> ```

Ошибку:

```
ERROR:  invalid input syntax for type time: "21:15:16:22"
```

Формат входных данных для дат/времени задается жестко, и лишние значения игнорироваться не будут.

---
> Что выведет этот запрос?
> ```sql
> SELECT pg_typeof('2016-09-16'::date - '2016-09-01'::date),
>        pg_typeof('09:16'::time - '09:01'::time);
> ```

В отличие от разности временных меток, разница дат дает целое число - дни (зд. `15`), не интервал:

```
 pg_typeof | pg_typeof
-----------+-----------
 integer   | interval
```

---
> Что выведет этот запрос?
> ```sql
> SELECT '2016-09-16'::date      - '2015-09-01'::date,
>        '2016-09-16'::timestamp - '2015-09-01'::timestamp;
> ```

Разность значений типа `date` имеет целочисленный тип. Для типов `time[stamp]` разность является интервалом:

```
 ?column? | ?column?
----------+----------
      381 | 381 days
```

---
> Что выведут эти запросы?
> ```sql
> SELECT '0:1'::time - '0:0'::time;
> SELECT '0:1'::time + '0:0'::time;
> ```

Первый вернет интервал в 1 минуту, а второй упадет с ошибкой:

```
 ?column?
----------
 00:01:00

ERROR:  operator is not unique: time without time zone + time without time zone
HINT:  Could not choose a best candidate operator.
  You might need to add explicit type casts.
```

Таким образом, прибавлять ко временной метке можно только интервал, но не другое значение времени.

---
> Что выведут эти запросы?
> ```sql
> SELECT '2016-09-16'::date - 1;
> SELECT '20:34:35'::time - 1;
> ```

Первый отработает корректно, вернет дату на день меньше. Второй упадет с ошибкой:

```
ERROR:  operator does not exist: time without time zone - integer
```

Таким образом, целые числа можно складывать/вычитать только из дат, для работы с типом `time[stamp]` нужно использовать временные метки или интервалы.

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT '0:1'::time, '0:1'::time + '1 mon'::interval AS time;
> ```

Интервал к временной метке прибавлять вполне можно, но сложение часов с днями ничего в метке не изменит - хранится только время суток, не сама дата:

```
   time   |   time
----------+----------
 00:01:00 | 00:01:00
```

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT
>   '2016-01-01'::date + '1 mon'::interval,
>   '2016-02-29'::date + '1 mon'::interval,
>   '2016-01-31'::date + '1 mon'::interval;
> ```

```
      ?column?       |      ?column?       |      ?column?
---------------------+---------------------+---------------------
 2016-02-01 00:00:00 | 2016-03-29 00:00:00 | 2016-02-29 00:00:00
```

- из первого числа всегда получается первое следующего месяца
- и вообще, число сохраняется, только месяц увеличивается на единицу
- если в следующем месяце нет такого (большого) числа, то берется последний день

---
> Какие значения принимает логический тип?

`bool[ean]` принимает три значения, не два: `TRUE`, `FALSE` и `NULL`. Таким образом, он реализует *троичную логику*.

---
> Какие строки приводятся к булевым значениям?

Регистр не играет роли:

- `'true'`, `'yes'`, `'on'`, `'1'` - к истинному значению
- `'false'`, `'no'`, `'off'`, `'0'` - к ложному

Также приводятся и их уникальные префиксы (напр., `t`/`f`). Предпочтительным является непосредственно использование констант `TRUE` и `FALSE`.

---
> Как использовать булевы поля в проверках?

Напрямую, без явного сравнения с константами:

```sql
SELECT * FROM databases WHERE is_open_source;
```

---
> Как задать тип-перечисление?

Этот тип требует предварительного объявления:

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
  ...
  current_mood mood
);
```

---
> Как присвоить столбцу перечислимого типа значение?

Значения `ENUM`-типа указываются как строки, в одинарных кавычках:

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
...
INSERT INTO person VALUES ('Moe', 'happy');
```

Регистр имеет значение (!). Элементы перечисления можно сравнивать, те, что идут в объявлении типа раньше, считаются меньшими по значению.

---
> Как можно сэмулировать перечислимый тип, чтобы не использовать предварительное объявление?

Через связку `CHECK` + `IN`:

```sql
CREATE TABLE person (
  ...
  current_mood CHECK (current_mood IN ('sad', 'ok', 'happy'))
);
```

---
> Перечислите некоторые прочие типы данных PostgreSQL

- денежный тип `money` завязан на настройку `lc_monetary`
- геометрические типы, вроде `point`, `line`
- сетевые адреса, вроде `inet`

---
> Как узнать тип выражения в `SELECT`?

Функция `pg_typeof()`:

```sql
SELECT pg_typeof('13:00'::time - '12:00'::time);
```

```
 pg_typeof
-----------
 interval
```

---

# Составные типы данных, `[types-compound]`

---
> В чем отличия `jsonb` от `json`?

`jsonb` - это бинарный формат хранения:

- данные в нем хранятся плотно упакованными (экономится место)
- он не сохраняет порядок ключей в JSON
- для него другой набор операторов
- вставка в поле такого типа происходит медленнее (из-за значения разбора), но чтение/поиск по нему идут быстрее

---
> Как создать столбец - типизированный массив?

Указать квадратные скобки после имени типа:

```sql
CREATE TABLE pilots(
  pilot_name text,
  schedule integer[]
);
```

---
> Как записать массив в поле `type[]`?

Массив обозначается литералом-строкой (в одинарных кавычках) - перечислением значением внутри фигурных скобок, с явным приведением ее к типу столбца:

```sql
INSERT INTO pilots VALUES (
  'Ivan', '{1, 3, 5, 6, 7}'::integer[]
);
```

Есть и нотация из SQL-стандарта, запись через ключевое слово `ARRAY`:

```sql
INSERT INTO pilots VALUES (
  'Ivan', ARRAY[1, 1, 1, 2]
);
```

---
> Как можно добавить элемент в конец списка значений столбца-массива?

Через оператор или функцию:

```sql
SET schedule = schedule || 7
SET schedule = array_append(schedule, 6)
```

Первый вариант (оператор `||`) позволяет добавлять как отдельный элемент, так и целый массив. Функция `array_append()` работает только с одиночным значением.

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '{1, 2}'::int[] || '{3, 4}'::int[], '{1, 2}' || '{3, 4}';
> ```

Ошибки не будет, оператор конкатенации `||` применим к обоим типам:

```
 ?column?  |   ?column?
-----------+--------------
 {1,2,3,4} | {1, 2}{3, 4}
```

Но без явного приведения массивы создаваться не будут, объединенное значение будет строкой (`text`).

---
> Как добавить элемент в начало списка значений столбца-массива?

Через функцию `array_prepend()`:

```sql
SET schedule = array_prepend(1, schedule)
```

- как и `array_append()` она работает лишь с одиночным элементом, не массивом
- в отличие от `array_append()` у нее другой порядок аргументов - добавляемый элемент идет первым

---
> Как удалить элемент из списка значений столбца-массива?

Функцией `array_remove()`:

```sql
SET schedule = array_remove(schedule, 5)
```

Эта функция удаляет элемент *по значению*, не по индексу.

---
> Как обращаться к элементам столбца-массива?

Через оператор "квадратные скобки". Индексация начинается с единицы (!):

```sql
SET schedule[1] = 2, schedule[2] = 3
```

Получить доступ только на чтение можно также через функцию:

```sql
WHERE array_position(schedule, 3) IS NOT NULL
```

---
> Как можно заменить сразу часть значений столбца-массива?

Через *срез* (slice):

```sql
SET schedule[1:2] = ARRAY[2, 3]
```

Индексация начинается с единицы (!), второй индекс включается в диапазон.

---
> Как проверить, что массив полностью включается в другой?

Оператор `@>` означает проверку того факта, что в левом массиве содержатся все элементы правого. Запрос с условием:

```sql
WHERE schedule @> '{1, 7}'::integer[]
WHERE schedule @> ARRAY[1, 7]
```

выберет все записи, столбец `schedule` в которых содержит оба числа `1` и `7`, например, `{1,3,6,7}`.

---
> Как проверить, что в массиве присутствуют элементы другого массива?

Оператор `&&` означает проверку того факта, что в левом массиве содержится хотя бы один элемент правого. Запрос с условием:

```sql
WHERE schedule && '{2, 5}'::integer[]
WHERE schedule && ARRAY[2, 5]
```

выберет все записи, столбец `schedule` в которых содержит хотя бы одно из чисел `2` и `5`, например, `{3,5,6,7}`, `{1,2,5,6}`, `{2,3,5,7}`.

В отличие от оператора `||`, этот возвращает булево значение, не массив.

---
> Как через операторы сформулировать условие "не содержит ни один из элементов указанного массива"?

Совместить `NOT` и `&&`:

```sql
WHERE NOT (schedule && ARRAY[2, 5])
```

В результате будут выбраны только те записи, в поле `schedule` которых нет чисел `2` и `5`, например, `{1,3,6,7}`.

---
> Как "развернуть" массив во множество (в выборку из строк)?

Функцией `unnest()`:

```sql
SELECT unnest(ARRAY[1,2,3]);
```

```
 unnest
--------
      1
      2
      3
```

---

# `SELECT`, части и порядок выполнения, `[select]`

---
> Перечислите основные части команды `SELECT`

```sql
SELECT col1, col2
  FROM table1 JOIN table2 USING(col3)
  WHERE col4 = 1
  GROUP BY col5
  HAVING count(*) > 0
  ORDER BY 1
  LIMIT 10 OFFSET 3;
```

- первым идет сам `SELECT` + перечень столбцов для выборки
- во `FROM` перечисляются таблицы, из которых выбираются данные
- внутри `FROM` могут присутствовать операции соединения - `JOIN` + `ON`/`USING`
- `WHERE` фильтрует записи
- `GROUP BY` их группирует
- `HAVING` фильтрует результаты группировки и, как правило, содержит агрегатные функции
- `ORDER BY` сортирует результат
- `LIMIT`/`OFFSET` ограничивают выдачу

---
> В каком порядке выполняются части `SELECT`?

1. первым выполняется `FROM` + `JOIN`-ы в нем
2. полученная "виртуальная таблица" фильтруется в `WHERE`
3.`GROUP BY` группирует строки
4. `HAVING` фильтрует результат группировки
5. выполняется операция проекции, `SELECT` + список столбцов. Здесь вычисляются и оконные функции
6. выполняется сортировка в `GROUP BY`. К этому моменту столбцы в `SELECT` определены, и можно обращаться к их псевдонимам
7. выполняются `LIMIT`/`OFFSET`

```sql
SELECT col1, avg(col2) OVER()         -- 5
  FROM table1 JOIN table2 USING(col3) -- 1
  WHERE col4 = 1                      -- 2
  GROUP BY col5                       -- 3
  HAVING count(*) > 0                 -- 4
  ORDER BY 1                          -- 6
  LIMIT 10 OFFSET 3;                  -- 7
```

---
> Что выведет этот код?
> 
> ```sql
> SELECT 1 AS id WHERE id = 1;
> ```

Ошибку:

```
ERROR:  column "id" does not exist
```

На момент выполнения `WHERE` часть с `SELECT <cols>` еще не выполнена, и псевдонимы столбцов не определены. Использовать псевдонимы можно не раньше `ORDER BY`.

---
> Как именуются столбцы в выводе `SELECT`-а?

- используется алиас (`AS <alias>`)
- если `AS` не указан - то имя самого столбца
- `?column?` - если имя неопределено (напр., `SELECT 1` или столбец вычисляемый)

---
> К какой части `SELECT` относится `DISTINCT`?

К ключевому слову, т.е. ко всей выборке, а не к отдельному столбцу:

```sql
SELECT DISTINCT name, start_year FROM students;
-- SELECT name, DISTINCT start_year FROM students; /* syntax error */
```

---
> Сколько строк будет содержать результат `SELECT` без `FROM`?

Одну:

```sql
SELECT 2+2 AS result;
```

```
 result
--------
      4
```

---
> При каких результатах сравнения в `WHERE` строка попадет в результат `SELECT`-а?

Если сравнение истинно. Не попадет, если сравнение ложно или *не определено* (напр, сравнение с `NULL`).

---
> В каких частях запроса можно использовать подзапросы (вложенный `SELECT`)?

Зависит от того, сколько строк такой подзапрос возвращает:

- если одну или меньше, то такой подзапрос называется *скалярным*, и его можно использовать как единственное значение, в том числе в списке столбцов для выборки или в условиях `WHERE`
- если больше одной строки, то в качестве источника ("таблицы") в `FROM`/`JOIN`, или также в `WHERE`, но только с операторами принадлежности существования, вроде `[NOT] IN`/`[NOT] EXISTS`

В последнем случае (`IN`) подзапрос должен возвращать множество скалярных значений.

---
> Какое значение используется в качестве результата скалярного подзапроса, не возвращающего ни одной строки?

Неопределенное, `NULL`:

```sql
SELECT c1, (SELECT ...) as c2 FROM ...;
```

```
  c1  | c2
------+----
 some |
```

---
> Как можно преобразовать скалярный подзапрос, используемый в качестве значения в столбце?

В `LEFT JOIN`.

Соединение должно быть именно внешнее: скалярный подзапрос в списке столбцов `SELECT`-а возвращает `NULL`, если для него не найдено ни одной строки; для `INNER JOIN` же возврат неопределнного значения невозможен.

---
> Можно ли в подзапросе ссылаться на таблицу из внешнего `SELECT`-а?

Да, вполне. Такой подзапрос называется *кореллированным*:

```sql
SELECT name, (
  SELECT score FROM exams WHERE exams.s_id = students.s_id
) FROM students;
```

---
> Как указываются алиасы имен столбцов/таблиц?

`AS` при этом не обязательно:

```sql
SELECT name AS n FROM students AS s;
SELECT name n FROM students s;
```

---
> Где в `ORDER BY` указывается `ASC`/`DESC`?

После каждого ключа, не одно на всё выражение:

```sql
SELECT * FROM students ORDER BY name ASC, start_year DESC;
```

---
> Каков по умолчанию порядок сортировки в `ORDER BY`?

```sql
ASC
```

---
> Где в составных запросах имеет смысл располагать `ORDER BY`?

Только в конце основного запроса, перед получением итогового результата. В подзапросах она обычно бесполезна.

---
> Что выдаст этот код?
> 
> ```sql
> SELECT model AS m FROM aircrafts ORDER BY m;
> ```

Отсортированный список моделей. `ORDER BY` вполне может сортировать по псевдониму.

---
> Какой результат дает составная сортировка?
> 
> ```sql
> ORDER BY a, b;
> ```

Результат сортируется по первому столбцу `a`. Внутри групп с одинаковыми значениями `a` строки сортируются по столбцу `b`:

```
 code | count
------+-------
 319  |    20
 319  |    96
 320  |    20
 320  |   120
 321  |    28
```

---
> Что выдаст `SELECT *` на запросе с группировкой?

Ошибку, он не подставит автоматически список полей из `GROUP BY`:

```sql
SELECT * FROM seats GROUP BY aircraft_code;
```

```
ERROR:  column "seats.seat_no" must appear in the
  GROUP BY clause or be used in an aggregate function
```

---
> Что будет в результатах выборки?
> 
> ```sql
> SELECT * FROM aircrafts WHERE 1 = 0;
> ```

Ничего, пустой результат:

```
 ?column?
----------
(0 rows)
```

Хотя условие `WHERE` и не связано со столбцами в `SELECT`, оно всегда ложное и ни одна строка в выборку не попадет.

---

# Соединения таблиц, операции теории множеств, `[joins-sets]`

---
> Перечислите ипы `JOIN`-ов в PostgreSQL

Ключевые слова `INNER`/`OUTER` везде опциональны:

- `[INNER] JOIN` - внутреннее соединение
- `LEFT|RIGHT [OUTER] JOIN` - левое/правое внешние, дополнение `NULL`-строками с противоположной стороны
- `CROSS JOIN` - декартово произведение, без условия
- `FULL [OUTER] JOIN` - полное внешнее соединение, дополнение `NULL`-строками с обоих сторон

---
> Как обрабатываются таблицы во `FROM`/`JOIN`?

`JOIN` связывает элементы сильнее, чем запятые, разделяющие элементы в списке `FROM`. Обработка таблиц - слева направо.

---
> Какие есть условия соединения в `JOIN`-ах?

Записываются:

- в `ON <cnd>`
- в `USING (col1, col2, ...)` перечисляются столбцы
- указывается `NATURAL` без доп. деталей; ~ `USING` со списком одноименных в двух таблицах столбцов

---
> Что делает `[INNER] JOIN`?

Внутреннее соединение, выдает лишь те записи, для которых нашлась пара в другой таблице:

- условие соединения указывать обязательно
- эквивалентен `FROM t1, t2 WHERE t1.key = t2.key`

---
> Что делает `LEFT|RIGHT [OUTER] JOIN`?

Возвращают все строки `INNER JOIN` + все строки левой/правой таблицы, которым не нашлось пары, дополненные `NULL`-значениями. Условие соединения указывать обязательно.

---
> В чем отличие `LEFT JOIN` от `RIGHT JOIN`?

`RIGHT JOIN` введен исключительно для удобства записи ("синтаксический сахар"), так как его можно легко свести к `LEFT JOIN`, поменяв левую и правую таблицы местами.

---
> Что делает `FULL [OUTER] JOIN`?

Дополнение `NULL`-значениями строк без пары идет для обеих - и левой и правой - таблиц.

---
> Как можно эмулировать внешнее соединение?

Через скалярный коррелированный подзапрос в `SELECT`.

---
> Что делает `CROSS JOIN`?

Выполняет полное декартово произведение:

- условие соединения указывать не нужно
- эквивалентен `FROM t1, t2 [WHERE TRUE]` или `FROM t1 INNER JOIN t2 ON TRUE`

---
> В чем принципиально различие?
> 
> ```sql
> LEFT JOIN exams ON students.s_id = exams.s_id AND exams.c_no = 'CS305';
> LEFT JOIN exams ON students.s_id = exams.s_id WHERE exams.c_no = 'CS305';
> ```

В `WHERE` стоит операция сравнения, а она не определена при сравнении с `NULL`. Так как `WHERE` выполняется последним, а `LEFT JOIN exams` может привести к появлению `NULL`-значений, проверка в `WHERE` отсечет значения, для которых при соединении не нашлось пары.

То есть первый вариант дает более "широкий" результат, а второй отсекает все `c_no = NULL`.

---
> Что выдаст этот код?
> 
> ```sql
> SELECT t1.*, t2.* FROM
>     (VALUES (1),(2)) AS t1(id)
>   LEFT JOIN
>     (VALUES (1),(3)) AS t2(id)
>   USING(id)
> WHERE t2.id IN (1,3);
> ```

`WHERE` после внешнего `JOIN`-а отсечет `NULL`-значения в правой таблице:

```
 id | id 
----+----
  1 |  1
```

Если это нежелательное поведение (нужно оставить строку `2 | NULL`), нужно вносить условие сравнения под `ON`:

```sql
ON t1.id = t2.id AND t2.id IN (1,3)
```

---
> Что происходит с дубликатами строк в командах `UNION`/`INTERSECT`/`EXCEPT`? При указании `ALL`?

- по умолчанию подразумевается ключевое слово `DISTINCT` - дубликаты удаляются, для каждой их группы остается единственное значение
- при указании `ALL` дубликаты сохраняются, их количество зависит от команды

`ALL` не требует сортировки/поиска дубликатов, и потому работает быстрее. Следует предпочитать его, где возможно.

---
> Что делает `UNION [DISTINCT | ALL]`?

Объединение двух выборок:

```sql
SELECT unnest(ARRAY[1,1,2]) UNION [ALL] SELECT unnest(ARRAY[1,3]);
```

Дубликаты при указании `ALL` сохраняются все:

```
(1, 1, 2) | (1, 3) = (1, 2, 3) -- DISTINCT
(1, 1, 2) | (1, 3) = (1, 1, 1, 2, 3) -- ALL
```

---
> Что делает `INTERSECT [DISTINCT | ALL]`?

Пересечение двух выборок:

```sql
SELECT unnest(ARRAY[1,1,1,2]) INTERSECT [ALL] SELECT unnest(ARRAY[1,1,3]);
```

С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `min(m,n)` раз.

```
(1, 1, 1, 2) & (1, 1, 3) = (1) -- DISTINCT
(1, 1, 1, 2) & (1, 1, 3) = (1, 1) -- ALL
```

---
> Что делает `EXCEPT [DISTINCT | ALL]`?

"Вычитание" правой выборки из левой. Вычисляет набор строк, которые присутствуют в результате левого запроса `SELECT`, но отсутствуют в результате правого:

```sql
SELECT unnest(ARRAY[1,1,2]) EXCEPT ALL SELECT unnest(ARRAY[1,3]);
```

С параметром `ALL` строка, повторяющаяся `m` раз в левой таблице и `n` раз в правой, будет выдана в результирующем наборе `max(m-n,0)` раз.

```
(1, 1, 2) | (1, 3) = (2) -- DISTINCT
(1, 1, 2) | (1, 3) = (1, 2) -- ALL
```

---

# Группировка и агрегатные функции, `[aggr-functions]`

---
> Назовите пять основных агрегатных функций

```sql
count(), min(), max(), sum(), avg()
```

---
> Можно ли использовать агрегатные функции без `GROUP BY`?

Да, вполне. Результат будет вычисляться для всей таблицы:

```sql
SELECT avg(amount) FROM orders;
```

---
> В каких частях `SELECT` можно использовать агрегатные функции?

Не раньше `HAVING`. Так, например, при попытке использовать в `WHERE` будет выброшена ошибка:

```
ERROR:  aggregate functions are not allowed in WHERE
```

---
> Различаются ли результаты вызова этих двух агрегатных функций?
> 
> ```sql
> count(*)
> count(DISTINCT id)
> ```

Да, различаются. Например, запрос

```sql
SELECT count(id), count(DISTINCT id) FROM (VALUES(1),(2),(1),(3)) AS t(id);
```

выдаст

```
 count | count
-------+-------
     4 |     3
```

---

# Оконные функции, `[window-functions]`

- общий синтаксис определения
- синтаксис задания рамки
- оставшиеся оконные функции

---
> Дайте определение *оконной функции*

Такие функции выполняют вычисления для набора строк, некоторым образом связанных с текущей строкой. Они схожи с агрегатными, но не группируют строки в одну, а оставляют их отдельными. Таким образом, оконные функции не изменяют выборку, а только добавляют некоторую дополнительную информацию о ней, новые поля.

---
> Приведите пример оконной функции

```sql
SELECT salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
```

Здесь выводится информация для каждого сотрудника ("все строки остаются отдельными сущностями"). При этом идет вычисление средней по отделу зарплаты функцией `avg()` (схожей с агрегатной; "вычисления для набора строк"), оперирующей над "разделом" - блоком строк, у которых отдел `depname` равен отделу сотрудника (полю `depname` текущей строки; "некоторым образом связанных с текущей строкой").

---
> Когда нужны оконные функции?

- когда агрегатное значение должно присутствовать в каждой записи (сравнения)
- вычисление ранга (?)
- считать скользящие средние и кумулятивные суммы (?)
- отказ от `JOIN`-ов и подзапросов (?)

---
> Когда вычисляются оконные функции?

В самом конце (но до `ORDER BY` основного запроса). Строки, обрабатываемые оконной функцией, представляют собой "виртуальные таблицы", созданные из предложения `FROM` и затем прошедшие через фильтрацию и группировку `WHERE` и `GROUP BY` и, возможно, условие `HAVING`. Например, строка, отфильтрованная из-за нарушения условия `WHERE`, не будет видна для оконных функций.

---
> Где разрешено использовать оконные функции?

Они вычисляются в конце, после `HAVING`. Таким образом, оконные функции разрешается использовать в запросе только в списке `SELECT` и предложении `ORDER BY`. Если нужно отфильтровать или сгруппировать строки после вычисления оконных функций, можно использовать вложенный запрос.

---
> Что такое *раздел* для оконных функций?

Это множество строк, на которых вычисляется оконная функция. Раздел обязан быть задан явно инструкцией

```sql
OVER ()
```

хотя и может быть пустым (это редко встречается на практике).

---
> Что такое *оконный кадр (рамка)* для оконных функций?

Многие оконные функции работают не со всеми строками раздела, а только с частью. Это часть и называется кадром/рамкой; задается явно или неявно.

Если кадр не задан явно, то его размер зависит от того, есть ли в объявлении раздела инструкция `ORDER BY`:

- если нет, то кадр равен всему разделу
- если есть, то кадр включает все строки от начала раздела до значений критерия сортировки, равных текущей строке (включительно)

---
> Какие функции используют оконный кадр?

Все агрегатные функции, используемые в качестве оконных, всегда обрабатывают строки с учетом оконного кадра. Часть оконных функций общего назначения использует рамку, а часть нет.

---
> Как отдельно определить окно (раздел) для оконной функции?

В конце запроса, `WINDOW` + `AS` + `(...)`:

```sql
FROM table_name WINDOW w AS (ORDER BY val)
```

---
> Какие неспециальные функции можно использовать в качестве оконных?

Инструкция `OVER(...)`, идущая после имени агрегатной функции, превращает ее в оконную. Также в качестве оконных можно использовать любые встроенные или пользовательские универсальные или статистические агрегатные функции.

---
> Как агрегатные функции, используемые в качестве оконных, выбирают строки для обработки?

Всегда с учетом оконного кадра. Иногда это может быть нежелательно, и тогда кадр нужно задавать явно на весь раздел.

---
> Что делают оконные функции `row_number()`, `rank()` и `dense_rank()`?

Вычисляют номера и ранги; оконный фрейм для них не важен (всё равно они упорядочивают строки):

```sql
SELECT row_number() OVER w, rank() OVER w, dense_rank() OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Номер строки, ранг с пропусками (номер первой строки в группе), ранг без пропусков:

```
val | row_number | rank | dense_rank
--- | ---------- | ---- | ----------
  1 |          1 |    1 |          1
  1 |          2 |    1 |          1
  2 |          3 |    3 |          2
  2 |          4 |    3 |          2
  3 |          5 |    5 |          3
  3 |          6 |    5 |          3
```

Обе функции рангов могут выполнятся и на окне без сортировки (`OVER ()`), но тогда они всегда возвращают `1`

---
> Что делают функции `first_value(val)`, `last_value(val)` и `nth_value(val, n)`?

Выдают значение из первой, последней и `N`-ной строки:

```sql
SELECT first_value(val) OVER w, last_value(val) OVER w, nth_value(val, 2) OVER w
  FROM table_name
  WINDOW w AS (ORDER BY val);
```

Эти функции учитывают оконный кадр. И если для `first_value()` это не важно (она всегда дает первую строку раздела), то для `last_value()` это дает значение, всегда совпадающее с текущей строкой. Такое (не полезное) поведение может быть нежелательно и для `nth_value()`. В обоих случаях можно явно переопределить рамку.

```
val | first_value | last_value | nth_value
--- | ----------- | -----------| ---------
  1 |           1 |          1 |
  1 |           1 |          1 |
  2 |           1 |          2 |         2
  2 |           1 |          2 |         2
  3 |           1 |          3 |         2
  3 |           1 |          3 |         2
```

---

# DML-команды изменения данных, `[ins-upd-del]`

- `RETURNING` для всех команд
- три способа копирования таблиц

---
> Какой общий синтаксис у `INSERT`?

```sql
INSERT INTO <table-name> [(<column-names>)] VALUES (<values>);
INSERT INTO students (s_id, name, start_year) VALUES (1451,'Анна', 2014);
```

---
> Какой общий синтаксис у `UPDATE` и `DELETE`?

```sql
UPDATE courses SET hours = hours * 2 [WHERE c_no = 'CS301'];
DELETE FROM exams                    [WHERE score < 5];
```

---
> Можно ли не перечислять имена столбцов таблицы в `INSERT`?

Да, но тогда значения в `VALUES()` должны идти в том же порядке, в каком столбцы объявлены при создании таблицы:

```sql
INSERT INTO test VALUES (1,2,3);
```

---
> Как можно вставить сразу несколько строк в таблицу?

В `INSERT ... VALUES()` перечислить сразу несколько кортежей:

```sql
INSERT INTO test VALUES (1,2,3), (5,6,7);
```

---
> Что выводят команды `INSERT`/`UPDATE`/`DELETE`?

Если не указан `RETURNING`, то количество обработанных строк:

```
INSERT 0 3
UPDATE 3
DELETE 3
```

Первое число в `INSERT` - системное поле `oid` - здесь не рассматривается.

---
> Как лимитировать строки в операциях `UPDATE`/`DELETE`?

Стандартно, через `WHERE`:

```sql
UPDATE test SET id = 1 WHERE id > 2;
DELETE FROM test WHERE id < 3;
```

---
> Как вставить JSON в поле таблицы?

- поле должно быть объявлено с типом `json[b]`
- данные вставляются стандартно, через `INSERT`, как строка (в одинарных кавычках) валидного JSON-а

---
> Можно ли в `UPDATE` обновлять поля через составные арифметические операторы?

Таких операторов в Postgres нет, так что только полными:

```sql
SET range = range * 2
```

---
> Что произойдет, если в команде удаления с условием
> 
> ```sql
> DELETE ... WHERE ...
> ```
> 
> последнее не совпадет ни с одной строкой?

Команда отработает штатно, это не ошибка. Просто выведет `DELETE 0`.

---
> Как удалить все строки из таблицы?

Два варианта:

- вызвать `DELETE` без `WHERE`
- использовать `TRUNCATE`

```sql
DELETE FROM aircrafts;
TRUNCATE aircrafts;
```

`TRUNCATE` работает немного быстрее.

---
> Что выведет эта команда?
> 
> ```sql
> INSERT INTO test_numeric SET num_1 = 101;
> ```

Синтаксическую ошибку:

```
ERROR:  syntax error at or near "SET"
```

Это только у `UPDATE` есть синтаксис через `SET`, не у `INSERT`.

---

# Представления, `[views]`

---

# Текстовый поиск, `[text-search]`

---

# Общее понятие транзакции, ACID, `[transact-common]`

- точки восстановления, их синтаксис

---
> Что такое *транзакция*?

Это группа последовательных операций с БД, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, либо не выполнена вообще. В простейшем случае транзакция состоит из одной операции.

Примером транзакции могут служить каскадные операции (напр., удаление), хотя атомарность их выполнения и так берет на себя СУБД.

---
> Что означает *ACID*?

Это акроним, объединяющий четыре свойства-требования к транзакционной системе (например, к СУБД), обеспечивающих наиболее надёжную и предсказуемую её (СУБД) работу:

- Atomicity - Атомарность
- Consistency - Согласованность
- Isolation - Изолированность
- Durability - Стойкость

---
> Что означает *A* в ACID?

Atomicity - Атомарность. Операция либо выполняется целиком, либо не выполняется вовсе; операция не может быть частично выполнена или частично не выполнена

Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие "отката" (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во "внешне исходное" состояние - со стороны будет казаться, что транзакции и не было

---
> Что означает *C* в ACID?

Consistency - Согласованность. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных (?)

Свойство охватывает как физические ограничения ссылочной целостности, так и бизнес-логику. Пример - согласованность в списании/зачислении денег на счет

---
> Что означает *I* в ACID?

Isolation - Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность - требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию

---
> Что означает *D* в ACID?

Durability - Стойкость/Долговечность. После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев в работе системы

---
> Какими командами начать и завершить/откатить транзакцию?

```sql
START TRANSACTION [ ISOLATION LEVEL <level> ];
COMMIT;
```

или через `BEGIN` - расширение Postgres:

```sql
BEGIN [ ISOLATION LEVEL <level> ];
ROLLBACK;
```

---
> Какие уровни изоляции можно указывать после `BEGIN`?

```sql
SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED
```

---

# Феномены и уровни изоляции транзакций в Postgres, блокировки, `[transact]`

---

# DCL-команды, `[dcl]`

---
> Назовите две основные DCL-команды

Это `GRANT` и `REVOKE`:

```sql
GRANT SELECT, INSERT ON orders TO localhost;
REVOKE ALL [PRIVILEGES] ON test FROM PUBLIC;
```

---
> В чем основное отличие синтаксиса команд `GRANT` и `REVOKE`?

В ключевых словах `TO` (для `GRANT`) и `FROM` (для `REVOKE`).

---

# Индексы и производительность, `[indexes]`

---
> Какой тип индекса по умолчанию генерируется для ключей?

B-дерево, для `UNIQUE`/`PRIMARY KEY`:

```
"aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
```

Имена индексов, если не заданы, генерируются автоматически.

---
> Какой формат имен у автоматически генерируемых первичных ключей?

К имени таблицы дописывается фиксированный суффикс:

```
<table-name>_pkey
```

Например, для таблицы `seats`

```
"seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
```

---
> Какой формат имен у автоматически генерируемых индексов для уникальных полей?

Имя таблицы + имена столбцов через подчеркивание + фиксированный суффикс `_key`. Например:

```
"boarding_passes_flight_id_seat_no_key"
  UNIQUE CONSTRAINT, btree (flight_id, seat_no)
```

---
> Какой формат имен у генерируемых вручную индексов?

Имя таблицы + имена столбцов через подчеркивание + фиксированный суффикс `_idx`. Например:

```
"airports_airport_name_idx" btree (airport_name)
```
