- <https://postgrespro.ru/docs/postgresql/12/index>
- <https://www.postgresql.org/docs/13/index.html>
- <https://www.postgresql.org/docs/13/source.html>
- <https://www.sqlstyle.guide/ru/>
- <https://planet.postgresql.org>
- <https://wiki.postgresql.org/wiki/Main_Page>

#### Лузанов П. и др., Postgres: первое знакомство
<https://postgrespro.ru/education/books/introbook>

#### Моргунов Е., PostgreSQL. Основы языка SQL
<https://postgrespro.ru/education/books/sqlprimer>

---
> Сохраняется ли порядок добавления строк в таблицу?

Нет, строки неупорядочены, хранятся не обязательно в порядке добавления

---
> Как называются целый, логический и строковый типы?

`integer`, `boolean` (`true`/`false`) и `text` соответственно

---
> Какой литерал у *неопределенного* значения?

```sql
NULL
```

---
> Какой синтаксис у описания столбца в `CREATE TABLE`?

`<name> <type>[ <PRIMARY KEY>]`:

```sql
CREATE TABLE courses(
    c_no text PRIMARY KEY,
    title text,
    hours integer
);
```

---
> Какие ограничения для данных в столбце `PRIMARY KEY`?

- значения должны быть уникальны
- неопределенные (`NULL`) значения не допускаются

---
> Какой командой лучше массово загружать данные в таблицы?

`COPY`, не `INSERT`

---
> Какой общий синтаксис у `INSERT`?

Перечисление имен столбцов не обязательно, но тогда нужно передавать значения в том порядке, в котором они следуют в определении таблицы:

```sql
INSERT INTO <table-name> [(<column-names>)] VALUES (<values>);
INSERT INTO students (s_id, name, start_year) VALUES (1451,'Анна', 2014);
```

---
> Что по умолчанию выводит `INSERT`?

Цифры - это `oid` (всегда `0`) + количество вставленных строк:

```
INSERT 0 3
```

Когда-то поддерживалось `WITH OID` при создании таблиц, и первое число могло быть не нулем, но больше это не доступно

Если `INSERT` содержит инструкцию `RETURNING`, то вывод будет таким, как указано в ней

---
> Как в `CREATE TABLE` задать первичный ключ из нескольких столбцов?

После описания всех столбцов, используя ключевое слово `PRIMARY KEY`:

```sql
  ...
  score integer,
  [CONSTRAINT pk ]PRIMARY KEY(s_id, c_no)
);
```

---
> Какой синтаксис у объявления внешнего ключа вместе со столбцом?

Через ключевое слово `REFERENCES` и ссылку вида `<table-name>(<column>)`:

```sql
CREATE TABLE exams(
  s_id integer REFERENCES students(s_id),
  ...
```

---
> Как именуются столбцы в выводе `SELECT`-а?

- используется алиас (`AS <alias>`)
- если `AS` не указан - то имя самого столбца
- `?column?` - если имя неопределено (напр., `SELECT 1` или столбец вычисляемый)

---
> К какой части `SELECT` относится `DISTINCT`?

К ключевому слову, т.е. ко всей выборке, а не к отдельному столбцу:

```sql
SELECT DISTINCT name, start_year FROM students;
-- SELECT name, DISTINCT start_year FROM students; /* syntax error */
```

---
> Какие комментарии есть в PostgreSQL?

Два дефиса и стандартный блочный:

```sql
-- Single-line comment
/*
 Multi-line comment
*/
```

---
> Сколько строк будет содержать результат `SELECT` без `FROM`?

Одну:

```sql
SELECT 2+2 AS result;
```

```
 result
--------
      4
```

---
> При каких результатах сравнения в `FROM` строка попадет в результат `SELECT`-а?

Если сравнение истинно. Не попадет, если сравнение ложно или *не определено* (напр, сравнение с `NULL`)

---
> В каких случаях результат операции не *определен*?

Все связаны с неопределенным значением `NULL`:

- результат сравнения чего угодно с `NULL` не определен
- результат логическиз операций с `NULL`, как правило, не определен


Как правило, это важно во `FROM` - строки, для которых результат сравнения не определен, в результат `SELECT`-а не попадают

---
> В каких случая логические операции с `NULL` всё же возвращают определенные значения?

Их два:

```sql
true OR NULL = true
false AND NULL = false
```

---
> Какой синтаксис у операторов "равно" и "не равно"?

Одинарное равно и две формы для "не равно":

```sql
-- equals
=
-- not equals
<>
!=
```

---
> Какими способами можно получить прямое (декартово) произведение таблиц?

С точки зрения СУБД обе формы эквивалентны:

```sql
FROM t1, t2 WHERE t1.id = t2.id
FROM t1 JOIN t2 ON t1.id = t2.id
```

Выборку без ограничивающего условия можно получить только первым способом

---
> Почему `LEFT JOIN` называется "левый"?

В выборку добавляются строки из левой таблицы даже такие, для которых не нашлось пары в правой

---
> На каком этапе выполняется `WHERE` в запросах с `JOIN`-ами? Какие подводные?

Условие в `WHERE` выполняется *после* `JOIN`-а, применяется к уже готовому соединению. Поэтому, для `LEFT JOIN` возможна ситуация когда столбцы правой таблицы окажутся равными `NULL`, и сравнение с ними в `WHERE` не сработает

---
> В каких частях запроса можно использовать подзапросы (вложенный `SELECT`)?

Зависит от того, сколько строк такой подзапрос возвращает:

- если одну или меньше, то такой подзапрос называется *скалярным*, и его можно использовать как единственное значение, в том числе в списке столбцов для выборки или в условиях `WHERE`
- если больше одной строки, то в качестве источника ("таблицы") в `FROM`/`JOIN`, или также в `WHERE`, но только с операторами принадлежности существования, вроде `[NOT] IN`/`[NOT] EXISTS`

---
> Какое значение используется в качестве результата скалярного подзапроса, не возвращающего ни одной строки?

Неопределенное, `NULL`:

```sql
SELECT c1, (SELECT ...) as c2 FROM ...;
```

```
  c1  | c2
------+----
 some |
```

---
> Как можно преобразовать скалярный подзапрос, используемый в качестве значения в столбце?

В `LEFT JOIN`

Соединение должно быть именно внешнее: скалярный подзапрос в списке столбцов `SELECT`-а возвращает `NULL`, если для него не найдено ни одной строки; для `INNER JOIN` же возврат неопределнного значения невозможен

---
> Можно ли в подзапросе ссылаться на таблицу из внешнего `SELECT`-а?

Да, вполне:

```sql
SELECT name, (
  SELECT score FROM exams WHERE exams.s_id = students.s_id
) FROM students;
```

---
> Как указываются алиасы имен столбцов/таблиц?

`AS` при этом не обязательно:

```sql
SELECT name AS n FROM students AS s;
SELECT name n FROM students s;
```

---
> Где в `ORDER BY` указывается `ASC`/`DESC`?

После каждого ключа, не одно на всё выражение:

```sql
SELECT * FROM students ORDER BY name ASC, start_year DESC;
```

---
> Каков по умолчанию порядок сортировки в `ORDER BY`?

```sql
ASC
```

---
> Где в составных запросах имеет смысл располагать `ORDER BY`?

Только в конце основного запроса, перед получением результата. В подзапросах она обычно бесполезна

---
> Что делает `GROUP BY`?

Разбивает результат выборки на группы, на основе указанного в `GROUP BY` поля/выражения

---
> Какие агрегатные функции дают количество записей и среднее значение?


```sql
count(<field>|*)
avg(<field>)
```

---
> В каком порядке применяются условия фильтрации `WHERE` и `HAVING` в запросах с группировкой?

- сначала, до группировки, применяется `WHERE` - там можно использовать только столбцы исходных таблиц
- группировка `GROUP BY`
- потом, после группировки, применяется `HAVING` - там уже можно использовать столбцы таблицы-результата

---
> В каких условиях фильтрации можно использовать агрегатные функции?

Только в `HAVING`, в `WHERE` выдаст ошибку

```
aggregate functions are not allowed in WHERE
```

---
> Какой общий синтаксис у `UPDATE` и `DELETE`?

```sql
UPDATE courses SET hours = hours * 2 WHERE c_no = 'CS301';
DELETE FROM exams                    WHERE score < 5;
```

Обе команды выводят количество измененных/удаленных записей:

```
UPDATE 1
DELETE 1
```

---
> Как запретить неопределенные значения в столбце?

При создании таблицы, после типа столбца, указать `NOT NULL`:

```sql
CREATE TABLE groups(
  monitor integer NOT NULL
);
```

---
> Как добавить поле в таблицу?

Спецификация столбца такая же, как при создании таблицы:

```sql
ALTER TABLE students ADD g_no text REFERENCES groups(g_no);
```

---
> Что такое *транзакция*?

Логически неделимая единица работы

Например, транзакции могут быть использованы для обновления логически связанных таблиц, чтобы между последовательностью операций обновления не терялась целостность данных

---
> Как вставить в таблицу данные из результатов выборки (из другой таблицы)?

Вместо `VALUES` напрямую указать `SELECT`:

```sql
INSERT INTO groups(g_no, monitor)
SELECT'A-101', s_id FROM students WHERE name ='Анна';
```

---
> Какие команды начинают, завершают или откатывают транзакцию?

```sql
BEGIN
...
COMMIT
ROLLBACK
```

---
> Какие есть свойства у транзакций?

- *атомарность* - между командами `BEGIN` и `COMMIT` выполняются либо все команды, либо ни одной
- *согласованность* - данные в конце транзакции должны удовлетворять всем ограничениям (могут ли не удовлетворять внутри транзакции?)
- *изоляция* - параллельные процессы не видят изменений до окончания транзакции, им недоступны еще не согласованные данные. Доступ до базы при этом во время транзакции не блокируется
- *долговечность* - зафиксированные данные не пропадут даже в случае сбоя


---
> Один клиентский процесс `psql` начал (но еще не завершил) транзакцию, и записал несколько строк в таблицу. Что выдаст `SELECT` на этой таблице для текущего и параллельного процессов?

- выборка в текущем процессе (с открытой транзакцией, после `BEGIN`) выдаст все вставленные строки
- выборка в параллельном процессе даст пустой результат: до завершения транзакции первым процессом (до `COMMIT` в первом процессе) результаты этой транзакции никому не доступны

---
> Различаются ли результаты вызова этих двух агрегатных функций?
> 
> ```sql
> count(*)
> count(DISTINCT id)
> ```

Да, различаются. Например, на таблице вида

```
  id
------
 1451
 1556
 1451
 1432
```

запрос

```sql
SELECT count(*), count(DISTINCT s_id) FROM ...;
```

выдаст

```
 count | count
-------+-------
     4 |     3
```

---
> В чем принципиально различие?
> 
> ```sql
> LEFT JOIN exams ON students.s_id = exams.s_id AND exams.c_no = 'CS305';
> LEFT JOIN exams ON students.s_id = exams.s_id WHERE exams.c_no = 'CS305';
> ```

В `WHERE` стоит операция сравнения, а она не определена при сравнении с `NULL`. Так как `WHERE` выполняется последним, а `LEFT JOIN exams` может привести к появлению `NULL`-значений, проверка в `WHERE` отсечет значения, для которых при соединении не нашлось пары

То есть первый вариант дает более "широкий" результат, а второй отсекает все `c_no = NULL`

---
> Как можно получить текущие дату и время?

Функция `now()`:

```sql
SELECT now();
```

```
              now
-------------------------------
 2020-06-14 06:16:56.282864+04
```

---
> Как называется Python-модуль для соединения с Postgres-ом?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
psycopg2
```

Версия 2 поддерживает массовую многопоточность и асинхронность

---
> Как через `python3-psycopg2` работать с базой?

Пять шагов:

```python
# 1. Подключение
conn = psycopg2.connect(
    database='appdb',
    user='app',
    ...
)
# 2. Получение курсора
cur = conn.cursor()
# 3. Выполнение запроса
cur.execute('SELECT * FROM greeting')
# 4. Получение списка кортежей записей
for row in cur[.fetchall()]:
    print row[0]
# 5. Закрытие соединения
conn.close()
```

---
> Какие есть 4 оператора полнотекстового поиска?

```sql
-- Из SQL-стандарта
LIKE -- он же @@
-- Специфичные для PostrgeSQL
ILIKE -- LIKE, не чувствительный к регистру
~
~*
```

---
> Как вставить JSON в поле таблицы?

- поле должно быть объявлено с типом `json`
- данные вставляются стандартно, через `INSERT`, как строка (в одинарных кавычках) валидного JSON-а

---
> Как обратиться к ключу верхнего уровня в поле с типом `json`?

Через оператор `->>`:

```sql
WHERE s.s_id = sd.s_id
AND sd.details ->> 'достоинства' IS NOT NULL
AND sd.details ->> 'достоинства' != 'отсутствуют'
```

---
> Как обратиться к ключу произвольного уровня в поле с типом `json`?

Через оператор `#>`, указав в фигурных сковках последовательность ключей или индексов:

```sql
'{"a": {"b": ["foo","bar"]}}'::json #> '{a,b,1}' -- "bar"
```

---
> В чем отличия `jsonb` от `json`?

Это бинарный формат хранения:

- данные в нем хранятся плотно упакованными (экономится место) и поиск по нему работает быстрее
- для преобразования в него нужно вызывать функцию `to_jsonb('...')`
- он не сохраняет порядок ключей в JSON
- для него другой набор операторов

---
> Как в `jsonb` проверить, что первое значение содержит второе?

Оператор `@>` работает и на вложенных объектах:

```sql
'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb -- t
'{"a":{"b":{c:1}}'::jsonb @>'{"a":{"b":{}}}'::jsonb -- t
```

---
> Как отформатировать вывод столбца типа `jsonb`?

Функция `jsonb_pretty()`:

```sql
SELECT s.name, jsonb_pretty(sd.details_b) FROM ...;
```

---
> Что делает функция `jsonb_each()`?

Разворачивает JSON-объект верхнего уровня в последовательность пар "ключ-значение"

---
> Что такое SQL/MED? Как реализуется в Postgres?

Это стандарт ISO/IEC9075-9 (Management of External Data) по работе в SQL с внешними источниками информации - как правило, другими СУБД (напр., MySQL)

Реализуется через специальные обертки. Создаются таблицы (foreign table), которые сами не содержат данных, а перенаправляют все обращения к внешнему источнику. Используются команды

```sql
CREATE FOREIGN DATA WRAPPER
CREATE SERVER
CREATE USER MAPPING
CREATE FOREIGN TABLE
IMPORT FOREIGN SCHEMA
```

---
> Как просмотреть список всех доступных расширений?

Он находится в таблице `pg_available_extensions`:

```sql
SELECT * FROM pg_available_extensions;
```

---
> Как установить расширение?

Например, для создания foreign table и связи с MySQL или другим экземпляром себя же:

```sql
CREATE EXTENSION mysql_fdw;
CREATE EXTENSION postgres_fdw;
```

Второе расширение и создаваемые на его основе внешние таблицы являются встроенным в PostgreSQL механизмом *шардинга*

---
> Как изменить значение конфигурационного параметра?

Отредактировать файл `/etc/postgresql/12/main/postgresql.conf` и перезагрузить настройки - например, выполнить от пользователя `postgres`

```sql
SELECT pg_reload_conf();
```

---
> Как узнать значение конфигурационного параметра?

Командой `SHOW`:

```sql
SHOW shared_buffers;
```

```
 shared_buffers
----------------
 128MB
```

---
> Как создать базу из дампа?

Перенаправить вывод, список SQL-команд на вход клиента, `psql`. Или воспользоваться его же опцей `-f`:

```shell
$ cat dump.sql | psql
$ psql < dump.sql
$ psql [-d <db-name>] -f dump.sql
```

При этом `sudo -u <user> psql` будет определять, от имени какого юзера выполняется заливка дампа, а `psql -U <user>` скажет, какому станет принадлежать создаваемая база

---
> Как создать нового пользователя?

От имени суперпользователя (`postgres`):

```sql
CREATE USER <user> PASSWORD '...';
```

---
> Как создать базу данных для другого пользователя?

С ключевым словом `OWNER`:

```sql
CREATE DATABASE <db-name> OWNER <user>;
```

Обычно выполняется от суперпользователя (`postgres`), чтобы хватило прав

---
> Какая библиотека является системным драйвером PostgreSQL?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
libpq
```

Написана на C

---
> Как заставить сервер перечитать настройки конфигурационных файлов?

```sql
SELECT pg_reload_conf();
```

Или из командной строки

```shell
$ sudo service postgresql reload|restart
```

---
> Что значит метод аутентификации `md5`?

В отличие от `peer`/`trust`, это уже требование на ввод пароля пользователем вручную

---
> Что значит метод аутентификации `peer`?

Что PostgreSQL запрашивает имя текущего пользователя у операционной системы и считает, что ОС уже выполнила необходимую проверку (спросила у пользователя пароль

Поэтому пользователю обычно не приходится вводить пароль при подключении к серверу на своем компьютере: достаточно того, что пароль был введен при входе в систему

---
> Какой формат у конфигурационного файла `pg_hba.conf`?

Строки разбиты на пять столбцов:

```
# TYPE  DATABASE  USER  ADDRESS  METHOD
local   all       all            peer
```

Строка из примера выше читается как "локальные соединения (`local`) к любой базе (`all`) под любым пользователем (`all`) должны проверяться методом `peer`". IP-адрес для локальных соединений не указывается

---
> Как называются два основных файла настроек?

```
postgresql.conf
pg_hba.conf
```

Оба хранятся в папке `/etc/postgresql/12/main/` (версия, естественно, может меняться)

---
> Какой формат по дефолту имеет строка приглашения в интерактивном терминале?

Имя текущей базы + `=` + решетка для суперпользователя или символ "больше" для обычного:

```
postgres=#
localhost=>
```

---
> Какой порт использует PostgreSQL по дефолту?

```
5432
```

Только на моей Ubuntu он почему-то `5433`

---
> Как в интерактивном терминале подключиться к базе от имени другого пользователя?

Так же, но после имени базы указать имя пользователя:

```
# \c <db-name> <user>
```

В конце можно также указать имя хоста и порт

---
> Как переподключиться к текущей базе?

Та же команда, но без аргумента:

```
# \c
```
Это бывает нужно для того, чтобы настройки применились после изменений

---
> Как создать полную "двоичную" резервную копию кластера СУБД?

Сохранит в каталоге `<backup>`:

```shell
$ pg_basebackup -D <backup>
```

---
> Какая команда создает дамп базы?

Вторая команда сохраняет все базы, а также пользователей и табличные пространства:

```shell
$ pg_dump <db-name>|$PGDATABASE [> dump.sql]
$ pg_dumpall [-f/--file=...]
```

Выводит в `stdout` SQL-команды. Если переменная среды `PGDATABASE` не задана, дампит дефолтную базу (совпадающую с именем текущего пользователя)

---
> Как выйти из интерактивного терминала?

```
# \q
```

---
> Как в интерактивном терминале включить/выключить отображение времени выполнения команд?

После этого самой нижней строкой будет отображаться `Time: N ms`:

```
# \timing [on|off]
```

По умолчанию выключено. Без опции переключает между значениями

---
> Как в интерактивном терминале сменить режим отображения на расширенный (построчный)?

По умолчанию такой режим отключен (`off`):

```
# \x [on|off|auto]
```

Без опций переключает между `on`/`off`. Опция `auto` выводит результаты по строкам только когда они не влезают в экран

---
> Чувствительна ли Postgres к регистру?

Backslash-команды да, а SQL-запросы нет, и это касается не только ключевых слов, но и имен таблиц/столбцов/etc.

---
> Как в текущей базе вывести список всех таблиц?

```
# \d[S+]
```

С невыбранной базой будет ошибка `Did not find any relations.`

---
> Как вывести описание таблицы?

```
# \d[S+] <table-name>
```

Выводит столбцы построчно:

```
test=# \d students
 s_id       | integer |           | not null |
 name       | text    |           |          |
 start_year | integer |           |          |
```

Вообще, `# \d <name>` отображает информацию для любого объекта СУБД

---
> Как отображает неопределенное значение в интерактивном терминале?

Никак, `NULL` в результатах выборок не отображается, вместо него пустая строка:

```sql
SELECT NULL;
```

```
 ?column?
----------

(1 row)
```

---
> Какой короткий вариант у опции командной строки `--help`?

Знак вопроса:

```shell
-?
```

Стоит помнить, что стандартное `-h` относится к другой опции - `--host=`

Кроме того, с короткой опцией нельзя получить справку по backslash-командам и переменным, они доступны лишь с длинным именем опции:

```shell
--help=commands
--help=variables
```

---
> Как из командной строки выполнить инструкции из `.sql`-файла?

Опция `-f|--file=`:

```shell
$ psql -f dump.sql
```

---
> Как изменяется приглашение интерактивного терминала в строках продолжения?

Добавляется открывающая скобка перед символом решетки:

```
test=# CREATE TABLE courses(
test(#
```

---
> Как и от какого пользователя запускается консольный клиент?

От пользователя `postgres`:

```shell
$ sudo -u postgres psql
```

Произойдет переход в интерактивный режим СУБД с дефолтным prompt-ом `postgres=#`

---
> Как вывести список всех баз данных?

Команда `# \l`

---
> Как в информационных backslash-командах вывести дополнительную информацию?

Указать после команды `S` (системные объекты; опция есть для примерно половины команд) и/или `+` (доп. детали; опция есть почти для всех):

```
# \l+
# \dnS
```

---
> Как получить справку по backslash-командам?

Из командной строки:

```shell
$ psql --help=commands
```

или в интерактивном терминале (дефолтный режим справки):

```
# \?
```

Второй не стоит путать с `\h` - тот выводит справку по SQL-командам

---
> Какой пейджер используется в интерактивном терминале?

Системный, `more` или `less`

---
> Как в интерактивном терминале переключиться на определенную базу данных?

Команда `\c`:

```
# \c[onnect] <db>[ <additional-info>]
```

Строка приглашения после этого поменяется с дефолтного `postgres=#` на `<db-name>=#`

---
> Как получить справку по опциям командной строки?

Из командной строки (дефолтный режим справки):

```shell
$ psql --help
$ psql --help=options
```

или в интерактивном терминале:

```
# \? options
```

---
> Как в интерактивном терминале получить справку по SQL-команде?

Без имени команды перечислит все, для которых доступна справка:

```
# \h[elp] <command>
# \help CREATE TABLE
# \h
```

Не стоит путать с `\?` - тот выводит справку по backslash-командам

---
> Перечислите основные термины (сущности), относящиеся к реляционным БД

- *таблица* состоит из набора *строк* или *записей*
- строка делится на *поля*, *столбцы* или *колонки*

Таким образом, таблицы состоят из строк и столбцов, на пересечении которых должны находиться "атомарные" значения, которые нельзя разбить на более мелкие элементы без потери смысла

---
> Перечислите основные термины формальной теории реляционных БД

- таблицы называются математическим термином *отношениями* (relations; отсюда и название *реляционная БД*)
- строки таблицы называются *кортежами* (tuples), а колонки - *атрибутами*
- таким образом, отношение имеет *заголовок*, состоящий из атрибутов, и *тело*, состоящее из кортежей
- количество атрибутов (столбцов) называется *степенью отношения*, а количество кортежей (строк) - его *кардинальным числом*

---
> Какое неявное ограничение накладывается на данные в столбце?

*Тип* столбца ограничивает спектр его (столбца) возможных значений

---
> Что такое *потенциальный ключ*?

Комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней. Если ключ состоит из более чем одного атрибута, он называется *составным*

Важным является то, что потенциальный ключ должен быть неизбыточным, т.е. никакое подмножество атрибутов, входящих в него, не должно обладать свойством уникальности

---
> Что такое *первичный ключ*?

Один (или единственный) из потенциальных ключей, выбранный по какому-либо критерию. Первичный ключ не может содержать значение `NULL`

Остальные потенциальные называются *альтернативными ключами*

---
> Что такое *внешний ключ*?

Набор атрибутов таблицы, соответствующий потенциальному ключу в другой таблице. Таблица, в которой содержится внешний ключ, называется *ссылающейся* (referencing table), а содержащая соответствующий потенциальный ключ - *ссылочной (целевой)* (referenced table)

Таким образом, сам внешний ключ не обязан быть уникальным набором атрибутов, он может повторятся. Он лишь обязан ссылаться на уникальный набор (потенциальный ключ). Пример - таблица с оценками за экзамены. ID студентов в ней повторяются, при этом являясь полем - внешним ключом в целевую таблицу студентов, в которой уже этот ID уникален

---
> Что такое *ссылочная целостность*?

Проблема обеспечения того, чтобы база данных не содержала неверных значений внешних ключей

Ограничение, согласно которому значения внешних ключей должны соответствовать значениям потенциальных ключей, называется *ограничением ссылочной целостности (ссылочным ограничением)*. Это берет на себя СУБД

---
> Что такое *каскадное удаление (обновление)*?

Автоматическое удаление/обновление (неуникальных) записей во всех ссылающихся через внешние ключи таблицах, при изменении записи в ссылочной (целевой) таблице - той, где данные уникальны, являются ключом

Вместо удаления записей, в ссылающихся таблицах возможна замена поля внешнего ключа на `NULL`

---
> Что такое *транзакция*?

Набор операций над базой данных, рассматриваемых как единая и неделимая единица работы, выполняемая полностью или не выполняемая вовсе, если произошел какой-то сбой в процессе выполнения транзакции

Таким образом, транзакции являются средством обеспечения согласованности данных

---
> Что такое язык SQL?

Это непроцедурный (декларативный) язык, который является стандартным средством работы с данными во всех реляционных СУБД. Операторы (команды), написанные на этом языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают процедуру получения этого результата. СУБД сама определяет способ выполнения команды пользователя

---
> На какие группы деляться операторы языка SQL?

- *DDL* (Data Definition Language) - определение данных: создание, изменение и удаление таблиц, представлений и других объектов БД
- *DML* (Data Manipulation Language) - манипулирование данными: выборка, вставка, обновление и удаление строк таблиц
- *DCL* (Data Control Language) - видимо, управление пользователями/ролями

---
> Какие типы данных могут задавать текстовые строки?

- `char[acter][(N)]` - строки фиксированной длины, дополняются пробелами если символов меньше. Если скобки с `N` опущены, то длина = 1
- `varchar(N)` / `character varying(N)` - строки переменной, ограниченной сверху, длины
- `text` - строки произвольной длины (ограничение есть (задается при компиляции), но оно очень велико)

---
> Как называется основной целочисленный тип?

```sql
int[eger]
```

Есть еще типы `smallint`, `bigint`

---
> Какой формат у объявления столбца?

```
<name> <type> [<constrains>]
```

```sql
aircraft_code char(3) NOT NULL
```

Объявления ограничений и ключей могут быть расположены после объявлений самих полей:

```sql
range integer NOT NULL,
CHECK (range > 0),
PRIMARY KEY (aircraft_code)
```

---
> Что говорит значение `NULL` в поле?

= "Значение не задано, данные отсутствуют"

---
> Как делятся ключи по критерию выбора?

На *естественные* и *суррогатные*. Первые находят естественное отражение в предметной области. Например, это код лайнера в таблице типов самолетов

---
> Какие приняты стилистические соглашения по регистру в инструкциях SQL? Почему?

Так их выводит `pg_dump`:

- ключевые слова (`CREATE`, `SELECT`) пишутся в верхнем регистре
- типы столбцов (`int`, `char`) пишутся в нижнем

---
> Как в интерактивном терминале вызвать внешний редактор?

Backslash-команда `# \e`

---
> Как посмотреть индекс и их типы у таблицы?

Стандартной командой `# \d <table-name>`. Под схемой столбцов будут показаны и индексы

---
> Какой тип индекс по умолчанию генерируется для первичных ключей?

B-дерево:

```sql
"aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
```

Имена индексов, если не заданы, генерируются автоматически

---
> Какая схема используется по умолчанию для создания таблиц и прочих объектов?

`public`

---
> Как записываются строковые литералы?

В одинарных кавычках, двойные используются для создания таблиц/столбцов с пробельными символами (и не только) в именах

Две строки, разделенные `\n`, будут слиты в одну, без пробела. Именно символ новой строки, два литерала через пробел дадут синтаксическую ошибку

---
> Что делает backslash-команда `# \s`?

Выводит на экран историю команд

Если указать после нее имя файла - `# \s <file-name>` - то история сохранится в него

---
> Как задать ограничение на значение столбца в общей форме?

Использовать ключевое слово `CHECK`. Можно задать имя ограничению, но обычно пишут без этого, и имя генерируется:

```sql
price numeric CHECK (price > 0)
price numeric CONSTRAINT positive_price CHECK (price > 0)
```

---
> Как задать автоматическое удаление записей при удалении внешнего ключа?

Указать это в *ссылающейся* (там, где поле неуникально) таблице:

```sql
FOREIGN KEY (aircraft_code)
  REFERENCES aircrafts (aircraft_code)
  ON DELETE CASCADE
```

---
> Как ограничить допустимые значения поля некоторым списком (перечислением)?

Указать этот список в `IN` внутри `CHECK`:

```sql
fare_conditions varchar(10) NOT NULL,
CHECK (
  fare_conditions IN ('Economy', 'Comfort', 'Business')
)
```

В полной форма (полученной через `# \d <table-name>`) это ограничение будет выглядеть сложнее:

```sql
CHECK (fare_conditions::text = ANY (ARRAY[
  'Economy'::character varying::text,
  'Comfort'::character varying::text,
  'Business'::character varying::text
]))
```

---
> Как в ссылающуюся таблицу вставить запись с внешним ключом, не существующим в основной таблице?

Никак, СУБД запретит это, выдаст ошибку. Например:

```sql
INSERT INTO seats VALUES ('123', '1A', 'Business');
```

```
ERROR:  insert or update on table "seats" violates foreign key ...
DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts_data"
```

---
> Как одним запросом посчитать количество строк с каждым значением одного поля?

Выборка с группировкой по этому полю, само поле + `count()` в результатах. Сортировка опциональна:

```sql
SELECT aircraft_code, count(*) FROM seats GROUP BY aircraft_code[ ORDER BY count];
```

```
 aircraft_code | count
---------------+-------
 CN1           |    12
 CR2           |    50
 SU9           |    97
 319           |   116
 ...
```

Добавляя новое поле в каждый из операторов `SELECT`, `GROUP BY` и `ORDER BY`, получим группировку уже по двум полям

---
> Что произойдет при попытке вставить запись с уже имеющимся первичным ключом?

```sql
INSERT INTO aircrafts_data VALUES ('SU9', '{"en":"Sukhoi SuperJet-100"}', 3000);
```

Выдаст ошибку

```
ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
DETAIL:  Key (aircraft_code)=(SU9) already exists
```

---
> Можно ли в `UPDATE` обновлять поля через составные арифметические операторы?

Таких операторов в Postgres нет, так что только полными:

```sql
SET range = range * 2
```

---
> Что произойдет, если в команде удаления с условием `DELETE ... WHERE ...` последнее не совпадет ни с одной строкой?

Команда отработает штатно, это не ошибка. Просто выведет `DELETE 0`

---
> Какие псевдонимы у целочисленных типов?

Цифра в названии отражает количество байт, занимаемых полем такого типа:

- `int2` ~ `smallint`
- `int4` ~ `int[eger]`
- `int8` ~ `bigint`

---
> На что обращать внимание при выборе целочисленного типа для поля?

На диапазона допустимых значений и затраты памяти на поле

Часто стандартный `integer` является оптимальным

---
> Какой тип задает *числа с фиксированной точностью*?

У типа два названия, псевдонимы: `numeric` и `decimal`. Конструктор типа принимает один или два параметра:

```sql
numeric|decimal(precision, scale)
```

Здесь точность - общее число цифр в числе, а масштаб - число цифр после запятой. Например:

```sql
12.3456 ~ numeric(precision=6, scale=4)
some_column decimal(6, 4) NOT NULL
```

---
> В чем преимущества и недостатки чисел с произвольной (фиксированной) точностью?

Тип `numeric`/`decimal` может хранить сотни тысяч цифр. Результаты арифметических операций с такими числами дают настолько большую точность, насколько это вообще возможно. Их рекомендуют использовать, например, для хранения и расчетов денежных сумм

Недостаткам является значительно более низкая скорость работы, по сравнению с числами с плавающей точкой

---
> Какие есть типы чисел с плавающей точкой?

Их два, они представляют реализацию стандарта IEEE 754:

- `real` - от `1E-37` до `1E+37`
- `double precision` - от `1E-307` до `1E+308`
- `float(p)` - тип из SQL-стандарта, в зависимости от параметра равен одному из двух предыдущих

---
> Что произойдет при попытке записи в поле типа `float`/`double` числа, большего максимального допустимого значения? Меньше машинного эпсилона? С более высокой, чем допустимо, точностью?

- для слишком большого выбрасывается ошибка
- для слишком маленького тоже (`undereflow error`)
- при точности выше допустимой ошибки не произойдет, число просто будет округлено

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0.1::real * 10 = 1.0::real
> ```

`f` (= `false`), сравнивать числа с плавающей точкой напрямую нельзя

---
> Какие специальные значения поддерживают типы чисел с плавающей точкой?

`Infinity`, `-Infinity`, `NaN` (не число)

---
> Какое влияние оказывает параметр `p` в конструкторе типа `float(p)`?

- если оно от `1` до `24`, то тип ~ `real`
- если от `25` до `53`, то ~ `double precision`
- без параметра также ~ `double precision`

---
> Что такое тип `serial`?

```sql
CREATE TABLE "table" ("col" serial);
```

Это псевдо-тип, псевдоним для создания последовательности целых чисел, и прикрепления ее к оператору `DEFAULT` в объявлении столбца:

```sql
CREATE SEQUENCE "table_col_seq";
CREATE TABLE "table"(
  "col" integer NOT NULL DEFAULT nextval('table_col_seq')
);
ALTER SEQUENCE "table_col_seq" OWNED BY "table.col";
```

---
> Что делает функция `nextval()`?

Получает следующее (целое) число из последовательности, имя которой передано параметром:

```sql
nextval('seq') -> integer
```

Как правило эта функция используется неявно (типом `serial`), для создания автоинкрементного индекса

---
> Какие особенности у типов `smallserial` и `bigserial`?

Это тот же `serial` - псевдоним для набора команд, но тип создаваемого столбца будет на `int`, а `smallint`/`bigint` соответственно

---
> Как в строковых литералах экранируются кавычки?

Строки задаются в одинарных кавычках. Одинарная кавычка внутри экранируется второй такой же кавычкой, не обратным слешем:

```sql
SELECT 'te''st';
```

Двойные кавычки внутри рассматриваются как обычные символы, их экранировать не нужно

---
> Какой литерал у "сырых" строк?

Два символа доллара с каждой стороны. Никакие символы (`'`, `\`, `$`) внутри экранировать не нужно:

```pgsql
SELECT $$t\e's$t$$;
```

Это расширение Postgres, не часть стандарта SQL

---
> Что такое строки в стиле C?

Строковые литералы, которые могут содержать escape-последовательности, вроде `\n`, `\t`. Такие строки нужно начинать с символа `E`:

```pgsql
SELECT E'PG\nDAY\'17';
```

Одинарная кавычка и обратный слеш в таких литералах экранируются одинаково - обратным слешем:

```
 ?column?
----------
 PG      +
 DAY'17
```

Это расширение Postgres, не часть стандарта SQL

---
> Строковые литералы какого формата распознаются при приведении дат `::date`?

- `yyyy-mm-dd` (ISO 8601)
- `Mon dd, yyyy`

```sql
SELECT '2016-09-12'::date = 'Sep 12, 2016'::date;
```

---
> Как выполняется явное приведение типа?

Через оператор `::<type>`:

```sql
'Sep 12, 2016'::date
1::real
```

---
> Какие 3 функции возвращают текущие значения даты и времени? Как они вызываются?

Все три вызываются без круглых скобок:

```sql
SELECT current_date, current_time, current_timestamp;
```

```
 current_date |    current_time    |       current_timestamp
--------------+--------------------+-------------------------------
 2020-06-16   | 03:50:49.525199+04 | 2020-06-16 03:50:49.525199+04
```

---
> Как отформатировать дату?

Вызвать функцию `to_char()` с объектом типа `date`. Она вернет тип `text`:

```sql
SELECT to_char(current_date, 'dd-mm-yyyy');
```

---
> Какие есть 2 типа для хранения времени?

Функция `current_time` возвращает второй тип:

- `time`
- `time with time zone` - хранит еще и часовой пояс

```sql
SELECT current_time::time, current_time;
```

```
  current_time   |    current_time
-----------------+--------------------
 04:03:21.171316 | 04:03:21.171316+04
```

---
> Какие рекомендации по использованию типа `time with time zone`?

Не использовать: смещение (часовой пояс) может зависеть от даты - дня перехода на летнее/зимнее время, при том что сама дата в этом типе не хранится (только время)

---
> Что выведут эти запросы?
> 
> ```sql
> SELECT '21:15'::time, '21:15:12'::time;
> SELECT '25:15'::time, '21:15:72'::time;
> ```

Первый отработает корректно. В случае отсутствия секунд во времени они установятся в нули:

```
   time   |   time
----------+----------
 21:15:00 | 21:15:12
```

Второй выдаст ошибку для любого из выражений:

```
ERROR:  date/time field value out of range: "25:15"
ERROR:  date/time field value out of range: "21:15:72"
```
---
> Строковые литералы какого формата распознаются при приведении времени `::time`?

```
hh:mm[:ss[ am|pm]]
```

```sql
'21:15'::time, '21:15:12'::time, '12:15:12 pm'::time
```

---
> Откуда функция `current_time` берет часовой пояс?

Из конфигурационного параметра `timezone`:

```sql
SHOW timezone;
```

Этот параметр (как и остальные) задается строкой в файле `/etc/postgresql/12/main/postgresql.conf`:

```
   TimeZone
---------------
 Europe/Samara
```

---
> Какие типы получаются при объединении даты и времени?

- `timestamp` - без учета часового пояса
- `timestamp with time zone` (или псевдоним `timestamptz`)

Второй тип - это расширение Postgres

```sql
SELECT timestamp '2016-09-21 22:25:35', timestamptz '2016-09-21 22:25:35';
```

```
      timestamp      |      timestamptz
---------------------+------------------------
 2016-09-21 22:25:35 | 2016-09-21 00:00:00+04
```

---
> Назовите 3 способа приведения типов для констант

Все три приведения дадут одно и то же значение:

```sql
SELECT
  '21:15'::time,         -- const::type
  time '21:15',          -- type const
  cast('21:15' as time); -- cast(const as type)
```

---
> Какие типы значений возвращают функции `current_time`, `current_timestamp`?

`timetz`, `timestamptz`:

```sql
SELECT current_time, current_timestamp;
```

Оба значения с часовым поясом:

```
    current_time    |       current_timestamp
--------------------+-------------------------------
 05:17:19.648166+04 | 2020-06-16 05:17:19.648166+04
```

---
> Приведите пример, когда нужно использовать тип `timestamp`, не `timestamptz`

В случаях, когда не нужно чтобы время автоматически приводилось к часовому поясу пользователя. Так, например, в расписании авиарейсов время отправления/прибытия привязывается к местному времени аэропортов

Но всё же `timestamptz` используется чаще
---
> Строковые литералы какого формата распознаются при приведении интервалов `::interval`?

- `'1 year 2 months[ ago]'`
- `'P0001-02-03T04:05:06'` (дате и времени предшествуют буквы `P` и `T`; стандарт ISO 8601)

---
> Как можно получить значение типа `interval`?

- из строковой константы
- вычитая одну временную отметку из другой

```sql
SELECT '1 hour'::interval, '13:00'::time - '12:00'::time;
```

```
 interval | ?column?
----------+----------
 01:00:00 | 01:00:00
```

---
> Как узнать тип выражения в `SELECT`?

Функция `pg_typeof()`:

```sql
SELECT pg_typeof('13:00'::time - '12:00'::time);
```

```
 pg_typeof
-----------
 interval
```

---
> Как усечь timestamp до нужной компоненты?

Функцией ` date_trunc(text, timestamp)`:

```sql
SELECT (date_trunc('hour', current_timestamp));
```

До границы часа, минуты/секунды станут нулями:

```
       date_trunc
------------------------
 2020-06-16 06:00:00+04
```

---
> Как извлечь из timestamp-а нужную компоненту?

Функцией `extract(<field> from <timestamp>)`:

```sql
SELECT extract('mon' FROM timestamp '1999-11-27 12:34:56.123459');
```

Она всегда возвращает число (`double precision`):

```
 date_part
-----------
        11
```
