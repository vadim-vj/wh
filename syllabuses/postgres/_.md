- <https://postgrespro.ru/docs/postgrespro/current/>
- <https://www.sqlstyle.guide/ru/>
- <https://planet.postgresql.org>
- <https://wiki.postgresql.org/wiki/Main_Page>

#### Лузанов П. и др., Postgres: первое знакомство
<https://postgrespro.ru/education/books/introbook>

#### Моргунов Е., PostgreSQL. Основы языка SQL
<https://postgrespro.ru/education/books/sqlprimer>

---
> Сохраняется ли порядок добавления строк в таблицу?

Нет, строки неупорядочены, хранятся не обязательно в порядке добавления

---
> Как называются целый, логический и строковый типы?

`integer`, `boolean` (`true`/`false`) и `text` соответственно

---
> Какой литерал у *неопределенного* значения?

```sql
NULL
```

---
> Какой синтаксис у описания столбца в `CREATE TABLE`?

`<name> <type>[ <PRIMARY KEY>]`:

```sql
CREATE TABLE courses(
    c_no text PRIMARY KEY,
    title text,
    hours integer
);
```

---
> Какие ограничения для данных в столбце `PRIMARY KEY`?

- значения должны быть уникальны
- неопределенные (`NULL`) значения не допускаются

Второе ограничение действует на любой компонент составных ключей

---
> Какой командой лучше массово загружать данные в таблицы?

`COPY`, не `INSERT`

---
> Какой общий синтаксис у `INSERT`?

Перечисление имен столбцов не обязательно, но тогда нужно передавать значения в том порядке, в котором они следуют в определении таблицы:

```sql
INSERT INTO <table-name> [(<column-names>)] VALUES (<values>);
INSERT INTO students (s_id, name, start_year) VALUES (1451,'Анна', 2014);
```

---
> Что по умолчанию выводит `INSERT`?

Цифры - это `oid` (всегда `0`) + количество вставленных строк:

```
INSERT 0 3
```

Когда-то поддерживалось `WITH OID` при создании таблиц, и первое число могло быть не нулем, но больше это не доступно. Если `INSERT` содержит инструкцию `RETURNING`, то вывод будет таким, как указано в ней

---
> Как в `CREATE TABLE` задать первичный ключ из нескольких столбцов?

После описания всех столбцов, используя ключевое слово `PRIMARY KEY`:

```sql
  ...
  score integer,
  [CONSTRAINT pk ]PRIMARY KEY(s_id, c_no)
);
```

---
> Какой синтаксис у объявления внешнего ключа вместе со столбцом?

Через ключевое слово `REFERENCES` и ссылку вида `<table-name>(<column>)`:

```sql
CREATE TABLE exams(
  s_id integer REFERENCES students(s_id),
  ...
```

---
> Как именуются столбцы в выводе `SELECT`-а?

- используется алиас (`AS <alias>`)
- если `AS` не указан - то имя самого столбца
- `?column?` - если имя неопределено (напр., `SELECT 1` или столбец вычисляемый)

---
> К какой части `SELECT` относится `DISTINCT`?

К ключевому слову, т.е. ко всей выборке, а не к отдельному столбцу:

```sql
SELECT DISTINCT name, start_year FROM students;
-- SELECT name, DISTINCT start_year FROM students; /* syntax error */
```

---
> Какие комментарии есть в PostgreSQL?

Два дефиса и стандартный блочный:

```sql
-- Single-line comment
/*
 Multi-line comment
*/
```

---
> Сколько строк будет содержать результат `SELECT` без `FROM`?

Одну:

```sql
SELECT 2+2 AS result;
```

```
 result
--------
      4
```

---
> При каких результатах сравнения в `FROM` строка попадет в результат `SELECT`-а?

Если сравнение истинно. Не попадет, если сравнение ложно или *не определено* (напр, сравнение с `NULL`)

---
> В каких случаях результат операции не *определен*?

Все связаны с неопределенным значением `NULL`:

- результат сравнения чего угодно с `NULL` не определен
- результат логических операций с `NULL`, как правило, не определен


Как правило, это важно в `WHERE` - строки, для которых результат сравнения не определен, в результат `SELECT`-а не попадают

---
> В каких случая логические операции с `NULL` всё же возвращают определенные значения?

Их два:

```sql
true OR NULL = true
false AND NULL = false
```

---
> Какой синтаксис у операторов "равно" и "не равно"?

Одинарное равно и две формы для "не равно":

```sql
-- equals
=
-- not equals
<>
!=
```

---
> Какими способами можно получить прямое (декартово) произведение таблиц?

С точки зрения СУБД обе формы эквивалентны:

```sql
FROM t1, t2 WHERE t1.id = t2.id
FROM t1 JOIN t2 ON t1.id = t2.id
```

Выборку без ограничивающего условия можно получить только первым способом

---
> Почему `LEFT JOIN` называется "левый"?

В выборку добавляются строки из левой таблицы даже такие, для которых не нашлось пары в правой

---
> На каком этапе выполняется `WHERE` в запросах с `JOIN`-ами? Какие подводные?

Условие в `WHERE` выполняется *после* `JOIN`-а, применяется к уже готовому соединению. Поэтому, для `LEFT JOIN` возможна ситуация когда столбцы правой таблицы окажутся равными `NULL`, и сравнение с ними в `WHERE` не сработает

---
> В каких частях запроса можно использовать подзапросы (вложенный `SELECT`)?

Зависит от того, сколько строк такой подзапрос возвращает:

- если одну или меньше, то такой подзапрос называется *скалярным*, и его можно использовать как единственное значение, в том числе в списке столбцов для выборки или в условиях `WHERE`
- если больше одной строки, то в качестве источника ("таблицы") в `FROM`/`JOIN`, или также в `WHERE`, но только с операторами принадлежности существования, вроде `[NOT] IN`/`[NOT] EXISTS`

В последнем случае (`IN`) подзапрос должен возвращать множество скалярных значений

---
> Какое значение используется в качестве результата скалярного подзапроса, не возвращающего ни одной строки?

Неопределенное, `NULL`:

```sql
SELECT c1, (SELECT ...) as c2 FROM ...;
```

```
  c1  | c2
------+----
 some |
```

---
> Как можно преобразовать скалярный подзапрос, используемый в качестве значения в столбце?

В `LEFT JOIN`

Соединение должно быть именно внешнее: скалярный подзапрос в списке столбцов `SELECT`-а возвращает `NULL`, если для него не найдено ни одной строки; для `INNER JOIN` же возврат неопределнного значения невозможен

---
> Можно ли в подзапросе ссылаться на таблицу из внешнего `SELECT`-а?

Да, вполне:

```sql
SELECT name, (
  SELECT score FROM exams WHERE exams.s_id = students.s_id
) FROM students;
```

---
> Как указываются алиасы имен столбцов/таблиц?

`AS` при этом не обязательно:

```sql
SELECT name AS n FROM students AS s;
SELECT name n FROM students s;
```

---
> Где в `ORDER BY` указывается `ASC`/`DESC`?

После каждого ключа, не одно на всё выражение:

```sql
SELECT * FROM students ORDER BY name ASC, start_year DESC;
```

---
> Каков по умолчанию порядок сортировки в `ORDER BY`?

```sql
ASC
```

---
> Где в составных запросах имеет смысл располагать `ORDER BY`?

Только в конце основного запроса, перед получением результата. В подзапросах она обычно бесполезна

---
> Что делает `GROUP BY`?

Разбивает результат выборки на группы, на основе указанного в `GROUP BY` поля/выражения

---
> Какие агрегатные функции дают количество записей и среднее значение?


```sql
count(<field>|*)
avg(<field>)
```

---
> В каком порядке применяются условия фильтрации `WHERE` и `HAVING` в запросах с группировкой?

- сначала, до группировки, применяется `WHERE` - там можно использовать только столбцы исходных таблиц
- группировка `GROUP BY`
- потом, после группировки, применяется `HAVING` - там уже можно использовать столбцы таблицы-результата

---
> В каких условиях фильтрации можно использовать агрегатные функции?

Только в `HAVING`, в `WHERE` выдаст ошибку

```
aggregate functions are not allowed in WHERE
```

---
> Какой общий синтаксис у `UPDATE` и `DELETE`?

```sql
UPDATE courses SET hours = hours * 2 WHERE c_no = 'CS301';
DELETE FROM exams                    WHERE score < 5;
```

Обе команды выводят количество измененных/удаленных записей:

```
UPDATE 1
DELETE 1
```

---
> Как запретить неопределенные значения в столбце?

При создании таблицы, после типа столбца, указать `NOT NULL`:

```sql
CREATE TABLE groups(
  monitor integer NOT NULL
);
```

---
> Как добавить поле в таблицу?

Спецификация столбца такая же, как при создании таблицы:

```sql
ALTER TABLE students ADD g_no text REFERENCES groups(g_no);
```

---
> Как вставить в таблицу данные из результатов выборки (из другой таблицы)?

Вместо `VALUES` напрямую указать `SELECT`:

```sql
INSERT INTO groups(g_no, monitor)
SELECT 'A-101', s_id FROM students WHERE name = 'Анна';
```

---
> Какие команды начинают, завершают или откатывают транзакцию?

```sql
BEGIN
...
COMMIT
ROLLBACK
--
END
```

---
> Какие есть свойства у транзакций?

- *атомарность* - между командами `BEGIN` и `COMMIT` выполняются либо все команды, либо ни одной
- *согласованность* - данные в конце транзакции должны удовлетворять всем ограничениям (могут ли не удовлетворять внутри транзакции?)
- *изоляция* - параллельные процессы не видят изменений до окончания транзакции, им недоступны еще не согласованные данные. Доступ до базы при этом во время транзакции не блокируется
- *долговечность* - зафиксированные данные не пропадут даже в случае сбоя


---
> Один клиентский процесс `psql` начал (но еще не завершил) транзакцию, и записал несколько строк в таблицу. Что выдаст `SELECT` на этой таблице для текущего и параллельного процессов?

- выборка в текущем процессе (с открытой транзакцией, после `BEGIN`) выдаст все вставленные строки
- выборка в параллельном процессе даст пустой результат: до завершения транзакции первым процессом (до `COMMIT` в первом процессе) результаты этой транзакции никому не доступны

---
> Различаются ли результаты вызова этих двух агрегатных функций?
> 
> ```sql
> count(*)
> count(DISTINCT id)
> ```

Да, различаются. Например, на таблице вида

```
  id
------
 1451
 1556
 1451
 1432
```

запрос

```sql
SELECT count(id), count(DISTINCT id) FROM ...;
```

выдаст

```
 count | count
-------+-------
     4 |     3
```

---
> В чем принципиально различие?
> 
> ```sql
> LEFT JOIN exams ON students.s_id = exams.s_id AND exams.c_no = 'CS305';
> LEFT JOIN exams ON students.s_id = exams.s_id WHERE exams.c_no = 'CS305';
> ```

В `WHERE` стоит операция сравнения, а она не определена при сравнении с `NULL`. Так как `WHERE` выполняется последним, а `LEFT JOIN exams` может привести к появлению `NULL`-значений, проверка в `WHERE` отсечет значения, для которых при соединении не нашлось пары

То есть первый вариант дает более "широкий" результат, а второй отсекает все `c_no = NULL`

---
> Как можно получить текущие дату и время?

Функция `now()`:

```sql
SELECT now();
```

```
              now
-------------------------------
 2020-06-14 06:16:56.282864+04
```

Эквивалентна

```sql
SELECT current_timestamp;
```

---
> Как называется Python-модуль для соединения с Postgres-ом?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
psycopg2
```

Версия 2 поддерживает массовую многопоточность и асинхронность

---
> Как через `python3-psycopg2` работать с базой?

Пять шагов:

```python
# 1. Подключение
conn = psycopg2.connect(
    database='appdb',
    user='app',
    ...
)
# 2. Получение курсора
cur = conn.cursor()
# 3. Выполнение запроса
cur.execute('SELECT * FROM greeting')
# 4. Получение списка кортежей записей
for row in cur[.fetchall()]:
    print row[0]
# 5. Закрытие соединения
conn.close()
```

---
> Какие есть 4 оператора полнотекстового поиска?

```sql
-- Из SQL-стандарта
LIKE -- он же @@
-- Специфичные для PostrgeSQL
ILIKE -- LIKE, не чувствительный к регистру
~
~*
```

---
> Как вставить JSON в поле таблицы?

- поле должно быть объявлено с типом `json`
- данные вставляются стандартно, через `INSERT`, как строка (в одинарных кавычках) валидного JSON-а

---
> Как обратиться к ключу верхнего уровня в поле с типом `json`?

Через оператор `->>`:

```sql
WHERE s.s_id = sd.s_id
AND sd.details ->> 'достоинства' IS NOT NULL
AND sd.details ->> 'достоинства' != 'отсутствуют'
```

---
> Как обратиться к ключу произвольного уровня в поле с типом `json`?

Через оператор `#>`, указав в фигурных сковках последовательность ключей или индексов:

```sql
'{"a": {"b": ["foo","bar"]}}'::json #> '{a,b,1}' -- "bar"
```

---
> В чем отличия `jsonb` от `json`?

Это бинарный формат хранения:

- данные в нем хранятся плотно упакованными (экономится место) и поиск по нему работает быстрее
- для преобразования в него нужно вызывать функцию `to_jsonb('...')`
- он не сохраняет порядок ключей в JSON
- для него другой набор операторов

---
> Как в `jsonb` проверить, что первое значение содержит второе?

Оператор `@>` работает и на вложенных объектах:

```sql
'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb -- t
'{"a":{"b":{c:1}}'::jsonb @> '{"a":{"b":{}}}'::jsonb -- t
```

Запомнить порядок аргументов можно, например, через аналогию "меньше" = "входит в"/"является частью большего"

Оператор аналогичен таковому для массивов

---
> Что выведут эти запросы?
> 
> ```sql
> SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;
> SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;
> ```

Оба `t[rue]`. Для оператора `@>` ("правый является подмножеством / входит в левый") не важны ни порядок элементов, ни их дубликаты

Эта логика справедлива и для типа "массив"

---
> Что выведут эти запросы?
> 
> ```sql
> SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;
> SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;
> ```

Первый `f[alse]`, а второй `t[rue]`: уровень вложенности важен, и должен быть одним и тем же у сравниваемых массивов. То же верно и для объектов:

```sql
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"bar": "baz"}'::jsonb; -- false
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"foo": {}}'::jsonb;    -- true
```

Общий принцип этой проверки в том, что входящий объект должен соответствовать объекту, содержащему его, по структуре и данным, возможно, после исключения из содержащего объекта лишних элементов массива или пар ключ/значение

---
> При проверке вхождения полей типа `jsonb` должны совпадать структуры/уровни вложенности сравниваемых объектов. Для какого случая сделано исключение?

Для проверки принадлежности элемента массиву. Этот запрос выведет `t[rue]`:

```sql
SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;
```

---
> Что выведет это запрос?
> 
> ```sql
> SELECT '"foo"'::json @> '"foo"'::json;
> ```

Синтаксическую ошибку - для типа `json` оператор `@>` не определен, только для `jsonb`:

```
ERROR:  operator does not exist: json @> json
```

Для типа же `jsonb` запрос вернет `t[rue]` - скалярные значения считаются содержащими сами себя

---
> Как отформатировать вывод столбца типа `jsonb`?

Функция `jsonb_pretty()`:

```sql
SELECT s.name, jsonb_pretty(sd.details_b) FROM ...;
```

---
> Что делает функция `jsonb_each()`?

Разворачивает JSON-объект верхнего уровня в последовательность пар "ключ-значение"

---
> Что такое SQL/MED? Как реализуется в Postgres?

Это стандарт ISO/IEC9075-9 (Management of External Data) по работе в SQL с внешними источниками информации - как правило, другими СУБД (напр., MySQL)

Реализуется через специальные обертки. Создаются таблицы (foreign table), которые сами не содержат данных, а перенаправляют все обращения к внешнему источнику. Используются команды

```sql
CREATE FOREIGN DATA WRAPPER
CREATE SERVER
CREATE USER MAPPING
CREATE FOREIGN TABLE
IMPORT FOREIGN SCHEMA
```

---
> Как просмотреть список всех доступных расширений?

Он находится в таблице `pg_available_extensions`:

```sql
SELECT * FROM pg_available_extensions;
```

---
> Как установить расширение?

Например, для создания foreign table и связи с MySQL или другим экземпляром себя же:

```sql
CREATE EXTENSION mysql_fdw;
CREATE EXTENSION postgres_fdw;
```

Второе расширение и создаваемые на его основе внешние таблицы являются встроенным в PostgreSQL механизмом *шардинга*

---
> Как изменить значение конфигурационного параметра?

Отредактировать файл `/etc/postgresql/12/main/postgresql.conf` и перезагрузить настройки - например, выполнить от пользователя `postgres`

```sql
SELECT pg_reload_conf();
```

---
> Как узнать значение конфигурационного параметра?

Командой `SHOW`:

```sql
SHOW shared_buffers;
```

```
 shared_buffers
----------------
 128MB
```

---
> Как создать базу из дампа?

Перенаправить вывод, список SQL-команд на вход клиента, `psql`. Или воспользоваться его же опцей `-f`:

```shell
$ cat dump.sql | psql
$ psql < dump.sql
$ psql [-d <db-name>] -f dump.sql
```

При этом `sudo -u <user> psql` будет определять, от имени какого юзера выполняется заливка дампа, а `psql -U <user>` скажет, какому станет принадлежать создаваемая база

---
> Как создать нового пользователя?

От имени суперпользователя (`postgres`):

```sql
CREATE USER <user> PASSWORD '...';
```

---
> Как создать базу данных для другого пользователя?

С ключевым словом `OWNER`:

```sql
CREATE DATABASE <db-name> OWNER <user>;
```

Обычно выполняется от суперпользователя (`postgres`), чтобы хватило прав

---
> Какая библиотека является системным драйвером PostgreSQL?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
libpq
```

Написана на C

---
> Как заставить сервер перечитать настройки конфигурационных файлов?

```sql
SELECT pg_reload_conf();
```

Или из командной строки

```shell
$ sudo service postgresql reload|restart
```

---
> Что значит метод аутентификации `md5`?

В отличие от `peer`/`trust`, это уже требование на ввод пароля пользователем вручную

---
> Что значит метод аутентификации `peer`?

Что PostgreSQL запрашивает имя текущего пользователя у операционной системы и считает, что ОС уже выполнила необходимую проверку (спросила у пользователя пароль)

Поэтому пользователю обычно не приходится вводить пароль при подключении к серверу на своем компьютере: достаточно того, что пароль был введен при входе в систему

---
> Какой формат у конфигурационного файла `pg_hba.conf`?

Строки разбиты на пять столбцов:

```
# TYPE  DATABASE  USER  ADDRESS  METHOD
local   all       all            peer
```

Строка из примера выше читается как "локальные соединения (`local`) к любой базе (`all`) под любым пользователем (`all`) должны проверяться методом `peer`". IP-адрес для локальных соединений не указывается

---
> Как называются два основных файла настроек?

Основной конфигурационный и настройки доступа:

```
postgresql.conf
pg_hba.conf
```

Оба хранятся в папке `/etc/postgresql/12/main/` (версия, естественно, может меняться). Удаленный доступ до этих файлов запрещен

---
> Какой формат по дефолту имеет строка приглашения в интерактивном терминале?

Имя текущей базы + `=` + решетка для суперпользователя или символ "больше" для обычного:

```
postgres=#
localhost=>
```

---
> Какой порт использует PostgreSQL по дефолту?

```
5432
```

Только на моей Ubuntu он почему-то `5433`

---
> Как в интерактивном терминале подключиться к базе от имени другого пользователя?

Так же, но после имени базы указать имя пользователя:

```
# \c <db-name> <user>
```

В конце можно также указать имя хоста и порт

---
> Как переподключиться к текущей базе?

Та же команда, но без аргумента:

```
# \c
```
Это бывает нужно для того, чтобы настройки применились после изменений

---
> Как создать полную "двоичную" резервную копию кластера СУБД?

Сохранит в каталоге `<backup>`:

```shell
$ pg_basebackup -D <backup>
```

---
> Какая команда создает дамп базы?

Вторая команда сохраняет все базы, а также пользователей и табличные пространства:

```shell
$ pg_dump <db-name>|$PGDATABASE [> dump.sql]
$ pg_dumpall [-f/--file=...]
```

Выводит в `stdout` SQL-команды. Если переменная среды `PGDATABASE` не задана, дампит дефолтную базу (совпадающую с именем текущего пользователя)

---
> Как выйти из интерактивного терминала?

```
# \q
```

---
> Как в интерактивном терминале включить/выключить отображение времени выполнения команд?

После этого самой нижней строкой будет отображаться `Time: N ms`:

```
# \timing [on|off]
```

По умолчанию выключено. Без опции переключает между значениями

---
> Как в интерактивном терминале сменить режим отображения на расширенный (построчный)?

По умолчанию такой режим отключен (`off`):

```
# \x [on|off|auto]
```

Без опций переключает между `on`/`off`. Опция `auto` выводит результаты по строкам только когда они не помещаются по ширине

---
> Чувствительна ли Postgres к регистру?

Backslash-команды да, а SQL-запросы нет, и это касается не только ключевых слов, но и имен таблиц/столбцов/etc.

---
> Как в текущей базе вывести список всех таблиц?

```
# \d[S+]
```

С невыбранной базой будет ошибка `Did not find any relations.`

---
> Как вывести описание таблицы?

```
# \d[S+] <table-name>
```

Выводит столбцы построчно:

```
test=# \d students
 s_id       | integer |           | not null |
 name       | text    |           |          |
 start_year | integer |           |          |
```

Вообще, `# \d <name>` отображает информацию для любого объекта СУБД

---
> Как отображается неопределенное значение в интерактивном терминале?

Никак, `NULL` в результатах выборок не отображается, вместо него пустая строка:

```sql
SELECT NULL;
```

```
 ?column?
----------

(1 row)
```

---
> Какой короткий вариант у опции командной строки `--help`?

Знак вопроса:

```shell
-?
```

Стоит помнить, что стандартное `-h` относится к другой опции - `--host=`

Кроме того, с короткой опцией нельзя получить справку по backslash-командам и переменным, они доступны лишь с длинным именем опции:

```shell
--help=commands
--help=variables
```

---
> Как из командной строки выполнить инструкции из `.sql`-файла?

Опция `-f|--file=`:

```shell
$ psql -f dump.sql
```

---
> Как изменяется приглашение интерактивного терминала в строках продолжения?

Добавляется открывающая скобка перед символом решетки:

```
test=# CREATE TABLE courses(
test(#
```

---
> Как и от какого пользователя запускается консольный клиент?

От пользователя `postgres`:

```shell
$ sudo -u postgres psql
```

Произойдет переход в интерактивный режим СУБД с дефолтным prompt-ом `postgres=#`

---
> Как вывести список всех баз данных?

Команда `# \l`

---
> Как в информационных backslash-командах вывести дополнительную информацию?

Указать после команды `S` (системные объекты; опция есть для примерно половины команд) и/или `+` (доп. детали; опция есть почти для всех):

```
# \l+
# \dnS
```

---
> Как получить справку по backslash-командам?

Из командной строки:

```shell
$ psql --help=commands
```

или в интерактивном терминале (дефолтный режим справки):

```
# \?
```

Второй не стоит путать с `\h` - тот выводит справку по SQL-командам

---
> Какой пейджер используется в интерактивном терминале?

Системный, `more` или `less`

---
> Как в интерактивном терминале переключиться на определенную базу данных?

Команда `\c`:

```
# \c[onnect] <db>[ <additional-info>]
```

Строка приглашения после этого поменяется с дефолтного `postgres=#` на `<db-name>=#`

---
> Как получить справку по опциям командной строки?

Из командной строки (дефолтный режим справки):

```shell
$ psql --help
$ psql --help=options
```

или в интерактивном терминале:

```
# \? options
```

---
> Как в интерактивном терминале получить справку по SQL-команде?

Без имени команды перечислит все, для которых доступна справка:

```
# \h[elp] <command>
# \help CREATE TABLE
# \h
```

Не стоит путать с `\?` - тот выводит справку по backslash-командам

---
> Перечислите основные термины (сущности), относящиеся к реляционным БД

- *таблица* состоит из набора *строк* или *записей*
- строка делится на *поля*, *столбцы* или *колонки*

Таким образом, таблицы состоят из строк и столбцов, на пересечении которых должны находиться "атомарные" значения, которые нельзя разбить на более мелкие элементы без потери смысла

---
> Перечислите основные термины формальной теории реляционных БД

- таблицы называются математическим термином *отношение* (relation; отсюда и название *реляционная БД*)
- строки таблицы называются *кортежами* (tuples), а колонки - *атрибутами*
- таким образом, отношение имеет *заголовок*, состоящий из атрибутов, и *тело*, состоящее из кортежей
- количество атрибутов (столбцов) называется *степенью отношения*, а количество кортежей (строк) - его *кардинальным числом*

---
> Какое неявное ограничение накладывается на данные в столбце?

*Тип* столбца ограничивает спектр его (столбца) возможных значений

---
> Что такое *потенциальный ключ*?

Комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней. Если ключ состоит из более чем одного атрибута, он называется *составным*

Важным является то, что потенциальный ключ должен быть неизбыточным, т.е. никакое подмножество атрибутов, входящих в него, не должно обладать свойством уникальности

---
> Что такое *первичный ключ*?

Один (или единственный) из потенциальных ключей, выбранный по какому-либо критерию. Первичный ключ обязан быть уникальным и не может содержать значение `NULL`:

```sql
product_no integer UNIQUE NOT NULL
~
product_no integer PRIMARY KEY
```

Остальные потенциальные называются *альтернативными ключами*

---
> Что такое *внешний ключ*?

Набор атрибутов таблицы, соответствующий потенциальному ключу в другой таблице. Таблица, в которой содержится внешний ключ, называется *ссылающейся* (referencing table), а содержащая соответствующий потенциальный ключ - *ссылочной (целевой)* (referenced table)

Таким образом, сам внешний ключ не обязан быть уникальным набором атрибутов, он может повторятся. Он лишь обязан ссылаться на уникальный набор (потенциальный ключ). Пример - таблица с оценками за экзамены. ID студентов в ней повторяются, при этом являясь полем - внешним ключом в целевую таблицу студентов, в которой уже этот ID уникален

---
> Что такое *ссылочная целостность*?

Проблема обеспечения того, чтобы база данных не содержала неверных значений внешних ключей

Ограничение, согласно которому значения внешних ключей должны соответствовать значениям потенциальных ключей, называется *ограничением ссылочной целостности (ссылочным ограничением)*. Это берет на себя СУБД

---
> Что такое *каскадное удаление (обновление)*?

Автоматическое удаление/обновление (неуникальных) записей во всех ссылающихся через внешние ключи таблицах, при изменении записи в ссылочной (целевой) таблице - той, где данные уникальны, являются ключом

Вместо удаления записей, в ссылающихся таблицах возможна замена поля внешнего ключа на `NULL`

---
> Что такое *транзакция*?

Набор операций над базой данных, рассматриваемых как единая и неделимая единица работы, выполняемая полностью или не выполняемая вовсе, если произошел какой-то сбой в процессе выполнения транзакции

Таким образом, транзакции являются средством обеспечения согласованности данных. Например, они могут быть использованы для обновления логически связанных таблиц, чтобы между последовательностью операций обновления не терялась целостность данных

---
> Что такое язык SQL?

Это непроцедурный (декларативный) язык, который является стандартным средством работы с данными во всех реляционных СУБД. Операторы (команды), написанные на этом языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают процедуру получения этого результата. СУБД сама определяет способ выполнения команды пользователя

---
> Является ли SQL языком программирования?

Да, является. Строго типизированным декларативным, но *не* тьюринг-полным

Последнее можно частично обойти через системы расширений (их описывает стандарт SQL/PSM)

---
> На какие группы деляться операторы языка SQL?

- *DDL* (Data Definition Language) - определение данных: создание, изменение и удаление таблиц, представлений и других объектов БД
- *DML* (Data Manipulation Language) - манипулирование данными: выборка, вставка, обновление и удаление строк таблиц
- *DCL* (Data Control Language) - видимо, управление пользователями/ролями

---
> Какие типы данных могут задавать текстовые строки?

- `char[acter][(N)]` - строки фиксированной длины, дополняются пробелами если символов меньше. Если скобки с `N` опущены, то длина = 1
- `varchar(N)` / `character varying(N)` - строки переменной, ограниченной сверху, длины
- `text` - строки произвольной длины (ограничение есть (задается при компиляции), но оно очень велико)

---
> Как называется основной целочисленный тип?

```sql
int[eger]
```

Есть еще типы `smallint`, `bigint`

---
> Какой формат у объявления столбца?

```
<name> <type> [<constrains>]
```

```sql
aircraft_code char(3) NOT NULL
```

Объявления ограничений и ключей могут быть расположены после объявлений самих полей:

```sql
range integer NOT NULL,
CHECK (range > 0),
PRIMARY KEY (aircraft_code)
```

---
> Что говорит значение `NULL` в поле?

= "Значение не задано, данные отсутствуют"

---
> Как делятся ключи по критерию выбора?

На *естественные* и *суррогатные*. Первые находят естественное отражение в предметной области. Например, это код лайнера в таблице типов самолетов

---
> Какие приняты стилистические соглашения по регистру в инструкциях SQL? Почему?

Так их выводит `pg_dump`:

- ключевые слова (`CREATE`, `SELECT`) пишутся в верхнем регистре
- типы столбцов (`int`, `char`) пишутся в нижнем

---
> Как в интерактивном терминале вызвать внешний редактор?

Backslash-команда `# \e`

---
> Как посмотреть индексы и их типы у таблицы?

Стандартной командой `# \d <table-name>`. Под схемой столбцов будут показаны и индексы

---
> Какой тип индекса по умолчанию генерируется для ключей?

B-дерево, для `UNIQUE`/`PRIMARY KEY`:

```sql
"aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
```

Имена индексов, если не заданы, генерируются автоматически

---
> Какой формат имен у автоматически генерируемых первичных ключей?

К имени таблицы дописывается фиксированный суффикс:

```
<table-name>_pkey
```

Например, для таблицы `seats`

```sql
"seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
```

---
> Какой формат имен у автоматически генерируемых индексов для уникальных полей?

Имя таблицы + имена столбцов через подчеркивание + фиксированный суффикс `_key`. Например:

```sql
"boarding_passes_flight_id_seat_no_key"
  UNIQUE CONSTRAINT, btree (flight_id, seat_no)
```

---
> Какой формат имен у генерируемых вручную индексов?

Имя таблицы + имена столбцов через подчеркивание + фиксированный суффикс `_idx`. Например:

```sql
"airports_airport_name_idx" btree (airport_name)
```

---
> Какая схема используется по умолчанию для создания таблиц и прочих объектов?

`public`

---
> Как записываются строковые литералы?

В одинарных кавычках, двойные используются для создания таблиц/столбцов с пробельными символами (и не только) в именах

Две строки, разделенные `\n`, будут слиты в одну, без пробела. Именно символ новой строки, два литерала через пробел дадут синтаксическую ошибку

---
> Что делает backslash-команда `# \s`?

Выводит на экран историю команд

Если указать после нее имя файла - `# \s <file-name>` - то история сохранится в него. Это позволит искать и извлекать команды из истории средствами текстового редактора

---
> Как задать ограничение на значение столбца в общей форме?

Использовать ключевое слово `CHECK`. Можно задать имя ограничению, но обычно пишут без этого, и имя генерируется:

```sql
price numeric CHECK (price > 0)
price numeric CONSTRAINT positive_price CHECK (price > 0)
```

---
> Как задать автоматическое удаление записей при удалении внешнего ключа?

Указать это в *ссылающейся* (там, где поле неуникально) таблице:

```sql
FOREIGN KEY (aircraft_code)
  REFERENCES aircrafts (aircraft_code)
  ON DELETE CASCADE
```

---
> Как ограничить допустимые значения поля некоторым списком (перечислением)?

Указать этот список в `IN` внутри `CHECK`:

```sql
fare_conditions varchar(10) NOT NULL,
CHECK (
  fare_conditions IN ('Economy', 'Comfort', 'Business')
)
```

В полной форма (полученной через `# \d <table-name>`) это ограничение будет выглядеть сложнее:

```sql
CHECK (fare_conditions::text = ANY (ARRAY[
  'Economy'::character varying::text,
  'Comfort'::character varying::text,
  'Business'::character varying::text
]))
```

---
> Как в ссылающуюся таблицу вставить запись с внешним ключом, не существующим в основной таблице?

Никак, СУБД запретит это, выдаст ошибку. Например:

```sql
INSERT INTO seats VALUES ('123', '1A', 'Business');
```

```
ERROR:  insert or update on table "seats" violates foreign key ...
DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts_data"
```

---
> Как одним запросом посчитать количество строк с каждым значением одного поля?

Выборка с группировкой по этому полю, само поле + `count()` в результатах. Сортировка опциональна:

```sql
SELECT aircraft_code, count(*) FROM seats GROUP BY aircraft_code[ ORDER BY count];
```

```
 aircraft_code | count
---------------+-------
 CN1           |    12
 CR2           |    50
 SU9           |    97
 319           |   116
 ...
```

Добавляя новое поле в каждый из операторов `SELECT`, `GROUP BY` и `ORDER BY`, получим группировку уже по двум полям

---
> Что выдаст `SELECT *` на запросе с группировкой?

Ошибку, он не подставит автоматически список полей из `GROUP BY`:

```sql
SELECT * FROM seats GROUP BY aircraft_code;
```

```
ERROR:  column "seats.seat_no" must appear in the
  GROUP BY clause or be used in an aggregate function
```

---
> Что выдаст этот код?
> 
> ```sql
> SELECT model AS m FROM aircrafts ORDER BY m;
> ```

Отсортированный список моделей. `ORDER BY` вполне может сортировать по псевдониму

---
> Какой результат дает составная сортировка?
> 
> ```sql
> ORDER BY a, b;
> ```

Результат сортируется по первому столбцу `a`. Внутри групп с одинаковыми значениями `a` строки сортируются по столбцу `b`:

```
 code | count
------+-------
 319  |    20
 319  |    96
 320  |    20
 320  |   120
 321  |    28
```

---
> Что произойдет при попытке вставить запись с уже имеющимся первичным ключом?

```sql
INSERT INTO aircrafts_data VALUES ('SU9', '{"en":"Sukhoi SuperJet-100"}', 3000);
```

Выдаст ошибку нарушения уникальности:

```
ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
DETAIL:  Key (aircraft_code)=(SU9) already exists
```

---
> Можно ли в `UPDATE` обновлять поля через составные арифметические операторы?

Таких операторов в Postgres нет, так что только полными:

```sql
SET range = range * 2
```

---
> Что произойдет, если в команде удаления с условием
> 
> ```sql
> DELETE ... WHERE ...
> ```
> 
> последнее не совпадет ни с одной строкой?

Команда отработает штатно, это не ошибка. Просто выведет `DELETE 0`

---
> Как удалить все строки из таблицы?

Два варианта:

- вызвать `DELETE` без `WHERE`
- использовать `TRUNCATE`

```sql
DELETE FROM aircrafts;
TRUNCATE aircrafts;
```

`TRUNCATE` работает немного быстрее

---
> Какие псевдонимы у целочисленных типов?

Цифра в названии отражает количество байт, занимаемых полем такого типа:

- `int2` ~ `smallint`
- `int4` ~ `int[eger]`
- `int8` ~ `bigint`

---
> На что обращать внимание при выборе целочисленного типа для поля?

На диапазона допустимых значений и затраты памяти на поле

Часто стандартный `integer` является оптимальным

---
> Какой тип задает *числа с фиксированной точностью*?

У типа два названия, псевдонимы: `numeric` и `decimal`. Конструктор типа принимает один или два параметра:

```sql
numeric|decimal(precision, scale)
```

Здесь точность - общее число цифр в числе, а масштаб - число цифр после запятой. Например:

```sql
12.3456 ~ numeric(precision=6, scale=4)
some_column decimal(6, 4) NOT NULL
```

---
> В чем преимущества и недостатки чисел с произвольной (фиксированной) точностью?

Тип `numeric`/`decimal` может хранить сотни тысяч цифр. Результаты арифметических операций с такими числами дают настолько большую точность, насколько это вообще возможно. Их рекомендуют использовать, например, для хранения и расчетов денежных сумм

Недостаткам является значительно более низкая скорость работы, по сравнению с числами с плавающей точкой

---
> Какие есть типы чисел с плавающей точкой?

Их два, они представляют реализацию стандарта IEEE 754:

- `real` - от `1E-37` до `1E+37`
- `double precision` - от `1E-307` до `1E+308`
- `float(p)` - тип из SQL-стандарта, в зависимости от параметра равен одному из двух предыдущих (`[1, 24]` ~ `real`, `[25, 53]` или без параметра ~ `double`)

---
> Что произойдет при попытке записи в поле типа `real`/`double precision` числа, большего или меньше максимального допустимого значения? Меньше машинного эпсилона? С более высокой, чем допустимо, точностью?

- для слишком большого или слишком маленького числа выбрасывается ошибка
- при точности ниже допустимой генерируется ошибка потери значимых разрядов (`underflow error`)
- а вот при точности выше допустимой ошибки не произойдет, число просто будет округлено

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0.1::real * 10 = 1.0::real
> ```

`f` (= `false`), сравнивать числа с плавающей точкой напрямую нельзя

---
> Какие специальные значения поддерживают типы чисел с плавающей точкой?

`Infinity`, `-Infinity`, `NaN` (не число)

---
> Какое влияние оказывает параметр `p` в конструкторе типа `float(p)`?

- если оно от `1` до `24`, то тип ~ `real`
- если от `25` до `53`, то ~ `double precision`
- без параметра также ~ `double precision`

---
> Что такое тип `serial`?

```sql
CREATE TABLE "table" ("col" serial);
```

Это псевдо-тип, псевдоним для создания последовательности целых чисел, и прикрепления ее к оператору `DEFAULT` в объявлении столбца:

```sql
CREATE SEQUENCE "table_col_seq";
CREATE TABLE "table"(
  "col" integer NOT NULL DEFAULT nextval('table_col_seq')
);
ALTER SEQUENCE "table_col_seq" OWNED BY "table.col";
```

---
> Что делает функция `nextval()`?

Получает следующее (целое) число из последовательности, имя которой передано параметром:

```sql
nextval('seq') -> integer
```

Как правило эта функция используется неявно (типом `serial`), для создания автоинкрементного индекса

---
> Какие особенности у типов `smallserial` и `bigserial`?

Это тот же `serial` - псевдоним для набора команд, но тип создаваемого столбца будет на `int`, а `smallint`/`bigint` соответственно

---
> Как соотносятся числа в объявлениях типов `character[ varying](N)` с длиной строк в многобайтовых (напр., UTF-8) кодировках?

`N` рассматривается как число символов, не число байт

---
> Какие строковые типы рекомендуется использовать в Postgres?

`text` и `varchar`, поскольку такое отличительное свойство типа `character`, как дополнение значений пробелами, на практике почти не востребовано

---
> Как в строковых литералах экранируются кавычки?

Строки задаются в одинарных кавычках. Одинарная кавычка внутри экранируется второй такой же кавычкой, не обратным слешем:

```sql
SELECT 'te''st';
```

Двойные кавычки внутри рассматриваются как обычные символы, их экранировать не нужно

---
> Какой литерал у "сырых" строк?

Два символа доллара с каждой стороны. Никакие символы (`'`, `\`, `$`) внутри экранировать не нужно:

```pgsql
SELECT $$t\e's$t$$;
```

Это расширение Postgres, не часть стандарта SQL

---
> Что такое строки в стиле C?

Строковые литералы, которые могут содержать escape-последовательности, вроде `\n`, `\t`. Такие строки нужно начинать с символа `E`:

```pgsql
SELECT E'PG\nDAY\'17';
```

Одинарная кавычка и обратный слеш в таких литералах экранируются одинаково - обратным слешем:

```
 ?column?
----------
 PG      +
 DAY'17
```

Это расширение Postgres, не часть стандарта SQL

---
> Строковые литералы какого формата распознаются при приведении дат `::date`?

- `yyyy-mm-dd` (ISO 8601)
- `Mon dd, yyyy`

```sql
SELECT '2016-09-12'::date = 'Sep 12, 2016'::date;
```

---
> Как выполняется явное приведение типа?

Через оператор `::<type>`:

```sql
'Sep 12, 2016'::date
1::real
```

---
> Какие 3 функции возвращают текущие значения даты и времени? Как они вызываются?

Все три вызываются без круглых скобок:

```sql
SELECT current_date, current_time, current_timestamp;
```

```
 current_date |    current_time    |       current_timestamp
--------------+--------------------+-------------------------------
 2020-06-16   | 03:50:49.525199+04 | 2020-06-16 03:50:49.525199+04
```

---
> Как отформатировать дату?

Вызвать функцию `to_char()` с объектом типа `date`/`time[stamp]` и строкой формата. Она вернет тип `text`:

```sql
SELECT
  to_char(current_date, 'dd-mm-yyyy'),
  to_char(current_timestamp, 'mi:ss'),
  to_char(current_timestamp, 'dd');
```

```
  to_char   | to_char | to_char
------------+---------+---------
 30-06-2020 | 13:53   | 30
```

---
> Какие есть 2 типа для хранения времени?

Функция `current_time` возвращает второй тип:

- `time`
- `time with time zone` - хранит еще и часовой пояс

```sql
SELECT current_time::time, current_time;
```

```
  current_time   |    current_time
-----------------+--------------------
 04:03:21.171316 | 04:03:21.171316+04
```

---
> Какие рекомендации по использованию типа `time with time zone`?

Не использовать: смещение (часовой пояс) может зависеть от даты - дня перехода на летнее/зимнее время, при том что сама дата в этом типе не хранится (только время)

---
> Что выведут эти запросы?
> 
> ```sql
> SELECT '21:15'::time, '21:15:12'::time;
> SELECT '25:15'::time, '21:15:72'::time;
> ```

Первый отработает корректно. В случае отсутствия секунд во времени они установятся в нули:

```
   time   |   time
----------+----------
 21:15:00 | 21:15:12
```

Второй выдаст ошибку для любого из выражений:

```
ERROR:  date/time field value out of range: "25:15"
ERROR:  date/time field value out of range: "21:15:72"
```

---
> Строковые литералы какого формата распознаются при приведении времени `::time`?

```
hh:mm[:ss[ am|pm]]
```

```sql
'21:15'::time, '21:15:12'::time, '12:15:12 pm'::time
```

---
> Откуда функция `current_time` берет часовой пояс?

Из конфигурационного параметра `timezone`:

```sql
SHOW timezone;
```

Этот параметр (как и остальные) задается строкой в файле `/etc/postgresql/12/main/postgresql.conf`:

```
   TimeZone
---------------
 Europe/Samara
```

---
> Какие типы получаются при объединении даты и времени?

- `timestamp` - без учета часового пояса
- `timestamp with time zone` (или псевдоним `timestamptz`)

Второй тип - это расширение Postgres

```sql
SELECT timestamp '2016-09-21 22:25:35', timestamptz '2016-09-21 22:25:35';
```

```
      timestamp      |      timestamptz
---------------------+------------------------
 2016-09-21 22:25:35 | 2016-09-21 00:00:00+04
```

---
> Назовите 3 способа приведения типов для констант

Все три приведения дадут одно и то же значение:

```sql
SELECT
  '21:15'::time,         -- const::type
  time '21:15',          -- type const
  cast('21:15' as time); -- cast(const as type)
```

---
> Какие типы значений возвращают функции `current_time`, `current_timestamp`?

`timetz`, `timestamptz`:

```sql
SELECT current_time, current_timestamp;
```

Оба значения с часовым поясом:

```
    current_time    |       current_timestamp
--------------------+-------------------------------
 05:17:19.648166+04 | 2020-06-16 05:17:19.648166+04
```

---
> Приведите пример, когда нужно использовать тип `timestamp`, не `timestamptz`

В случаях, когда не нужно чтобы время автоматически приводилось к часовому поясу пользователя. Так, например, в расписании авиарейсов время отправления/прибытия привязывается к местному времени аэропортов

Но всё же `timestamptz` используется чаще

---
> Строковые литералы какого формата распознаются при приведении интервалов `::interval`?

- `'1 year 2 months[ ago]'` (где единицы измерения - от `microsecond` до `millennium`)
- `'P0001-02-03T04:05:06'` (дате и времени предшествуют буквы `P` и `T`; стандарт ISO 8601)

---
> Как можно получить значение типа `interval`?

- из строковой константы
- вычитая одну временную отметку из другой

```sql
SELECT '1 hour'::interval, '13:00'::time - '12:00'::time;
```

```
 interval | ?column?
----------+----------
 01:00:00 | 01:00:00
```

---
> Как узнать тип выражения в `SELECT`?

Функция `pg_typeof()`:

```sql
SELECT pg_typeof('13:00'::time - '12:00'::time);
```

```
 pg_typeof
-----------
 interval
```

---
> Как усечь timestamp до нужной компоненты?

Функцией `date_trunc(text, timestamp)`:

```sql
SELECT date_trunc('hour', current_timestamp);
```

До границы часа, минуты/секунды станут нулями. Идет простое отбрасывание, не округление:

```
       date_trunc
------------------------
 2020-06-16 06:00:00+04
```

Первый параметр может быть от микросекунд до тысячелетий. Как правило, усечение просто заменяет всё справа нулями. Исключение - параметр `week`

Функция всегда возвращает тип `timestamp[ without time zone]`, хотя принимать может не только таймстемпы, но и интервалы

---
> Что выведет этот запрос?
> ```sql
> SELECT date_trunc('sec', '1:2:3.4'::time);
> ```

Компонента - первый параметр, - это граница, усекается по ней, а не она сама отбрасывается. В этом примере секунды остаются, но отбрасывается их дробная часть:

```
 date_trunc
------------
 01:02:03
```

---
> Как извлечь из timestamp-а нужную компоненту?

Функцией `extract(<field> from <timestamp>)`:

```sql
SELECT extract('mon' FROM timestamp '1999-11-27 12:34:56.123459');
```

Она всегда возвращает число (`double precision`):

```
 date_part
-----------
        11
```

---
> Какие значения принимает тип `bool`?

Их три:

```sql
TRUE, FALSE, NULL
```

Последнее указывает, что значение не определено

---
> Какие литералы неявно приводятся к булевым значениям?

Выделенные литералы для типа `boolean` это `TRUE`/`FALSE`, а приводиться могут *строки*. Все значения не чувствительны к регистру:

- `t[rue]`/`f[false]`, так же как отображаются в результатах выборок
- `y[es]`/`n[o]`
- `on`/`off`
- `1`/`0`

При попытке вставить целое число в булево поле будет выброшена ошибка

---
> Как использовать булевы поля в проверках?

Напрямую, без явного сравнения с константами:

```sql
SELECT * FROM databases WHERE is_open_source;
```

---
> Как создать столбец - типизированный массив?

Указать квадратные скобки после имени типа:

```sql
CREATE TABLE pilots(
  pilot_name text,
  schedule integer[]
);
```

---
> Как записать массив в поле `type[]`?

Массив обозначается литералом-строкой (в одинарных кавычках) - перечислением значением внутри фигурных скобок, с явным приведением ее к типу столбца:

```sql
INSERT INTO pilots VALUES (
  'Ivan', '{1, 3, 5, 6, 7}'::integer[]
);
```

Есть и нотация из SQL-стандарта, запись через ключевое слово `ARRAY`:

```sql
INSERT INTO pilots VALUES (
  'Ivan', ARRAY[1, 1, 1, 2]
);
```

---
> Как можно добавить элемент в конец списка значений столбца-массива?

Через оператор или функцию:

```sql
SET schedule = schedule || 7
SET schedule = array_append(schedule, 6)
```

Первый вариант (оператор `||`) позволяет добавлять как отдельный элемент, так и целый массив. Функция `array_append()` работает только с одиночным значением

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '{1, 2}'::int[] || '{3, 4}'::int[], '{1, 2}' || '{3, 4}';
> ```

Ошибки не будет, оператор конкатенации `||` применим к обоим типам:

```
 ?column?  |   ?column?
-----------+--------------
 {1,2,3,4} | {1, 2}{3, 4}
```

Но без явного приведения массивы создаваться не будут, объединенное значение будет строкой (`text`)

---
> Как добавить элемент в начало списка значений столбца-массива?

Через функцию `array_prepend()`:

```sql
SET schedule = array_prepend(1, schedule)
```

- как и `array_append()` она работает лишь с одиночным элементом, не массивом
- в отличие от `array_append()` у нее другой порядок аргументов - добавляемый элемент идет первым

---
> Как удалить элемент из списка значений столбца-массива?

Функцией `array_remove()`:

```sql
SET schedule = array_remove(schedule, 5)
```

Эта функция удаляет элемент *по значению*, не по индексу

---
> Как обращаться к элементам столбца-массива?

Через оператор "квадратные скобки". Индексация начинается с единицы (!):

```sql
SET schedule[1] = 2, schedule[2] = 3
```

Получить доступ только на чтение можно также через функцию:

```sql
WHERE array_position(schedule, 3) IS NOT NULL
```

---
> Как можно заменить сразу часть значений столбца-массива?

Через *срез* (slice):

```sql
SET schedule[1:2] = ARRAY[2, 3]
```

Индексация начинается с единицы (!), второй индекс включается в диапазон

---
> Как проверить, что массив полностью включается в другой?

Оператор `@>` означает проверку того факта, что в левом массиве содержатся все элементы правого. Запрос с условием:

```sql
WHERE schedule @> '{1, 7}'::integer[]
WHERE schedule @> ARRAY[1, 7]
```

выберет все записи, столбец `schedule` в которых содержит оба числа `1` и `7`, например, `{1,3,6,7}`

---
> Как проверить, что в массиве присутствуют элементы другого массива?

Оператор `&&` означает проверку того факта, что в левом массиве содержится хотя бы один элемент правого. Запрос с условием:

```sql
WHERE schedule && '{2, 5}'::integer[]
WHERE schedule && ARRAY[2, 5]
```

выберет все записи, столбец `schedule` в которых содержит хотя бы одно из чисел `2` и `5`, например, `{3,5,6,7}`, `{1,2,5,6}`, `{2,3,5,7}`

В отличие от оператора `||`, этот возвращает булево значение, не массив

---
> Как через операторы сформулировать условие "не содержит ни один из элементов указанного массива"?

Совместить `NOT` и `&&`:

```sql
WHERE NOT (schedule && ARRAY[2, 5])
```

В результате будут выбраны только те записи, в поле `schedule` которых нет чисел `2` и `5`, например, `{1,3,6,7}`

---
> Как "развернуть" столбец-массив, представить его в виде строк - результатов выборки?

Функция `unnest()`:

```sql
SELECT unnest(schedule) AS days_of_week FROM pilots WHERE pilot_name = 'Ivan';
```

```
 days_of_week
--------------
            1
            3
            6
            7
```

Если условию удовлетворяет несколько записей (с полями-массивами), то на выходе также будет одно результирующее поле `days_of_week`, только число строк в результирующей выборке будет больше

---
> В чем отличия типов `json` и `jsonb`?

- `json` записывается в поле как есть, а его разбор производится каждый раз, когда поле извлекается. `jsonb` наоборот, разбирается при записи
- из-за предыдущего пункта быстродействие при записи у `jsonb` немного ниже, но выше при чтении
- кроме того, `jsonb` не сохраняет исходный порядок ключей

Рекомендуется в приложениях использовать `jsonb`, если нет каких-то особых аргументов в пользу выбора типа `json`

---
> Как можно проверить, что ключ содержится в поле с типом `json`?

С помощью оператора `@>` либо напрямую, либо предварительно уточняя поле в левой части через оператор `->`:

```sql
WHERE hobbies @> ' "sports":["футбол"]}'
WHERE hobbies -> 'sports' @> '["футбол"]'
```

JSON-ключи/значения внутри строк JSON-а заключаются в двойные кавычки

---
> Как проверить, что в поле типа `jsonb` присутствует ключ верхнего уровня?

Оператором `? 'key'` (ключ без внутренних двойных кавычек):

```sql
SELECT '{"foo": "bar"}'::jsonb ? 'foo';
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar'; -- для массивов это тоже верно
SELECT '"foo"'::jsonb ? 'foo'; -- примитив содержит сам себя, true
-- а вот ключи нижнего уровня и значения будут возвращать false
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar';
SELECT '{"foo": "bar"}'::jsonb ? 'bar';
```

В разных записях в полях типах `jsonb` структура JSON-а не обязана совпадать, и тогда этот оператор может быть полезен

```sql
... WHERE hobbies ? 'sports'
```

---
> Как изменить только часть структуры JSON в поле типа `jsonb`?

Оператором `||`:

```sql
SET hobbies = hobbies || '{"sports": ["хоккей"]}'
```

---
> Как добавить новый элемент в структуру JSON в поле типа `jsonb`?

Функцией `jsonb_set()`. Второй параметр указывает путь в пределах JSON-объекта, куда нужно добавить новое значение:

```sql
SET hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"')
```

Нумерация массивов с нуля. Добавляемые значения (третий параметр) имеют тип `jsbonb`, литералы внутри них должны быть в двойных кавычках

---
> Что будет в результатах выборки?
> 
> ```sql
> SELECT * FROM aircrafts WHERE 1 = 0;
> ```

Ничего, пустой результат:

```
 ?column?
----------
(0 rows)
```

Хотя условие `WHERE` и не связано со столбцами в `SELECT`, оно всегда ложное и ни одна строка в выборку не попадет

---
> Что выведет этот код?
> 
> ```sql
> CREATE TABLE test_numeric(
>   measurement numeric(5, 2),
>   description text
> );
> INSERT INTO test_numeric VALUES (999.9999, 'some');
> ```

Ошибку переполнения:

```
ERROR:  numeric field overflow
DETAIL:  A field with precision 5, scale 2 must round
  to an absolute value less than 10^3.
```

---
> Какое максимальное число можно записать в поле `numerc(N, M)`? В поле `numeric(N)`?

Если `M` опущено, то оно равно `0`, а общая длина целой части равна `N-M`. Таким образом, диапазон допустимых значений:

```
[-10^(N-M), +10^(N-M)]
```

Например, для `numeric(5, 2)` (= `numeric(3)`) допустимый диапазон `[-1000, 1000]`

---
> Что выведет эта команда?
> 
> ```sql
> INSERT INTO test_numeric SET num_1 = 101;
> ```

Синтаксическую ошибку:

```
ERROR:  syntax error at or near "SET"
```

Это только у `UPDATE` есть синтаксис через `SET`, не у `INSERT`

---
> Какой тип должен быть у поля, если в нем предполагается хранить действительные числа с различной точностью?

`numeric` без указания масштаба и точности:

```sql
CREATE TABLE test_numeric(
  measurement numeric,
  ...
);
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT
>   'NaN'::numeric = 'NaN'::numeric,
>   'NaN'::numeric < 'NaN'::numeric,
>   1 < 'NaN'::numeric;
> ```

```
 ?column? | ?column? | ?column?
----------+----------+----------
 t        | f        | t
```

`NaN` в Postgres равен самому себе и больше любого другого числа

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '4e-324'::double precision < '5e-324'::double precision;
> ```

```
 ?column?
----------
 f
```

Число `4.94065645841247e-324` - минимально представимое. Оба числа из примера выше округляются до `5e-324, float(8)` и считаются равными

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 1E+308 < 'Inf'::double precision;
> ```

```
 ?column?
----------
 t
```

`Inf` больше самого большого числа, представимого типом

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0 * 'Inf'::real;
> ```

```
 ?column?
----------
      NaN
```

Ноль на бесконечность дает математическую неопределенность

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 'Inf'::real < 'NaN'::real;
> ```

```
 ?column?
----------
 t
```

В Postrges `NaN` больше любого числа, даже бесконечности

---
> Как на генератор последовательности поля `serial` влияет вставка записи с указанным вручную значением?

Никак, последовательность его не учитывает, не "перешагивает", а генерирует следующий номер, совпадающий с заданным вручную

В случае, когда поле `serial` задано как `PRIMARY KEY`, это может приводить к ошибкам

```
ERROR:  duplicate key value violates unique constraint "test_serial_pkey"
DETAIL:  Key (id)=(2) already exists.
```

Но даже неудачная попытка вставки сдвинет указатель последовательности, и уже следующая вставка отработает нормально: ключа `3` в таблице еще нет

---
> Как на генератор последовательности поля `serial` влияет удаление некоторой (напр., последней) записи?

Не влияет, вычисления максимального значение в столбце не ведется, последовательность просто продолжается с последнего автоматически вставленного номера

---
> Какой календарь используется в PostgreSQL для работы с датами: юлианский или григорианский?

Все даты считаются по Григорианскому календарю, даже для времени до его введения (т.н. *пролептический григорианский календарь*)

---
> Какое наименьшее значение у типов `timestamp[ with time zone]` и `date`?

1 января 4713 до н.э. - юлианский полдень (правда, Postgres считает с полуночи), JD 0

---
> Какой размер у типов `timestamp[ with time zone]` и `date`?

У первого 8 байт, а у даты 4 байта

Несмотря на это, максимальное значение для `date` сильно больше, чем для таймстемпов: время ей хранить не надо

---
> Что означают цифры в скобках после типов `timestamp`, `time` и `interval`?

*Точность* - количество десятичных цифр в поле секунд:

```sql
SELECT current_time::time, current_time::time(0), current_time::time(3);
```

```
  current_time   | current_time | current_time
-----------------+--------------+--------------
 22:41:11.777138 | 22:41:12     | 22:41:11.777
```

Для `date` такого параметра нет

---
> Какой параметр управляет форматом даты? Какое у него значение по умолчанию?

```sql
SHOW datestyle;
```

Первый компонент управляет форматом вывода, а второй - форматом ввода, строки для преобразования в дату, "день"-"месяц"-"год" (`'18-05-2016'::date`)

```
 DateStyle
-----------
 ISO, DMY
```

---
> Каков *универсальный* формат строки для преобразования в дату?

"Год"-"месяц"-"число", `YYYY-MM-DD`:

```sql
SELECT '2016-05-18'::date;
```

Использовать этот формат для ввода дат можно всегда, независимо от второй компоненты параметра `datestyle`. Кроме того, это дефолтный формат вывода дат. Результат для примера выше:

```
    date
------------
 2016-05-18
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '05-18-2016'::date;
> ```

На дефолтных настройках - ошибку:

```
ERROR:  date/time field value out of range: "05-18-2016"
HINT:  Perhaps you need a different "datestyle" setting.
```

По умолчанию второй компонент параметра `datestyle`, отвечающий за формат вводимых дат, равен `DMY`. В нашем же примере во второй позиции стоит `18`, и как месяц оно интерпретироваться не может (в случае числа < 12 ошибки бы не было)


---
> Как через SQL можно получить и задать значение конфигурационного параметра?

На примере формата дат:

```sql
SHOW datestyle;
SET datestyle TO 'MDY';
```

Во втором случае используется `TO`, или оператор "равно". Кроме того, в том же втором примере устанавливается только часть значения


---
> Как через SQL установить значение конфигурационного параметра в исходное (сбросить)?

Используя ключевое слово `DEFAULT`:

```sql
SET datestyle TO DEFAULT;
```

---
> Как через SQL установить значение конфигурационного параметра `datestyle`?

В первом случае модифицируется только второй компонент (формат ввода):

```sql
SET datestyle TO 'MDY';
SET datestyle TO 'Postgres, DMY';
```

---
> Какие есть 4 формата отображения даты-времени (допустимые значения первого компонента конф. параметра `datestyle`)?

- `ISO` - ISO 8601, стандарт SQL: `1997-12-17 07:37:16-08`
- `SQL` - традиционный стиль: `12/17/1997 07:37:16.00 PST`
- `Postgres` - изначальный стиль: `Wed Dec 17 07:37:16 1997 PST`
- `German` - региональный стиль: `17.12.1997 07:37:16.00 PST`

---
> Какими 3мя способами можно изменить конфигурационный параметр, например, `datestyle`?

- через SQL: `SET datestyle TO 'MDY';`
- задав переменную окружения: `$ PGDATESTYLE="Postgres" psql`
- отредактировав файл `/etc/postgresql/12/main/postgresql.conf` и перезапустив сервер

---
> Что выведет этот запрос?
> ```sql
> SELECT 'Feb 29, 2015'::date;
> ```

Ошибку:

```
ERROR:  date/time field value out of range: "Feb 29, 2015"
```

При парсинге дат выполняется много проверок, в том числе и на високосные года

---
> Что выведет этот запрос?
> ```sql
> SELECT '21:15:16:22'::time;
> ```

Ошибку:

```
ERROR:  invalid input syntax for type time: "21:15:16:22"
```

Формат входных данных для дат/времени задается жестко, и лишние значения игнорироваться не будут

---
> Что выведет этот запрос?
> ```sql
> SELECT pg_typeof('2016-09-16'::date - '2016-09-01'::date),
>        pg_typeof('09:16'::time - '09:01'::time);
> ```

В отличие от разности временных меток, разница дат дает целое число - дни (зд. `15`), не интервал:

```
 pg_typeof | pg_typeof
-----------+-----------
 integer   | interval
```

---
> Что выведет этот запрос?
> ```sql
> SELECT '2016-09-16'::date      - '2015-09-01'::date,
>        '2016-09-16'::timestamp - '2015-09-01'::timestamp;
> ```

Разность значений типа `date` имеет целочисленный тип. Для типов `time[stamp]` разность является интервалом:

```
 ?column? | ?column?
----------+----------
      381 | 381 days
```

---
> Что выведут эти запросы?
> ```sql
> SELECT '0:1'::time - '0:0'::time;
> SELECT '0:1'::time + '0:0'::time;
> ```

Первый вернет интервал в 1 минуту, а второй упадет с ошибкой:

```
 ?column?
----------
 00:01:00

ERROR:  operator is not unique: time without time zone + time without time zone
HINT:  Could not choose a best candidate operator.
  You might need to add explicit type casts.
```

Таким образом, прибавлять ко временной метке можно только интервал, но не другое значение времени

---
> Что выведут эти запросы?
> ```sql
> SELECT '2016-09-16'::date - 1;
> SELECT '20:34:35'::time - 1;
> ```

Первый отработает корректно, вернет дату на день меньше. Второй упадет с ошибкой:

```
ERROR:  operator does not exist: time without time zone - integer
```

Таким образом, целые числа можно складывать/вычитать только из дат, для работы с типом `time[stamp]` нужно использовать временные метки или интервалы

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT '0:1'::time, '0:1'::time + '1 mon'::interval AS time;
> ```

Интервал к временной метке прибавлять вполне можно, но сложение часов с днями ничего в метке не изменит - хранится только время суток, не сама дата:

```
   time   |   time
----------+----------
 00:01:00 | 00:01:00
```

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT
>   '2016-01-01'::date + '1 mon'::interval,
>   '2016-02-29'::date + '1 mon'::interval,
>   '2016-01-31'::date + '1 mon'::interval;
> ```

```
      ?column?       |      ?column?       |      ?column?
---------------------+---------------------+---------------------
 2016-02-01 00:00:00 | 2016-03-29 00:00:00 | 2016-02-29 00:00:00
```

- из первого числа всегда получается первое следующего месяца
- и вообще, число сохраняется, только месяц увеличивается на единицу
- если в следующем месяце нет такого (большого) числа, то берется последний день


---
> Какой параметр управляет форматом интервалов?

```
intervalstyle
```

Он похож на `datestyle`, но состоит из единственного компонента (не из двух через запятую)

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT extract('cent' FROM '1999-01-01'::date);
> ```

```
 date_part
-----------
        20
```

Иногда `extract()` не просто выбирает число из записи даты/времени/интервала, а еще и делает некоторые преобразования. `cent` ~ `century`, а 1999 год принадлежит двадцатому веку

---
> Можно ли сравнивать булево поле с целым числом? Со строкой?

Со строкой можно, и это эквивалентно сравнению с литералом `TRUE`/`FALSE`. С числом выбросит ошибку:

```sql
SELECT * FROM databases WHERE is_open_source <> '1';
SELECT * FROM databases WHERE is_open_source <> 1;
```

```
 is_open_source |   dbms_name
----------------+---------------
 f              | Oracle
 f              | MS SQL Server

ERROR:  operator does not exist: boolean <> integer
```

Нужно явно приводить целые числа к `bool[ean]`

---
> Каковы правила приведения целых чисел к типу `bool[ean]`?

Нуль приводится к `f[alse]`, все остальные числа, положительные и отрицательные, - к `t[rue]`:

```sql
SELECT (-1)::bool; -- TRUE
SELECT 1111::bool; -- TRUE
SELECT 0::bool;    -- FALSE
```

---
> Как из таблицы с полем типа `date` выбрать все записи, где месяц в дате - это март?

Через функцию `extract()`:

```sql
SELECT * FROM birthdays WHERE extract('mon' from birthday) = 3;
```

---
> Дана таблица с полем `birthday` типа `date`. Как выбрать всех людей, достигших возраста 40 лет на данный момент?

Воспользоваться сложением с интервалом и сравнением с текущей датой:

```sql
WHERE birthday + '40 years'::interval < current_date;
```

Важно помнить о типах операндов и типах результатов операций

---
> Дана таблица с полем `birthday` типа `date`. Как найти возраст человека для каждой записи?

Если просто в днях, то можно вычитать `birthday` из `current_date`. Для отображения же в человекочитаемом виде существует встроенная функция `age`:

```sql
SELECT current_date - birthday
SELECT age(birthday)
```

Вообще, в общем случае `age()` принимает 2 параметра, и вычитает второй из первого. Если параметр только один, то вычитает его из `current_date`:

```sql
age(timestamp=current_date, timestamp)
```

---
> Какой тип у результата сложения `date + interval`?

```
timestamp without time zone
```

Пример:

```sql
SELECT '23.04.1998'::date + '40 years'::interval;
```

---
> Можно ли сравнивать тип `date` с `timestamp`? С `interval`?

С первым можно, со вторым нет:

```sql
-- OK:  timestamp < date
'23.04.1998'::date + '40 years'::interval < current_date;
-- ERROR:  operator does not exist: date < interval
SELECT '23.04.1998'::date < '40 years'::interval;
```

---
> Как можно объединить два массива?

Через оператор или функцию:

```sql
SELECT array_cat(ARRAY[1, 2, 3], ARRAY[3, 5]);
SELECT ARRAY[1, 2, 3] || ARRAY[3, 5];
```

Эти способы дадут один и тот же результат:

```
  ?column?
-------------
 {1,2,3,3,5}
```

---
> Допустимы ли поля - многомерные массивы?

Да, вполне. Синтаксис задания/обращения к элементам такой же:

```sql
'{ {"some", "text"}, {"other", "text"} }'::text[][]
field[1][1]
```

Нумерация индексов так же с единицы

---
> Как удалить ключ в JSON-объекте?

Оператором `-` ("минус"). Удалит ключ и соответствующее ему значение

---
> Как для столбца задается значение по умолчанию?

Через ключевое слово `DEFAULT`:

```sql
CREATE TABLE progress(
  mark numeric(1) DEFAULT 5,
  ...
);
```

---
> Как для столбца задается ограничение на уникальность?

Через ключевое слово `UNIQUE`, сразу после объявления столбца или внизу:

```sql
CREATE TABLE students(
  record_book1 numeric(5) UNIQUE,
  record_book2 numeric(5),
  [CONSTRAINT unique_record_book ]UNIQUE (record_book2)
);
```

Аналогичен синтаксис и для `PRIMARY KEY`. В обоих случаях только общий - с записью после столбцов - синтаксис может использоваться для ограничений, накладываемых на два и более столбцов

---
> Как для столбца задается внешний ключ?

Через ключевое слово `REFERENCES` сразу после объявления столбца. А вот для объявления после остальных столбцов (в отличие от `UNIQUE`/`PRIMARY KEY`), нужно дополнительно указывать `FOREIGN KEY`:

```sql
CREATE TABLE students(
  record_book1 numeric(5) REFERENCES students (record_book),
  record_book2 numeric(5),
  FOREIGN KEY (record_book1) REFERENCES students (record_book)
);
```

Можно так же задавать имя ограничения (ключа) - напр., `CONSTRAINT students_fkey`

---
> Какую логику реализует внешний ключ, объявленный с `ON DELETE CASCADE`?

При удалении записи из *основной* (ссылочной) таблицы, удаляются также записи (целиком) во всех *ссылающихся* таблицах

Таким образом, при наличие внешнего ключа (и не только каскадированного), ссылочную таблицу можно назвать *главной*, а ссылающуюся - *подчиненной*

---
> Какие есть варианты для `ON DELETE` во внешних ключах?

- `CASCADE` - удаление записи в связанной таблице при удалении из основной
- `NO ACTION` / `RESTRICT` - запрет на удаление из основной, если в ссылающейся есть связанные записи
- `SET NULL` - присваивание `NULL` внешнему ключу (полю ссылающейся таблицы). Необходимо, чтобы на это поле не было наложено ограничение `NOT NULL`
- `SET DEFAULT` - присваивание значения по умолчанию внешнему ключу (полю ссылающейся таблицы). Дефолтное значение, разумеется, должно быть задано для столбца. В случае, если соответствующего дефолтному значению поля в главной таблице нет, то будет выброшена ошибка и удаление не пройдет

В случае `RESTRICT` проверка выполняется сразу, а для `NO ACTION` может быть отложена до конца транзакции. Это их единственное отличие

---
> Для чего могут служить ограничения, накладываемые на столбцы таблиц?

Как для чисто технических моментов, вроде определенности (`NOT NULL`) или уникальности (`UNIQUE`), так и для описания предметной области, например, ограничения диапазонов значений для номеров семестров или оценок:

```sql
term numeric(1) CHECK ( term = 1 OR term = 2 ),
mark numeric(1) CHECK ( mark >= 3 AND mark <= 5 ),
```

Ограничения предметной области могут быть достаточно сложны, состоять из множества логических связок, перечислений и т.д.

---
> Какая есть альтернативная запись для `NOT NULL`?

Более длинная и менее эффективная:

```sql
CHECK (column_name IS NOT NULL)
```

После имени столбца или после всех остальных

---
> Обязателен ли первичный ключ в таблице?

Обязателен только в теории реляционных БД, реальные (в том числе PostgreSQL) не обязывают иметь его. Первичный ключ может быть *только один*

---
> Как осуществляется выбор текущей схемы?

Через конфигурационный параметр `search_path`:

```sql
SHOW search_path;
SET search_path TO bookings;
```

Вообще, вместо `TO` в `SET` может использоваться и "равно" `=`

```
   search_path
-----------------
 "$user", public
```

После переключения через `SET` команды `CREATE` начнут создавать объекты в новом пространстве имен

---
> В каком порядке должны создаваться таблицы с внешними ключами?

Сначала должны создаваться ссылочные таблицы, а потом ссылающиеся. Если в базе данных нет циклических ссылок, то всегда существует таблица или таблицы, которые не ссылаются ни на какие другие. С них и нужно начинать. Перед созданием очередной таблицы, имеющей внешние ключи, уже должны существовать все ссылочные таблицы для нее. Продвигаться "вниз" от вершины иерархии, где находится таблица, не имеющая внешних ключей

При наличии циклических ссылок таблиц друг на друга придется пользоваться командой `ALTER TABLE`

---
> Что такое *схема*?

Раздел базы данных, где создаются таблицы и прочие объекты. По сути - пространство имен

По дефолту используется схема `public`

---
> Что такое Postgres-комментарии?

Расширение - команда `COMMENT`, позволяющая хранить прямо в БД комментарии к объектам:

```sql
COMMENT ON COLUMN airports.city IS 'Город';
```

После этого, в выводе `# \d+ airports`, в поле `Description` начнет отображаться созданный комментарий

---
> Как просмотреть информацию о последовательности, лежащей за полем `serial`?

Слеш-команда `# \d <table-name>` выведет имя последовательности:

```sql
DEFAULT nextval('flights_flight_id_seq'::regclass)
```
Та же команда на имени последовательности выведет информацию уже о ней самой:

```
\d flights_flight_id_seq
```

---
> Что будет если удалить ссылочную (для внешних ключей) таблицу?

СУБД не позволит удалить ее стандартным `DROP`-ом:

```
ERROR:  cannot drop table aircrafts_data because other objects depend on it
DETAIL:  ...
constraint ...
constraint ...
```

В подсказке будет сказано, что удалять нужно через

```sql
DROP TABLE aircrafts CASCADE;
```

---
> Что делает команда `DROP <table-name> CASCADE`?

Удаляет основную (ссылочную) таблицу, но не ссылающиеся таблицы. Из них (подчиненных таблиц) только удаляются внешние ключи (ограничения), сами таблицы остаются

Без `CASCADE` удаление не пройдет, будет выброшена ошибка (поведение `RESTRICT` по умолчанию)

---
> Как сделать проверку перед удалением, что таблица существует?

Ключевое слово пишется в третьем лице:

```sql
DROP TABLE IF EXISTS aircrafts[ CASCADE];
```

Вместо ошибки (если таблица не существует) выводится notice:

```
NOTICE:  table "<name>" does not exist, skipping
```

---
> Как добавить / удалить столбец в таблице?

```sql
ALTER TABLE airports ADD COLUMN speed <definitions>;
ALTER TABLE airports DROP COLUMN speed;
```

---
> Как добавить в непустую таблицу `NOT NULL`-столбец?

Проблема в том, что для существующих записей новый столбец окажется незаполненным, и будет выброшена ошибка. Выход - сначала добавлять (через `ALTER TABLE ... ADD COLUMN ...`) столбец без `NOT NULL`-ограничения, заполнять таблицу значениями этого столбца, и только потом назначать ему ограничение через `ALTER TABLE ... ALTER COLUMN ...`:

```sql
ALTER TABLE aircrafts ADD COLUMN speed integer;
UPDATE aircrafts SET speed = ...
...
ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
```

Удалить такое ограничение можно аналогично:

```sql
ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
```

---
> Как добавить / удалить ограничение общего типа на столбец?

Использовать в `ALTER TABLE` ключевые слова `CHECK`/`CONSTRAINT`:

```sql
ALTER TABLE aircrafts ADD CHECK (speed >= 300);
ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
```

---
> Как в `ALTER TABLE` можно выполнить сразу несколько действий?

Через запятую перечислить их все:

```sql
ALTER TABLE airports
  ALTER COLUMN longitude SET DATA TYPE numeric(5, 2),
  ALTER COLUMN latitude  SET DATA TYPE numeric(5, 2);
```

---
> Как изменить тип столбца?

В случае приводимых друг к другу типов смена пройдет гладко - в автоматическом режиме:

```sql
ALTER TABLE <table> ALTER COLUMN <column> SET DATA TYPE <new-type>;
ALTER TABLE <table> ALTER COLUMN <column> TYPE <new-type>[ USING (...)];
```

`USING` с набором кейсов может пригодиться только для неоднозначных приведений

---
> Какой синтаксис у конструкции `CASE`?

Обрамление в `CASE`/`END`, ветви состоят из `WHEN` - `THEN`, дефолтная ветвь не обрамлена, просто `ELSE`:

```sql
CASE WHEN fare_conditions = 'Economy' THEN 1
     WHEN fare_conditions = 'Business'THEN 2
     ELSE 3
END
```

Такой switch может использоваться, например, при смене типа столбца внутри `USING`:

```sql
ALTER TABLE ... SET DATA TYPE <new-type> USING (CASE ... END);
```

---
> Как переименовать столбец или ограничение?

```sql
ALTER TABLE seats
  RENAME COLUMN fare_conditions TO fare_conditions_code;
ALTER TABLE seats
  RENAME CONSTRAINT seats_fkey TO seats_code_fkey;
```

Второе может понадобиться потому, что переименование столбцов не переименовывает соответствующие ограничения, даже те, чьи имена были автоматически сгенерированы по имени столбца

---
> Как указать уникальность для существующего столбца?

Станадартно, как и для любых других ограничений, через `ALTER TABLE ... ADD`:

```sql
ALTER TABLE fare_conditions ADD UNIQUE (fare_conditions_name);
```

---
> Какой общий синтаксис создания представлений?

Если список имен столбцов не указан, тогда их имена "вычисляются" (формируются) на основании текста запроса:

```sql
CREATE VIEW <name> [<column-names>] AS SELECT ...;
```

После создания view, к нему можно обращаться как к обычной таблице. Вместо написания (сложного) первоначального `SELECT`-а:

```sql
SELECT * FROM <view>;
```

Хотя первоначальный `SELECT` всё равно выполняется каждый раз при запросах к view

---
> Какое расширение предоставляет Postgres для `CREATE VIEW`?

`OR REPLACE` сработает только тогда, когда имена столбцов представления сохраняются:

```sql
CREATE OR REPLACE VIEW <view-name> AS SELECT ...
```

При изменении имен столбцов нужно сначала удалить представление через `DROP VIEW[ IF EXISTS]`

---
> Как можно задать имена столбцов в представлении?

- сначала будут просмотрены явно указанные в списке:

```sql
CREATE OR REPLACE VIEW seats (code, fare_cond, num_seats) AS SELECT ...
```

- потом просматриваются алиасы:

```sql
CREATE VIEW ... AS SELECT ... count(*) AS num_seats ...
```

- потом берутся имена самих столбцов из `SELECT`-а

---
> Чем отличается материализованное представление от таблицы?

Оно не только хранит данные, но и хранит запрос, на основе которого оно построено

---
> Как создать материализованное представление?

Синтаксис похож на создание обычного view:

```sql
CREATE MATERIALIZED VIEW ... [ WITH [ NO ] DATA ];
```

---
> В каком случае материализованное представление заполняется данными при создании?

Если не было указано `WITH NO DATA` в конце команды `CREATE MATERIALIZED VIEW`

---
> Как загрузить/обновить данные в материализованном представлении?

```sql
REFRESH MATERIALIZED VIEW <view-name>;
```

---
> Как посмотреть список схем в текущей базе?

```
# \dn
```

```
   List of schemas
   Name   |   Owner
----------+-----------
 bookings | localhost
 public   | postgres
```

---
> Каково дефолтное значение конфигурационного параметра `search_path`?

```
"$user", public
```

Схема `"$user"` присутствует на случай если будут созданы схемы с именами, совпадающими с именами пользователей

---
> Как в `search_path` задать несколько схем?

Перечислить их через запятую, без кавычек. Ни внешние, ни у каждой схемы, кавычки не нужны:

```sql
SET search_path = bookings, public;
```

Для объектов, у которых имя схемы не указано явно (напр., `public.aircrafts`), схемы из этого параметра просматриваются слева направо

---
> Как узнать имя текущей схемы?

```sql
SELECT current_schema;
```

Имеется в виду, видимо, самая левая схема в параметре `search_path`

---
> Как можно в каждой записи таблицы сохранять, кто эту запись добавил?

Создать поле типа `text` и указать ему соответствующий `DEFAULT`:

```sql
who_adds_row text DEFAULT current_user,
```

То есть, `DEFAULT` не обязан быть константой, и вполне может быть функцией

---
> Как убрать ограничение `NOT NULL` у столбца?

Ключевое слово `DROP`:

```sql
ALTER TABLE <table-name> ALTER COLUMN <column-name> DROP NOT NULL;
```

---
> Как добавить существующему столбцу ограничение `NOT NULL`?

Ключевое слово `SET`:

```sql
ALTER TABLE table_name ALTER COLUMN col_name SET NOT NULL;
```

---
> Дан столбец с ограничением:
> 
> ```sql
> CHECK (mark >= 3::numeric AND mark <= 5::numeric)
> ```
> 
> Можно ли в него вставить `NULL`-значение?

Да, ограничения типа не отменяют необходимость `NOT NULL`. Без него в поле можно вставлять либо числа `3, 4, 5`, либо неопределенное значение `NULL`

---
> Можно ли создать столбец с таким ограничением?
> 
> ```sql
> mark CHECK (mark >= 3 AND mark <= 5) DEFAULT 6
> ```

Да, можно, то, что `DEFAULT` нарушает ограничения не проверяется во время создания таблицы или выполнения `ALTER TABLE`

Но вот вставить запись с дефолтным значением в него уже не получится, запрос будет всегда падать с ошибкой

```
ERROR:  new row for relation "<t-name>" violates check constraint "<c-name>"
```

Только указывать явно

---
> Какие значения всё же могут повторяться для столбцов с ограничением `UNIQUE`?

Неопределенные, `NULL`. В таблице может быть несколько записей, уникальный столбец которых содержит `NULL`

Такое возможно, т.к. два `NULL` не считаются совпадающими. Результат их сравнения неопределен, сам является `NULL`:

```sql
SELECT NULL = NULL, NULL <> NULL;
```

```
 ?column? | ?column?
----------+----------
          |
```

---
> Как удалить первичный ключ в таблице?

Потребуется узнать (например, через `# \d <table-name>`) его имя:

```sql
ALTER TABLE <t-name> DROP CONSTRAINT <pk-name>[ CASCADE];
```

Каскадирование может потребоваться, если от этого ключа зависят другие, например, внешние

---
> Что здесь лишнее?
> 
> ```sql
> NOT NULL PRIMARY KEY
> ```

`NOT NULL`: первичный ключ подразумевает это по умолчанию

---
> Будет ли ограничение `NOT NULL` на текстовом столбце препятствовать вставке пустых строк?

Нет, не будет. Нужно создавать явное ограничение для такого:

```sql
ALTER TABLE students ADD CHECK (name <> '');
```

Такое ограничение не будет отсекать строки, состоящие из пробелов. Проверку/подготовку строк можно возложить на прикладную программу или воспользоваться встроенной функцией `trim()`

---
> Можно ли сменить тип столбца с `numeric` на `char`? А обратно?

Если длина строки (`N` в `char(N)`) достаточна, то смена `numeric` -> `char` идет без лишних движений, гладко

Обратная смена (`char` -> `numeric`) уже требует явного приведения - использования `USING`:

```sql
ALTER TABLE students ALTER COLUMN doc_ser TYPE decimal(4,0) USING doc_ser::numeric(4,0);
```

---
> Как переименовать таблицу?

Команда обычная, подкоманда - `RENAME TO`:

```sql
ALTER TABLE table_name RENAME TO new_table_name;
```

---
> Что произойдет при попытке удаления таблицы, на которой базируются (другие) представления?

Будет выброшена ошибка. Для удаления зависимых объектов (в том числе views) нужно писать

```sql
DROP TABLE ... CASCADE;
```

---
> Можно ли изменять данные при помощи представлений?

Да, можно пользоваться стандартными `INSERT`, `UPDATE` и `DELETE` на view, но представление должно удовлетворять некоторым условиям

Представление становится *изменяемым* автоматически, если его `SELECT` достаточно простой: у `FROM` ровно один элемент, в нем не используются агрегатные и оконные функции, `LIMIT`, `UNION` и некоторые другие конструкции

---
> Какими командами модифицируется структура представлений?

```sql
ALTER VIEW
ALTER MATERIALIZED VIEW
```

---
> Что такое *горизонтальные* и *вертикальные* представления?

- в вертикальное включается лишь часть столбцов исходной таблицы (`SELECT col1, col2, ...`)
- в горизонтальные включается лишь часть строк (`SELECT * ... WHERE/HAVING`)

Или может быть смешанный вариант

---
> Какие подстановочные символы (wildcard-ы) допустимы в шаблонах оператора `LIKE`?

Их два:

- `%` - любое количество любых символов (`.*`)
- `_` - в точности один любой символ (`.`)

---
> Какой охват у шаблона в операторе `LIKE`?

Вся строка, он неявно подразумевает `^...$`

Таким образом, если нужно найти вхождение в середине строки, нужно обрамлять в `%` искомую подстроку:

```sql
LIKE '%abc%'
```

---
> В каких случаях индекс столбца не будет использоваться при поиске через оператор `LIKE`?

Если шаблон поиска в `LIKE` начинается с `%`:

```sql
LIKE '%abc'
```

---
> Как найти все записи, где столбец `a` не начинается на `A` или `B`?

Через отрицание `LIKE`:

```sql
WHERE a NOT LIKE 'A%' AND a NOT LIKE 'B%'
```

---
> Как найти все записи, где столбец `a` содержит строки длиной ровно 3 символа?

Можно, например, через `LIKE` с `_`:

```sql
WHERE a LIKE '___'
```

---
> Как в Postgres реализуется поиск по регулярным выражениям?

Операторами `~`/`!~` - (не) соответствует. Примеры:

```sql
SELECT * FROM aircrafts WHERE model ~ '^(A|Boe)';
SELECT * FROM aircrafts WHERE model !~ '300$';
```

Судя по описанию, полнофункциональные регекспы

---
> Что такое *предикаты сравнения*?

Похожи на операторы сравнения, но имеют немного другой синтаксис. В качестве единственного примера приводится `BETWEEN`:

```sql
SELECT * FROM aircrafts WHERE range BETWEEN 3000 AND 6000;
```

`BETWEEN` ищет значения *включительно* - в выборку из примера выше попадут значения `3000`

---
> Каков поорядок строк в результатах `SELECT`-а в общем случае?

Произвольный. СУБД никак не гарантирует порядок выборки без `ORDER BY`

---
> Как можно ссылаться на столбец внутри `ORDER BY`?

- по имени
- по псевдониму
- по порядковому номеру

```sql
SELECT DISTINCT timezone FROM airports ORDER BY 1;
```

---
> Какой подход можно использовать для решения задач поиска "N самых ..."-записей?

Комбинацию сортировки (как правило, `DESC`) и лимита. Пример - три самых восточных аэропорта:

```sql
SELECT * FROM airports ORDER BY longitude DESC LIMIT 3;
```

---
> В задаче нужно найти "N самых ..." записей, но, например, с третьего места. Какой подход можно использовать для решения?

Такой же, как и для "N самых ..." в общем случае + `OFFSET`:

```sql
SELECT * FROM airports ORDER BY longitude DESC LIMIT 3 OFFSET 3;
```
Три первые записи будут пропущены

---
> Где можно использовать *условные выражения* `CASE`?

- в `USING` при изменении типа столбца
- в `SELECT`-е, в качестве вычисляемого столбца

```sql
SELECT CASE WHEN ... END AS type FROM ...
```

---
> Как получить часть строки?

Встроенной функцией `substr()`

Она может использоваться, например, вместо регулярных выражений (`a.model ~ '^Cessna'`) или оператора `LIKE`

---
> Когда удобны псевдонимы таблиц в `JOIN`-ах?

Когда в соединяемых таблицах есть одноименные атрибуты

---
> Как записать простое соединения таблиц без `JOIN`?

Указать обе таблицы во `FROM`, а условие соединения вынести из `ON` в `WHERE`:

```sql
SELECT * FROM a JOIN b ON a.key = b.key;
~
SELECT * FROM a, b WHERE a.key = b.key;
```

---
> Что является результатом операций над отношениями?

Тоже отношения - таблицы/представления. Поэтому реляционные операции можно произвольно комбинировать друг с другом

---
> Можно ли указать одну и ту же таблицу во `FROM` дважды?

Да, только желательно (обязательно?) использовать псевдонимы:

```sql
... FROM airports dep, airports arr
```

В примере выше упоминание дважды нужно т.к. в соединяемыой таблице `flights` присутствуют два поля - `departure_airport` и `arrival_airport`: соединять с одной таблицей нельзя, поля могут иметь (и всегда имеют) разное значение. Таким образом, соединение идет с двумя *различными* строками из таблицы `airports`, к которой обращаются дважды, как будто это две копии одной и той же таблицы (на деле просто дважды производится поиск, копий не создается)

---
> Приведите 3 альтернативных варианта простого соединения таблицы самой с собой

На примере построения всех возможных маршрутов между аэропортами:

```sql
SELECT count(*) FROM airports a1, airports a2 WHERE a1.city <> a2.city;
SELECT count(*) FROM airports a1 JOIN airports a2 ON a1.city <> a2.city;
SELECT count(*) FROM airports a1 CROSS JOIN airports a2 WHERE a1.city <> a2.city;
```

С точки зрения СУБД эти три варианта эквивалентны и отличаются лишь синтаксисом. Для них PostgreSQL выберет один и тот же план (порядок) выполнения запроса

---
> Что относится к части `FROM` запроса с соединением таблиц?

Весь `JOIN`:

```sql
SELECT * FROM (a JOIN b ON a.key = b.key);
```

Здесь соединение таблиц рассматривается как новая таблица, из которой и идет выборка. Это следует из того факта, что результат операций над отношениями сам является отношением (таблицей)

---
> Какие есть две альтернативы *безусловного* декартова произведения таблиц?

```sql
SELECT * FROM a, b;
SELECT * FROM a CROSS JOIN b;
```

---
> Каковы правила использования ключевых слов `INNER` и `OUTER`?

- для всех `JOIN`-ов они опциональны, и неявно подразумеваются
- с `LEFT`/`RIGHT`/`FULL` может использоваться только `OUTER`
- c `JOIN` без префикса может использоваться только `INNER`

---
> В чем разница между `count(*)` и `count(col_name)`?

Вторая может дать меньшую цифру: она считает только те записи, в которых значение указанного столбца определено, не `NULL`

---
> Взаимозаменяемы ли `LEFT` и `RIGHT` `JOIN`-ы?

Да, всегда можно просто поменять таблицы местами. Правое соединение, таким образом, - лишь синтаксический прием

---
> Какие строки включаются в `FULL [OUTER] JOIN`?

Все в обеих таблицах, в том числе из левой, для которых не нашлось соответствующих строк в правой, и из правой, для которых не нашлось соответствующих строк в левой

---
> Какова ассоциативность у операций соединения таблиц?

Левая. `JOIN`-ы групиируются слева направо:

```sql
...FROM a JOIN b ON a.key = b.key LEFT OUTER JOIN c ...;
~
...FROM (a JOIN b ON a.key = b.key) LEFT OUTER JOIN c...;
```

Таблица, полученная в результате левого `JOIN`-а, соединяется с таблицей из следующего `JOIN`-а

---
> Как использовать виртуальные таблицы константных данных?

Внутри `FROM`/`JOIN`, через ключевое слово `VALUES`:

```sql
JOIN (VALUES (0, 100000), (100000, 200000), ...) AS v (col1, col2) ...
```

Имя новой таблицы задается через `AS`, а после имени, в скобках, перечисляются имена столбцов

---
> Для чего служит ключевое слово `UNION`?

Оно соединяет два `SELECT`-а, возвращает *объединение* множеств строк из двух выборок. Строка включается в итоговое множество (выборку), если она присутствует хотя бы в одном из них:

```sql
SELECT ...
UNION [ALL]
SELECT ...
```

Такие объединения можно использовать для решения задач с "или" в условиях (напр., "в какие города можно улететь или из Москвы, или из Санкт-Петербурга?")

---
> Включаются ли строки-дубликаты в результаты `UNION`?

Нет, не включаются. Для их включения нужно использовать `UNION ALL`

---
> Для чего служит ключевое слово `INTERSECT`?

Как и `UNION`, применяется к двум `SELECT`-ам. Возвращает *пересечение* множеств строк из двух выборок. Строка включается в итоговое множество (выборку), если она присутствует в каждом из них:

```sql
SELECT ...
INTERSECT [ALL]
SELECT ...
```

Такие объединения можно использовать для решения задач с "и" в условиях (напр., "в какие города можно улететь и из Москвы, и из Санкт-Петербурга?")

---
> Включаются ли строки-дубликаты в результаты `INTERSECT`?

Нет, не включаются. Для их включения нужно использовать `INTERSECT ALL`

---
> Для чего служит ключевое слово `EXCEPT`?

Оно соединяет два `SELECT`-а, возвращает *разность* множеств строк из двух выборок. Строка включается в итоговое множество (выборку), если она присутствует в первом множестве, но отсутствует во втором:

```sql
SELECT ...
EXCEPT [ALL]
SELECT ...
```

Такие объединения можно использовать для решения задач с "но"/"кроме" в условиях (напр., "в какие города можно улететь из Москвы, но нельзя из Санкт-Петербурга?")

---
> Включаются ли строки-дубликаты в результаты `EXCEPT`?

Нет, не включаются. Для их включения нужно использовать `EXCEPT ALL`

---
> Какой приоритет у операторов (ключевых слов) работы с множествами (`SELECT`-ами)?

- у `INTERSECT`-а самый высокий приоритет
- `UNION`/`EXCEPT` имеют одинаковый (более низкий чем у `INTERSECT`) приоритет

---
> Сколько строк будет в результате `SELECT` + агрегатная функция?

Зависит от того, есть ли в `SELECT` группировка:

- без нее будет одна строка
- с ней - столько, сколько уникальных значений в поле группировки

```sql
-- 1 строка
SELECT avg(total_amount) FROM bookings;
-- 56 строк
SELECT avg(total_amount) FROM bookings GROUP BY book_date::date;
```

---
> Назовите 4 основные агрегатные функции

```sql
min(), max(), avg(), count()
```

---
> Как получить длину массива?

Встроенной функцией. Второй аргумент - мерность массива (обычно `1`):

```sql
array_length(arr, N)
```

---
> Что такое *оконные функции*?

Window functions, подвид агрегатных функций. Они предоставляют возможность производить вычисления на множестве строк, логически связанных с текущей строкой, т.е. имеющих то или иное отношение к ней

---
> Какие два основных понятия связаны с оконными функциями?

- *раздел* (partition) - группа строк, объединенных, например, равенством какого-либо столбца
- *оконный кадр* (window frame) - совпадает с разделом если тот не сортирован, и ограничен строками от начала раздела до *значения* поля сортировки текущей строки иначе

Таким образом, оконный кадр свой для каждой (текущей) строки

---
> Каков общий синтаксис использования оконных функций?

Сама функция + задание раздела + (опционально) задание оконного кадра

```sql
func() OVER (PARTITION BY group_expr[ ORDER BY order_field])
```

Здесь `ORDER BY` сортирует строки внутри раздела, не глобально

---
> В каких случаях агрегатная функция становится оконной?

Когда за ней идет ключевое слово `OVER`

---
> В каком порядке вызываются `GROUP BY`/`HAVING` и оконная функция, если они одновременно присутствуют в запросе?

Сначала группировка `GROUP BY`, а вызов оконных функций происходит на уже сгруппированных данных

Вообще, оконные функции выполняются после всех манипуляций и проверок в запросе. Так, например, строка, отфильтрованная из-за нарушения условия `WHERE`, не будет видна для оконных функций

---
> В чем отличие оконных функций от агрегатных?

Они не приводят к финальной группировке строк, хотя и могут обращаться к группам строк внутри раздела

---
> Как можно создать ссылку на раздел для последующего его использования в оконных функциях?

В конце запроса, через ключевые слова `WINDOW ... AS`:

```sql
SELECT rank() OVER tz
FROM some_table
WINDOW tz AS (PARTITION BY timezone ORDER BY latitude DESC);
```

---
> Дана таблица "отдел"-"сотрудник"-"зарплата-этого-сотрудника". Как сравнить зарплату каждого сотрудника со средней зарплатой его отдела?

Нужна одновременно и группировка по разделу для поиска среднего, и сохранение отдельных записей для каждого сотрудника. Выход - использование оконных функций:

```sql
SELECT [employee, ]salary, avg(salary) OVER (PARTITION BY depname) ...
```

В первой колонке окажется зарплата каждого сотрудника, а во второй - средняя его (сотрудника) отдела. Общая группировка на запрос не требуется

---
> Может ли `OVER` в вызове оконных функций быть пустым?

Да, вполне. В примере ниже идет суммирование по всей таблице, и сопоставление (одинаковой) суммы с каждой записью:

```sql
SELECT salary, sum(salary) OVER () FROM empsalary;
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
```

Во втором примере `OVER` не пуст, но не содержит `PARTITION BY` - суммирование так же идет по всей таблице, но результат совсем другой, суммы неодинаковы: в них накапливаются значения только оконных кадров, сумма только до текущей строки

---
> В каких частях запроса разрешено использовать оконные функции?

Только в `SELECT` и `ORDER BY`. Во всех остальных, включая `GROUP BY`, `HAVING` и `WHERE`, они запрещены

---
> В каком порядке выполняются части `SELECT`?

1. `FROM` - реальные и виртуальные (созданные через `VALUES`) таблицы. Если таблиц несколько, то формируется их декартово произведение. В строках пока сохраняются все атрибуты
2. `WHERE` отсекает строки из предыдущего пункта, не удовлетворяющие условиям
3. `GROUP BY` группирует строки и вычисляет значения агрегатных функций
4. `HAVING` отфильтровывает результаты предыдущего шага
5. `SELECT` - выбираются или вычисляются результирующие столбцы, `DISTINCT` удаляет дубликаты. Этот пункт присутствует всегда
6. `ORDER BY` сортирует по одному или нескольким значениям
7. `LIMIT`/`OFFSET` возвращают подмножество строк выборки

Это логическая схема выполнения запроса. На уровне реализации схему строит планировщик

---
> Как получить среднее значение поля по всей таблице?

Использовать агрегатную функцию `avg()` без группировки:

```sql
SELECT avg(total_amount) FROM bookings;
```

---
> Как синтаксически выделяются подзапросы?

Заключаются в скобки:

```sql
... WHERE total_amount > (SELECT avg(total_amount) FROM bookings);
```

---
> Где (в каких частях `SELECT`) могут присутствовать подзапросы?

В `SELECT`, `FROM`, `WHERE` и `HAVING`, а также в предложении `WITH`

---
> Какие подзапросы называются *некоррелированными*?

Те, которые не зависят от внешнего запроса. Они выполняются только один раз, а не при обработке каждой строки из внешнего запроса

На самом деле и коррелированный подзапрос не обязательно выполняется для каждой строки внешнего, планировщик может оптимизировать это

---
> Что делает предикат `[NOT] EXISTS`?

Проверяет сам факт наличия/отсутствия строк в таблице или подзапросе:

```sql
WHERE NOT EXISTS (SELECT 1 FROM ...)
```

---
> Как рекомендуется оформлять `SELECT`-ы (подзапросы) внутри предиката `[NOT] EXISTS`?

Т.к. важен лишь сам факт наличия строк в выборке, вместо списка столбцов или символа `*` лучше указывать единицу:

```sql
WHERE NOT EXISTS (SELECT 1 FROM ...)
```

---
> Что делает функция `string_agg(field, sep)`?

Это агрегатная функция, но возвращает она не числовое значение, а строку символов, составленную из значений первого параметра, разделенных вторым параметром:

```sql
'val1, val2, ..., valN'
```

---
> Что делает функция `array_agg(field)`?

Это агрегатная функция, но возвращает она не числовое значение, а массив, составленный из значений первого параметра:

```sql
ARRAY[val1, val2, ..., valN]
```

В отличие от `string_agg()`, здесь второй параметр - разделитель - не требуется

---
> Что такое `CTE`?

Common Table Expression, *общее табличное выражение* - отдельная конструкция, именованный подзапрос, который можно использовать впоследствии:

```sql
WITH ts AS (SELECT ...) SELECT ts.flight_id ...
```

Фактически это синтаксический сахар, уменьшение уровня вложенности, вынесение подзапроса на уровень выше. Внутри основного запроса CTE можно рассматривать просто как таблицу

---
> Как у CTE можно задать имена столбцов?

Неявно, из имен столбцов в `SELECT`-е. Или явно, перечислив их в скобках:

```sql
WITH RECURSIVE ranges (min_sum, max_sum) AS ...
```

---
> Напишите пример рекурсивного общего табличного выражения

```sql
WITH RECURSIVE ranges (min_sum, max_sum) AS(
  VALUES (0, 100000)
  UNION ALL
  SELECT min_sum + 100000, max_sum + 100000
  FROM ranges WHERE max_sum < ...
)
```

На первом шаге `VALUES (0, 100000)` пишется во временную область памяти, после чего к нему на каждом шаге добавляются строки из `SELECT`-а. До тех пор, пока условие в `WHERE` не станет ложным

---
> Могут ли CTE использоваться в процессе создания представлений?

Да, вполне, они предшествуют порождающему `SELECT`-у:

```sql
CREATE MATERIALIZED VIEW routes AS
  WITH f3 AS ( ... )
  SELECT f3.flight_no, ...
  FROM F3, ...
```

---
> Будет ли соответствовать строка `'A B'` паттерну `'%'` в `LIKE`? Паттерну `'% %%'`?

Да, будет соответствовать, для обоих. Похоже, `%` включает в себя пробелы

---
> Что делает оператор `[NOT ]SIMILAR TO`?

Сравнивает строку слева от себя с шаблоном справа, и возвращает `true`/`false`:

```sql
'abc' SIMILAR TO 'abc'     -- true
'abc' SIMILAR TO 'a'       -- false
'abc' SIMILAR TO '%(b|d)%' -- true
'abc' SIMILAR TO '(b|c)%'  -- false
```

Синтаксис шаблонов для этого оператора - некий гибрид синтаксиса `LIKE` и регулярных выражений POSIX

---
> Что делает предикат `BETWEEN SYMMETRIC`?

Аналогичен обычному `BETWEEN`, но не требует, чтобы левый аргумент был меньше правого. Автоматически меняет аргументы местами, если их порядок нарушен

---
> Можно ли записать предикат, обратный `BETWEEN`?

Да, стандартным способом, через `NOT`:

```sql
a NOT BETWEEN x AND y
```

---
> Как проверить столбец/выражение на неопределенное значение?

```sql
a IS [NOT] NULL
-- эквивалентно предыдущему, но
-- применимо только для булевых выражений
a IS [NOT] UNKNOWN
-- оба - нестандартный синтаксис
a ISNULL
a NOTNULL
```

Сравнение `a = NULL` не сработает, т.к. `NULL` не равен самому себе

---
> Как `COALESCE()` проверяет свои аргументы?

На неопределенность, она возвращает первый аргумент, который не `NULL`

---
> Что вернет `COALESCE()`, если все ее аргументы не определены?

```sql
NULL
```

---
> Что делает встроенная функция `NULLIF(a, b)`?

Возвращает значение `NULL`, если `a` равно `b`, в противном случае возвращает `a`:

```js
a === b ? null : a
```

Эта функция может рассматриваться как обратная к `COALESCE()`: если та возвращает свой второй, "дефолтный", аргумент в случае неопределенности первого, то эта возвращает `NULL` в случае равенства первого аргумента "дефолтному", второму, и сам аргумент иначе

---
> Что делают встроенные функции `GREATEST()` и `LEAST()`?

Возвращают максимальный и минимальный из своих аргументов соответственно

Не стоит путать с `max()`/`min()`: те являются агрегатными функциями и ищут экстремальные значения среди строк, "вертикально". Эти же сравнивают выражения/столбцы, работают "горизонтально"

Эти функции не часть стандарта SQL, это расширение Postgres

---
> Что делает функция `left(str, n)`?

Возвращает первые `n` символов в строке. Когда `n < 0`, возвращаются все символы слева, кроме последних `|n|`:

```sql
left('abcde', 2) = 'ab'
left('abcde', -2) = 'abc'
```

---
> Для чего используется ключевое слово `FILTER`?

Для ограничения числа записей, передаваемых агрегатной функции. Синтаксис - через `WHERE` в скобках:

```sql
count(*) FILTER (WHERE i < 5)
```

---
> Что делают функции `ANY()`/`ALL()`?

Синтаксис:

```sql
a = ANY(SELECT b FROM ...)
```

В скобках должен записываться подзапрос, возвращающий ровно один столбец. Всё выражение (`a` + равно + запись функции) вернет `true`, если хотя бы одна (`ANY`) или все (`ALL`) строки совпали с `a`, и `false` иначе

Ключевое слово `SOME` является синонимом `ANY`

Эквивалентные выражения:

```sql
IN ~ = ANY
NOT IN ~ <> ALL
```

---
> Что такое временная таблица?

Таблица, существующая только на время сеанса или транзакции. Создается через ключевое слово `TEMP[ORARY]`:

```sql
CREATE TEMP TABLE aircrafts_tmp AS SELECT ...;
```

---
> Как создать таблицу из результатов запроса?

Синтаксис стандартный + `AS SELECT`:

```sql
CREATE TABLE films_recent AS SELECT ...
```

---
> Как создать таблицу из результатов выборки, не копируя при этом данные, а только структуру?

Создание через `AS SELECT`, а копировать ли данные при создании, определяют ключевые слова в конце:

```sql
CREATE TEMP TABLE aircrafts_tmp AS SELECT * FROM aircrafts WITH [ NO ] DATA;
```

По умолчанию данные копируются (`WITH DATA`)

---
> Какой есть короткий синтаксис копирования таблицы?

Вместо `AS SELECT * ...`:

```sql
CREATE TABLE films2 AS TABLE films;
```

---
> Копируются ли ограничения при создании таблицы через `CREATE TABLE AS SELECT`?

Нет, на новой таблице их нужно создавать вручную, через `ALTER TABLE`

Для копирования ограничений нужно воспользоваться синтаксисом через `LIKE`

---
> Как скопировать таблицу вместе с индексами и ограничениями?

Синтаксис `CREATE TABLE ... (LIKE ...)`:

```sql
CREATE TEMP TABLE aircrafts_tmp
  (LIKE aircrafts INCLUDING_CONSTRAINTS INCLUDING_INDEXES);
```

Почти десяток опций `INCLUDING_*`, и `INCLUDING_ALL`, включающая их все

---
> Можно ли использовать `INSERT`/`UPDATE`/`DELETE` в качестве CTE?

Да, но он должен иметь в конце `RETURNING`

В книге приводятся примеры, когда `INSERT`/`UPDATE`/`DELETE` внутри CTE делает основную работу - копирует/обновляет таблицу, а основной `INSERT` ведет лог изменений:

```sql
WITH add_row AS(
  INSERT INTO aircrafts_tmp
    SELECT * FROM aircrafts
  RETURNING *
)
INSERT INTO aircrafts_log
  SELECT add_row.aircraft_code ...
  FROM add_row;
```

---
> Что делает ключевое слово `RETURNING` после `INSERT`?

Возвращает значения для каждой фактически добавленной строки. Список `RETURNING` имеет тот же синтаксис, что и список результатов `SELECT`, например:

```sql
INSERT INTO ... RETURNING *
```

В основном это полезно для получения значений, присвоенных по умолчанию, например, последовательного номера записи. Или, например, используя `INSERT` в качестве CTE, можно ссылаться на результаты его (`INSERT`-а) в основном запросе

---
> Можно ли использовать `RETURNING` где-то помимио `INSERT`?

Да, оно полностью поддерживается в `UPDATE`/`DELETE`. Синтаксис тот же

---
> Где используется выражение `ON CONFLICT`?

В `INSERT`, при нарушении уникальности или ограничения. Общий синтаксис - `ON CONFLICT` + объект проверки + действие:

```sql
INSERT INTO ... VALUES ... ON CONFLICT [ (obj) ] DO NOTHING RETURNING ...
```

Варианты действий: `DO NOTHING` - не делать ничего для этой (вставляемой) строки, или `DO UPDATE` - команда, после которой идет подробное описание (напр, через `SET` и `WHERE`), какие действия выполнить для предотвращения конфликта

---
> Что такое таблица `excluded`?

Специальная (служебная) таблица, поддерживаемая СУБД, в которой хранятся все вставляемые строки. Обращаться к ним можно, например, в `ON CONFLICT`:

```sql
INSERT INTO distributors (did, dname)
  VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
  ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
```

---
> Что называют "операцией `UPSERT`"?

Предложение `ON CONFLICT DO UPDATE`. Это атомарная операция - "`UPDATE` или `INSERT`": проверка наличия конфликта и последующее обновление выполняются как неделимая операция; другая транзакция не может устранить или создать текущий конфликт

---
> Какое средство используется для массового копирования данных?

Команда `COPY` может копировать как данные из файлов (или стандартного ввода) в таблицы, так и наоборот - данные из таблиц в файл:

```sql
COPY aircrafts_tmp FROM '/home/postgres/aircrafts.txt';
```

Поля в файле разделяются символами табуляции. Строки не заключаются в одинарные кавычки

---
> Что выводит команда `COPY`?

Количество добавленных строк:

```
COPY 2
```

---
> Как в команде `COPY` указать направление ввода (вывода) и формат файла?

- использовать ключевые слова `FROM`/`TO`
- использовать ключевые слова `WITH FORMAT`

```sql
COPY aircrafts_tmp FROM '/home/postgres/aircrafts.txt';
COPY aircrafts_tmp FROM STDIN                          WITH (FORMAT csv);
COPY aircrafts_tmp TO   '/home/postgres/aircrafts.txt' WITH (FORMAT csv);
```

По умолчанию формат - разделение табуляцией; `csv` разделяет запятыми

---
> Как в `DELETE` можно сослаться на другую таблицу?

Через ключевое слово `USING`:

```sql
DELETE FROM a
  USING b
  WHERE a.key = b.key
```

Как правило, такой подход используется для ссылок на другие таблицы в условии `WHERE`

---
> Как должен завершаться файл с данными для копирования, для его использования в команде `COPY`?

Символами `\.`

---
> Можно ли использовать не-скалярные значения в предикате `IN`?

Да, можно, например, использовать кортежи:

```sql
WHERE (departure_city, arrival_city) IN (
  ('Красноярск', 'Москва'),
  ('Москва', 'Сочи'),
  ('Сочи', 'Москва'),
  ('Сочи', 'Красноярск')
)
```

---
> Как соединить две строки?

Оператором `||`:

```sql
SELECT seat_row || letter ...;
```

---
> Как хранятся записи в индексе?

Упорядочено: это значительно ускоряет поиск. Индекс - это отдельная структура, поэтому порядок хранения в нем может отличаться от порядка в таблице. Но в каждый элемент индекса помещается указатель на строку, так что соответствие однозначное

---
> Опишите кратко, как происходит поиск с помощью индекса

- например, в условии `WHERE` встречается упоминание некоторых столбцов
- специальная подсистема СУБД, называемая *планировщиком*, проверяет, имеется ли индекс, созданный на основе этих столбцов
- планировщик оценивает целесообразность использования индекса в данном конкретном случае
- если решает использовать, то значения ищутся в индексе, не в таблице
- от найденных значений в индексе на строки в таблице ведут прямые указатели. Они и используются для доступа к записям при выполнении запроса

---
> Как реализована проверка на дублирование значений в поле?

Через индекс - он позволяет делать такую проверку очень быстро

Например, индекс автоматически создается для первичных ключей, которые обязаны быть уникальными. Автоматически же он генерируется и для полей с `UNIQUE`-ограничением

---
> Как создать индекс вручную?

Имя индекса не обязательно:

```sql
CREATE INDEX [ index_name ] ON table_name (column_name, ...);
```

---
> Как посмотреть список всех индексов в текущей БД?

Backslash-команда перечислит имена и таблицы, к которым эти индексы относятся:

```
# \di[+]
```

---
> Как удалить индекс?

```sql
DROP INDEX index_name;
```

---
> Ускоряет ли индекс операцию соединения таблиц по индексированному столбцу? Операцию сортировки?

Соединение - да, ускоряет. Сортировка вообще не выполняется: индекс уже сортирован, но да - общая операции выполняется быстрее

---
> Что такое *селективность* выборки? Как она соотносится с необходимостью создания индекса?

Это доля записей, выбираемая при типичном запросе к таблице. Если из таблицы всегда выбирается б*о*льшая часть строк, то селективность такой выборки низка. И наоборот

Индексы дают преимущество на выборках с высокой селективностью, когда из таблицы выбирается лишь небольшая доля строк. Иначе, для выборок большой доли записей, явная сортировка может работать быстрее

---
> Как работает `ORDER BY` + `LIMIT` с индексом и без?

Если столбец, по которому идет сортировка, не индексирован, то потребуется отсортировать все записи, чтобы извлечь первые `N`. В случае же индекса эти первые `N` строк могут быть извлечены непосредственно, без сканирования остальных строк вообще

---
> Как при создании индекса можно модифицировать порядок следования неопределенных значений и общий порядок сортировки элементов?

После каждого стобца указывать нужные ключевые слова:

```sql
CREATE INDEX ON table_name (col_name NULLS FIRST, ...);
CREATE INDEX ON table_name (col_name DESC NULLS LAST, ...);
```

---
> В какой части индекса располагаются `NULL`-значения, если этот индекс создан с использованием ключевых слов `ASC`/`DESC`?

- при возрастающем порядке (`ASC`), неопределенные значения располагаются в конце
- при убывающем (`DESC`) - в начале

---
> Как вручную создать уникальный индекс?

Добавить ключевое слово `UNIQUE` в стандартную инструкцию:

```sql
CREATE UNIQUE INDEX [ index_name ] ON table_name (column_name, ...);
CREATE UNIQUE INDEX aircrafts_unique_model_key ON aircrafts (model);
```

---
> Какие записи считаются совпадающими, если создан уникальный индекс по нескольким атрибутам?

Те, в которых совпадают значения *всех* соответствующих атрибутов

---
> Можно ли строить индексы на основе выражений?

Да, вполне. Например, такой индекс:

```sql
CREATE UNIQUE INDEX ON aircrafts (lower(model));
```

запретит даже имена моделей, различающиеся регистром символов

---
> Как преобразовать строку в нижний регистр?

Встроенной функцией

```sql
lower(some_column)
```

---
> В каких случаях индексы на основе выражений работают быстрее и медленней?

При вставке/обновлении строк в таблицы они требуют больше времени и ресурсов на поддержание индекса

При выборках же они работают быстрее. Поэтому их целесообразно использовать тогда, когда выборки производятся многократно, и время, затраченное на создание и поддержание индекса, компенсируется (окупается) при выполнении выборок из таблицы

---
> Что такое *предикат индекса*?

Условное выражение внутри `WHERE`, в команде создания индекса:

```sql
CREATE INDEX ON bookings (book_date) WHERE total_amount > 10;
```

Такой синтаксис создает т.н. *частичные индексы* - индексы, охватывающие лишь часть строк таблицы. Их размер меньше стандартных, но часто они не дают столь уж больших преимуществ

---
> В каком направлении обход индекса более эффективен?

В любом, Postgres умеет обходить индекс как по возрастанию, так и по убыванию с одинаковой эффективностью

Поэтому, при объявлении частичных индексов, нет необходимости указывать `ORDER BY ASC/DESC`

---
> В каких случаях при выборках будет использоваться частичный индекс?

В случаях, когда условие выборки точно совпадает с предикатом индекса или *математически к нему сводимо*. Так, например, для индекса с предикатом

```sql
CREATE INDEX ON ... WHERE amount > 10;
```

первое условие сводимо (и индекс будет использоваться в выборке), а второе нет:

```sql
SELECT ... WHERE amount > 11;
SELECT ... WHERE amount > 9;
```

---
> В каких случаях целесообразно создавать индекс по внешнему ключу - полю ссылающейся таблицы?

Когда нужно ускорить операции `DELETE`/`UPDATE` над главной (ссылочной) таблицей

---
> Как при создании индекса указать класс операторов?

Вставить нужное значение после имени столбца, например:

```sql
CREATE INDEX ON tickets (passenger_name text_pattern_ops);
```

Здесь `text_pattern_ops` - класс операторов для столбцов типа `text`, необходимый для ускорения поиска с помощью `LIKE`/регулярных выражений, в случае несовпадения локали системы со стандартной

---
> Из скольки операций минимум может состоять транзакция?

Из одной

---
> Назовите два средств обеспечения согласованности БД

- ограничения целостности (constraints)
- транзакции

---
> Сколько исходов имеет транзакция?

Два, успешное выполнение (commit) и откат (rollback)

---
> На какой модели основана реализация транзакций в PostgreSQL?

На *многоверсионной* модели - Multiversion Concurrency Control, MVCC

Эта модель предполагает, что каждый SQL-оператор видит так называемый *снимок данных* (snapshot), т.е. то согласованное состояние (версию) базы данных, которое она имела на определенный момент времени. При этом параллельно исполняемые транзакции, даже вносящие изменения в базу данных, не нарушают согласованности данных этого снимка

Такой результат достигается за счет того, что когда параллельные транзакции изменяют одни и те же строки таблиц, тогда создаются отдельные версии этих строк, доступные соответствующим транзакциям. Это позволяет ускорить работу с базой данных, однако требует больше дискового пространства и оперативной памяти

Еще одно важное следствие применения MVCC - операции чтения никогда не блокируются операциями записи, а операции записи никогда не блокируются операциями чтения

---
> В каком (единственном) случае происходит блокировка данных в Postgres?

При одновременном изменении одной и той же строки данных в нескольких процессах

В остальных же случаях, благодаря MVCC, блокировок не происходит. Не происходит их в том числе и при обращении к одной и той же строке, но с разным типом доступа - на чтение и запись

---
> Что означает аббревиатура *ACID*?

Это 4 свойства, которыми должны обладать транзакции, согласно теории баз данных:

1. *Атомарность* (atomicity) - будут зафиксированы либо все операции транзакции, либо ни одной
2. *Согласованность* (consistency) - в результате выполнения транзакции база должна быть переведена из одного согласованного состояния в другое
3. *Изолированность* (isolation) - во время выполнения транзакции другие транзакции должны оказывать по возможности минимальное влияние на нее
4. *Долговечность* (durability) - после успешной фиксации данные надежно сохранены в базе данных и могут быть извлечены из нее, независимо от сбоев

---
> Какие феномены возможны при параллельном выполнении транзакций?

1. *Потерянное обновление* (lost update) - перезапись одной транзакцией данных, зафиксированных другой транзакцией
2. *"Грязное" чтение* (dirty read) - чтение измененных данных, еще не зафиксированных другой транзакцией. В случае отката этой другой окажется, что первая транзакция прочитала данные, которых нет в системе
3. *Неповторяющееся чтение* (non-repeatable read) - при повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные - тот же самый запрос выдает другой результат
4. *Фантомное чтение* (phantom read) - похож на пред. п., только речь идет о другом подмножестве строк при повторной выборке
5. *Аномалия сериализации* (serialization anomaly) - результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одного из возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно

---
> В чем состоит *концепция сериализации* для транзакций?

Это проблема выбора порядка параллельных транзакций. Результат некоторых операций (пример - перевод суммы на счет + начисление процентов) зависит от порядка, в котором они выполняются. Это же относится и к транзакциям

В общем случае нельзя сказать точно, какой из вариантов сериализации для нескольких параллельных транзакций будет реализован

---
> Что будет в случае, если СУБД не сможет гарантировать успешную сериализацию группы параллельных транзакций?

Тогда некоторые из этих транзакций могут быть завершены с ошибкой. Их придется выполнить повторно

---
> Что характеризует и чем характеризуется *уровень изоляции транзакций*?

- характеризует степень независимости параллельных транзакций
- характеризуется перечнем тех феноменов, которые на данном уровне не допускаются

Всего уровней изоляции в стандарте SQL четыре

---
> Перечислите уровни изоляции транзакций

1. *Read Uncommitted*. Самый низкий уровень, стандарт SQL допускает на нем чтение "грязных" данных (dirty read). В Postgres этот уровень более строгий, и dirty read на нем не допускается
2. *Read Committed*. Dirty read на нем не допускается. Таким образом, в Postgres он совпадает с предыдущим
3. *Repeatable Read*. Не допускаются dirty read и non-repeatable read. В Postgres этот уровень более строгий, и на нем также не допускается phantom read
4. *Serializable*. Не допускается ни один из феноменов, в том числе и аномалии сериализации

---
> Как узнать текущий (дефолтный) уровень изоляции транзакций?

Посмотреть конфигурационный параметр:

```sql
SHOW default_transaction_isolation;
```
По умолчанию это

```
default_transaction_isolation
------------------------------
 read committed
```

---
> Как обеспечить конкретный уровень изоляции транзакции?

СУБД сама обеспечит его, достаточно указать нужный в команде при старте транзакции:

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- или
BEGIN ISOLATION LEVEL READ COMMITTED;
```

Но можно и дополнительно использовать некоторые операторы и приемы программирования, напр., устанавливать блокировки на уровне отдельных строк или всей таблицы

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции с уровнем изоляции Read Uncommitted. Первая транзакция выполняет `UPDATE`, после чего вторая читает данные из той же таблицы. Увидит ли вторая транзакция незакоммитанные еще изменения?

Нет, не увидит. Уровень Read Uncommitted в Postgres более строгий, чем в стандарте SQL, и не позволяет чтение "грязных" данных (dirty read). Фактически этот уровень тождественен уровню изоляции Read Committed

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции с уровнем изоляции Read Uncommitted. Первая транзакция выполняет `UPDATE`, после чего вторая читает данные из той же таблицы. Если предположить, что Postgres следует стандарту SQL для этого уровня изоляции, увидит ли вторая транзакция незакоммитанные еще изменения?

Да, увидит. Изменения внесены, но транзакция не завершена, `COMMIT` не вызван. Её обновленные данные "грязные", и возможность их чтения извне - это как раз разрешенный на уровне Read Uncommitted феномен dirty read

---
> Можно ли откатить транзакцию (выполнить `ROLLBACK`), в которой не было ни одного `INSERT`/`UPDATE`/`DELETE`?

Да, вызвать `ROLLBACK` можно даже на транзакции, где не было выполнено вообще ни одного действия

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции с дефолтным уровнем изоляции Read Committed. Первая транзакция выполняет `UPDATE`, после чего вторая также выполняет `UPDATE` на тех же данных. Что произойдет во втором терминале?

Команда `UPDATE` на втором терминале перейдет в статус ожидания - пока в первой транзакции не будут зафиксированы изменения (выполнен `COMMIT`). После этого `UPDATE` во второй транзакции выполнится уже с учетом изменений из первой

Пример: есть столбец с целочисленным значением `3000` в нем. Первая транзакция добавляет к нему `100`, а вторая `200`. Т.к. вторая будет дожидаться результатов первой, итоговой цифрой во втором терминале будет `3300`

---
> Чем в Postgres отличаются уровни изоляции транзакций Read Uncommitted и Read Committed?

Ничем, синонимы. Это из-за того, что Read Uncommitted в PostgreSQL более строгий, чем в стандарте SQL, и запрещает также чтение "грязных" данных (dirty read)

---
> Как можно закоммитать транзакцию?

Помимо стандартного, у PostgreSQL есть и свое ключевое слово - расширение:

```sql
COMMIT;
END;
```

`END` выполняет либо `COMMIT`, либо `ROLLBACK`, в зависимости от того, возникли ли ошибки во время выполнения транзакции

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции. Первая транзакция выполняет `SELECT`, потом вторая выполняет `DELETE` на той же таблице, после чего первая повторяет тот же `SELECT`. Изменятся дли данные выборок в первой транзакции?

Да, изменятся, вторая выборка вернет уже не все, а только оставшиеся после удаления строки

Это феномен неповторяющегося чтения (non-repeatable read), и он разрешен на дефолтном уровне изоляции транзакций Read Committed

---
> В какой момент транзакции на уровнях Read Committed и Repeatable Read делают снимки данных?

- Read Committed - перед каждым выполнением запроса
- Repeatable Read - однократно, перед выполнением первого запроса транзакции

Поэтому транзакции со вторым уровнем изоляции не могут изменять строки, которые были изменены другими завершившимися транзакциями уже после создания снимка

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции с уровнем изоляции Repeatable Read. Первая транзакция выполняет `SELECT`, потом вторая выполняет `INSERT` и `UPDATE` на той же таблице, после чего первая повторяет тот же `SELECT`. Изменятся дли данные выборок в первой транзакции?

Нет, не изменятся, вторая выборка вернет ровно тот же набор строк с теми же значениями атрибутов

На уровне изоляции Repeatable Read запрещен феномен неповторящегося чтения (non-repeatable read) - изменения, внесенные `UPDATE`, не видны. из-за более строгой трактовки Postrgres-ом уровня запрещено еще и фантомное чтение (phantom read) - фантомные строки, добавленные `INSERT`, также не видны

---
> Что произойдет, если две транзакции с уровнем изоляции Repeatable Read попытаются изменить одну и ту же строку таблицы?

СУБД не позволит зафиксировать вторую транзакцию. Снимок данных на этом уровне создается не перед выполнением каждого запроса, а только однократно, перед выполнением первого

Приложения, использующие этот уровень изоляции, должны быть готовы к тому, что придется выполнять транзакции повторно

---
> В двух параллельных терминалах запущены клиенты `psql`, и в обоих начаты транзакции с уровнем изоляции Repeatable Read. Первая транзакция выполняет `UPDATE`, после чего вторая также выполняет `UPDATE` на тех же данных. Что произойдет во втором терминале?

Команада `UPDATE` на втором терминале перейдет в статус ожидания - пока в первой транзакции не будут зафиксированы изменения (выполнен `COMMIT`). После этого `UPDATE` во второй транзакции упадет с ошибкой "не удалось сериализовать доступ из-за параллельного изменения"

Пример: есть столбец с целочисленным значением `3000` в нем. Первая транзакция добавляет к нему `100`, а вторая `200`. Т.к. на уровне Repeatable Read снимок данных создается на момент начала выполнения первого запроса и в течение транзакции уже не меняется, то делать обновление нельзя: потеряется обновление из первой. Возникает аномалия сериализации

---
> Как увидеть только что вставленные/обновленные строки не выполняя дополнительный `SELECT`?

Возвратить значение из `INSERT`/`UPDATE`. Команда:

```sql
UPDATE modes SET mode ='HIGH' WHERE mode ='LOW' RETURNING *;
```

выведет

```
 num | mode
-----+------
   1 | HIGH
```

---
> Что будет, если вторая из параллельных транзакций с уровнем изоляции Serializable попытается изменить те же данные, что и первая?

Упадет с ошибкой сериализации, две такие транзакции нельзя упорядочить каким-либо образом так, чтобы их результат был эквивалентен последовательному выполнению

---
> На каких уровнях изоляции транзакций, как правило, требуются блокировки?

На уровне Read Committed, когда требуется более детальное управление параллельным выполнением

---
> Назовите две наиболее популярные явные блокировки

- предложение `FOR UPDATE` в конце `SELECT` блокирует часть строк для последующего их обновления
- `LOCK TABLE table_name IN ACCESS EXCLUSIVE MODE;` блокирует таблицу целиком, полностью запрещая доступ до нее другим транзакциям

---
> Чему эквивалентна транзакция с единственной командой?

Самой этой команде. Предполагается, что уровень изоляции транзакции дефолтный - Read Committed

---
> Что такое *метод доступа*? Какие они бывают?

Это способ, который используется для просмотра таблиц и извлечения только тех строк, которые соответствуют критерию отбора. Бывают:

- последовательный просмотр (sequential scan) - индекс не используется
- просмотр по индексу (index scan)
- просмотр исключительно на основе индекса (index only scan)
- просмотр на основе битовой карты (bitmap scan)

---
> Как происходит обращение к таблицам и индексам в памяти?

И таблицы и индексы хранятся на диске, для работы с ними эти объекты считываются в память, в которой они представлены разбитыми на отдельные фрагменты, называемые *страницами*. Эти страницы имеют специальную структуру

Размер страниц по умолчанию составляет 8 кбайт

---
> В каких случаях применяется метод *последовательного просмотра* табличных страниц?

Sequential scan, когда *селективность выборки* низка - т.е. когда извлекаются все (или большинство) записей таблицы. В таком случае обращение к индексу не ускорит процесс просмотра, а возможно даже и замедлит

---
> В каких случаях для табличных страниц применяется метод *просмотра на основе индекса*?

Index scan, когда *селективность выборки* высока. Хотя записи в индексе упорядочены, но обращения к страницам таблицы происходят хаотически, поскольку строки в таблицах не упорядочены. Поэтому при низкой селективности выборки использование индексного поиска может не только не давать ускорения работы, но даже и снижать производительность

---
> В каких случаях для табличных страниц применяется метод *просмотра исключительно на основе индекса*?

Index only scan, когда не требуется обращение к самими страницам таблиц, например, когда в `SELECT` присутствуют только столбцы, для которых существует индекс. Такой просмотр особенно эффективен, когда выбираемые данные изменяются редко

Обойтись полностью без обращения к страницам таблиц можно лишь в том случае, если нужные строки видны всем транзакциям. Выяснить этот факт можно через карту видимости (visibility map), которая существует для каждой таблицы. Если бит в этой карте, означающий общую доступность строк, не выставлен, то нужно обращаться к странице таблицы, и получается обычный индексный поиск

---
> Чем *просмотр на основе битовой карты* отличается от просмотра на основе индекса?

Bitmap scan. Метод похож тем, что сначала так же производится поиск по индексу, но перед обращением к страницам таблиц идет формирование т.н. *битовой карты*, которая позволяет обращаться к каждой табличной странице лишь один раз

---
> Чем отличаются способ соединения таблиц (JOIN) и *способ соединения наборов строк*?

Первое понятие относится к языку SQL и является высокоуровневым, логическим, оно не касается вопросов реализации. А второе относится именно к реализации, это механизм непосредственного выполнения соединения наборов строк

Принципиально важным является то, что за один раз соединяются только два набора строк

---
> Какие существуют три способа соединения наборов строк?

- вложенный цикл (nested loop)
- хеширование (hash join)
- слияние (merge join)

---
> Как реализуется метод соединения строк *вложенный цикл*?

Nested loop. Перебираются строки из "внешнего" набора и для каждой из них выполняется поиск соответствующих строк во "внутреннем" наборе. Если соответствующие строки найдены, то выполняется их соединение со строкой из "внешнего" набора

Метод поддерживает соединения как на основе равенства значений атрибутов (*эквисоединения*), так и любые другие виды условий. Поскольку он не требует подготовительных действий, то способен быстро приступить к непосредственной выдаче результата. Метод эффективен для небольших выборок

---
> Как реализуется метод соединения строк *хешированием*?

Hash join. Из строк одного (как правило, меньшего) набора формируется хеш-таблица, а строки второго перебираются, и для каждой строки ищется соответствие в хеш-таблице

Метод работает только для эквисоединений, поскольку для хеш-таблицы имеет смысл только проверка на равенство. Метод эффективен для больших выборок

---
> Как реализуется метод соединения строк *слиянием*?

Merge join. Оба набора должны быть отсортированы по тому столбцу, по которому идет соединение. Дальше используется алгоритм слияния двух сортированных списков

Метод работает только для эквисоединений. Пригоден для работы с большими наборами строк

---
> Что такое *планировщик*?

Planner, специальная подсистема СУБД, которая строит *план* запроса. План всегда строится перед выполнением самого запроса

Посмотреть план любого запроса можно командой `EXPLAIN`

---
> Что представляет собой *структура плана запроса*?

Дерево:

- узлы на нижних уровнях дерева отвечают за просмотр и выдачу строк таблиц одним из методов (sequential scan, index scan, index only scan, bitmap scan)
- если требуются операции агрегирования, соединения таблиц, сортировки, то они (в виде дополнительных узлов) будут располагаться над узлами выборки строк
- для операций соединения наборов строк (операции из пред. группы) будут использоваться способы nested loop, hash join, merge join

---
> В какой форме команда `EXPLAIN` выводит структуру плана запроса?

В форме дерева, по строке на каждый узел. Каждый же узел содержит оценку стоимости выполнения своих операций. В случае необходимости для конкретных узлов могут выводиться дополнительные строки

Самая первая строка плана содержит общую оценку стоимости выполнения данного запроса

---
> Что выведет эта команда? Объясните вывод
> ```sql
> EXPLAIN SELECT * FROM aircrafts;
> ```

```
                            QUERY PLAN
------------------------------------------------------------------
 Seq Scan on aircrafts_data ml  (cost=0.00..3.36 rows=9 width=52)
```

Выборка не содержит `WHERE`, селективность низкая, планировщик выбрал метод последовательного просмотра (sequential scan)

---
> Что значат цифры `cost=0.00..3.36` в выводе команды `EXPLAIN`?

Первое число означает оценку ресурсов, требуемых для того, чтобы приступить к выводу данных. Равенство ее нулю означает, что никакие доп. операции не требуются, и прочитанные строки можно выводить сразу

Второе число - это оценка общей стоимости выполнения запроса. Эта оценка всегда рассчитывается исходя из предположения, что запрос будет выполнен до конца, хотя он может завершиться и досрочно, напр., из-за `LIMIT`

Обе оценки стоимости выполнения выражаются в неких *условных единицах*, которые вычисляются на основе ряда параметров сервера баз данных. При этом не важно, в каких конкретно единицах производится измерение стоимости: важны соотношения стоимостей

---
> Как планировщик выбирает вариант плана запроса?

Планов запроса может формироваться несколько. Выбран будет тот, чья общая стоимость выполнения минимальна

---
> Что значат цифры `rows=9 width=52` в выводе команды `EXPLAIN`?

Это количество строк, которое должно быть извлечено на данном узле плана, и средний размер ("ширина") каждой извлекаемой строки

Число строк является оценкой, которую планировщик получает на основе статистики, накапливаемой в специальных системных таблицах

---
> Как в `EXPLAIN` отключить показ численных оценок?

Предложение `COSTS OFF` в скобках после команды:

```sql
EXPLAIN (COSTS OFF) SELECT * FROM aircrafts;
```

```
          QUERY PLAN
-------------------------------
 Seq Scan on aircrafts_data ml
```

---
> Сколько узлов плана будет показано для запроса?
> 
> ```sql
> EXPLAIN SELECT * FROM aircrafts WHERE model ~ 'Air';
> ```

Два, из-за условия `WHERE` добавится еще уровень:

```
                            QUERY PLAN
------------------------------------------------------------------
 Seq Scan on aircrafts_data ml  (cost=0.00..3.64 rows=1 width=52)
   Filter: ((model ->> lang()) ~ 'Air'::text)
```

По сравнению с запросом без условия уменьшается цифра в `rows=` (хотя `1` - это всего лишь оценка, реально выбрано будет 3 строки). Ширина при этом сохраняет то же значение

Т.к. здесь не используется индекс, условие фильтрации реализуется через `Filter`, а не через `IndexCond`

---
> Сколько строк выводит команда `EXPLAIN`?

Столько же, сколько узлов в плане:

```
                            QUERY PLAN
------------------------------------------------------------------
 Seq Scan on aircrafts_data ml  (cost=0.00..3.64 rows=1 width=52)
   Filter: ((model ->> lang()) ~ 'Air'::text)
(2 rows)
```

По своей форме вывод команды `EXPLAIN` также является выборкой, поэтому в конце выборки, как обычно, выводится информация о числе строк в ней, т.е. в дереве плана

---
> Сколько узлов плана будет показано для запроса (маленькая таблица)?
> 
> ```sql
> EXPLAIN SELECT * FROM aircrafts ORDER BY aircraft_code;
> ```

Три. Цифра `3.51` на верхнем уровне говорит, сколько времени нужно на сортировку перед тем, как можно будит приступить к выводу строк:

```
                               QUERY PLAN
------------------------------------------------------------------------
 Sort  (cost=3.51..3.53 rows=9 width=52)
   Sort Key: ml.aircraft_code
   ->  Seq Scan on aircrafts_data ml  (cost=0.00..3.36 rows=9 width=52)
```

Хотя по столбцу `aircraft_code` создан индекс (для поддержки первичного ключа), планировщик предпочел не использовать этот индекс, а прибегнуть к последовательному сканированию (Seq Scan) таблицы, о чем говорит нижний узел плана. Это потому, что таблица очень маленькая, и обращение к индексу не дает выигрыша

На собственно сортировку уйдет меньше времени (чем `3.51`), ведь в нее включено и время выборки из нижнего узла - `3.36`

---
> Сколько узлов плана будет показано для запроса (большая таблица)?
> 
> ```sql
> EXPLAIN SELECT * FROM bookings ORDER BY book_ref;
> ```

Один, здесь планировщик уже считает целесообразным использовать индекс:

```
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 Index Scan using bookings_pkey on bookings  (cost=0.42..8511.24 rows=262788 width=21)
```

Первая цифра в `cost=0.42` - это время, необходимое чтобы найти первую строку

---
> Сколько узлов плана будет показано для запроса (большая таблица) с фильтрацией?
> 
> ```sql
> EXPLAIN SELECT * FROM bookings
>   WHERE book_ref >'0000FF' AND book_ref < '000FFF' ORDER BY book_ref;
> ```

Два, к просмотру по индексу добавится условие фильтрации:

```
                                   QUERY PLAN
---------------------------------------------------------------------------------
 Index Scan using bookings_pkey on bookings  (cost=0.42..8.46 rows=2 width=21)
   Index Cond: ((book_ref > '0000FF'::bpchar) AND (book_ref < '000FFF'::bpchar))
```

Т.к. здесь используется индекс, условие фильтрации реализуется не через `Filter`, а через `IndexCond`

---
> Для следующего запроса планировщик выберет метод сканирования на основе битовой карты:
> 
> ```sql
> EXPLAIN SELECT * FROM seats WHERE aircraft_code = 'SU9';
> ```
> 
> Сколько строк будет в выводе команды `EXPLAIN`?

Четыре:

```
                                QUERY PLAN
--------------------------------------------------------------------------
 Bitmap Heap Scan on seats  (cost=5.03..14.24 rows=97 width=15)
   Recheck Cond: (aircraft_code = 'SU9'::bpchar)
   ->  Bitmap Index Scan on seats_pkey  (cost=0.00..5.00 rows=97 width=0)
         Index Cond: (aircraft_code = 'SU9'::bpchar)
```

Для отбора через `WHERE` используется индекс - `Index Cond`. Дальше строится битовая карта, на этом этапе строки еще не выбираются и ширина = `0`. В верхнем узле идет отбор строк по построенной битовой карте

---
> В запросе идет выборка значений только индексированного столбца в некотором диапазоне:
> 
> ```sql
> EXPLAIN SELECT book_ref FROM bookings WHERE book_ref < '000FFF';
> ```
> 
> Сколько строк будет в выводе команды `EXPLAIN`?

Две, планировщик здесь выбирает метод просмотра исключительно на основе индекса (+ фильтрация):

```
                                    QUERY PLAN
-----------------------------------------------------------------------------------
 Index Only Scan using bookings_pkey on bookings  (cost=0.42..8.47 rows=3 width=7)
   Index Cond: (book_ref < '000FFF'::bpchar)
```

В этом плане только один узел - `Index Only Scan`. Здесь также первая оценка стоимости не нулевая, т.к. отыскание в индексе наименьшего значения требует некоторого времени

---
> На каком уровне плана будет выполнено агрегирование?
> 
> ```sql
> EXPLAIN SELECT count(*) FROM seats;
> ```

На верхнем, на нижнем будет последовательный просмотр:

```
                          QUERY PLAN
---------------------------------------------------------------
 Aggregate  (cost=24.74..24.75 rows=1 width=8)
   ->  Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=0)
```

Как видно, само агрегирование занимает не так уж много времени (`24.74 - 21.39`)

Если в этот запрос добавить условие `WHERE aircraft_code = 'SU9'`, то будет использован индекс, и вместо простого последовательного просмотра будет сканирование на основе битовой карты (это как-то связано с проверкой видимости строк в разных транзакциях)

---
> Дан запрос вида:
> 
> ```sql
> EXPLAIN SELECT ... FROM a JOIN b ON a.key = b.key WHERE ... ORDER BY ...
> ```
> 
> В каком порядке планировщик расположит узлы плана? Какие возможны варианты соединения строк?

Сортировка на верхнем, фильтрация на нижнем, `JOIN` в середине:

```
                                      QUERY PLAN
---------------------------------------------------------------------------
 Sort  (cost=63.17..63.54 rows=149 width=59)
   Sort Key: s.seat_no
   ->  Nested Loop  (cost=5.43..57.79 rows=149 width=59)
     ...
        ->  Bitmap Index Scan on b_pkey  (cost=0.00..5.39 rows=149 width=0)
              Index Cond: (key = b.key)
```

Варианты соединений: Nested Loop (вложенный цикл), Hash Join (хеш-таблица) и Merge Cond (слияние), в зависимости от таблиц

---
> О чем говорит большой разрыв в цифрах `cost` (напр., `cost=0.42..67058.74`) в выводе `EXPLAIN`?

Первая оценка говорит, сколько ресурсов будет затрачено (сколько времени, в условных единицах, пройдет) до начала вывода первых результатов выполнения операции на данном уровне дерева плана. Вторая оценка показывает общее количество ресурсов, требующихся для полного завершения операции на данном уровне дерева плана

Таким образом, можно заключить, что вывод результирующих строк начнется еще задолго до завершения всех действий на данном шаге (напр., сканирования исходных таблиц)

---
> Как задаются настройки планировщика?

Командой `SET`:

```sql
SET enable_hashjoin = off;
```

---
> Какие три настройки планировщика управляют методами соединения строк?

Все имеют формат `enable_*`:

```sql
SET enable_hashjoin = off;
SET enable_mergejoin = off;
SET enable_nestloop = off;
```

По умолчанию все эти параметры имеют значение `on` (включено). Установка параметра в `off` не запрещает метод полностью, но устанавливает ему очень высокую "стоимость"

---
> В чем отличие `EXPLAIN` от `EXPLAIN ANALYZE`?

Во втором случае запрос физически выполнится, и вместо оценок будут получены точные цифры. Под строками оценок добавятся строки фактического времени выполнения узлов. Могут быть добавлены строки с информацией о расходах дисковой памяти:

```
(actual time=0.087..10642.643 rows=1045726 loops=1)
Sort Method: external sort Disk: 2768kB
```

Внизу будет выведен общий итог:

```
Planning time: 122.347 ms
Execution time: 10948.791 ms
```

Результат запроса (строки выборки) при этом выведен на консоль не будет, только информация о плане

---
> Какой параметр добавляет опция `ANALYZE` для `EXPLAIN` в узлы плана?

`loops` - фактическое число повторений каждого конкретного узла

---
> Каким алгоритмом обычно выполняется `ORDER BY` в запросах?

`quicksort`, а точно можно посмотреть через `EXPLAIN ANALYZE` - она пишет строчки вроде

```
Sort (actual time=3.423..3.666 rows=426 loops=1)
  Sort Key: s.seat_no
  Sort Method: quicksort Memory: 46kB
```

для узлов сортировки

---
> Каков общий синтаксис записи опций для `EXPLAIN`?

В скобках, через запятую:

```sql
EXPLAIN (ANALYZE, COSTS OFF) UPDATE ...
```

---
> Можно ли вызывать `EXPLAIN` на запросах, отличающихся от `SELECT`?

Да, вполне, можно например тестировать им `INSERT`/`UPDATE`

---
> Какой рекомендуемый способ выполнения `EXPLAIN ANALYZE` с запросами, изменяющими данными?

Т.к. с опцией `ANALYZE` команда `EXPLAIN` физически выполнит запрос, это может изменить данные, что нежелательно. Поэтому рекомендуется такие проверки выполнять внутри транзакции, завершая ее откатом:

```sql
BEGIN;
EXPLAIN (ANALYZE, COSTS OFF) UPDATE ...;
ROLLBACK;
```

---
> Зависит ли выбор плана запроса от размера таблицы?

Да, зависит, и это одна из причин, почему нельзя экстраполировать, пусть даже и с некоторыми поправками, оценки, полученные для таблиц небольшого размера, на таблицы большого размера. Оценки, вычисляемые планировщиком, не являются линейными

Например, для маленькой таблицы может быть выбрано последовательное сканирование, а для большой - сканирование по индексу

---
> Как принудительно обновить статистику планировщика запросов?

Вызвать команду `ANALYZE` на нужной таблице:

```sql
ANALYZE aircrafts;
```

---
> Как можно прервать выполнение команды в интерактивном терминале?

```
Ctrl + C
```

---
> Для какого рода операций в выборках наличие индекса будет ускорять процесс?

Для поиска/соединения/фильтрации - для тех, где сравниваются значения столбцов. Например, в:

```sql
WHERE t.book_ref = b.book_ref
```

создание индекса `book_ref` изменит план построения запроса, станет использоваться индекс вместо обычного `Filter`

---
> В каких случаях в качестве метода доступа может использоваться просмотр исключительно на основе индекса (index only scan) вместо обычного просмотра по индексу (index scan)?

Например, когда нужно найти лишь число строк:

```sql
count(*)
```

а их содержимое (напр., `avg(col1)`) не нужно

---
> Чем можно заменить корелированный подзапрос? Зачем это может понадобиться?

Можно заменить (внешним) соединением таблиц, `JOIN`-ом

Это может понадобиться в целях оптимизации, но нужно проверять через `EXPLAIN [ANALYZE]`, это не общий рецепт ускорения запросов

---
> Как называется узел плана запроса, относящийся к оконной функции?

```
WindowAgg
```

---
> Как в интерактивном терминале выполнить команды из файла?

```
# \i <file>
```

---
> Перечислите четыре способа повышения производительности через изменение схемы данных, связанное с денормализацией

1. создание материализованных представлений
2. использование вычисляемых столбцов
3. использование временных таблиц
4. создание индексов

---
> Как можно сгенерировать таблицу с целочисленным столбцом, заполненным последовательными значениями?

Воспользоваться функцией `generate_series()` + синтаксисом `CREATE TABLE ... AS SELECT`:

```sql
CREATE TABLE nulls AS
  SELECT num::integer, 'TEXT' || num::text AS txt
    FROM generate_series(1, 200000) AS gen_ser(num);
```

Во втором столбце здесь генерируются строки вида `TEXT1`, `TEXT2`, etc.

---
> Дана сортировка для столбца, содержащего неопределенные значения:
> 
> ```sql
> ... ORDER BY num NULLS FIRST;
> ```
> 
> Будет ли в таком случае для сортировки использоваться индекс?

Нет, не будет. Направление `ASC` предполагает расположение `NULL`-значений в конце. Здесь же они принудительно указаны в начале

Так что, для использования индекса, нужно либо убрать `NULLS FIRST`, либо добавить `DESC`

---
> Как рекомендуется поступать с индексами таблиц при массовом вводе данных?

Индексы обновляются при вставке каждой строки, так что массовая заливка данных может привести к сильной потере производительности во время ввода

Рекомендуется удалять индексы до заливки большого количества данных, и пересоздавать их после

---
> Как можно и как нужно хранить JSON?

Хранить можно хоть в `text`, но недостаток этого - строка JSON-а не проверяется на валидность. Лучше использовать типы `json[b]`, для них и специальные операторы есть

---
> Как типы `json` и `jsonb` обрабатывают повторяющиеся ключи в объектах?

`json` хранит как есть - все, а `jsonb` только последний

`json`, кроме того, сохраняет и незначащие пробелы

---
> В какие типы Postgres преобразуются примитивы JSON при сохранении в поле типа `jsonb`?

- `string` ~ `text`
- `number` ~ `numeric`
- `boolean` ~ `boolean` (допустимы только литералы `true`/`false` в нижнем регистре)
- `null` - нет соответствия, в PSQL `NULL` имеет другой смысл

---
> Допускается ли преобразование гетерогенных массивов в тип `json[b]`?

Да, вполне. Запрос:

```sql
SELECT '[1, 2, "foo", null]'::jsonb;
```

выдаст

```
        jsonb
---------------------
 [1, 2, "foo", null]
```

---
> Что выдаст этот запрос?
> 
> ```sql
> SELECT '{"bar": "baz", foo: 1}'::json;
> ```

Ошибку

```
ERROR:  invalid input syntax for type json
DETAIL:  Token "foo" is invalid.
```

Ключи объектов в JSON-строках обязаны быть в кавычках

---
> В каком формате выведет числа этот запрос?
> 
> ```sql
> SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
> ```

Тип `jsonb` приводит примитивные типы JSON к внутренним типам Postgres, так что отображаться числа будут по-разному:

```
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
```

---
> Когда, кем и где была начата работа над Postgres?

В 1985 году, профессором Калифорнийского университета в Беркли Майклом Стоунбрейкером (Michael Stonebraker)

До этого он возглавлял разработку INGRES - одной из первых реляционных СУБД, - и POSTGRES возник как результат осмысления предыдущей работы и желания преодолеть ограниченность жесткой системы типов

---
> Когда была выпущена первая версия Postgres?

В 1989 году, после публикации между 85 и 88м годами нескольких статей и описания языка POSTQUEL (в то время SQL ещене был общепризнанным стандартом)

POSTGRES иногда относят к так называемым постреляционным СУБД. Ограниченность реляционной модели всегда была предметом критики, хотя и являлась обратной стороной ее простоты и строгости

---
> В каком году и на какой версии проект POSTGRES был закрыт?

В 1993м, на v4.2

---
> Что произошло с POSTGRES в 1994-95 годах?

Выпускники Беркли Эндрю Ю и Джоли Чен в 1994 году выпустили Postgres95, воспользовавшись открытым кодом и BSD-лицензией исходной разработки

Они заменили язык запросов POSTQUEL на ставший к тому времени общепринятым SQL, а проект назвали Postgres95

---
> Когда PostgreSQL получил свое текущее имя? Какая была в это время версия?

В 1996м году, когда стало ясно, что название Postgres95 не выдержит испытание временем. Новое название отражает связь и с оригинальным проектом POSTGRES, и с переходом на SQL в предыдущей версии

Новая версия стартовала как 6.0, продолжая исходную нумерацию

---
> Кто управляет проектом PostgreSQL?

Группа инициативных пользователей и разработчиков - *Глобальная группа разработки PostgreSQL* (PostgreSQL Global Development Group)

Все основные решения о планах развития и выпусках новых версий принимаются Управляющим комитетом (Core team), состоящим сейчас из пяти человек

Помимо обычных разработчиков, вносящих посильную лепту в развитие системы, выделяется группа основных разработчиков (major contributors), сделавших существенный вклад в развитие PostgreSQL, а также группа разработчиков, имеющих право записи в репозиторий исходного кода (committers)

---
> С какой периодичностью выходят новые версии PostgreSQL?

Примерно раз в год

В некоторый момент (обычно весной, примерно за полгода до релиза) объявляется этап стабилизации кода

---
> Какая нумерация принята для версий Postgres?

Раньше номер основной версии состоял из двух чисел, но, начиная с 2017 года, было решено оставить только одно. Таким образом, за 9.6 последовала 10, а последней актуальной версией PostgreSQL является версия 12, вышедшая в октябре 2019 года

Обычно раз в квартал выпускается дополнительные (minor) версии, включающие накопленные исправления. Например, версия 10.6 содержит только исправления ошибок, найденных в 10.5, а 11.2 - для версии 11.1

---
> Сколько времени с момента релиза поддерживаются версии Postgres?

Пять лет с момента выпуска Глобальная группа разработки PostgreSQL (PostgreSQL Global Development Group) выполняет поддержку основных версий системы

Поддержка, как и координация, осуществляется через списки рассылки

Есть и коммерческие компании, осуществляющие поддержку

---
> Перечислите три вида репликации в Postgres

- синхронная
- асинхронная
- каскадная

---
> Сколько обязательных возможностей стандарта SQL2016 поддерживает Postgres?

160 из 179, и множество необязательных

---
> Какая система используется на уровне изоляции транзакций Serializable?

Serializable Snapshot Isolation, обеспечивает полное отсутствие аномалий сериализации и гарантирует, что при одновременном выполнении транзакций результат будет таким же, как и при последовательном выполнении

---
> Какие типы индексов поддерживаются в Postgres?

Стандартные и самые распространенные - это индексы на основе B-деревьев. Помимо них могут использоваться:

- Hash - индекс на основе хеширования. Проверка только на равенство, но иногда могут оказаться быстрее и компактнее
- GiST - обобщенное сбалансированное дерево поиска, которое применяется для данных, не допускающих упорядочения
- SP-GiST - обобщенное несбалансированное дерево, основанное на разбиении области значений на непересекающиеся вложенные области
- GIN - обобщенный инвертированный индекс, используется для сложных значений. Основные области применения: полнотекстовый поиск, поиск значений в массивах данных
- BRIN - компактная структура, позволяющая найти компромисс между размером индекса и скоростью поиска. Эффективен на больших кластеризованных таблицах
- Bloom - индекс, основанный на фильтре Блума

---
> По каким данным может строиться индекс?

Вариантов много:

- индекс может строиться как по столбцам, так и по выражениям
- и столбцов и выражений в индексе может быть несколько
- частичные индексы охватывают лишь часть строк

---
> Что позволяет делать *покрывающий* индекс?

Ускорять запросы за счет того, что все необходимые данные извлекаются из самого индекса без обращения к таблице

---
> На каком языке написана PostgreSQL?

На C. Это обеспечивает высокую кроссплатформенность и переносимость кода

---
> Назовите две самые известные системы, построенные на основе расширений PostgreSQL

- CitusDB - возможность распределения данных по разным экземплярам PostgreSQL (шардинг) и массивно-параллельного выполнения запросов
- PostGIS - одна из наиболее известных и мощных систем обработки геоинформационных данных

---
> Под какой лицензией распространяется  PostgreSQL?

Под собственной, PostgreSQL License, схожей с BSD и MIT

---
> Как выполнить SQL-запрос из командной строки?

Опция клиента `-c`:

```
$ sudo -u postgres psql -c 'select now()'
```

---
> Где расположен файл журнала службы PostgreSQL?

```
/var/log/postgresql/postgresql-12-main.log
/var/log/postgresql/postgresql-12-main.log.1
```

---
> Где на файловой системе хранятся файлы баз данных?

В каталоге

```
/var/lib/postgresql/12/main/
```

И для самого каталога, и для файлов внутри, владельцем установлен юзер `postgres`. Служба вообще работает от него

---
> Какие операторы должны быть определены в реляционной системе?

*Сокращения* - позволяющий получить подмножество строк таблицы, и *проекции* - позволяющий получить подмножество ее столбцов

---
> Как выдать права на операции в таблице какому-либо пользователю?

Например, на выборку и вставку (или сразу все):

```sql
GRANT SELECT, INSERT ON <table-name> TO <user-name>;
GRANT ALL [PRIVILEGES] ON <table-name> TO <user-name>;
```

---
> Как отозвать права на операции в таблице у какого-либо пользователя?

Например, на выборку и вставку (или сразу все):

```sql
REVOKE SELECT, INSERT ON <table-name> FROM <user-name>;
REVOKE ALL [PRIVILEGES] ON <table-name> FROM <user-name>;
```

---
> Какая база называется *реляционной*?

Такая, в которой все данные организованы в виде таблиц, а все операции выполняются над этими таблицами

---
> Назовите два подкласса Data Language (DL)

- DDL - Data Definition Language - определение БД (напр., `CREATE TABLE`)
- DML - Data Manipulation Language - вставка, редактирование, удаление и извлечение

---
> Какие существуют три типа бинарных связей?

- один к одному (редко; неправильное проектирование?)
- один ко многим (самое частое)
- многие ко многим (не поддерживается реляционной моделью напрямую; через промежуточную таблицу)

---
> В чем преимущества и недостаток выбора естественного первичного ключа?

Преимущества:

- не тратится доп. память
- дополнительная проверка на корректность ввода информации

Недостатки:

- данные в столбцах, из которых состоит естественный ключ, могут правиться человеком. Это требует обновления всех ссылающихся записей

Суррогатные первичные ключи имеют свои преимущества и недостатки (обратные перечисленным)

---
> Какие аномалии решает нормализация таблиц?

- аномалию вставки - нельзя записать информацию об одной сущности, не записав при этом информацию о другой (нет отдельной таблицы для этого)
- аномалию редактирования - потеря целостности данных, необходимость редактирования сразу всех записей, при изменении одной сущности
- аномалию удаления - нельзя удалить информацию об одной сущности, не удалив при этом информацию о другой

То есть, эти аномалии возникают когда в записи таблицы хранится информация более чем об одной сущности. И нормализация эту проблему устраняет

---
> Какие ограничения накладываются на данные в столбце?

- физические - тип столбца. Он устанавлает формат хранения и определяет набор допустимых операций с данными
- логические - ограничения предметной области, домена. Они дополняют предыдущие, обеспечивают дополнительную целостность данных

Пример - дата рождения. Тип `datetime` устанавливает базовое ограничение на формат данных, а явное ограничение `> 18 лет` описывает требования доменной области

---
> Какие основные требования к 1NF?

- нет повторяющихся строк
- значения столбцов атомарны
- строки и столбцы не упорядочены

В реляционной теории любая таблица уже находится в первой нормальной форме

---
> Что попадает под определение "отношение"?

Не только таблицы, но и их объединение, и, например, результаты `SELECT`

---
> Какая модель лежит в основе архитектуры Postgres?

Клиент-сервер. Сервер PostgreSQL может обслуживать одновременно несколько подключений клиентов. Для этого он запускает ("порождает") отдельный процесс для каждого подключения. Можно сказать, что клиент и серверный процесс общаются, не затрагивая главный процесс `postgres`

Клиент и сервер могут располагаться на разных компьютерах. В этом случае они взаимодействуют по сети TCP/IP

---
> Как создать/удалить базу данных из командной строки?

Утилитами `createdb`/`dropdb`:

```shell
$ createdb my_db
$ dropdb my_db
```

---
> Как `psql` указать имя базы данных для подключения?

Через опцию `-d, --dbname=DBNAME` или просто параметром команды:

```shell
$ psql -d my_db
$ psql my_db
```

---
> Чем отличается синтаксис команд `GRANT` и `REVOKE`?

Ключевыми словами `TO`/`FROM`:

```sql
GRANT ALL PRIVILEGES ON some_table TO PUBLIC;
REVOKE INSERT ON some_table FROM localhost
```

---
> В каком случае Postgres всё же чувствителен к регистру?

SQL не чувствителен к регистру в ключевых словах и идентификаторах, за исключением идентификаторов, взятых в кавычки

---
> Как по-русски называется тип `real`?

Числа с плавающей точкой одинарной точности

---
> Как называется тип данных "координатная точка"?

```sql
p point
p = '(-194.0, 53.0)'
```

---
> Дана команда
> 
> ```sql
> COPY weather FROM '/home/user/weather.txt';
> ```
> 
> На какой машине должен быть доступен этот файл?

На сервере, не на клиенте

---
> Что не так с этим запросом?
> 
> ```sql
> SELECT city FROM weather WHERE temp_lo = max(temp_lo);
> ```

Агрегатная функция не может использоваться в `WHERE`: `WHERE` определяет, для каких строк будут вычисляться агрегатные функции, так что на этой стадии они еще не могут использоваться

Можно переписать, применив подзапрос:

```sql
SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
```

---
> Что делает `HAVING`?

Фильтрует результат группировки, фильтрует сгруппированные строки

---
> Может ли `HAVING` содержать агрегатные функции?

Может, и почти всегда содержит: без них он не очень полезен. В этом его важное отличие от `WHERE`, где агрегаты использоваться не могут

---
> Как можно переписать `HAVING`, в котором не используются агрегатные функции?

Перенести его условие в `WHERE` - там оно будет работать более эффективно: на более ранней стадии будут отсечены ненужные строки, и в стадии группировки будет уже меньше данных

---
> Приведите пример операций, когда нужны транзакции

Банковские операции, например:

- перевод денег со счета на счет
- снятие денег со своего счета

Не должно быть ситуации, что деньги из одного источника ушли, но до другого не дошли. В случае сбоя в процессе, они должны возвращаться обратно (атомарность, "всё или ничего")

---
> На какой стадии запроса формируются "разделы" для оконных функций?

На поздних, после `FROM`, `WHERE`, `GROUP BY` и `HAVING`. Так например, строка, отфильтрованная в `WHERE`, не будет видна для оконных функций

---
> Как реализуется *наследование* таблиц?

Через ключевое слово `INHERITS` можно наследовать одну или несколько таблиц:

```sql
CREATE TABLE cities (
  name       text,
  population real,
  elevation  int
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);
```

В данном случае строка таблицы `capitals` наследует все столбцы (`name`, `population` и `elevation`) от родительской таблицы `cities`, и добавляет один собственный столбец

---
> Можно ли использовать ключевое слов в качестве идентификатора?

Только если заключить его в двойные кавычки:

```sql
SELECT * FROM "select";
```

Кроме того, имена в кавычках позволяют создавать идентификаторы с любыми символами, например, с пробелами. Идентификатор, заключённый в кавычки, становится зависимым от регистра

---
> Какие автоматические действия выполняются в реляционной модели для поддержания целостности данных?

Например, каскадные: обновление внешних ключей или удаление записей из подчиненных таблиц

Это одно из (больших) удобств реляционной модели, эти операции не приходится реализовывать вручную. Декларативный характер SQL избавляет программиста от работы на атомарном уровне

---
> Что такое *неизбыточность* потенциального ключа?

Никакое подмножество его атрибутов не должно быть уникальным

---
> Как выравнивается вывод в зависимости от типа?

Строки выравниваются по левому краю, а числа по правому

---
> Что происходит при попытке вставки более длинной, чем допустимо, строки в поля `[var]char(n)`?

Выбрасывается ошибка

```
ERROR:  22001: value too long for type character[ varying](3)
```

---
> Как узнать версию PostgreSQL?

В консоли:

```shell
$ psql --version
```

В интерактивном терминале:

```sql
SELECT version();
```

---
> Что делает опция `$ psql -s`?

Переводит интерактивный терминал в пошаговый режим, когда требуется подтверждение каждой команды

---
> Можно ли использовать агрегатные функции без `GROUP BY`?

Да, вполне:

```sql
SELECT max(temp_lo) FROM weather;
```

Но стоит помнить, что агрегатные функции вычисляются на поздних этапах, после `WHERE` (для использования их в `WHERE` нужно включать в условие подзапрос)

---
> Что выполняется раньше, оконные или (настоящие) агрегатные функции?

Оконные функции выполняются последними. Это значит, что агрегатную функцию можно вызывать в аргументах оконной, но не наоборот

---
> Как можно использовать результаты оконных функций в `WHERE` или `GROUP BY`?

Оконные функции выполняются последними, так что только через подзапрос:

```sql
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
    rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
   FROM empsalary
  ) AS ss
WHERE pos < 3;
```

---
> В каких случаях выражения с `NULL` возвращают определенное значение?

Для двух логических операторов - `AND` и `OR` - при вычислении по короткой цепи:

```sql
SELECT true OR NULL, false AND NULL;
```

```
 ?column? | ?column?
----------+----------
 t        | f
```

---
> В каких случаях `NULL` равен сам себе?

При сравнении строк в `GROUP BY`

Стандартом ISO определено, что при проведении группировки все отсутствующие значения рассматриваются как равные. Если две строки таблицы в одном и том же группируемом столбце содержат значения NULL, а значения во всех остальных непустых группируемых столбцах идентичны, то они помещаются в одну и ту же группу

---
> Как группировать по месяцу данные из столбца с типом `timestamp[tz]`?

```sql
GROUP|PARTITION BY date_trunc('month', col_name)
```
