- <https://postgrespro.ru/docs/postgrespro/current/>
- <https://www.sqlstyle.guide/ru/>
- <https://planet.postgresql.org>
- <https://wiki.postgresql.org/wiki/Main_Page>

#### Лузанов П. и др., Postgres: первое знакомство
<https://postgrespro.ru/education/books/introbook>

#### Моргунов Е., PostgreSQL. Основы языка SQL
<https://postgrespro.ru/education/books/sqlprimer>

---
> Сохраняется ли порядок добавления строк в таблицу?

Нет, строки неупорядочены, хранятся не обязательно в порядке добавления

---
> Как называются целый, логический и строковый типы?

`integer`, `boolean` (`true`/`false`) и `text` соответственно

---
> Какой литерал у *неопределенного* значения?

```sql
NULL
```

---
> Какой синтаксис у описания столбца в `CREATE TABLE`?

`<name> <type>[ <PRIMARY KEY>]`:

```sql
CREATE TABLE courses(
    c_no text PRIMARY KEY,
    title text,
    hours integer
);
```

---
> Какие ограничения для данных в столбце `PRIMARY KEY`?

- значения должны быть уникальны
- неопределенные (`NULL`) значения не допускаются

Второе ограничение действует на любой компонент составных ключей

---
> Какой командой лучше массово загружать данные в таблицы?

`COPY`, не `INSERT`

---
> Какой общий синтаксис у `INSERT`?

Перечисление имен столбцов не обязательно, но тогда нужно передавать значения в том порядке, в котором они следуют в определении таблицы:

```sql
INSERT INTO <table-name> [(<column-names>)] VALUES (<values>);
INSERT INTO students (s_id, name, start_year) VALUES (1451,'Анна', 2014);
```

---
> Что по умолчанию выводит `INSERT`?

Цифры - это `oid` (всегда `0`) + количество вставленных строк:

```
INSERT 0 3
```

Когда-то поддерживалось `WITH OID` при создании таблиц, и первое число могло быть не нулем, но больше это не доступно. Если `INSERT` содержит инструкцию `RETURNING`, то вывод будет таким, как указано в ней

---
> Как в `CREATE TABLE` задать первичный ключ из нескольких столбцов?

После описания всех столбцов, используя ключевое слово `PRIMARY KEY`:

```sql
  ...
  score integer,
  [CONSTRAINT pk ]PRIMARY KEY(s_id, c_no)
);
```

---
> Какой синтаксис у объявления внешнего ключа вместе со столбцом?

Через ключевое слово `REFERENCES` и ссылку вида `<table-name>(<column>)`:

```sql
CREATE TABLE exams(
  s_id integer REFERENCES students(s_id),
  ...
```

---
> Как именуются столбцы в выводе `SELECT`-а?

- используется алиас (`AS <alias>`)
- если `AS` не указан - то имя самого столбца
- `?column?` - если имя неопределено (напр., `SELECT 1` или столбец вычисляемый)

---
> К какой части `SELECT` относится `DISTINCT`?

К ключевому слову, т.е. ко всей выборке, а не к отдельному столбцу:

```sql
SELECT DISTINCT name, start_year FROM students;
-- SELECT name, DISTINCT start_year FROM students; /* syntax error */
```

---
> Какие комментарии есть в PostgreSQL?

Два дефиса и стандартный блочный:

```sql
-- Single-line comment
/*
 Multi-line comment
*/
```

---
> Сколько строк будет содержать результат `SELECT` без `FROM`?

Одну:

```sql
SELECT 2+2 AS result;
```

```
 result
--------
      4
```

---
> При каких результатах сравнения в `FROM` строка попадет в результат `SELECT`-а?

Если сравнение истинно. Не попадет, если сравнение ложно или *не определено* (напр, сравнение с `NULL`)

---
> В каких случаях результат операции не *определен*?

Все связаны с неопределенным значением `NULL`:

- результат сравнения чего угодно с `NULL` не определен
- результат логическиз операций с `NULL`, как правило, не определен


Как правило, это важно в `WHERE` - строки, для которых результат сравнения не определен, в результат `SELECT`-а не попадают

---
> В каких случая логические операции с `NULL` всё же возвращают определенные значения?

Их два:

```sql
true OR NULL = true
false AND NULL = false
```

---
> Какой синтаксис у операторов "равно" и "не равно"?

Одинарное равно и две формы для "не равно":

```sql
-- equals
=
-- not equals
<>
!=
```

---
> Какими способами можно получить прямое (декартово) произведение таблиц?

С точки зрения СУБД обе формы эквивалентны:

```sql
FROM t1, t2 WHERE t1.id = t2.id
FROM t1 JOIN t2 ON t1.id = t2.id
```

Выборку без ограничивающего условия можно получить только первым способом

---
> Почему `LEFT JOIN` называется "левый"?

В выборку добавляются строки из левой таблицы даже такие, для которых не нашлось пары в правой

---
> На каком этапе выполняется `WHERE` в запросах с `JOIN`-ами? Какие подводные?

Условие в `WHERE` выполняется *после* `JOIN`-а, применяется к уже готовому соединению. Поэтому, для `LEFT JOIN` возможна ситуация когда столбцы правой таблицы окажутся равными `NULL`, и сравнение с ними в `WHERE` не сработает

---
> В каких частях запроса можно использовать подзапросы (вложенный `SELECT`)?

Зависит от того, сколько строк такой подзапрос возвращает:

- если одну или меньше, то такой подзапрос называется *скалярным*, и его можно использовать как единственное значение, в том числе в списке столбцов для выборки или в условиях `WHERE`
- если больше одной строки, то в качестве источника ("таблицы") в `FROM`/`JOIN`, или также в `WHERE`, но только с операторами принадлежности существования, вроде `[NOT] IN`/`[NOT] EXISTS`

---
> Какое значение используется в качестве результата скалярного подзапроса, не возвращающего ни одной строки?

Неопределенное, `NULL`:

```sql
SELECT c1, (SELECT ...) as c2 FROM ...;
```

```
  c1  | c2
------+----
 some |
```

---
> Как можно преобразовать скалярный подзапрос, используемый в качестве значения в столбце?

В `LEFT JOIN`

Соединение должно быть именно внешнее: скалярный подзапрос в списке столбцов `SELECT`-а возвращает `NULL`, если для него не найдено ни одной строки; для `INNER JOIN` же возврат неопределнного значения невозможен

---
> Можно ли в подзапросе ссылаться на таблицу из внешнего `SELECT`-а?

Да, вполне:

```sql
SELECT name, (
  SELECT score FROM exams WHERE exams.s_id = students.s_id
) FROM students;
```

---
> Как указываются алиасы имен столбцов/таблиц?

`AS` при этом не обязательно:

```sql
SELECT name AS n FROM students AS s;
SELECT name n FROM students s;
```

---
> Где в `ORDER BY` указывается `ASC`/`DESC`?

После каждого ключа, не одно на всё выражение:

```sql
SELECT * FROM students ORDER BY name ASC, start_year DESC;
```

---
> Каков по умолчанию порядок сортировки в `ORDER BY`?

```sql
ASC
```

---
> Где в составных запросах имеет смысл располагать `ORDER BY`?

Только в конце основного запроса, перед получением результата. В подзапросах она обычно бесполезна

---
> Что делает `GROUP BY`?

Разбивает результат выборки на группы, на основе указанного в `GROUP BY` поля/выражения

---
> Какие агрегатные функции дают количество записей и среднее значение?


```sql
count(<field>|*)
avg(<field>)
```

---
> В каком порядке применяются условия фильтрации `WHERE` и `HAVING` в запросах с группировкой?

- сначала, до группировки, применяется `WHERE` - там можно использовать только столбцы исходных таблиц
- группировка `GROUP BY`
- потом, после группировки, применяется `HAVING` - там уже можно использовать столбцы таблицы-результата

---
> В каких условиях фильтрации можно использовать агрегатные функции?

Только в `HAVING`, в `WHERE` выдаст ошибку

```
aggregate functions are not allowed in WHERE
```

---
> Какой общий синтаксис у `UPDATE` и `DELETE`?

```sql
UPDATE courses SET hours = hours * 2 WHERE c_no = 'CS301';
DELETE FROM exams                    WHERE score < 5;
```

Обе команды выводят количество измененных/удаленных записей:

```
UPDATE 1
DELETE 1
```

---
> Как запретить неопределенные значения в столбце?

При создании таблицы, после типа столбца, указать `NOT NULL`:

```sql
CREATE TABLE groups(
  monitor integer NOT NULL
);
```

---
> Как добавить поле в таблицу?

Спецификация столбца такая же, как при создании таблицы:

```sql
ALTER TABLE students ADD g_no text REFERENCES groups(g_no);
```

---
> Как вставить в таблицу данные из результатов выборки (из другой таблицы)?

Вместо `VALUES` напрямую указать `SELECT`:

```sql
INSERT INTO groups(g_no, monitor)
SELECT 'A-101', s_id FROM students WHERE name = 'Анна';
```

---
> Какие команды начинают, завершают или откатывают транзакцию?

```sql
BEGIN
...
COMMIT
ROLLBACK
```

---
> Какие есть свойства у транзакций?

- *атомарность* - между командами `BEGIN` и `COMMIT` выполняются либо все команды, либо ни одной
- *согласованность* - данные в конце транзакции должны удовлетворять всем ограничениям (могут ли не удовлетворять внутри транзакции?)
- *изоляция* - параллельные процессы не видят изменений до окончания транзакции, им недоступны еще не согласованные данные. Доступ до базы при этом во время транзакции не блокируется
- *долговечность* - зафиксированные данные не пропадут даже в случае сбоя


---
> Один клиентский процесс `psql` начал (но еще не завершил) транзакцию, и записал несколько строк в таблицу. Что выдаст `SELECT` на этой таблице для текущего и параллельного процессов?

- выборка в текущем процессе (с открытой транзакцией, после `BEGIN`) выдаст все вставленные строки
- выборка в параллельном процессе даст пустой результат: до завершения транзакции первым процессом (до `COMMIT` в первом процессе) результаты этой транзакции никому не доступны

---
> Различаются ли результаты вызова этих двух агрегатных функций?
> 
> ```sql
> count(*)
> count(DISTINCT id)
> ```

Да, различаются. Например, на таблице вида

```
  id
------
 1451
 1556
 1451
 1432
```

запрос

```sql
SELECT count(id), count(DISTINCT id) FROM ...;
```

выдаст

```
 count | count
-------+-------
     4 |     3
```

---
> В чем принципиально различие?
> 
> ```sql
> LEFT JOIN exams ON students.s_id = exams.s_id AND exams.c_no = 'CS305';
> LEFT JOIN exams ON students.s_id = exams.s_id WHERE exams.c_no = 'CS305';
> ```

В `WHERE` стоит операция сравнения, а она не определена при сравнении с `NULL`. Так как `WHERE` выполняется последним, а `LEFT JOIN exams` может привести к появлению `NULL`-значений, проверка в `WHERE` отсечет значения, для которых при соединении не нашлось пары

То есть первый вариант дает более "широкий" результат, а второй отсекает все `c_no = NULL`

---
> Как можно получить текущие дату и время?

Функция `now()`:

```sql
SELECT now();
```

```
              now
-------------------------------
 2020-06-14 06:16:56.282864+04
```

Эквивалентна

```sql
SELECT current_timestamp;
```

---
> Как называется Python-модуль для соединения с Postgres-ом?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
psycopg2
```

Версия 2 поддерживает массовую многопоточность и асинхронность

---
> Как через `python3-psycopg2` работать с базой?

Пять шагов:

```python
# 1. Подключение
conn = psycopg2.connect(
    database='appdb',
    user='app',
    ...
)
# 2. Получение курсора
cur = conn.cursor()
# 3. Выполнение запроса
cur.execute('SELECT * FROM greeting')
# 4. Получение списка кортежей записей
for row in cur[.fetchall()]:
    print row[0]
# 5. Закрытие соединения
conn.close()
```

---
> Какие есть 4 оператора полнотекстового поиска?

```sql
-- Из SQL-стандарта
LIKE -- он же @@
-- Специфичные для PostrgeSQL
ILIKE -- LIKE, не чувствительный к регистру
~
~*
```

---
> Как вставить JSON в поле таблицы?

- поле должно быть объявлено с типом `json`
- данные вставляются стандартно, через `INSERT`, как строка (в одинарных кавычках) валидного JSON-а

---
> Как обратиться к ключу верхнего уровня в поле с типом `json`?

Через оператор `->>`:

```sql
WHERE s.s_id = sd.s_id
AND sd.details ->> 'достоинства' IS NOT NULL
AND sd.details ->> 'достоинства' != 'отсутствуют'
```

---
> Как обратиться к ключу произвольного уровня в поле с типом `json`?

Через оператор `#>`, указав в фигурных сковках последовательность ключей или индексов:

```sql
'{"a": {"b": ["foo","bar"]}}'::json #> '{a,b,1}' -- "bar"
```

---
> В чем отличия `jsonb` от `json`?

Это бинарный формат хранения:

- данные в нем хранятся плотно упакованными (экономится место) и поиск по нему работает быстрее
- для преобразования в него нужно вызывать функцию `to_jsonb('...')`
- он не сохраняет порядок ключей в JSON
- для него другой набор операторов

---
> Как в `jsonb` проверить, что первое значение содержит второе?

Оператор `@>` работает и на вложенных объектах:

```sql
'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb -- t
'{"a":{"b":{c:1}}'::jsonb @>'{"a":{"b":{}}}'::jsonb -- t
```

---
> Как отформатировать вывод столбца типа `jsonb`?

Функция `jsonb_pretty()`:

```sql
SELECT s.name, jsonb_pretty(sd.details_b) FROM ...;
```

---
> Что делает функция `jsonb_each()`?

Разворачивает JSON-объект верхнего уровня в последовательность пар "ключ-значение"

---
> Что такое SQL/MED? Как реализуется в Postgres?

Это стандарт ISO/IEC9075-9 (Management of External Data) по работе в SQL с внешними источниками информации - как правило, другими СУБД (напр., MySQL)

Реализуется через специальные обертки. Создаются таблицы (foreign table), которые сами не содержат данных, а перенаправляют все обращения к внешнему источнику. Используются команды

```sql
CREATE FOREIGN DATA WRAPPER
CREATE SERVER
CREATE USER MAPPING
CREATE FOREIGN TABLE
IMPORT FOREIGN SCHEMA
```

---
> Как просмотреть список всех доступных расширений?

Он находится в таблице `pg_available_extensions`:

```sql
SELECT * FROM pg_available_extensions;
```

---
> Как установить расширение?

Например, для создания foreign table и связи с MySQL или другим экземпляром себя же:

```sql
CREATE EXTENSION mysql_fdw;
CREATE EXTENSION postgres_fdw;
```

Второе расширение и создаваемые на его основе внешние таблицы являются встроенным в PostgreSQL механизмом *шардинга*

---
> Как изменить значение конфигурационного параметра?

Отредактировать файл `/etc/postgresql/12/main/postgresql.conf` и перезагрузить настройки - например, выполнить от пользователя `postgres`

```sql
SELECT pg_reload_conf();
```

---
> Как узнать значение конфигурационного параметра?

Командой `SHOW`:

```sql
SHOW shared_buffers;
```

```
 shared_buffers
----------------
 128MB
```

---
> Как создать базу из дампа?

Перенаправить вывод, список SQL-команд на вход клиента, `psql`. Или воспользоваться его же опцей `-f`:

```shell
$ cat dump.sql | psql
$ psql < dump.sql
$ psql [-d <db-name>] -f dump.sql
```

При этом `sudo -u <user> psql` будет определять, от имени какого юзера выполняется заливка дампа, а `psql -U <user>` скажет, какому станет принадлежать создаваемая база

---
> Как создать нового пользователя?

От имени суперпользователя (`postgres`):

```sql
CREATE USER <user> PASSWORD '...';
```

---
> Как создать базу данных для другого пользователя?

С ключевым словом `OWNER`:

```sql
CREATE DATABASE <db-name> OWNER <user>;
```

Обычно выполняется от суперпользователя (`postgres`), чтобы хватило прав

---
> Какая библиотека является системным драйвером PostgreSQL?

Устанавливается apt-ом по умолчанию, идет в стандартной поставке:

```
libpq
```

Написана на C

---
> Как заставить сервер перечитать настройки конфигурационных файлов?

```sql
SELECT pg_reload_conf();
```

Или из командной строки

```shell
$ sudo service postgresql reload|restart
```

---
> Что значит метод аутентификации `md5`?

В отличие от `peer`/`trust`, это уже требование на ввод пароля пользователем вручную

---
> Что значит метод аутентификации `peer`?

Что PostgreSQL запрашивает имя текущего пользователя у операционной системы и считает, что ОС уже выполнила необходимую проверку (спросила у пользователя пароль)

Поэтому пользователю обычно не приходится вводить пароль при подключении к серверу на своем компьютере: достаточно того, что пароль был введен при входе в систему

---
> Какой формат у конфигурационного файла `pg_hba.conf`?

Строки разбиты на пять столбцов:

```
# TYPE  DATABASE  USER  ADDRESS  METHOD
local   all       all            peer
```

Строка из примера выше читается как "локальные соединения (`local`) к любой базе (`all`) под любым пользователем (`all`) должны проверяться методом `peer`". IP-адрес для локальных соединений не указывается

---
> Как называются два основных файла настроек?

```
postgresql.conf
pg_hba.conf
```

Оба хранятся в папке `/etc/postgresql/12/main/` (версия, естественно, может меняться)

---
> Какой формат по дефолту имеет строка приглашения в интерактивном терминале?

Имя текущей базы + `=` + решетка для суперпользователя или символ "больше" для обычного:

```
postgres=#
localhost=>
```

---
> Какой порт использует PostgreSQL по дефолту?

```
5432
```

Только на моей Ubuntu он почему-то `5433`

---
> Как в интерактивном терминале подключиться к базе от имени другого пользователя?

Так же, но после имени базы указать имя пользователя:

```
# \c <db-name> <user>
```

В конце можно также указать имя хоста и порт

---
> Как переподключиться к текущей базе?

Та же команда, но без аргумента:

```
# \c
```
Это бывает нужно для того, чтобы настройки применились после изменений

---
> Как создать полную "двоичную" резервную копию кластера СУБД?

Сохранит в каталоге `<backup>`:

```shell
$ pg_basebackup -D <backup>
```

---
> Какая команда создает дамп базы?

Вторая команда сохраняет все базы, а также пользователей и табличные пространства:

```shell
$ pg_dump <db-name>|$PGDATABASE [> dump.sql]
$ pg_dumpall [-f/--file=...]
```

Выводит в `stdout` SQL-команды. Если переменная среды `PGDATABASE` не задана, дампит дефолтную базу (совпадающую с именем текущего пользователя)

---
> Как выйти из интерактивного терминала?

```
# \q
```

---
> Как в интерактивном терминале включить/выключить отображение времени выполнения команд?

После этого самой нижней строкой будет отображаться `Time: N ms`:

```
# \timing [on|off]
```

По умолчанию выключено. Без опции переключает между значениями

---
> Как в интерактивном терминале сменить режим отображения на расширенный (построчный)?

По умолчанию такой режим отключен (`off`):

```
# \x [on|off|auto]
```

Без опций переключает между `on`/`off`. Опция `auto` выводит результаты по строкам только когда они не помещаются по ширине

---
> Чувствительна ли Postgres к регистру?

Backslash-команды да, а SQL-запросы нет, и это касается не только ключевых слов, но и имен таблиц/столбцов/etc.

---
> Как в текущей базе вывести список всех таблиц?

```
# \d[S+]
```

С невыбранной базой будет ошибка `Did not find any relations.`

---
> Как вывести описание таблицы?

```
# \d[S+] <table-name>
```

Выводит столбцы построчно:

```
test=# \d students
 s_id       | integer |           | not null |
 name       | text    |           |          |
 start_year | integer |           |          |
```

Вообще, `# \d <name>` отображает информацию для любого объекта СУБД

---
> Как отображается неопределенное значение в интерактивном терминале?

Никак, `NULL` в результатах выборок не отображается, вместо него пустая строка:

```sql
SELECT NULL;
```

```
 ?column?
----------

(1 row)
```

---
> Какой короткий вариант у опции командной строки `--help`?

Знак вопроса:

```shell
-?
```

Стоит помнить, что стандартное `-h` относится к другой опции - `--host=`

Кроме того, с короткой опцией нельзя получить справку по backslash-командам и переменным, они доступны лишь с длинным именем опции:

```shell
--help=commands
--help=variables
```

---
> Как из командной строки выполнить инструкции из `.sql`-файла?

Опция `-f|--file=`:

```shell
$ psql -f dump.sql
```

---
> Как изменяется приглашение интерактивного терминала в строках продолжения?

Добавляется открывающая скобка перед символом решетки:

```
test=# CREATE TABLE courses(
test(#
```

---
> Как и от какого пользователя запускается консольный клиент?

От пользователя `postgres`:

```shell
$ sudo -u postgres psql
```

Произойдет переход в интерактивный режим СУБД с дефолтным prompt-ом `postgres=#`

---
> Как вывести список всех баз данных?

Команда `# \l`

---
> Как в информационных backslash-командах вывести дополнительную информацию?

Указать после команды `S` (системные объекты; опция есть для примерно половины команд) и/или `+` (доп. детали; опция есть почти для всех):

```
# \l+
# \dnS
```

---
> Как получить справку по backslash-командам?

Из командной строки:

```shell
$ psql --help=commands
```

или в интерактивном терминале (дефолтный режим справки):

```
# \?
```

Второй не стоит путать с `\h` - тот выводит справку по SQL-командам

---
> Какой пейджер используется в интерактивном терминале?

Системный, `more` или `less`

---
> Как в интерактивном терминале переключиться на определенную базу данных?

Команда `\c`:

```
# \c[onnect] <db>[ <additional-info>]
```

Строка приглашения после этого поменяется с дефолтного `postgres=#` на `<db-name>=#`

---
> Как получить справку по опциям командной строки?

Из командной строки (дефолтный режим справки):

```shell
$ psql --help
$ psql --help=options
```

или в интерактивном терминале:

```
# \? options
```

---
> Как в интерактивном терминале получить справку по SQL-команде?

Без имени команды перечислит все, для которых доступна справка:

```
# \h[elp] <command>
# \help CREATE TABLE
# \h
```

Не стоит путать с `\?` - тот выводит справку по backslash-командам

---
> Перечислите основные термины (сущности), относящиеся к реляционным БД

- *таблица* состоит из набора *строк* или *записей*
- строка делится на *поля*, *столбцы* или *колонки*

Таким образом, таблицы состоят из строк и столбцов, на пересечении которых должны находиться "атомарные" значения, которые нельзя разбить на более мелкие элементы без потери смысла

---
> Перечислите основные термины формальной теории реляционных БД

- таблицы называются математическим термином *отношение* (relation; отсюда и название *реляционная БД*)
- строки таблицы называются *кортежами* (tuples), а колонки - *атрибутами*
- таким образом, отношение имеет *заголовок*, состоящий из атрибутов, и *тело*, состоящее из кортежей
- количество атрибутов (столбцов) называется *степенью отношения*, а количество кортежей (строк) - его *кардинальным числом*

---
> Какое неявное ограничение накладывается на данные в столбце?

*Тип* столбца ограничивает спектр его (столбца) возможных значений

---
> Что такое *потенциальный ключ*?

Комбинация атрибутов таблицы, позволяющая уникальным образом идентифицировать строки в ней. Если ключ состоит из более чем одного атрибута, он называется *составным*

Важным является то, что потенциальный ключ должен быть неизбыточным, т.е. никакое подмножество атрибутов, входящих в него, не должно обладать свойством уникальности

---
> Что такое *первичный ключ*?

Один (или единственный) из потенциальных ключей, выбранный по какому-либо критерию. Первичный ключ обязан быть уникальным и не может содержать значение `NULL`:

```sql
product_no integer UNIQUE NOT NULL
~
product_no integer PRIMARY KEY
```

Остальные потенциальные называются *альтернативными ключами*

---
> Что такое *внешний ключ*?

Набор атрибутов таблицы, соответствующий потенциальному ключу в другой таблице. Таблица, в которой содержится внешний ключ, называется *ссылающейся* (referencing table), а содержащая соответствующий потенциальный ключ - *ссылочной (целевой)* (referenced table)

Таким образом, сам внешний ключ не обязан быть уникальным набором атрибутов, он может повторятся. Он лишь обязан ссылаться на уникальный набор (потенциальный ключ). Пример - таблица с оценками за экзамены. ID студентов в ней повторяются, при этом являясь полем - внешним ключом в целевую таблицу студентов, в которой уже этот ID уникален

---
> Что такое *ссылочная целостность*?

Проблема обеспечения того, чтобы база данных не содержала неверных значений внешних ключей

Ограничение, согласно которому значения внешних ключей должны соответствовать значениям потенциальных ключей, называется *ограничением ссылочной целостности (ссылочным ограничением)*. Это берет на себя СУБД

---
> Что такое *каскадное удаление (обновление)*?

Автоматическое удаление/обновление (неуникальных) записей во всех ссылающихся через внешние ключи таблицах, при изменении записи в ссылочной (целевой) таблице - той, где данные уникальны, являются ключом

Вместо удаления записей, в ссылающихся таблицах возможна замена поля внешнего ключа на `NULL`

---
> Что такое *транзакция*?

Набор операций над базой данных, рассматриваемых как единая и неделимая единица работы, выполняемая полностью или не выполняемая вовсе, если произошел какой-то сбой в процессе выполнения транзакции

Таким образом, транзакции являются средством обеспечения согласованности данных. Например, они могут быть использованы для обновления логически связанных таблиц, чтобы между последовательностью операций обновления не терялась целостность данных

---
> Что такое язык SQL?

Это непроцедурный (декларативный) язык, который является стандартным средством работы с данными во всех реляционных СУБД. Операторы (команды), написанные на этом языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают процедуру получения этого результата. СУБД сама определяет способ выполнения команды пользователя

---
> На какие группы деляться операторы языка SQL?

- *DDL* (Data Definition Language) - определение данных: создание, изменение и удаление таблиц, представлений и других объектов БД
- *DML* (Data Manipulation Language) - манипулирование данными: выборка, вставка, обновление и удаление строк таблиц
- *DCL* (Data Control Language) - видимо, управление пользователями/ролями

---
> Какие типы данных могут задавать текстовые строки?

- `char[acter][(N)]` - строки фиксированной длины, дополняются пробелами если символов меньше. Если скобки с `N` опущены, то длина = 1
- `varchar(N)` / `character varying(N)` - строки переменной, ограниченной сверху, длины
- `text` - строки произвольной длины (ограничение есть (задается при компиляции), но оно очень велико)

---
> Как называется основной целочисленный тип?

```sql
int[eger]
```

Есть еще типы `smallint`, `bigint`

---
> Какой формат у объявления столбца?

```
<name> <type> [<constrains>]
```

```sql
aircraft_code char(3) NOT NULL
```

Объявления ограничений и ключей могут быть расположены после объявлений самих полей:

```sql
range integer NOT NULL,
CHECK (range > 0),
PRIMARY KEY (aircraft_code)
```

---
> Что говорит значение `NULL` в поле?

= "Значение не задано, данные отсутствуют"

---
> Как делятся ключи по критерию выбора?

На *естественные* и *суррогатные*. Первые находят естественное отражение в предметной области. Например, это код лайнера в таблице типов самолетов

---
> Какие приняты стилистические соглашения по регистру в инструкциях SQL? Почему?

Так их выводит `pg_dump`:

- ключевые слова (`CREATE`, `SELECT`) пишутся в верхнем регистре
- типы столбцов (`int`, `char`) пишутся в нижнем

---
> Как в интерактивном терминале вызвать внешний редактор?

Backslash-команда `# \e`

---
> Как посмотреть индексы и их типы у таблицы?

Стандартной командой `# \d <table-name>`. Под схемой столбцов будут показаны и индексы

---
> Какой тип индекса по умолчанию генерируется для ключей?

B-дерево, для `UNIQUE`/`PRIMARY KEY`:

```sql
"aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
```

Имена индексов, если не заданы, генерируются автоматически

---
> Какой формат имен у автоматически генерируемых первичных ключей?

К имени таблицы дописывается фиксированный суффикс:

```
<table-name>_pkey
```

Например, для таблицы `seats`

```sql
"seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
```

---
> Какая схема используется по умолчанию для создания таблиц и прочих объектов?

`public`

---
> Как записываются строковые литералы?

В одинарных кавычках, двойные используются для создания таблиц/столбцов с пробельными символами (и не только) в именах

Две строки, разделенные `\n`, будут слиты в одну, без пробела. Именно символ новой строки, два литерала через пробел дадут синтаксическую ошибку

---
> Что делает backslash-команда `# \s`?

Выводит на экран историю команд

Если указать после нее имя файла - `# \s <file-name>` - то история сохранится в него. Это позволит искать и извлекать команды из истории средствами текстового редактора

---
> Как задать ограничение на значение столбца в общей форме?

Использовать ключевое слово `CHECK`. Можно задать имя ограничению, но обычно пишут без этого, и имя генерируется:

```sql
price numeric CHECK (price > 0)
price numeric CONSTRAINT positive_price CHECK (price > 0)
```

---
> Как задать автоматическое удаление записей при удалении внешнего ключа?

Указать это в *ссылающейся* (там, где поле неуникально) таблице:

```sql
FOREIGN KEY (aircraft_code)
  REFERENCES aircrafts (aircraft_code)
  ON DELETE CASCADE
```

---
> Как ограничить допустимые значения поля некоторым списком (перечислением)?

Указать этот список в `IN` внутри `CHECK`:

```sql
fare_conditions varchar(10) NOT NULL,
CHECK (
  fare_conditions IN ('Economy', 'Comfort', 'Business')
)
```

В полной форма (полученной через `# \d <table-name>`) это ограничение будет выглядеть сложнее:

```sql
CHECK (fare_conditions::text = ANY (ARRAY[
  'Economy'::character varying::text,
  'Comfort'::character varying::text,
  'Business'::character varying::text
]))
```

---
> Как в ссылающуюся таблицу вставить запись с внешним ключом, не существующим в основной таблице?

Никак, СУБД запретит это, выдаст ошибку. Например:

```sql
INSERT INTO seats VALUES ('123', '1A', 'Business');
```

```
ERROR:  insert or update on table "seats" violates foreign key ...
DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts_data"
```

---
> Как одним запросом посчитать количество строк с каждым значением одного поля?

Выборка с группировкой по этому полю, само поле + `count()` в результатах. Сортировка опциональна:

```sql
SELECT aircraft_code, count(*) FROM seats GROUP BY aircraft_code[ ORDER BY count];
```

```
 aircraft_code | count
---------------+-------
 CN1           |    12
 CR2           |    50
 SU9           |    97
 319           |   116
 ...
```

Добавляя новое поле в каждый из операторов `SELECT`, `GROUP BY` и `ORDER BY`, получим группировку уже по двум полям

---
> Что выдаст `SELECT *` на запросе с группировкой?

Ошибку, он не подставит автоматически список полей из `GROUP BY`:

```sql
SELECT * FROM seats GROUP BY aircraft_code;
```

```
ERROR:  column "seats.seat_no" must appear in the
  GROUP BY clause or be used in an aggregate function
```

---
> Что выдаст этот код?
> 
> ```sql
> SELECT model AS m FROM aircrafts ORDER BY m;
> ```

Отсортированный список моделей. `ORDER BY` вполне может сортировать по псевдониму

---
> Какой результат дает составная сортировка?
> 
> ```sql
> ORDER BY a, b;
> ```

Результат сортируется по первому столбцу `a`. Внутри групп с одинаковыми значениями `a` строки сортируются по столбцу `b`:

```
 code | count
------+-------
 319  |    20
 319  |    96
 320  |    20
 320  |   120
 321  |    28
```

---
> Что произойдет при попытке вставить запись с уже имеющимся первичным ключом?

```sql
INSERT INTO aircrafts_data VALUES ('SU9', '{"en":"Sukhoi SuperJet-100"}', 3000);
```

Выдаст ошибку нарушения уникальности:

```
ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
DETAIL:  Key (aircraft_code)=(SU9) already exists
```

---
> Можно ли в `UPDATE` обновлять поля через составные арифметические операторы?

Таких операторов в Postgres нет, так что только полными:

```sql
SET range = range * 2
```

---
> Что произойдет, если в команде удаления с условием `DELETE ... WHERE ...` последнее не совпадет ни с одной строкой?

Команда отработает штатно, это не ошибка. Просто выведет `DELETE 0`

---
> Как удалить все строки из таблицы?

Вызвать `DELETE` без `WHERE`:

```sql
DELETE FROM aircrafts;
```

---
> Какие псевдонимы у целочисленных типов?

Цифра в названии отражает количество байт, занимаемых полем такого типа:

- `int2` ~ `smallint`
- `int4` ~ `int[eger]`
- `int8` ~ `bigint`

---
> На что обращать внимание при выборе целочисленного типа для поля?

На диапазона допустимых значений и затраты памяти на поле

Часто стандартный `integer` является оптимальным

---
> Какой тип задает *числа с фиксированной точностью*?

У типа два названия, псевдонимы: `numeric` и `decimal`. Конструктор типа принимает один или два параметра:

```sql
numeric|decimal(precision, scale)
```

Здесь точность - общее число цифр в числе, а масштаб - число цифр после запятой. Например:

```sql
12.3456 ~ numeric(precision=6, scale=4)
some_column decimal(6, 4) NOT NULL
```

---
> В чем преимущества и недостатки чисел с произвольной (фиксированной) точностью?

Тип `numeric`/`decimal` может хранить сотни тысяч цифр. Результаты арифметических операций с такими числами дают настолько большую точность, насколько это вообще возможно. Их рекомендуют использовать, например, для хранения и расчетов денежных сумм

Недостаткам является значительно более низкая скорость работы, по сравнению с числами с плавающей точкой

---
> Какие есть типы чисел с плавающей точкой?

Их два, они представляют реализацию стандарта IEEE 754:

- `real` - от `1E-37` до `1E+37`
- `double precision` - от `1E-307` до `1E+308`
- `float(p)` - тип из SQL-стандарта, в зависимости от параметра равен одному из двух предыдущих (`[1, 24]` ~ `real`, `[25, 53]` или без параметра ~ `double`)

---
> Что произойдет при попытке записи в поле типа `real`/`double precision` числа, большего или меньше максимального допустимого значения? Меньше машинного эпсилона? С более высокой, чем допустимо, точностью?

- для слишком большого или слишком маленького числа выбрасывается ошибка
- при точности ниже допустимой генерируется ошибка потери значимых разрядов (`underflow error`)
- а вот при точности выше допустимой ошибки не произойдет, число просто будет округлено

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0.1::real * 10 = 1.0::real
> ```

`f` (= `false`), сравнивать числа с плавающей точкой напрямую нельзя

---
> Какие специальные значения поддерживают типы чисел с плавающей точкой?

`Infinity`, `-Infinity`, `NaN` (не число)

---
> Какое влияние оказывает параметр `p` в конструкторе типа `float(p)`?

- если оно от `1` до `24`, то тип ~ `real`
- если от `25` до `53`, то ~ `double precision`
- без параметра также ~ `double precision`

---
> Что такое тип `serial`?

```sql
CREATE TABLE "table" ("col" serial);
```

Это псевдо-тип, псевдоним для создания последовательности целых чисел, и прикрепления ее к оператору `DEFAULT` в объявлении столбца:

```sql
CREATE SEQUENCE "table_col_seq";
CREATE TABLE "table"(
  "col" integer NOT NULL DEFAULT nextval('table_col_seq')
);
ALTER SEQUENCE "table_col_seq" OWNED BY "table.col";
```

---
> Что делает функция `nextval()`?

Получает следующее (целое) число из последовательности, имя которой передано параметром:

```sql
nextval('seq') -> integer
```

Как правило эта функция используется неявно (типом `serial`), для создания автоинкрементного индекса

---
> Какие особенности у типов `smallserial` и `bigserial`?

Это тот же `serial` - псевдоним для набора команд, но тип создаваемого столбца будет на `int`, а `smallint`/`bigint` соответственно

---
> Как соотносятся числа в объявлениях типов `character[ varying](N)` с длиной строк в многобайтовых (напр., UTF-8) кодировках?

`N` рассматривается как число символов, не число байт

---
> Какие строковые типы рекомендуется использовать в Postgres?

`text` и `varchar`, поскольку такое отличительное свойство типа `character`, как дополнение значений пробелами, на практике почти не востребовано

---
> Как в строковых литералах экранируются кавычки?

Строки задаются в одинарных кавычках. Одинарная кавычка внутри экранируется второй такой же кавычкой, не обратным слешем:

```sql
SELECT 'te''st';
```

Двойные кавычки внутри рассматриваются как обычные символы, их экранировать не нужно

---
> Какой литерал у "сырых" строк?

Два символа доллара с каждой стороны. Никакие символы (`'`, `\`, `$`) внутри экранировать не нужно:

```pgsql
SELECT $$t\e's$t$$;
```

Это расширение Postgres, не часть стандарта SQL

---
> Что такое строки в стиле C?

Строковые литералы, которые могут содержать escape-последовательности, вроде `\n`, `\t`. Такие строки нужно начинать с символа `E`:

```pgsql
SELECT E'PG\nDAY\'17';
```

Одинарная кавычка и обратный слеш в таких литералах экранируются одинаково - обратным слешем:

```
 ?column?
----------
 PG      +
 DAY'17
```

Это расширение Postgres, не часть стандарта SQL

---
> Строковые литералы какого формата распознаются при приведении дат `::date`?

- `yyyy-mm-dd` (ISO 8601)
- `Mon dd, yyyy`

```sql
SELECT '2016-09-12'::date = 'Sep 12, 2016'::date;
```

---
> Как выполняется явное приведение типа?

Через оператор `::<type>`:

```sql
'Sep 12, 2016'::date
1::real
```

---
> Какие 3 функции возвращают текущие значения даты и времени? Как они вызываются?

Все три вызываются без круглых скобок:

```sql
SELECT current_date, current_time, current_timestamp;
```

```
 current_date |    current_time    |       current_timestamp
--------------+--------------------+-------------------------------
 2020-06-16   | 03:50:49.525199+04 | 2020-06-16 03:50:49.525199+04
```

---
> Как отформатировать дату?

Вызвать функцию `to_char()` с объектом типа `date`/`time[stamp]` и строкой формата. Она вернет тип `text`:

```sql
SELECT
  to_char(current_date, 'dd-mm-yyyy'),
  to_char(current_timestamp, 'mi:ss'),
  to_char(current_timestamp, 'dd');
```

```
  to_char   | to_char | to_char
------------+---------+---------
 30-06-2020 | 13:53   | 30
```

---
> Какие есть 2 типа для хранения времени?

Функция `current_time` возвращает второй тип:

- `time`
- `time with time zone` - хранит еще и часовой пояс

```sql
SELECT current_time::time, current_time;
```

```
  current_time   |    current_time
-----------------+--------------------
 04:03:21.171316 | 04:03:21.171316+04
```

---
> Какие рекомендации по использованию типа `time with time zone`?

Не использовать: смещение (часовой пояс) может зависеть от даты - дня перехода на летнее/зимнее время, при том что сама дата в этом типе не хранится (только время)

---
> Что выведут эти запросы?
> 
> ```sql
> SELECT '21:15'::time, '21:15:12'::time;
> SELECT '25:15'::time, '21:15:72'::time;
> ```

Первый отработает корректно. В случае отсутствия секунд во времени они установятся в нули:

```
   time   |   time
----------+----------
 21:15:00 | 21:15:12
```

Второй выдаст ошибку для любого из выражений:

```
ERROR:  date/time field value out of range: "25:15"
ERROR:  date/time field value out of range: "21:15:72"
```
---
> Строковые литералы какого формата распознаются при приведении времени `::time`?

```
hh:mm[:ss[ am|pm]]
```

```sql
'21:15'::time, '21:15:12'::time, '12:15:12 pm'::time
```

---
> Откуда функция `current_time` берет часовой пояс?

Из конфигурационного параметра `timezone`:

```sql
SHOW timezone;
```

Этот параметр (как и остальные) задается строкой в файле `/etc/postgresql/12/main/postgresql.conf`:

```
   TimeZone
---------------
 Europe/Samara
```

---
> Какие типы получаются при объединении даты и времени?

- `timestamp` - без учета часового пояса
- `timestamp with time zone` (или псевдоним `timestamptz`)

Второй тип - это расширение Postgres

```sql
SELECT timestamp '2016-09-21 22:25:35', timestamptz '2016-09-21 22:25:35';
```

```
      timestamp      |      timestamptz
---------------------+------------------------
 2016-09-21 22:25:35 | 2016-09-21 00:00:00+04
```

---
> Назовите 3 способа приведения типов для констант

Все три приведения дадут одно и то же значение:

```sql
SELECT
  '21:15'::time,         -- const::type
  time '21:15',          -- type const
  cast('21:15' as time); -- cast(const as type)
```

---
> Какие типы значений возвращают функции `current_time`, `current_timestamp`?

`timetz`, `timestamptz`:

```sql
SELECT current_time, current_timestamp;
```

Оба значения с часовым поясом:

```
    current_time    |       current_timestamp
--------------------+-------------------------------
 05:17:19.648166+04 | 2020-06-16 05:17:19.648166+04
```

---
> Приведите пример, когда нужно использовать тип `timestamp`, не `timestamptz`

В случаях, когда не нужно чтобы время автоматически приводилось к часовому поясу пользователя. Так, например, в расписании авиарейсов время отправления/прибытия привязывается к местному времени аэропортов

Но всё же `timestamptz` используется чаще

---
> Строковые литералы какого формата распознаются при приведении интервалов `::interval`?

- `'1 year 2 months[ ago]'` (где единицы измерения - от `microsecond` до `millennium`)
- `'P0001-02-03T04:05:06'` (дате и времени предшествуют буквы `P` и `T`; стандарт ISO 8601)

---
> Как можно получить значение типа `interval`?

- из строковой константы
- вычитая одну временную отметку из другой

```sql
SELECT '1 hour'::interval, '13:00'::time - '12:00'::time;
```

```
 interval | ?column?
----------+----------
 01:00:00 | 01:00:00
```

---
> Как узнать тип выражения в `SELECT`?

Функция `pg_typeof()`:

```sql
SELECT pg_typeof('13:00'::time - '12:00'::time);
```

```
 pg_typeof
-----------
 interval
```

---
> Как усечь timestamp до нужной компоненты?

Функцией `date_trunc(text, timestamp)`:

```sql
SELECT date_trunc('hour', current_timestamp);
```

До границы часа, минуты/секунды станут нулями. Идет простое отбрасывание, не округление:

```
       date_trunc
------------------------
 2020-06-16 06:00:00+04
```

Первый параметр может быть от микросекунд до тысячелетий. Как правило, усечение просто заменяет всё справа нулями. Исключение - параметр `week`

Функция всегда возвращает тип `timestamp[ without time zone]`, хотя принимать может не только таймстемпы, но и интервалы

---
> Что выведет этот запрос?
> ```sql
> SELECT date_trunc('sec', '1:2:3.4'::time);
> ```

Компонента - первый параметр, - это граница, усекается по ней, а не она сама отбрасывается. В этом примере секунды остаются, но отбрасывается их дробная часть:

```
 date_trunc
------------
 01:02:03
```

---
> Как извлечь из timestamp-а нужную компоненту?

Функцией `extract(<field> from <timestamp>)`:

```sql
SELECT extract('mon' FROM timestamp '1999-11-27 12:34:56.123459');
```

Она всегда возвращает число (`double precision`):

```
 date_part
-----------
        11
```

---
> Какие значения принимает тип `bool`?

Их три:

```sql
TRUE, FALSE, NULL
```

Последнее указывает, что значение не определено

---
> Какие литералы неявно приводятся к булевым значениям?

Выделенные литералы для типа `boolean` это `TRUE`/`FALSE`, а приводиться могут *строки*. Все значения не чувствительны к регистру:

- `t[rue]`/`f[false]`, так же как отображаются в результатах выборок
- `y[es]`/`n[o]`
- `on`/`off`
- `1`/`0`

При попытке вставить целое число в булево поле будет выброшена ошибка

---
> Как использовать булевы поля в проверках?

Напрямую, без явного сравнения с константами:

```sql
SELECT * FROM databases WHERE is_open_source;
```

---
> Как создать столбец - типизированный массив?

Указать квадратные скобки после имени типа:

```sql
CREATE TABLE pilots(
  pilot_name text,
  schedule integer[]
);
```

---
> Как записать массив в поле `type[]`?

Массив обозначается литералом-строкой (в одинарных кавычках) - перечислением значением внутри фигурных скобок, с явным приведением ее к типу столбца:

```sql
INSERT INTO pilots VALUES (
  'Ivan', '{1, 3, 5, 6, 7}'::integer[]
);
```

Есть и нотация из SQL-стандарта, запись через ключевое слово `ARRAY`:

```sql
INSERT INTO pilots VALUES (
  'Ivan', ARRAY[1, 1, 1, 2]
);
```

---
> Как можно добавить элемент в конец списка значений столбца-массива?

Через оператор или функцию:

```sql
SET schedule = schedule || 7
SET schedule = array_append(schedule, 6)
```

Первый вариант (оператор `||`) позволяет добавлять как отдельный элемент, так и целый массив. Функция `array_append()` работает только с одиночным значением

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '{1, 2}'::int[] || '{3, 4}'::int[], '{1, 2}' || '{3, 4}';
> ```

Ошибки не будет, оператор конкатенации `||` применим к обоим типам:

```
 ?column?  |   ?column?
-----------+--------------
 {1,2,3,4} | {1, 2}{3, 4}
```

Но без явного приведения массивы создаваться не будут, объединенное значение будет строкой (`text`)

---
> Как добавить элемент в начало списка значений столбца-массива?

Через функцию `array_prepend()`:

```sql
SET schedule = array_prepend(1, schedule)
```

- как и `array_append()` она работает лишь с одиночным элементов, не массивом
- в отличие от `array_append()` у нее другой порядок аргументов - добавляемый элемент идет первым

---
> Как удалить элемент из списка значений столбца-массива?

Функцией `array_remove()`:

```sql
SET schedule = array_remove(schedule, 5)
```

Эта функция удаляет элемент *по значению*, не по индексу

---
> Как обращаться к элементам столбца-массива?

Через оператор "квадратные скобки". Индексация начинается с единицы (!):

```sql
SET schedule[1] = 2, schedule[2] = 3
```

Получить доступ только на чтение можно также через функцию:

```sql
WHERE array_position(schedule, 3) IS NOT NULL
```

---
> Как можно заменить сразу часть значений столбца-массива?

Через *срез* (slice):

```sql
SET schedule[1:2] = ARRAY[2, 3]
```

Индексация начинается с единицы (!), второй индекс включается в диапазон

---
> Как проверить, что массив полностью включается в другой?

Оператор `@>` означает проверку того факта, что в левом массиве содержатся все элементы правого. Запрос с условием:

```sql
WHERE schedule @> '{1, 7}'::integer[]
WHERE schedule @> ARRAY[1, 7]
```

выберет все записи, столбец `schedule` в которых содержит оба числа `1` и `7`, например, `{1,3,6,7}`

---
> Как проверить, что в массиве присутствуют элементы другого массива?

Оператор `&&` означает проверку того факта, что в левом массиве содержится хотя бы один элемент правого. Запрос с условием:

```sql
WHERE schedule && '{2, 5}'::integer[]
WHERE schedule && ARRAY[2, 5]
```

выберет все записи, столбец `schedule` в которых содержит хотя бы одно из чисел `2` и `5`, например, `{3,5,6,7}`, `{1,2,5,6}`, `{2,3,5,7}`

В отличие от оператора `||`, этот возвращает булево значение, не массив

---
> Как через операторы сформулировать условие "не содержит ни один из элементов указанного массива"?

Совместить `NOT` и `&&`:

```sql
WHERE NOT (schedule && ARRAY[2, 5])
```

В результате будут выбраны только те записи, в поле `schedule` которых нет чисел `2` и `5`, например, `{1,3,6,7}`

---
> Как "развернуть" столбец-массив, представить его в виде строк - результатов выборки?

Функция `unnest()`:

```sql
SELECT unnest(schedule) AS days_of_week FROM pilots WHERE pilot_name = 'Ivan';
```

```
 days_of_week
--------------
            1
            3
            6
            7
```

Если условию удовлетворяет несколько записей (с полями-массивами), то на выходе также будет одно результирующее поле `days_of_week`, только число строк в результирующей выборке будет больше

---
> В чем отличия типов `json` и `jsonb`?

- `json` записывается в поле как есть, а его разбор производится каждый раз, когда поле извлекается. `jsonb` наоборот, разбирается при записи
- из-за предыдущего пункта быстродействие при записи у `jsonb` немного ниже, но выше при чтении
- кроме того, `jsonb` не сохраняет исходный порядок ключей

Рекомендуется в приложениях использовать `jsonb`, если нет каких-то особых аргументов в пользу выбора типа `json`

---
> Как можно проверить, что ключ содержится в поле с типом `json`?

С помощью оператора `@>` либо напрямую, либо предварительно уточняя поле в левой части через оператор `->`:

```sql
WHERE hobbies @> ' "sports":["футбол"]}'
WHERE hobbies -> 'sports' @> '["футбол"]'
```

JSON-ключи/значения внутри строк JSON-а заключаются в двойные кавычки

---
> Как проверить, что в поле типа `json[b]` присутствует ключ верхнего уровня?

Оператором `?`:

```sql
WHERE hobbies ? 'sports'
```

В разных записях в полях типах `json[b]` структура JSON-а не обязана совпадать, и тогда этот оператор может быть полезен

---
> Как изменить только часть структуры JSON в поле типа `json[b]`?

Оператором `||`:

```sql
SET hobbies = hobbies || '{"sports": ["хоккей"]}'
```
---
> Как добавить новый элемент в структуру JSON в поле типа `json[b]`?

Функцией `jsonb_set()`. Второй параметр указывает путь в пределах JSON-объекта, куда нужно добавить новое значение:

```sql
SET hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"')
```

Нумерация массивов с нуля. Добавляемые значения (третий параметр) имеют тип `jsbonb`, литералы внутри них должны быть в двойных кавычках

---
> Что будет в результатах выборки?
> 
> ```sql
> SELECT * FROM aircrafts WHERE 1 = 0;
> ```

Ничего, пустой результат:

```
 ?column?
----------
(0 rows)
```

Хотя условие `WHERE` и не связано со столбцами в `SELECT`, оно всегда ложное и ни одна строка в выборку не попадет

---
> Что выведет этот код?
> 
> ```sql
> CREATE TABLE test_numeric(
>   measurement numeric(5, 2),
>   description text
> );
> INSERT INTO test_numeric VALUES (999.9999, 'some');
> ```

Ошибку переполнения:

```
ERROR:  numeric field overflow
DETAIL:  A field with precision 5, scale 2 must round
  to an absolute value less than 10^3.
```

---
> Какое максимальное число можно записать в поле `numerc(N, M)`? В поле `numeric(N)`?

Если `M` опущено, то оно равно `0`, а общая длина целой части равна `N-M`. Таким образом, диапазон допустимых значений:

```
[-10^(N-M), +10^(N-M)]
```

Например, для `numeric(5, 2)` (= `numeric(3)`) допустимый диапазон `[-100, 100]`

---
> Что выведет эта команда?
> 
> ```sql
> INSERT INTO test_numeric SET num_1 = 101;
> ```

Синтаксическую ошибку:

```
ERROR:  syntax error at or near "SET"
```

Это только у `UPDATE` есть синтаксис через `SET`, не у `INSERT`

---
> Какой тип должен быть у поля, если в нем предполагается хранить действительные числа с различной точностью?

`numeric` без указания масштаба и точности:

```sql
CREATE TABLE test_numeric(
  measurement numeric,
  ...
);
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT
>   'NaN'::numeric = 'NaN'::numeric,
>   'NaN'::numeric < 'NaN'::numeric,
>   1 < 'NaN'::numeric;
> ```

```
 ?column? | ?column? | ?column?
----------+----------+----------
 t        | f        | t
```

`NaN` в Postgres равен самому себе и больше любого другого числа

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '4e-324'::double precision < '5e-324'::double precision;
> ```

```
 ?column?
----------
 f
```

Число `4.94065645841247e-324` - минимально представимое. Оба числа из примера выше округляются до `5e-324, float(8)` и считаются равными

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 1E+308 < 'Inf'::double precision;
> ```

```
 ?column?
----------
 t
```

`Inf` больше самого большого числа, представимого типом

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 0 * 'Inf'::real;
> ```

```
 ?column?
----------
      NaN
```

Ноль на бесконечность дает математическую неопределенность

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT 'Inf'::real < 'NaN'::real;
> ```

```
 ?column?
----------
 t
```

В Postrges `NaN` больше любого числа, даже бесконечности

---
> Как на генератор последовательности поля `serial` влияет вставка записи с указанным вручную значением?

Никак, последовательность его не учитывает, не "перешагивает", а генерирует следующий номер, совпадающий с заданным вручную

В случае, когда поле `serial` задано как `PRIMARY KEY`, это может приводить к ошибкам

```
ERROR:  duplicate key value violates unique constraint "test_serial_pkey"
DETAIL:  Key (id)=(2) already exists.
```

Но даже неудачная попытка вставки сдвинет указатель последовательности, и уже следующая вставка отработает нормально: ключа `3` в таблице еще нет

---
> Как на генератор последовательности поля `serial` влияет удаление некоторой (напр., последней) записи?

Не влияет, вычисления максимального значение в столбце не ведется, последовательность просто продолжается с последнего автоматически вставленного номера

---
> Какой календарь используется в PostgreSQL для работы с датами: юлианский или григорианский?

Все даты считаются по Григорианскому календарю, даже для времени до его введения (т.н. *пролептический григорианский календарь*)

---
> Какое наименьшее значение у типов `timestamp[ with time zone]` и `date`?

1 января 4713 до н.э. - юлианский полдень (правда, Postgres считает с полуночи), JD 0

---
> Какой размер у типов `timestamp[ with time zone]` и `date`?

У первого 8 байт, а у даты 4 байта

Несмотря на это, максимально значение для `date` сильно больше, чем для таймстемпов: время ей хранить не надо

---
> Что означают цифры в скобках после типов `timestamp`, `time` и `interval`?

*Точность* - количество десятичных цифр в поле секунд:

```sql
SELECT current_time::time, current_time::time(0), current_time::time(3);
```

```
  current_time   | current_time | current_time
-----------------+--------------+--------------
 22:41:11.777138 | 22:41:12     | 22:41:11.777
```

Для `date` такого параметра нет

---
> Какой параметр управляет форматом даты? Какое у него значение по умолчанию?

```sql
SHOW datestyle;
```

Первый компонент управляет форматом вывода, а второй - форматом ввода, строки для преобразования в дату, "день"-"месяц"-"год" (`'18-05-2016'::date`)

```
 DateStyle
-----------
 ISO, DMY
```

---
> Каков *универсальный* формат строки для преобразования в дату?

"Год"-"месяц"-"число", `YYYY-MM-DD`:

```sql
SELECT '2016-05-18'::date;
```

Использовать этот формат для ввода дат можно всегда, независимо от второй компоненты параметра `datestyle`. Кроме того, это дефолтный формат вывода дат. Результат для примера выше:

```
    date
------------
 2016-05-18
```

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT '05-18-2016'::date;
> ```

На дефолтных настройках - ошибку:

```
ERROR:  date/time field value out of range: "05-18-2016"
HINT:  Perhaps you need a different "datestyle" setting.
```

По умолчанию второй компонент параметра `datestyle`, отвечающий за формат вводимых дат, равен `DMY`. В нашем же примере во второй позиции стоит `18`, и как месяц оно интерпретироваться не может (в случае числа < 12 ошибки бы не было)


---
> Как через SQL можно получить и задать значение конфигурационного параметра?

На примере формата дат:

```sql
SHOW datestyle;
SET datestyle TO 'MDY';
```

Во втором случае используется `TO`, или оператор "равно". Кроме того, в том же втором примере устанавливается только часть значения


---
> Как через SQL установить значение конфигурационного параметра в исходное (сбросить)?

Используя ключевое слово `DEFAULT`:

```sql
SET datestyle TO DEFAULT;
```

---
> Как через SQL установить значение конфигурационного параметра `datestyle`?

В первом случае модифицируется только второй компонент (формат ввода):

```sql
SET datestyle TO 'MDY';
SET datestyle TO 'Postgres, DMY';
```

---
> Какие есть 4 формата отображения даты-времени (допустимые значения первого компонента конф. параметра `datestyle`)?

- `ISO` - ISO 8601, стандарт SQL: `1997-12-17 07:37:16-08`
- `SQL` - традиционный стиль: `12/17/1997 07:37:16.00 PST`
- `Postgres` - изначальный стиль: `Wed Dec 17 07:37:16 1997 PST`
- `German` - региональный стиль: `17.12.1997 07:37:16.00 PST`

---
> Какими 3мя способами можно изменить конфигурационный параметр, например, `datestyle`?

- через SQL: `SET datestyle TO 'MDY';`
- задав переменную окружения: `$ PGDATESTYLE="Postgres" psql`
- отредактировав файл `/etc/postgresql/12/main/postgresql.conf` и перезапустив сервер

---
> Что выведет этот запрос?
> ```sql
> SELECT 'Feb 29, 2015'::date;
> ```

Ошибку:

```
ERROR:  date/time field value out of range: "Feb 29, 2015"
```

При парсинге дат выполняется много проверок, в том числе и на високосные года

---
> Что выведет этот запрос?
> ```sql
> SELECT '21:15:16:22'::time;
> ```

Ошибку:

```
ERROR:  invalid input syntax for type time: "21:15:16:22"
```

Формат входных данных для дат/времени задается жестко, и лишние значения игнорироваться не будут

---
> Что выведет этот запрос?
> ```sql
> SELECT pg_typeof('2016-09-16'::date - '2016-09-01'::date),
>        pg_typeof('09:16'::time - '09:01'::time);
> ```

В отличие от разности временных меток, разница дат дает целое число - дни (зд. `15`), не интервал:

```
 pg_typeof | pg_typeof
-----------+-----------
 integer   | interval
```

---
> Что выведет этот запрос?
> ```sql
> SELECT '2016-09-16'::date      - '2015-09-01'::date,
>        '2016-09-16'::timestamp - '2015-09-01'::timestamp;
> ```

Разность значений типа `date` имеет целочисленный тип. Для типов `time[stamp]` разность является интервалом:

```
 ?column? | ?column?
----------+----------
      381 | 381 days
```

---
> Что выведут эти запросы?
> ```sql
> SELECT '0:1'::time - '0:0'::time;
> SELECT '0:1'::time + '0:0'::time;
> ```

Первый вернет интервал в 1 минуту, а второй упадет с ошибкой:

```
 ?column?
----------
 00:01:00

ERROR:  operator is not unique: time without time zone + time without time zone
HINT:  Could not choose a best candidate operator.
  You might need to add explicit type casts.
```

Таким образом, прибавлять ко временной метке можно только интервал, но не другое значение времени

---
> Что выведут эти запросы?
> ```sql
> SELECT '2016-09-16'::date - 1;
> SELECT '20:34:35'::time - 1;
> ```

Первый отработает корректно, вернет дату на день меньше. Второй упадет с ошибкой:

```
ERROR:  operator does not exist: time without time zone - integer
HINT:  No operator matches the given name and argument types.
  You might need to add explicit type casts.
```

Таким образом, целые числа можно складывать/вычитать только из дат, для работы с типом `time[stamp]` нужно использовать временные метки или интервалы

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT '0:1'::time, '0:1'::time + '1 mon'::interval AS time;
> ```

Интервал к временной метке прибавлять вполне можно, но сложение часов с днями ничего в метке не изменит - хранится только время суток, не сама дата:

```
   time   |   time
----------+----------
 00:01:00 | 00:01:00
```

---
> Что вернет этот запрос?
> 
> ```sql
> SELECT
>   '2016-01-01'::date + '1 mon'::interval,
>   '2016-01-31'::date + '1 mon'::interval,
>   '2016-02-29'::date + '1 mon'::interval;
> ```

```
      ?column?       |      ?column?       |      ?column?
---------------------+---------------------+---------------------
 2016-02-01 00:00:00 | 2016-02-29 00:00:00 | 2016-03-29 00:00:00
```

- из первого числа всегда получается первое следующего месяца
- и вообще, число сохраняется, только месяц увеличивается на единицу
- если в следующем месяце нет такого (большого) числа, то берется последний день


---
> Какой параметр управляет форматом интервалов?

```
intervalstyle
```

Он похож на `datestyle`, но состоит из единственного компонента (не из двух через запятую)

---
> Что выведет этот запрос?
> 
> ```sql
> SELECT extract('cent' FROM '1999-01-01'::date);
> ```

```
 date_part
-----------
        20
```

Иногда `extract()` не просто выбирает число из записи даты/времени/интервала, а еще и делает некоторые преобразования. `cent` ~ `century`, а 1999 год принадлежит двадцатому веку

---
> Можно ли сравнивать булево поле с целым числом? Со строкой?

Со строкой можно, и это эквивалентно сравнению с литералом `TRUE`/`FALSE`. С числом выбросит ошибку:

```sql
SELECT * FROM databases WHERE is_open_source <> '1';
SELECT * FROM databases WHERE is_open_source <> 1;
```

```
 is_open_source |   dbms_name
----------------+---------------
 f              | Oracle
 f              | MS SQL Server

ERROR:  operator does not exist: boolean <> integer
```

Нужно явно приводить целые числа к `bool[ean]`

---
> Каковы правила приведения целых чисел к типу `bool[ean]`?

Нуль приводится к `f[alse]`, все остальные числа, положительные и отрицательные, - к `t[rue]`:

```sql
SELECT (-1)::bool; -- TRUE
SELECT 1111::bool; -- TRUE
SELECT 0::bool;    -- FALSE
```

---
> Как из таблицы с полем типа `date` выбрать все записи, где месяц в дате - это март?

Через функцию `extract()`:

```sql
SELECT * FROM birthdays WHERE extract('mon' from birthday) = 3;
```

---
> Дана таблица с полем `birthday` типа `date`. Как выбрать всех людей, достигших возраста 40 лет на данный момент?

Воспользоваться сложением с интервалом и сравнением с текущей датой:

```sql
WHERE birthday + '40 years'::interval < current_date;
```

---
> Дана таблица с полем `birthday` типа `date`. Как найти возраст человека для каждой записи?

Если просто в днях, то можно вычитать `birthday` из `current_date`. Для отображения же в человекочитаемом виде существует встроенная функция `age`:

```sql
SELECT current_date - birthday
SELECT age(birthday)
```

Вообще, в общем случае `age()` принимает 2 параметра, и вычитает второй из первого. Если параметр только один, то вычитает его из `current_date`:

```sql
age(timestamp=current_date, timestamp)
```

---
> Как можно объединить два массива?

Через оператор или функцию:

```sql
SELECT array_cat(ARRAY[1, 2, 3], ARRAY[3, 5]);
SELECT ARRAY[1, 2, 3] || ARRAY[3, 5];
```

Эти способы дадут один и тот же результат:

```
  ?column?
-------------
 {1,2,3,3,5}
```

---
> Допустимы ли поля - многомерные массивы?

Да, вполне. Синтаксис задания/обращения к элементам такой же:

```sql
'{ {"some", "text"}, {"other", "text"} }'::text[][]
field[1][1]
```

Нумерация индексов так же с единицы

---
> Как удалить ключ в JSON-объекте?

Оператором `-` ("минус"). Удалит ключ и соответствующее ему значение

---
> Как для столбца задается значение по умолчанию?

Через ключевое слово `DEFAULT`:

```sql
CREATE TABLE progress(
  mark numeric(1) DEFAULT 5,
  ...
);
```

---
> Как для столбца задается ограничение на уникальность?

Через ключевое слово `UNIQUE`, сразу после объявления столбца или внизу:

```sql
CREATE TABLE students(
  record_book1 numeric(5) UNIQUE,
  record_book2 numeric(5),
  [CONSTRAINT unique_record_book ]UNIQUE (record_book2)
);
```

Аналогичен синтаксис и для `PRIMARY KEY`. В обоих случаях только общий - с записью после столбцов - синтаксис может использоваться для ограничений, накладываемых на два и более столбцов

---
> Как для столбца задается внешний ключ?

Через ключевое слово `REFERENCES` сразу после объявления столбца. А вот для объявления после остальных столбцов (в отличие от `UNIQUE`/`PRIMARY KEY`), нужно дополнительно указывать `FOREIGN KEY`:

```sql
CREATE TABLE students(
  record_book1 numeric(5) REFERENCES students (record_book),
  record_book2 numeric(5),
  FOREIGN KEY (record_book1) REFERENCES students (record_book)
);
```

Можно так же задавать имя ограничения (ключа) - напр., `CONSTRAINT students_fkey`

---
> Какую логику реализует внешний ключ, объявленный с `ON DELETE CASCADE`?

При удалении записи из *основной* (ссылочной) таблицы, удаляются также записи (целиком) во всех *ссылающихся* таблицах

Таким образом, при наличие внешнего ключа (и не только каскадированного), ссылочную таблицу можно назвать *главной*, а ссылающуюся - *подчиненной*

---
> Какие есть варианты для `ON DELETE` во внешних ключах?

- `CASCADE` - удаление записи в связанной таблице при удалении из основной
- `NO ACTION` / `RESTRICT` - запрет на удаление из основной, если в ссылающейся есть связанные записи
- `SET NULL` - присваивание `NULL` внешнему ключу (полю ссылающейся таблицы). Необходимо, чтобы на это поле не было наложено ограничение `NOT NULL`
- `SET DEFAULT` - присваивание значения по умолчанию внешнему ключу (полю ссылающейся таблицы). Дефолтное значение, разумеется, должно быть задано для столбца. В случае, если соответствующего дефолтному значению поля в главной таблице нет, то будет выброшена ошибка и удаление не пройдет

В случае `RESTRICT` проверка выполняется сразу, а для `NO ACTION` может быть отложена до конца транзакции. Это их единственное отличие

---
> Для чего могут служить ограничения, накладываемые на столбцы таблиц?

Как для чисто технических моментов, вроде определенности (`NOT NULL`) или уникальности (`UNIQUE`), так и для описания предметной области, например, ограничения диапазонов значений для номеров семестров или оценок:

```sql
term numeric(1) CHECK ( term = 1 OR term = 2 ),
mark numeric(1) CHECK ( mark >= 3 AND mark <= 5 ),
```

Ограничения предметной области могут быть достаточно сложны, состоять из множества логических связок, перечислений и т.д.

---
> Какая есть альтернативная запись для `NOT NULL`?

Более длинная и менее эффективная:

```sql
CHECK (column_name IS NOT NULL)
```

После имени столбца или после всех остальных

---
> Обязателен ли первичный ключ в таблице?

Обязателен только в теории реляционных БД, реальные (в том числе PostgreSQL) не обязывают иметь его. Первичный ключ может быть *только один*

---
> Как осуществляется выбор текущей схемы?

Через конфигурационный параметр `search_path`:

```sql
SHOW search_path;
SET search_path TO bookings;
```

Вообще, вместо `TO` в `SET` может использоваться и "равно" `=`

```
   search_path
-----------------
 "$user", public
```

После переключения через `SET` команды `CREATE` начнут создавать объекты в новом пространстве имен

---
> В каком порядке должны создаваться таблицы с внешними ключами?

Сначала должны создаваться ссылочные таблицы, а потом ссылающиеся. Если в базе данных нет циклических ссылок, то всегда существует таблица или таблицы, которые не ссылаются ни на какие другие. С них и нужно начинать. Перед созданием очередной таблицы, имеющей внешние ключи, уже должны существовать все ссылочные таблицы для нее. Продвигаться "вниз" от вершины иерархии, где находится таблица, не имеющая внешних ключей

При наличии циклических ссылок таблиц друг на друга придется пользоваться командой `ALTER TABLE`

---
> Что такое *схема*?

Раздел базы данных, где создаются таблицы и прочие объекты. По сути - пространство имен

По дефолту используется схема `public`

---
> Что такое Postgres-комментарии?

Расширение - команда `COMMENT`, позволяющая хранить прямо в БД комментарии к объектам:

```sql
COMMENT ON COLUMN airports.city IS 'Город';
```

После этого, в выводе `# \d+ airports`, в поле `Description` начнет отображаться созданный комментарий

---
> Как просмотреть информацию о последовательности, лежащей за полем `serial`?

Слеш-команда `# \d <table-name>` выведет имя последовательности:

```sql
DEFAULT nextval('flights_flight_id_seq'::regclass)
```
Та же команда на имени последовательности выведет информацию уже о ней самой:

```
\d flights_flight_id_seq
```

---
> Что будет если удалить ссылочную (для внешних ключей) таблицу?

СУБД не позволит удалить ее стандартным `DROP`-ом:

```
ERROR:  cannot drop table aircrafts_data because other objects depend on it
DETAIL:  ...
constraint ...
constraint ...
```

В подсказке будет сказано, что удалять нужно через

```sql
DROP TABLE aircrafts CASCADE;
```

---
> Что делает команда `DROP ... CASCADE`?

Удаляет основную (ссылочную) таблицу, но не ссылающиеся таблицы

Из них (подчиненных таблиц) только удаляются внешние ключи, сами таблицы остаются

---
> Как сделать проверку перед удалением, что таблица существует?

Ключевое слово пишется в третьем лице:

```sql
DROP TABLE IF EXISTS aircrafts[ CASCADE];
```

Вместо ошибки (если таблица не существует) выводится notice:

```
NOTICE:  table "<name>" does not exist, skipping
```

---
> Как добавить / удалить столбец в таблице?

```sql
ALTER TABLE airports ADD COLUMN speed <definitions>;
ALTER TABLE airports DROP COLUMN speed;
```

---
> Как добавить в непустую таблицу `NOT NULL`-столбец?

Проблема в том, что для существующих записей новый столбец окажется незаполненным, и будет выброшена ошибка. Выход - сначала добавлять (через `ALTER TABLE ... ADD COLUMN ...`) столбец без `NOT NULL`-ограничения, заполнять таблицу значениями этого столбца, и только потом назначать ему ограничение через `ALTER TABLE ... ALTER COLUMN ...`:

```sql
ALTER TABLE aircrafts ADD COLUMN speed integer;
UPDATE aircrafts SET speed = ...
...
ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
```

Удалить такое ограничение можно аналогично:

```sql
ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
```

---
> Как добавить / удалить ограничение общего типа на столбец?

Использовать в `ALTER TABLE` ключевые слова `CHECK`/`CONSTRAINT`:

```sql
ALTER TABLE aircrafts ADD CHECK (speed >= 300);
ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
```

---
> Как в `ALTER TABLE` можно выполнить сразу несколько действий?

Через запятую перечислить их все:

```sql
ALTER TABLE airports
  ALTER COLUMN longitude SET DATA TYPE numeric(5, 2),
  ALTER COLUMN latitude  SET DATA TYPE numeric(5, 2);
```

---
> Как изменить тип столбца?

В случае приводимых друг к другу типов смена пройдет гладко - в автоматическом режиме:

```sql
ALTER TABLE <table> ALTER COLUMN <column> SET DATA TYPE <new-type>;
ALTER TABLE <table> ALTER COLUMN <column> TYPE <new-type>[ USING (...)];
```

`USING` с набором кейсов может пригодиться только для неоднозначных приведений

---
> Какой синтаксис у конструкции `CASE`?

Обрамление в `CASE`/`END`, ветви обрамлены в `WHEN`/`THEN`, дефолтная ветвь не обрамлена, просто `ELSE`:

```sql
CASE WHEN fare_conditions = 'Economy' THEN 1
     WHEN fare_conditions = 'Business'THEN 2
     ELSE 3
END
```

Такой switch может использоваться, например, при смене типа столбца внутри `USING`:

```sql
ALTER TABLE ... SET DATA TYPE <new-type> USING (CASE ... END);
```

---
> Как переименовать столбец или ограничение?

```sql
ALTER TABLE seats
  RENAME COLUMN fare_conditions TO fare_conditions_code;
ALTER TABLE seats
  RENAME CONSTRAINT seats_fkey TO seats_code_fkey;
```

Второе может понадобиться потому, что переименование столбцов не переименовывает соответствующие ограничения, даже те, чьи имена были автоматически сгенерированы по имени столбца

---
> Как указать уникальность для существующего столбца?

Станадартно, как и для любых других ограничений, через `ALTER TABLE ... ADD`:

```sql
ALTER TABLE fare_conditions ADD UNIQUE (fare_conditions_name);
```

---
> Какой общий синтаксис создания представлений?

Если список имен столбцов не указан, тогда их имена "вычисляются" (формируются) на основании текста запроса:

```sql
CREATE VIEW <name> [<column-names>] AS SELECT ...;
```

После создания view, к нему можно обращаться как к обычной таблице. Вместо написания (сложного) первоначального `SELECT`-а:

```sql
SELECT * FROM <view>;
```

Хотя первоначальный `SELECT` всё равно выполняется каждый раз при запросах к view

---
> Какое расширение предоставляет Postgres для `CREATE VIEW`?

`OR REPLACE` сработает только тогда, когда имена столбцов представления сохраняются:

```sql
CREATE OR REPLACE VIEW <view-name> AS SELECT ...
```

При изменении имен столбцов нужно сначала удалить представление через `DROP VIEW[ IF EXISTS]`

---
> Как можно задать имена столбцов в представлении?

- сначала будут просмотрены явно указанные в списке:

```sql
CREATE OR REPLACE VIEW seats (code, fare_cond, num_seats) AS SELECT ...
```

- потом просматриваются алиасы:

```sql
CREATE VIEW ... AS SELECT ... count(*) AS num_seats ...
```

- потом берутся имена самих столбцов из `SELECT`-а

---
> Чем отличается материализованное представление от таблицы?

Оно не только хранит данные, но и хранит запрос, на основе которого оно построено

---
> Как создать материализованное представление?

Синтаксис похож на создание обычного view:

```sql
CREATE MATERIALIZED VIEW ... [ WITH [ NO ] DATA ];
```

---
> В каком случае материализованное представление заполняется данными при создании?

Если не было указано `WITH NO DATA` в конце команды `CREATE MATERIALIZED VIEW`

---
> Как загрузить/обновить данные в материализованном представлении?

```sql
REFRESH MATERIALIZED VIEW <view-name>;
```

---
> Как посмотреть список схем в текущей базе?

```
# \dn
```

```
   List of schemas
   Name   |   Owner
----------+-----------
 bookings | localhost
 public   | postgres
```

---
> Каково дефолтное значение конфигурационного параметра `search_path`?

```
"$user", public
```

Схема `"$user"` присутствует на случай если будут созданы схемы с именами, совпадающими с именами пользователей

---
> Как в `search_path` задать несколько схем?

Перечислить их через запятую, без кавычек. Ни внешние, ни у каждой схемы, кавычки не нужны:

```sql
SET search_path = bookings, public;
```

Для объектов, у которых имя схемы не указано явно (напр., `public.aircrafts`), схемы из этого параметра просматриваются слева направо

---
> Как узнать имя текущей схемы?

```sql
SELECT current_schema;
```

Имеется в виду, видимо, самая левая схема в параметре `search_path`

---
> Как можно в каждой записи таблицы сохранять, кто эту запись добавил?

Создать поле типа `text` и указать ему соответствующий `DEFAULT`:

```sql
who_adds_row text DEFAULT current_user,
```

То есть, `DEFAULT` не обязан быть константой, и вполне может быть функцией

---
> Как убрать ограничение `NOT NULL` у столбца?

Ключевое слово `DROP`:

```sql
ALTER TABLE <table-name> ALTER COLUMN <column-name> DROP NOT NULL;
```

---
> Как добавить столбцу ограничение `NOT NULL`?

Ключевое слово `SET`:

```sql
ALTER TABLE <table-name> ALTER COLUMN <column-name> SET NOT NULL;
```

---
> Дан столбец с ограничением:
> 
> ```sql
> CHECK (mark >= 3::numeric AND mark <= 5::numeric)
> ```
> 
> Можно ли в него вставить `NULL`-значение?

Да, ограничения типа не отменяют необходимость `NOT NULL`. Без него в поле можно вставлять либо числа `3, 4, 5`, либо неопределенное значение `NULL`

---
> Можно ли создать столбец с таким ограничением?
> 
> ```sql
> mark CHECK (mark >= 3 AND mark <= 5) DEFAULT 6
> ```

Да, можно, то, что `DEFAULT` нарушает ограничения не проверяется во время создания таблицы или выполнения `ALTER TABLE`

Но вот вставить запись с дефолтным значением в него уже не получится, запрос будет всегда падать с ошибкой

```
ERROR:  new row for relation "<t-name>" violates check constraint "<c-name>"
```

Только указывать явно

---
> Какие значения всё же могут повторяться для столбцов с ограничением `UNIQUE`?

Неопределенные, `NULL`. В таблице может быть несколько записей, уникальный столбец которых содержит `NULL`

Такое возможно, т.к. два `NULL` не считаются совпадающими. Результат их сравнения неопределен, сам является `NULL`:

```sql
SELECT NULL = NULL, NULL <> NULL;
```

```
 ?column? | ?column?
----------+----------
          |
```

---
> Как удалить первичный ключ в таблице?

Потребуется узнать (например, через `# \d <table-name>`) его имя:

```sql
ALTER TABLE <t-name> DROP CONSTRAINT <pk-name>[ CASCADE];
```

Каскадирование может потребоваться, если от этого ключа зависят другие, например, внешние

---
> Что здесь лишнее?
> 
> ```sql
> NOT NULL PRIMARY KEY
> ```

`NOT NULL`: первичный ключ подразумевает это по умолчанию

---
> Будет ли ограничение `NOT NULL` на текстовом столбце препятствовать вставке пустых строк?

Нет, не будет. Нужно создавать явное ограничение для такого:

```sql
ALTER TABLE students ADD CHECK (name <> '');
```

Такое ограничение не будет отсекать строки, состоящие из пробелов. Проверку/подготовку строк можно возложить на прикладную программу или воспользоваться встроенной функцией `trim()`

---
> Можно ли сменить тип столбца с `numeric` на `char`? А обратно?

Если длина строки (`N` в `char(N)`) достаточна, то смена `numeric` -> `char` идет без лишних движений, гладко

Обратная смена (`char` -> `numeric`) уже требует явного приведения - использования `USING`:

```sql
ALTER TABLE students ALTER COLUMN doc_ser TYPE decimal(4,0) USING doc_ser::numeric(4,0);
```

---
> Как переименовать таблицу?

Команда обычная, подкоманда - `RENAME TO`:

```sql
ALTER TABLE table_name RENAME TO new_table_name;
```

---
> Что произойдет при попытке удаления таблицы, на которой базируются (другие) представления?

Будет выброшена ошибка. Для удаления зависимых объектов (в том числе views) нужно писать

```sql
DROP TABLE ... CASCADE;
```

---
> Можно ли изменять данные при помощи представлений?

Да, можно пользоваться стандартными `INSERT`, `UPDATE` и `DELETE` на view, но представление должно удовлетворять некоторым условиям

Представление становится *изменяемым* автоматически, если его `SELECT` достаточно простой: у `FROM` ровно один элемент, в нем не используются агрегатные и оконные функции, `LIMIT`, `UNION` и некоторые другие конструкции

---
> Какими командами модифицируется структура представлений?

```sql
ALTER VIEW
ALTER MATERIALIZED VIEW
```

---
> Что такое *горизонтальные* и *вертикальные* представления?

- в вертикальное включается лишь часть столбцов исходной таблицы (`SELECT col1, col2, ...`)
- в горизонтальные включается лишь часть строк (`SELECT * ... WHERE/HAVING`)

Или может быть смешанный вариант
