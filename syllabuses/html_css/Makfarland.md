- введение в CSS и HTML, что это такое, различия, почему лучше разделять
- о `doctype`, о различении тегов `<br>` (HTML4) `<br />` (XHTML), и что HTML5 понимает оба варианта
- CSS3 делится на модули: Selectors, Values and Units, Box Alignment etc. Единого CSS4 не будет, будут только обновления модулей
- стандартные рекомендации:
  * теги `font`, `b`, `i` устарели
  * использование CSS упрощает написание HTML и *уменьшает размер* страниц
  * использование тега `table` для layout-а усложняет код страницы
  * не злоупотреблять тегом `br`
  * не используйте теги и их атрибуты для изменения внешнего вида
  * не злоупотреблять тегами `div` и `span`
- при написании HTML-кода думайте о структуре, о роли, которую играет блок, а не о внешнем виде (он задается в CSS)
- теги `div` и `span` - стандартные, общие теги для группировки блочных и inline-элементов соответственно
- перечисление семантических тегов HTML5, признание что от них мало пользы. Тег `code` тоже семантический
- опять упоминание скрипта HTML5-shiv для IE8. Дальше игнорируем все трюки для старых IE
- пользуйтесь валидатором (validator.w3c.org) или аналогичными расширениями для браузера. Для CSS тоже есть
- важность doctype, совместимость со старыми IE (неактуально)
- формат правил CSS, внешние и внутренние (размещаются перед `</head>`, в HTML5 атрибут `type="text/css"` у `style`) таблицы стилей, их кеширование
- 2 типа подключения CSS: через тег `link` и через CSS-конструкцию `@import`. `@import` должен идти до (любого) первого правила, иначе будет проигнорирован браузером
- длинный пример ("обучающий урок"), дальше будут пропущены
- описание CSS-селекторов. Идея группирования элементов в контейнеры на основе `div` и `span`
- `id` и селекторы на основе него используются всё реже, но могут быть полезны для якорных ссылок (`#`)
- наследование CSS-свойств предпочтительнее использования `*`
- для гибкости лучше не указывать имя тега вместе с классом (`p.intro`), только класс (`.intro`)
- в CSS2 псевдоэлементы пишутся с одним двоеточием (`:first-letter`). В CSS3 уже с двумя (`::first-letter`), для различения с псевдоклассами (напр., `:hover`), хотя браузеры распознают и так и так. Кроме `::selection` (выделенные юзером части страницы) - он только с двумя
- сайт <https://www.quirksmode.org>, некий аналог caniuse
- использование `title` (всплывающих подсказок) - это хорошо
- ключевые слова для `:nth-child(odd|even)` для "зебры" в таблицах. Числа и `n`, вроде `:nth-child(3n+2)` - для более сложных случаев
- различия `:(first|last|nth)-child` (любой потомок) и `:(first|last|nth)-of-type` (потомок указанного перед двоеточием типа). Это всё псевдоклассы (не (псевдо)элементы), пишутся с одним двоеточием
- как и `:not()`. Он внутри скобок поддерживает только простые выражения, составные типа `a > span` нельзя, как нельзя и подряд несколько not: ~~`:not(...):not(...)`~~ (так ли?)
- описание наследования CSS-свойств, оно распространяется на всех потомков, не только на прямых. Почему оно удобно (напр., задание `font-family` на `body`). Не наследуются:
  * `margin`, `padding`, `border`
  * в тегах типа `h1` или `a` (их отображение определяет браузер)
- общее описание каскадирования и приоритеты (выбранный приоритет лучше смотреть с помощью инспектора в браузере):
  * стиль самого элемента перекрывает родителя
  * стиль более близкого родителя перекрывает остальных родителей
  * несколько стилей объединяются
  * более специфичные перекрывают. Чем больше число, тем более специфичный: tag - 1, class - 10, id - 100, inline - 1000
  * последующие (по порядку) перекрывают предыдущие
  * `!important`. Если неоднозначность (два свойства с `!important`), то снова вычисляются приоритеты
- нужно стараться избегать "войн значимости", делать селекторы короче и понятней. Это одна из причин отказа от `id`: слишком высокая значимость у селектора, и отменить общий стиль (`#article p` = 100 + 1) единичным классом (`.special` = 10) не получается. Добавление `#article .special` делает селектор длиннее и копировать/двигать HTML теперь нельзя (+ статья на тему: <https://csswizardry.com/2011/09/when-using-ids-can-be-a-pain-in-the-class/>)
- "сброс стилей" - выставление всем на свете начальных значений, видимо, решение времен "войны браузеров". Напр., всем тегам `margin: 0; padding; 0;`, телу `line-height: 1.2em;`, спискам и таблицам начальных стилей и т.д. Видимо, уже неактуально
- Times New Roman, Georgia, Palatino Linotype = serif (с засечками, для больших текстов), Arial, Helvetica, Verdana, Tahoma = sans-serif (без засечек, для заголовков), Courier, Lucida Console, Monaco (Mac) = monospace (моноширинный, для кода)
- некоторые считают, что на веб-страницах нужно использовать только шрифты без засечек: декоративные штрихи шрифтов плохо отображаются на экранах с низким разрешением
- `@font-face`, форматы и правовые вопросы, поддержка полужирного и курсива отдельными директивами
- Google Web Fonts и какой-то TypeKit (не нужно)
- если в шестнадцатеричном представлении цвета каждая пара состоит из одинаковых чисел, что можно сократить до 3х знаков: `#aa22cc` === `#a2c`
- `font-size: medium` - базовый размер шрифта в браузере (как правило, 16px). Есть еще 6 именованных констант, от `xx-small` (9px) до `xx-large` (32px)
- `em` - размер заглавной "M", `1em` === `100%` === `16px` для шрифта. Это что-то вроде размера шрифта, ориентация на его размер 
- относительные единицы измерения и наследование (напр., `ul { font-size: 75%; }` и вложенные списки) могут приводить к проблеме всё большего уменьшения размера. Для избежания этого есть единица `rem` (= root em) - размер корневого элемента
- `font-weight` ("плотность" шрифта) не только имеет именованные значения `normal|bold`, но и 9 градаций, от 100 до 900. `font-style` помимо `italic` имеет значение `oblique`
- `font-transform` меняет строчные/прописные, `font-variant` (стенографическое свойство) что только не делает, напр., `small-caps` отображает всю фразу прописными в размере строчных
- `text-decoration`, `letter|word-spacing`, `text-shadow`, `line-height`, `text-align`, `font` (стенографическое), `text-indent`, `::first-line|letter`
- стилизация списков, `list-style-type|position|image`, `list-style` (стенографическое). Выделение маркеров (цветом, начертанием) отдельно от контента `li` возможно двумя способами: через заключение содержимого `li` в `span` и сброса стиля для этого `span`-а, и (рекомендованный) через `ol { list-style: none; } li::before { content: counter(li); ... }`
- путь внутри `url("...")` в CSS должен задаваться относительно таблицы стилей, а не веб-страницы
- область заполнения `background-*` внутри границы (`border`) *включает `padding`*
- описание `margin`/`border`/`padding`, пример с отступами в процентах (считаются от размера самого элемента)
- у `0` не нужно указывать единицы измерения. Последовательность сторон в стенографических свойствах: **TR**ou**BL**e - Top -> Right -> Bottom -> Left. Два значения - TB + RL, три - T + RL + B
- `margin`-ы двух соседних элементов не суммируются, а берется больший (!). Для предотвращения этого можно использовать `padding`. Горизонтальные поля, плавающие, и абсолютно/относительно позиционированные элементы не конфликтуют
- вполне допустимо использовать отрицательные марджины для создания нужных эффектов
- блочный элемент создает разрыв строки до и после тега
- `padding` и `margin` на линейном элементе не возымеют действия, отступы будут добавлены только справа и слева. Паддинг увеличит блок, но он просто будет перекрывать окружающий текст. Только `display: inline-block` расширит строку (переноса строк не будет (`inline`), но поля, отступы, ширина и высота будут применяться (`block`))
- опять пример с горизонтальным списком - `display: inline` для элементов списка
- описание свойства `border`, пример краткого описания 3х границ (`border: ...; border-right: none;`)
- формат вроде `border-radius: 20px/40px` задает *эллиптические углы*. Они также могут быть заданы через `border-top-left|right-radius` или `border-radius: %`
- вендорные префиксы обозначают экспериментальные свойства: `-moz-` (FireFox), `-webkit-` (Chrome, Safari), `-o-` (Opera), `-ms-` (IE)
- дробные значения свойств меньше единицы можно писать без нуля - `.75`
- `box-shadow` поддерживает несколько теней (через запятую): `box-shadow: ..., ...`
- ширина в процентах высчитывается относительно элемента-контейнера (процент его ширины)
- общее правило для блоков с текстом - не указывайте их высоту. При изменении текста и/или размера его шрифта может произойти переполнение блока
- указываемая в CSS ширина (`width`) - это ширина содержимого, самой внутренней части элемента. Фактически же браузер выделит ему место равное `width` + `padding` + `border` + `margin`
- свойство `box-sizing` управляет описанными в пред. пункте вычислениями. `content-box` - дефолт, суммирует всё, как описано; `padding-box` - включать паддинги в указанную ширину (область контента станет меньше); `border-box` - включать еще и границу (контент еще меньше); ~~`margin-box`~~ - не существует (дискуссия: <https://stackoverflow.com/questions/10808413/css3-box-sizing-margin-box-why-not>)
- четыре значения свойства `overflow`
- `min|max-width|height` нужны для адаптивного дизайна, когда меняется размер окна браузера
- `float` смещает элемент к краю его контейнера, а нижележащий контент поднимается до одного с ним уровня и начинает обтекать плавающий элемент. Это полезно, например, для обтекания картинок текстом. Или боковой панели. Или плавающей цитаты. Для всех плавающих элементов кроме изображений нужно указывать ширину
- `clear` запрещает обтекание с указанной стороны. `both` совсем разрывает `float`-поток, а `left|right` полезны, чтобы несколько `float`-элементов не выстраивались в линию, но обтекание остальными элементами сохранялось (разобрать позже)
- три формата изображений: PNG/GIF для картинок с малым числом цветов, однотонными областями и/или прозрачностью, JPEG - для фотографий и других картинок с множеством цветов
- в `url()` допустимы любые кавычки (`'`/`"`) или их отсутствие. Пути - относительно .css-файла (напр., если файл `styles/index.css` а картинки в папке `images/` на корневом уровне, то путь будет `url(../images/...)`). Корневой путь (папка с сайтом на хосте) начинается со слеша (`url(/...)`), это позволяет размещать css и картинки как угодно и не использовать везде `../`
- начальное значение `background-repeat` = `repeat`
- `background-attachment: scroll` можно использовать, например, для фиксации логотипа на странице
- CSS3-свойства `background-origin|clip: content|padding|border-box` ограничивают области расположения фоновой картинки. `background-size: contain|cover|..px` задает размеры
- пример свитка (с масштабированием средней части) - использование трех фоновых изображений через запятую
- много про `background-image; [repeating-]linear|radial-gradient(...)`. Интересные примеры: <https://leaverou.github.io/css3patterns/>, <http://www.standardista.com/cssgradients/> (и даже флаги стран: <http://www.standardista.com/CSS3gradients/flags.html>). Генератор градиентов: <https://www.colorzilla.com/gradient-editor/>
- для задания картинки в качестве маркера списка можно использовать как `list-style-image`, так и `background-image` (последний вариант рекомендует автор, т.к. можно точно позиционировать)
- из четырех псевдоклассов - `:link`, `:active`, `:hover`, `:visited` - последний выделяется. В целях безопасности для него можно указывать только небольшой набор свойств (цвет текста, фона и границы), а `getComputedStyle()` всегда возвращает цвет непосещенных ссылок. Для обеспечения правильной каскадности, переопределяя эти классы, нужно располагать их в порядке **L**o**V**e/**HA**te: link -> visited -> hover -> active
- примеры создания ссылок в виде кнопок + ролловеры. Примеры и описание в сети: <https://webdesignerwall.com/tutorials/css3-gradient-buttons>. Генератор: <http://css3button.net>
- ссылки на создание выпадающих меню, средствами только CSS или с JQuery [p. 324]. Ссылки на туториалы по спискам и панелям навигации [p. 327]
- спрайты, туториалы по ним и упоминания инструментов генерации [pp. 328-329]
- селектор для всех сторонних ссылок: `a[href^='http://']:not(a[href^='http://www.mysite.com'])`
- при преобразованиях `[<vendor-prefix>]transform: ...` браузер не выделяет доп. место под элемент, поэтому он может перекрывать соседние. Типы: `rotate([-]Ndeg)`, `scale[X|Y](N[,M])`, `translate[X|Y](Npx[,Mpx])` (перемещение), `skew(Ndeg[,Mdeg])` (наклон). Можно в одном `transform` перечислить несколько функций через пробел. Генератор трансформаций: <http://westciv.com/tools/transforms/index.html>
- по умолчанию преобразования идут относительно центральной точки элемента. Поменять ее можно через `transform-origin: left|..px|...%|etc.`
- есть и трехмерные преобразования, на туториалы даны ссылки [p. 358]
- плавная анимация смены свойств: `transition-property: all|<name>, ...` и `transition-duration: .1s, ...`. Свойство `transition-timing-function: linear|ease|...` управляет скоростью анимации (линейная, нарастающая, и т.д.). Про скорости анимирования переходов: <https://www.the-art-of-web.com/css/timing-function/>. Задержка перехода - `transition-delay`, и стенографическое свойство `transition`
- CSS3-анимация: `@keyframes <name> { from { <propreties> } [N% {}] to { <propreties> } }`. Запись `@<keyword>` называется *правилом*
- применение анимации: `<selector>[:<pseudo-class>] { animation-name: <name>, ...; animation-duration: .1s, ...; }`. По аналогии с переходами есть `animation-timing-function`, а также `animation-iteration-count: <N>|infinite` - число запусков анимации (по дефолту 1). Есть еще `animation-direction`, `animation-fill-mode`, `animation-play-state` и стенографическое `animation`
- теги внутри таблицы: `caption` (заголовок) и `col` внутри `colgroup` (группа столбцов для одновременного задания стилей для всех их ячеек, из стилей доступны только ширина и `background-*`)
- выравнивание в ячейках: `text-align: left|center|right|justify`, удобно использовать в `th`, сразу на все ячейки. `vertical-align: top|middle|bottom|baseline`, где `baseline` чем-то почти незаметно отличается от `top`
- браузеры по умолчанию добавляют между ячейками таблицы промежуток ~2px. Управляется это через свойство `border-spacing`. Если оно равно нулю, то границы начнут удваиваться, ведь дефолтное значение свойства `border-collapse` равно `separate`. Если же установить его в `collapse`, то `border-spacing` начнет игнорироваться, а границы выровняются по толщине
- "зебра" в таблицах: `tr:nth-of-type(odd|even) { background-color: ...; }`
- не стоит менять дефолтный вид кнопки "Submit" в формах, чтобы пользователи узнавали ее от сайта к сайту
- организация форм: теги `fieldset`, `legend`, `input` всех видов и `select`. Текст заключается в `label` (inline-элемент), для выравнивания которым устанавливается `display: inline-block` и фиксированная ширина. Полезно для меток и `vertical-align`. Какой-то гайд про accessible forms: <https://www.htmldog.com/guides/html/advanced/forms/>. И еще какой-то про стилизацию на псевдоклассах: <http://html5doctor.com/css3-pseudo-classes-and-html5-forms/>
- два варианта макета: фиксированная (напр., 960px) и нефиксированная ширина. Более сложный вариант второй - адаптивный дизайн, с использованием media queries
- краткая история перехода от табличной верстки к div-ам
- не нужно заворачивать всё подряд в div, код должен быть минимальным. Использовать div-ы (или HTML5-аналоги) нужно только когда они необходимы. В HTML5 div используется в основном для группировки по стилистическим соображениям
- верстка по столбцам возможна через `float` или абсолютное позиционирование (редко: плохо подходит), multicolumn (?), flexbox и grid
- движение Mobile First - в первую очередь думать о мобильных пользователях, не забивать каждый сантиметр страницы, а выделить только главную информацию и размещать ее
- о важности наброска страницы, предварительного планирования макета
- пример с колонками на основе `float`: левое поле (идет первым) имеет `float: left` и фиксированную ширину, а основной блок (идет вторым) его обтекает, растягиваясь на всю оставшуюся ширину. Порядок следования элементов в коде важен. Основному блоку добавляется `margin-left|right` чуть больше ширины боковой панели, чтобы он не обтекал боковую панель снизу (если боковая панель с малой высотой)
- три колонки делаются так же: блок 1 имеет `float: left`, блок 2 - `float: right`, блок 3 (центральный) - обтекает их оба по центру, между ними
- хитро манипулируя вложенными контейнерами и float-ами `right|left`, можно добиться что основной блок будет идти по порядку перед левой и правой панелями (полезно для accessability и поисковых ботов)
- опять какое-то длинное описание проблем с переполнением float-контейнеров, всякие хаки и свойство `clear`
- разбивка текста на колонки: `column-count|gap|rule` до сих пор плохо поддерживается и (возможно) требует вендорных префиксов
- статья о многоколоночных layout-ах, надо почитать позже: <https://www.w3.org/TR/css-multicol-1/>
- цитата: "HTML-таблицы не совсем подходят для разметки веб-страницы. Они добавляют много кода, их трудно обновлять, и они не работают так же хорошо в альтернативных браузерах, например тех, что используются в мобильных телефонах."
- опять какие-то хаки с высотой плавающих элементов и background-картинками
- во врезке упоминаются flexbox и grid. Ссылка на стандарт, можно почитать: <https://drafts.csswg.org/css-flexbox/>
- если суммарная ширина (плавающих) столбцов больше ширины контейнера, последний элемент будет на новой строке - произойдет его выпадение. Это можно исправить, уменьшив чью-либо ширину, заменив отступы через `margin` на `padding`, использование процентов ширины и `box-sizing: border-box` (последнее некоторые даже предлагают использовать всегда, вешать на `*`-селектор)
- RWD = Responsive Web Desing = адаптивный веб-дизайн - верстка для всех типов устройств. Итан Маркотт, книга "Отзывчивый веб-дизайн" - идеолог подхода
- мобильные браузеры могут уменьшать масштаб, если страница не помещается в экран. Отменить такое поведение можно указав (перед `<title>`) `<meta name="viewport" content="width=device-width">` (ширина экрана браузера (`vieweport`) должна быть равна ширине экрана устройства). Этот метатег нужен для адаптивного дизайна. Есть аналогичное правило в CSS - `@viewport { width: device-width; }`, но с плохой поддержкой браузерами
- стратегии использования медиазапросов:
  * изменение числа колонок
  * фиксированная ширина на десктопах и 100% на мобильных
  * сужение полей и отступов на узких экранах
  * увеличение размера основного текста и уменьшение заголовков на маленьких экранах (уменьшение "контраста" размеров)
  * что-то делать с большими меню навигации (возможно, с использованием JS)
  * скрытие части контента (с осторожностью, может сбить с толку юзавших десктоп-версию)
  * использование фоновых картинок разного размера
- определение контрольных точек ширины зависит от дизайна. Частый пример, 2 точки: до 480px - смартфоны, до 768px (иногда до 1024px) - планшеты, выше - десктопы
- сначала создается дизайн с прицелом на десктоп или мобильные, только потом добавляются медиазапросы
- медиазапросы через тег: `<link href="css/small.css" rel="stylesheet" media="(max-width: 480px)">`
- свойство `max-width: 480px` в медиазапросах эквивалентно высказыванию "имеет ширину **до** (как максимум) 480px", `min-width: 769px` - "имеет ширину **от** (как минимум) 769px". Интервал - `(min-width:481px) and (max-width:768px)`
- медиазапросами можно проверять и высоту, ориентацию, цветность устройства, и т.д.
- способы включения медиазапросов прямо в CSS:
  * `@import url(css/small.css) (max-width:320px);` (может вести к проблеме с каскадностью: `@import` должен быть первым в CSS. Можно составлять основной CSS только из импортов, тогда будут перекрывать как надо)
  * `@media (max-width: 480px) { ... }`. Должны идти после основных (десктопных) свойств (хотя, если дизайн ориентирован в первую очередь на мобильные, то после)
- `width: auto` ~ `width: 100%` (всегда?)
- дальше идет пример с float-ами и вычислением процентов (гибкие сетки)
- гибкие изображения - масштабирование средствами браузера. Проблемы:
  * мелкие изображения растягиваются и пикселизуются на десктопах
  * крупные изображения вызывают большой расход трафика на мобильных
- вторая проблема не решена, одна из самых существенных в RWD. Группа по решению проблем адаптивного дизайна: <https://www.w3.org/community/respimg/>. Или автоподбор размеров картинок через JS: <http://adaptive-images.com>
- величина "пиксела" на экранах с высоким разрешением (долее высокой плотностью пикселов на дюйм) подгоняется (вычисляется), чтобы шрифт не становился слишком мелким. "Пиксел" в таком случае не единичная точка на экране
- позиционирование, 4 типа. `relative` оставляет "дыру" на старом месте и перекрывает других. `float` не работает вместе с абсолютным
- если не указать значение позиции (`top|left|right|bottom`), браузер помещает элемент в то же самое место на странице, где бы он располагался без позиционирования. То есть, если просто установить для элемента позицию `absolute`, но не указать позицию, браузер просто оставляет элемент на том же месте, но располагает поверх другого содержимого
- если контейнер имеет позиционирование `absolute|fixed|relative`, то любые его дочерние элементы располагаются относительного него самого (контейнера). Иначе (для `static`-контейнеров) их `absolute`-потомки располагаются относительно окна браузера. Из пред. пункта, однако, следует, что если у такого дочернего `absolute`-элемента не задать позицию вручную, он будет продолжать располагаться внутри контейнера, даже статического
- таким образом, `relative`-позиционирование применяется в основном к контейнерам ("относительно меня"), тогда как `absolute` - к их вложенным, дочерним тегам. Это позволяет перемещать контейнер, сохраняя (возможно, вынесенный за него) абсолютно позиционированный тег. Например: `<h1 style="position: relative;"><img style="position: absolute; left: -50px;" ,,,/></h1>`
- по умолчанию `z-index` равен 0. Абсолютно позиционированные элементы - следующий по порядку в коде перекрывает предыдущий. Аналогия для `absolute`-элементов - приклеиваемая сверху на лист/доску записка
- `opacity: 0` - аналог установки `visibility: hidden`. Отличие в том, что `opacity` можно анимировать
- сайтец по генерации всплывающих CSS-подсказок: <http://www.menucool.com/tooltip/css-tooltip>
- стратегии позиционирования:
  * абсолютное подходит для размещения маленьких элементов `relative`-контейнеров (заметки/даты в углу, выдавливания изображения из блока, подписи поверх фото)
  * фиксированные "фреймы" - header/footer/боковая панель - `fixed`, главная область с прокруткой и `margin-left+top` - способ верстки макета
- задание стилей для принтера: `<link rel="stylesheet" media="print" .../>`, `@import url(...) print;`, `@media print { ... }`
- 10 типов устройств: `all`, `braille`, `embossed`, `handheld`, `print`, `projection`, `screen`, `speech`, `tty` и `tv`
- зачем-то (чтобы уж наверняка) рекомендует использовать `!important` для печати
- в стилях для принтера хорошо будет задавать размер шрифта (и задавать в пунктах, `12pt` - дефолт для печати) и цвет текста `#000`. Сброс картинок и цвета одновременно, стенографическим свойством: `background: #fff;`
- "раскрытие" ссылок при печати: `a[href^="http://"]:after { content: " (" attr(href) ") ";}`. Чтобы длинные ссылки не вылезали за край - `word-wrap: break-word;`. Скрытие ненужных блоков (напр., панелей навигации) - через `display: none;`
- статья про CSS для печати: <https://alistapart.com/article/goingtoprint/>
- `page-break-before|after` печатает новую страницу (разрывает) - указанный элемент всегда первый/последний на странице
- комментарии CSS: `/* ... */`
- общие рекомендации:
  * не называйте стили именами по их внешнему виду, типа `.redText` или `.font20px`
  * называйте стили по позиции (напр., `.floatLeft`), только если их единственное (служебное) предназначение - двигать элементы. Иначе даже `.header`/`.footer` лучше называть по назначению
  * избегайте непонятных названий, типа `.s1`
  * используйте несколько классов, напр., один сдвигает элементы (`float`), а другой задает границы (`margin`)
  * группируйте внутри файла стили, относящиеся к одной части страницы, или стили со связанными задачами (напр., расположение, оформление, и т.д.). Разделяйте группы комментариями
  * группируйте по файлам, в пределах разумного. Удобно создать одну базовую таблицу, и подключать ее через HTML-тег. В ней же подключать все остальные через `@import`
  * не указывайте класс у каждого тега ("тяга к классификации"), пользуйтесь селекторами потомков
  * классифицируйте тег `<body class="home">` по страницам сайта, и на его основе стройте остальные стили (`.home h1 { ... }`), свои для каждой страницы. Кроме того, такой подход позволяет выделить текущую позицию в навигационной панели
- CSS-препроцессоры (такие как LESS/SASS) имеют разные полезные фичи, типа использования переменных, генерации вендорных префиксов, объединения и минификации файлов
- необходимость обновлять кеш CSS у пользователей можно решить через параметры урла (`<link rel="stylesheet" href="main.css?v=2">`), но возникает необходимость обновлять HTML-теги. Можно через серверные языки, типа PHP
- рекомендует сбрасывать и обнулять стили браузера в начале (занулять отступы, ставить `line-height`, и т.д.). Ссылка на проект Normalize.css: <http://nicolasgallagher.com/about-normalize-css/>
- для очень больших CSS есть попытки упорядочить код, напр., Object Oriented CSS (OOCSS, немного похож на "тягу к классификации"), или Scalable and Modular Architecture for CSS (SMACSS)
- условные комментарии для IE: `<!--[if Internet Explorer]> ... <![endif]-->` или `<!--[if lte IE 8]> <link href="IE7_styles.css" rel="stylesheet" > <![endif]-->`
- хорошее приложение, свойства справочно + некоторые общие моменты, типа цветов
- приложение 2 - подборка ресурсов в интернете
