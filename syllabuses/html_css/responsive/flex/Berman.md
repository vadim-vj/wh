- flexbox = CSS3 flexible box layout module (выходит, целый модуль)
- этот модуль определяет новый layout mode (`flex`), такой же, как `block`, `inline`, `table` etc.
- причина использования flexbox - простота: не нужны `float`-ы, хаки и умный javascript. Примеры проблем, решаемых флексбоксом: <https://philipwalton.github.io/solved-by-flexbox/>
- на момент написания книги 81% браузеров в мире подддерживали флексбокс (сейчас уже 95-98%). Для поддержки старых браузеров можно использовать:
  * вендорные префиксы
  * концепцию прогрессивного улучшения (progressive enhancement, ?)
- драфт последней версии стандарта: <https://drafts.csswg.org/css-flexbox/>
- терминология (+ картинка):
  * flex container - родительский элемент
  * flex items - дочерние элементы
  * main (дефолт - горизонтальная, row container)/cross (перпендикулярная главной) axis - оси
  * main/cross size - размеры контейнера
  * main/cross start/end - начальная и конечная координаты углов контейнера
  * все main/cross меняются местами при смене направления контейнера
  * column/row flex container - тип контейнера, в зависимости от направления расположения элементов
  * single/multi-line flex container - во сколько линий располагаются элементы контейнера (`flex-wrap`)
  * cross size-а в многострочных контейнерах несколько - свой для каждой строки
  * при этом cross start/end для таких контейнеров всё же один - всё так же координаты углов
- во всех примерах книги для всех элементов установлен `box-sizing: border-box`

- `display`: `flex` и `inline-flex`. Оба делают элемент flex-контейнером, но первый превращает его (сам контейнер) в блочный элемент, а второй в inline. Это имеет значение, когда несколько контейнеров идут рядом (располагаются на новых строках или в одной)
- `flex-direction`: `row` (дефолт), `row-reverse`, `column`, `column-reverse`. Значения `-reverse` раполагают элементы контейнера справа налево или снизу вверх
- если ширина/высота item-а (элемента контейнера) не задана, то он занимает всё доступное место по cross axis: растягивается на полную высоту row-контейнеров или на полную ширину в column-к (см. `align-items`). Можно ограничить через `width` (напр., `width: 40%;`; это для `flex-direction: column`)
- направление `flex-direction` (и `-reverse`-опций соотвественно) зависит от направляения письма (иврит - справа налево, китайский - сверху вниз)
- `flex-wrap`: `nowrap` (дефолт), `wrap`, `wrap-reverse`. Определяет, будет ли контейнер одно- или многострочным. `-reverse` будет добавлять новые линии не под/после, а над/перед
- пример: контейнеру задано `width: 900px` и каждому его элементу - `min-width: 200px`. При `nowrap` происходит переполнение контейнера (item-ы вылезают за правую границу), при `wrap` две штуки переносятся на новую строку вниз, а при `wrap-reverse` первая строка (4 элемента) находится внизу, а вторая (два оставшихся элемента) - *над* ней
- `flex-flow: [flex-direction] [flex-wrap]` - стенографическое. Пример: `flex-flow: row wrap`
- `order` распределяет item-ы по группам. По дефолту у всех `order: 0`. Порядок следования в контейнере: по группам (`order`-у) по возрастанию (0-1-2-...), внутри одной группы - по порядку следования в HTML-коде. `order` может быть отрицательным
- применение `order` - для поисковых роботов: можно расположить главный контент первым, но в CSS указать нужную для него позицию
- `justify-content`: `flex-start` (дефолт), `flex-end`, `center`, `space-between`, `space-around`. Задается для контейнера. Выравнивает элементы вдоль главной оси (по умолчанию, по горизонтали). Вступает в игру когда item-ы занимают не всё место в контейнере или переполняют его. Для `space-between` места по краям крайних item-ов, не выделяется, а для `space-around` - по половине от ширине пространства между самими элементами, и оба этих значения работают только если места в контейнере больше нужного (т.е. не важны при переполнении). Распределять item-ы можно и по вертикали, если `flex-direction: column`
- `align-items`: `stretch` (дефолт), `flex-start`, `flex-end`, `center`, `baseline`. Задается для контейнера. Определяет положение item-ов по вспомогательной оси (cross axis). По умолчанию растягиваются, занимают всю высоту (или ширину). `baseline` будет отличаться от `flex-start` при различии шрифтов в item-ах, и только при выравнивании по вертикали (в случае дефолтного `flex-direction: row`, иначе будет совпадать c `flex-start`). И, как мне видится, `baseline` лучше не использовать
- в обоих `flex-start|end` соотвествует координатам "main/cross start/end" (см. определения выше). В книге есть картинка [p. 44]
- `justify|align-self` - аналог двух предыдущих, но применяется уже к item-у, не к контейнеру. Значения свойств такие же + `auto` = унаследовать значение от контейнера
- также можно выравнивать item-ы через `margin: auto`. Устанавливая любую границу в `auto`, браузер отведет ей всё доступное место. Напр., `margin: auto 0 0 auto` прижмет элемент к правому нижнему краю. Свойства `align|justify-*` перестают действовать с авто-марджинами, потому что просто не остается свободного места в контейнере, которое можно распределять (оно занято этими авто-границами). В книге не сказано, какой способ предпочитать и чем они хуже/дучше друг друга
- `align-content` выравнивает целые строки в `wrap`-контейнере, и не имеет влияния на отдельные элементы или однострочные (одностолбцовые) контейнеры. Значения те же, + похожая картинка [p. 55]

- когда контейнер изменяет размеры, item-ы изменяются вслед за ним. Три свойства *для элементов*, `flex-grow|shrink|basis`, контролируют это поведение. Элемент полностью негибкий (inflexible), если `flex-grow: 0; flex-shrink: 0;`, иначе гибкий
- W3C не рекомендует использовать эти свойста по отдельности, рекомендует юзать стенографическое `flex`
- `flex-basis` - начальный размер элемента, перед приведением размеров во flexbox-е:
  * значение - `auto|<width>`. `auto` берет значение ширины элемента, `<width>` задает свое
  * `flex-basis` имеет преимущество над `width` (напр., `width: 200px; flex-basis: 600px;` ---> (start) width=600px)
  * важно помнить, что из-за дефолтного `flex-shrink: 1`, элемент вполне может быть сжат, несмотря на установку исходной ширины (напр., `width: 200px; flex-basis: auto;` ---> (final) width=88px)
  * при `flex-shrink: 0` пред. пример даст (final) width=200px
  * **IMPORTANT**: но при любом `shrink` флексбокс сожмет (блочный) элемент до размеров его контента, если ширина и/или базис не заданы совсем (`width: auto; flex-basis: auto;`)
  * в таком случае (при незаданной ширине) ширина нескольких колонок будет распределена согласно длине их (многострочного) контента
  * от себя: базис в `0` === `0%` сведет ширину item-а к минимуму (одному слову, или одной букве при `word-break: break-word`), к ширине контента. Это позволяет делать что-то вроде "fit content"
- контейнер тянется вдоль своей *главной* оси. `flex-grow|shrink` задаются в (неотрицательных) долях, насколько расширяется/ужимается элемент относительно других элементов
- `flex-shrink` - коэффициент сжатия:
  * вступает в игру, когда item-ам недостаточно места в строке контейнера (negative free space)
  * по умолчанию для всех элементов равен `1` - размеры всех item-ов сокращаются пропорционально
  * *результирующий коэффициент сжатия* вычисляется как `flex-basis * flex-shrink` - то есть пропорционально как размеру item-а, так и заданному `flex-shrink`
  * в книге дан пример - три item-а одинаковой ширины, но с разным `flex-shrink`: 1-2-3. Первый (shrink=1) самый большой, второй (shrink=2) меньше (сжимается сильнее), третий еще меньше. Сжатие идет только когда контейнер в ширину меньше 3x200px, иначе все элементы одинаковой ширины, несжатые
- `flex-grow` - коэффициент расширения:
  * вступает в игру, когда в контейнере есть свободное место
  * по умолчанию для всех элементов равен `0` - размеры всех item-ов не растут
  * в книге дан пример - три item-а с незеданной шириной (сжаты до ширины контента), у первого `grow` не задан, у двух остальных по единице. Первый не растет, остальные два делят всё свободно пространство контейнера пополам
  * второй пример аналогичен примеру из `shrink` (с заменой на `grow`), только теперь item-ы растут пропорционально, а не сжимаются (зеркальная картина)
- `flex: [flex-grow] [flex-shrink] [flex-basis]` - стенографическо:
  * `initial` === `0 1 auto` - дефолт
  * `none` === `0 0 auto` - негибкий элемент, см. выше. Сжатие до ширины контента всё равно идёт
  * `auto` === `1 1 auto` - размер пропорционален остальным элементам
  * от себя: `1` === `1 1 0%` (базовая ширина = ширине контента, пропорциональное сжатие/расширение), `0` === `0 1 0%` (базовая ширина = ширине контента и всегда минимальна (`grow` === `0`), пропорциональное сжатие)

- две стратегии кроссбраузерной совместимости: вендорные префиксы (проще, но дает меньше), и постепенное улучшение/"progressive enhancement" (сложнее, но будет работать везде)
- префиксы:
  * порядок: сначала с префиксами, потом без
  * автопрефиксеры: <https://github.com/postcss/autoprefixer>, <http://pleeease.io/play/>, <https://autoprefixer.github.io>
- progressive enhancement:
  * подход, при котором сначала создается и тестируется базовая структура, и только потом добавляются продвинутые фичи, и только для поддерживающих их браузеров
  * базовая версия должна быть простая, и работать на CSS2 (или вообще без CSS), и без JS
  * использует js-утилиту Modernizr, которая проверяет поддержку флексбокса браузером и добавляет к тегу `html` классы `[no-]flexbox`/`[no-]flexwrap`/..., что потом можно использовать в CSS (`.flexbox .container-flex { display: flex; ... }`)

- медиазапросы используются для очень больших изменений, которых нельзя достичь иначе
- общее описание медиазапросов (`@media media-type and (media-feature) { ... }`), типы
- responsive text. Общие рекомендации:
  * размер шрифта должен быть достаточно большим (`font-size`)
  * длина строки 45-100 символов (`width` контейнера)
  * высота строки ~ 150% от размера шрифта (`line-height`, `padding`/`margin`)
- рекомендует использовать в качестве единиц `em`/`rem` (`rem` - базовый размер для `html`). `1 em` === текущий `font-size` (16px по дефолту)
- задает `html { font-size: 15px; }`, все остальные шрифты в `rem`, а потом для маленьких экранов, в медиазапросе, меняет одно значение - `html { font-size: 18px; }`. В пикселах пришлось бы переопределять все размеры
- или еще рекомендует задавать `html { font-size: 100%; }` (задает величину `rem` равной базовому размеру шрифта, настроенному в браузере), дальше снова всё в `rem`. И на малых экранах уменьшать размер, напр., `@media (max-width: 480px) { html { font-size: .65rem; } }`
- долго и нудно рассматривает отличия `rem` от `em` и пересчет одного в другое. Пишет, что `rem` проще, хотя и поддерживаются "всего" в 97% браузеров (`em` везде)
- рекомендует задавать высоту строки в безразмерных единицах, долях от размера шрифта: `div { font-size: 10px; line-height: 1.5; }`. Можно еее немного увеличиать на больших экранах, через медиазапросы
- отзывчивые картинки. Одно изображение:
  * установив `img { max-width: 100%; }` картинка будет растягиваться когда нужно, но не превысит свои изначальные размеры
  * если установить `img { width: 100%; }`, то будет тянуться на весь контейнер, превышая свой изначальный размер и теряя качество
  * установка еще и высоты - `img { max-width: 100%; height: auto; }` - дает небольшой выигрыш в производительности (врет наверное)
- отзывчивые картинки. Несколько изображений:
  * несколько `img`-тегов рядом, с разными классами. В медиазапросах одни из картинок скрываются, другие показываются
- в первом случае смартфонам требуется загружать большие картинки, но и второй вариант не выход: современные браузеры прелоадят изображания, будет грузить все из `img`. Решения:
  * аттрибут `srcset` у `img`: `<img srcset=“small.jpg 400w, medium.jpg 700w, big.jpg 1000w" />`, где `w` - это ширина картинки. Браузер сам выберет нужную, основываясь на текущей ширине экрана, медиазапросы не нужны
  * не все поддерживают `srcset` (Android 4.4 не поддерживает), но можно продублировать его аттрибутом `src` с какой-нибудь одной картинкой (напр., самой маленькой) и установить `img { width: 100%; }` чтобы она тянулась под любой экран
  * можно использовать и тег `picture`, внутри которого есть и `img` для обратной совместимости, и теги `source` с аттрибутами `media` и `srcset` на все случаи жизни. Поддерживают его тоже не все (Android 4.4 не поддерживает)
- `viewport` - ширина окна браузера. Хз, но тег `<meta name="viewport" content="width=device-width, initial-scale=1">` вроде как нужен всегда, для создания отзывчивого дизайна, без нее браузер не масштабирует страницу, а тупо уменьшает шрифт (так ли?)
- также `viewport` влияет на поисковую оптимизацию, у гугла есть доп. коэффициент на это дело. Онлайн-тулза для проверки адаптивности страниц: <https://search.google.com/test/mobile-friendly>

- четвертая часть книги посвящена примерам. Использует "постепенное улучшение"
- навигационное меню:
  * использует медиазапросы с контрольной точкой в 850px
  * на ней превращает горизонтальное меню в вертикальное (`li` внутри `nav`-блока меняет `display: inline-block|block`)
  * использует некий "checkbox hack" - скрытый (через абсолютное позиционирование или `opacity: 0`) чекбокс + `label` с ним связанный, по которому можно кликать, меняя состояния рядом находящегося третьего элемента (`#toggle:checked ~ .control-me { /* A toggled state! No JavaScript! */ }`). Типа обработка клика без JS. клик Ссылка на статью: <https://css-tricks.com/the-checkbox-hack/>
  * использует флексбоксы для меню
- что-то похожее для футера, еще меняет шрифт
- вообще вся глава это листинги кода с медиазапросами, в который не стоит и лезть
- статья "Multi-Device Layout Patterns": <https://www.lukew.com/ff/entry.asp?1514> и реализация описанных в ней концепций: <https://developers.google.com/web/fundamentals/design-and-ux/responsive/patterns?hl=ru>. Там описываются пять layout-ов:
  * Tiny Tweaks - простейший. Один столбец из блоков в ширину окна. Не требует продвинутого CSS и JS, поэтому хорош для базовой версии
  * Column Drop - на самых широких экранах все столбцы идут бок о бок. При уменьшении ширины они один за одним переносятся вниз, вплоть до одноколоночного дизайна. Автор реализует через флекбокс с `flex-wrap: wrap;`, и через медиазапросы, для разных ширин, устанавливает блокам ширину (напр., `width: 60|100%`)
  * Mostly Fluid - в средней части два столбца всегда остаются бок о бок. На некоторой точке блок перестает расширяться чтобы заполнить ширину окна, а начинают появляться границы (свободное место) по бокам (`.container { max-width: 900px; margin: 0 auto; }`)
  * Layout Shifter - тасование блоков, с измененим размеров экрана нижние выстраиваются в столбцы, потом верхний уходит в бок
  * Off Canvas - скрывает элементы для экономии места (напр., на маленьких экранах). Показывает их только по некоторму действию (напр., по клику на чекбокс показывается навигационное меню). Опять юзают checkox hack
- еще 30 страниц верстают полный пример страницы

- приложение A, направление флексбокса:
  * в западной системе письма строки идут горизонтально, постепенно заполняя страницу сверху вниз (`writing-mode: horizontal-tb`). Направление письма слева направа (`direction: ltr`)
  * в этой (западной) системе направления флекса: `row` - слева направо, `row-reverse` - справа налево, `column` сверху вниз, `column-reverse` - снизу вверх
  * в других системах (напр., иврит - письмо справа налево, китайский - сверху вниз) направления флекса могут отличаться
  * направление письма задается браузером пользователя, но можно определять и явно (напр., для английских страниц) - `html { writing-mode: horizontal-tb; direction: ltr; }`
- приложение B, ссылки на автопрефиксеры
- приложение C, разбор checkbox hack

----

- `width: 1000px` для каждого item-а в контейнере почему-то не действует, не переполняет контейнер. А вот `min-width: 1000px` действует вполне. UPD. Объяснение с SO: по дефолту, все item-ы имеют `flex-shrink: 1`, т.е. им разрешено уменьшаться, чтобы влезть в контейнер. Установка `flex-shrink: 0` - и они перестанут игнорировать ширину, перестанут сжиматься, начнуть переполнять контейнер. Можно установить только одной колонке, тогда только она станет 1000px, вторая сожмется до остатка ширины контейнера
- у `justify-content` еще много значений, не описанных в книге. Вероятно, то же и для `align-items`
- всё равно не понимаю. Если задать большой `flex-basis` для первой колонки, напр., `1500px`, то ее ширина станет меньше чем вообще без задания этого базиса. Изменение `flex-shrink` с `1` на `0` это исправляет, а вот `flex-grow` никак на размеры не влияет. Но почему при `flex-shrink: 1` колонка остается меньше в ширину чем вторая, с незаданными шириной и базисом? Даже если задать `width: 100%; flex-basis: 100%` - всё равно меньше
- в книге не рассматриваются случаи базиса и сжатия для блочных элементов с нефиксированной шириной и большим размером контента, плохо
