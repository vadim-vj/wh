- заявляет что grid (= "сетка")- обобщенный layout, универсальный, шагнувший дальше flexbox-а. Имеет природу таблиц
- концепция та же - item-ы внутри контейнера, который может быть `grid` или `inline-grid` (без новых строк перед и после контейнера)
- что-то про отличие (от `display: block`) в поведении совместно с float-элементами (не переносится на новую строку после float-блока)
- и что-то про то, что margin-ы грида и его дочернего элемента не соединяются (collapse) в одну, в отличие от блочных элементов
- мелкие отличия в CSS-свойствах, типа игорирования `float`/`clear` внтури контейнера, `vertical-align` не работает на item-ах (хотя работает внутри item-ов), `column-count`,  `columns`,  etc. и `::first-line`/`::first-letter` неприменимы (не работают)
- основные понятия:
  * line - (разделительные) линии, базовое понятие. Определяя одну или несколько линий, автоматически создаются остальные компоненты:
  * tracks - полосы сетки. Фактически, столбец или строка грида. Ширина или высота определяются расположением линий
  * cell - ячейка, пространство ограниченное 4мя линиями. Аналог ячейки таблицы
  * area - область, объединяет несколько ячеек. Но может состоять и из только одной ячейки, или из всех (занимать весь грид)
- стоит помнить, ччто все описанные выше вещи виртуальны, не привязаны к конкретным html-блокам. Это именно разметка сетки, задание layout-а, и любые ячейки могут быть пустыми
- другой момент - сетка не ограничивает в задании линий и не заставляет определять больше нужного. Можно задать только столбцы или только строки (сетка из одной строки или из одного столбца соответственно)
- `grid-template-rows|columns` задают линии сетки. Ссылки на линии идут по номерам (от 1) или по именам (задаются самостоятельно; напр., если в примерах встретится "start" - то это не предопределенное имя, его нужно задавать самому)
- примеры:
  * `grid-template-columns: 200px 50% 100px` - три вертикальных линии. Называет такое задание *fixed-width*, даже с процентами: это потому, что ширина второго столбца зависит только от ширины контейнера, но не от контента внутри этой item-ы. Если в этот столбец поместить более широкий или узкий контент, ширина самого столбца не изменится. Замечания по примеру: a. три значения задают 3 столбца и т.о. *4* линии, b. последняя линия не обязана достигать края контейнера
  * `grid-template-columns: [start col-a] 200px [col-b] 50% [col-c] 100px [stop end last]` - именование линий. Квадратные скобки. Первая линия тоже именуется, перед ее именем не идет значения (нулевая позиция)
  * `grid-template-rows: [start masthead] 3em [content] 80% [footer] 2em [stop end]` - если добавить к пред. в тот же контейенер, то уже получим таблицу. Имена линий для строк и столбцов могут совпадать: у них разные пространства имен. Замечания по примеру: задание высоты строки в 100% сделает ее высоту *равной* высоте контейнера (не оставшейся части (- высота первой строки), а всего контейнера), так что она и сама выйдет за границы контейнера, и вытолкнет из него строку футера
  * решается это через паттерн `minmax`, напр., `... [content] minmax(3em, 100%) ...` - высота должны быть минимум `3em` и максимум `100%`, браузер подберет значение в этом интервале сам, чтобы остальные строки не переполняли контейнер. Замечания по примеру: если второе значение (max) меньше первого, то оно замещается на min
  * если `minmax` кажется неясным, то можно использовать `calc`, напр., `grid-template-rows: [start masthead] 3em [content] calc(100%-5em) [footer] 2em [stop end]`. Такое решение более хрупкое, т.к. в случае внесения изменений в ширину одного столбца требует согласования всех значений
- до этого все наши полосы были негибкими - в них жестко задавалась ширина/высота. Это можно обойти
- задание размера полос в частях/дробях (fractional units). Единица измерения `fr`. Пример разделения контейнер на 4 части - `grid-template-columns: 1fr 1fr 1fr 1fr` (примерно ~ `grid-template-columns: 25% 25% 25% 25%`)
- при смешивании в одном выражении гибких и негибких единиц, доли (`fr`) берутся от свободного пространства, оставшегося после выделения места под элементы фиксированного размера. В примере `grid-template-columns: 15em 1fr 10%` гибкая часть одна, и она займет 100% оставшегося свободного пространства
- можно использовать и `minmax`, но доли в нем разрешены только в `max`-позиции. Пример: `grid-template-columns: 15em 4.5fr minmax(5em,3fr) 10%`. Если третьему столбцу выделяется меньше или равно 5em, он становится негибким, и тянется только второй столбец
- еше вариант гибких полос - задание размеров по контенту (content-aware tracks): `min|max-content`. Например, для блоков с текстом, `max-content`, вероятно, будет занимать всю доступную ширину, `min-content` сделает очень высокий блок с переносами в один символ шириной
- пример сетки для галереи, где для всех строк и столбцов задано `max-content`. Это ограничит размер строки/столбца размером самой большой картинки в нем/ней. Но вот если добавить подписи к картинкам, текст начнет тянуть столбцы на свою полную ширину
- `min|max-content` часто используют внутри `minmax`
- есть еще `auto`, которое тоже можно везде использовать. Браузер сам будет высчитывать размеры. Хоть использование `auto` и не всегда желательно, только с ним работают свойства `align|justify-content` (см. ниже)
- `repeat(N, <size>)` для большого числа строк/столбцов:
  * пример: `grid-template-columns: repeat(10, 5em)`
  * можно повторять что угодно, включая `auto`, `min-|max-content` и т.д.
  * можно повторять целые группы, напр., `repeat(3, 2em 1fr 1fr)`
  * `repeat` не обязан быть единственным в выражении, можно добавлять и обычные столбцы/строки (напр., `grid-template-columns: repeat(3, 2em 1fr 1fr) 2em`)
  * а вот вкладывать `repeat` один в другой нельзя
  * можно повторять и имена линий, они не обязаны быть уникальными (`grid-template-columns: repeat(4, 10px [col-start] 250px [col-end]) 10px`)
  * но при повторении имен линий, имена крайних будут объединены: `repeat(3, [top] 5em [bottom])` ~ `[top] 5em [bottom top] 5em [top bottom] 5em [bottom]`
  * ключевое слово `auto-fill` можно использовать вместо `N` в `repeat`. Будет повторять пока не заполнит весь контейнер. `auto-fill` поддерживает только фиксированные размеры
  * несколько `repeat` могут встречаться в одном определении, но только один из них может иметь `auto-fill` (иначе непонятно, у кого приоритет). У повторений с фиксированным размером преимущество, им выделяется место первым
  * `auto-fill` всегда выделяет хотя бы один столбец. Кроме того, он выделяет место даже если нет заполнителей в столбцах (оставляет пустое место)
  * есть еще `auto-fit`, вот он уже выделяет место только если в столбце/строке есть элемент, иначе не создает полосу

- сравнивает `grid-template-areas` с ASCII-артом:

```
grid-template-areas:
  "h h h h"
  "l c c r"
  "l f f f";
```

#### Области
- `grid-template-areas`:
  * названия могут быть любыми, одинаковые объединяются
  * пробелы между строками игнорируются, в примере выше так расположено просто для удобства
  * кавычки важны, они разделяют строки грида. Иначе получим одну строку из 12ти столбцов
  * совпадение имени (объединения ячеек) и в направлении столбца, и в направлении строки, - ошибка, непрямоугольная область. В таком случае всё объявление станет невалидным, и грид не будет задан
  * точка `.` называется "null cell token", и задает безымянную ячейку. Можно писать одну или несколько точек (`...`)
- `grid-template-areas` именует области, а `grid-template-columns|rows` задают их размеры. Используются совместно. В этом случае линии грида именуются неявно, как `<area-name>-start` и `<area-name>-end` для линий, ограничивающих область. Заданные явно имена линий не перезаписываются, а объединяются с неявными
- это работает и в обратную сторону. Если линиям заданы имена в формате `<name>-start`/`<name>-end`, то `<name>` неявно именует область между линиями
- неявно именовать область можно и через только две линии (напр., столбец), но это приводит к созданию лишней строки в контейнере (?), так что явное именование областей всё же предпочтительнее

#### "Крепление" элементов к сетке
- элемент растягивается до размеров ячейки (так ли?)
- `grid-row|column-start|end` задаются на самих элементах, и определяют, к какой ячейке этот элемент приаттачить:
  * значения - цифры (номера линий) или строки (названия линий)
  * если указана только одна линия, то берется область в одну ячейку
  * или можно вместо конечной линии указать `span [N|1]`, охват - кол-во ячеек от начальной линии (просто `span` = `span 1`). Работает и налево и направо
  * поддерживает и отрицательные значения - отсчет от другого края. Напр., `grid-column-start: -1; grid-row-start: -1;` задает крепление к правому нижнему углу
  * значения могут объединять названия и цифры: это разрешает неоднозначности при нескольких линиях с одинаковым названием. Это можно использовать и в `span`
  * `auto` в этих свойствах приведет к тому, что размещение будет управляться через *grid flow* (?) (см. ниже)
- `grid-row|column` - стенографические свойства для предыдущих. Запись через слеш - `grid-column: col-B / span -2`, где одна часть может быть опущена. Можно ссылаться и через имена областей (`grid-row: footer`) - будет взята первая линия области (= `grid-row: footer 1`)
- описывает какую-то проблему с растяжением областей, и пишет что лучше не использовать одинаковые имена для линий и областей
- задание `grid-row|column[-start|end]`, охватывающего несуществующие ячейки, создает т.н. *неявную сетку* (implicit grid) - дополнительные ячейки. Отсчет с этих ячеек вести нельзя. Рекомендует всё же придерживаться явного грида
- если `start` больше `end`, они меняются местами. Некорректные `span`-ы заменяются на `auto`
- свойство `grid-area` привязывает элемент к (целой) ранее определенной области сетки. Вместо названия области можно указать до 4х линий (номера или имена; порядок - `row-start -->  column-start --> row-end --> column-end`, полностью противоположен стандартному TRBL (Top, Right, Bottom, Left))
- `grid-row|column`/`grid-area` можно задать и так, что элементы пересекутся. Это вполне допустимо

#### Grid flow
- `grid-auto-flow: row|column|dense` управляет размещением элементов, которые явно не определяют `grid-row|column`/`grid-area`
- самим элементам в книге он задает `grid-row: auto; grid-column: auto;` (а оно надо? а что без него?)
- заполняет по одной ячейке на элемент внутри контейнера, по строкам или по столбцам
- линии сетки можно не задавать, автоматическое раположение элементов определит их неявно
- размер этих неявных ячеек можно задавать через `grid-auto-rows|columns` (напр., `grid-auto-rows: 50px`), иначе задаются в ширину контента
- направление grid flow - слева-направа, сверху-вниз. В европейских языках
- `grid-auto-flow: dense row|column` заставляют браузер самому подбирать наиболее удачное расположение для заполнения свободного места (так ли?), но из его рисунков трудно понять, как конкретно. Может делать некоторые контейнеры (напр., галереи фотографий) более компактными

#### Стенографическое свойство `grid`
- позволяет либо задать шаблон сетки, либо grid flow и размер авто-полос, но не оба одновременно. То, которое не задается, будет сброшено до дефолта
- приводит примеры, как в несколько строк задать и области, и их размеры, и для столбцов и для строк. Удобное свойство, если научиться им пользоваться
- `grid: subgrid` задается на элементе, и он начинает охватывать несколько ячеек родительского грида (вроде бы)

#### Границы
- `grid-row|column-gap` задавется на контейнере, и только в фиксированных единицах (не процентах или `fr`)
- `grid-gap: <row> <column>` - стенографическое
- марджины элементов учитываются уже после расположения их на сетке, а при расчете полос игнорируются

#### Выравнивание
- семейства `justify-*` и `align-*` свойств такие же, как для флексбокса
- значения тоже такие же, тянуть ли элемент внутри ячейки или прижимать к краям
- `*-items` и `*-content` различаются тем, что первый выравнивает внутри ячеек, а второй как-то распределяет сами ячейки (???)

#### Упорядочивание
- как упоминалось выше, ячейки могут перекрывать друг друга
- управлять перекрытием можно через `z-index`
- или через `order`, такое же свойство, как во флексбоксе
