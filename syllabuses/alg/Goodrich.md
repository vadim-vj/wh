
---
> Что выдаст этот код?
> 
> ```python
> divmod(8.2, 3.14)
> ```

Результат деления `//` всегда целый (хотя и имеет здесь тип `float`), а вот остаток может быть дробным:

```python
(2.0, 1.92)
```

Это связано с выполнением равенства:

```python
2.0 * 3.14 + 1.92 = 8.2
```

---
> В чем принципиальное отличие оператора `in` для строк от списков/кортежей?

Он может искать вхождение сразу подстрок, тогда как для остальных коллекций он проверяет только вхождение одиночного элемента:

```python
('ab' in 'abcd') == True
(list('ab') in list('abcd')) == False
```

---
> Как происходит сравнение последовательностей?

В *лексикографическом порядке* - поэлементное сравнение, до нахождения первого различия:

```python
([5, 6, 9] < [5, 7]) == True
```

Множества не являются последовательностями, сравнения в них идут независимо от порядка элементов. Словари вообще не поддерживают опреации типа "больше"/"меньше".

---
> Чему равны `alpha` и `beta` после выполнения этого кода?
> 
> ```python
> alpha = [1, 2, 3]
> beta = alpha
> beta += [4, 5]
> beta = beta + [6, 7]
> ```

```python
alpha == [1,2,3,4,5]
beta  == [1, 2, 3, 4, 5, 6, 7]
```

Составные операции изменяют тот же список, тогда как обычные переприсваивают переменной новое значение, заставляют ее ссылаться на новый список.

---
> Как, без встроенных функций, найти позицию элемента в последовательности?

```python
val = 24
i = 0
while i < len(seq) and seq[i] != val:
    i += 1
```

Т.к. вычисление идет по короткой цепи, вторая проверка никогда не выбросит `IndexError`.

---
> Как, без встроенных функций, найти сумму последовательности?

```python
total = 0
for i in seq:
    total += i

assert total == sum(seq)
```

---
> Как, без встроенных функций, найти максимальный элемент последовательности?

```python
biggest = seq[0]
for i in seq[1:]:
    if i > biggest:
        biggest = i

assert biggest == max(seq)
```

---
> Как, без встроенных функций, найти индекс максимального элемента последовательности?

```python
biggest_index = 0
for i, val in enumerate(seq):
    if val > seq[biggest_index]:
        biggest_index = i

assert biggest_index == seq.index(max(seq))
```

Или аналогично, через `i in range(len(seq))`.

---
> Как, без встроенных функций, найти количество вхождений элемента в последовательности?

```python
occ_count = 0
elem = 1
for i in seq:
    if elem == i:
        occ_count += 1

assert occ_count == seq.count(elem)
```

---
> На что в функции поиска элемента в последовательности можно заменить `break`?

На `return`. Вместо флага + `break` 

```python
found = True
break
```

можно сразу выходить из функции

```python
return True
```

---
> Как, без встроенных функций, умножить все элементы последовательности на константу?

Нужно перебирать по индексу:

```python
factor = 2
for i, _ in enumerate(seq):
    seq[i] *= factor
```

Или аналогично, через `i in range(len(seq))`.

---
> Напишите функцию - аналог `range()`, с поддержкой опционального параметра `stop`

Если указан только один параметр, то его и берем за `stop`:

```python
def cust_range(start, stop=None, step=1):
    if stop is None:
        stop = start
        start = 0

    while start < stop:
        yield start
        start += step
```

---
> Напишите прооверки, нужные для функции, вычисляющей квадратный корень

```python
def cust_sqrt(x):
    if not isinstance(x, (int, float)):
        raise TypeError('x must be numeric')
    elif x < 0:
        raise ValueError('x cannot be negative')

    return x ** .5
```

---
> Как проверить, что объект итерируемый?

```python
isinstance(x, collections.Iterable)
```

---
> Какой базовый класс у исключения, выбрасываемого при невозможности открыть файл?

`IOError`:

```python
try:
    fp = open('sample.txt')
except IOError as e:
    print('Unable to open the file:', e)
```

---
>Напишите функцию чтения положительного целого с клавиатуры, которая перехватывала бы и неправильные значения, и `Ctrl+D`

Нужно использовать кортеж классов исключений:

```python
x = -1
while x <= 0:
    try:
        x = int(input('Enter positive number: '))
    except (ValueError, EOFError):
        pass
    else:
        print('Num:', x)
```

---
> Напишите генератор всех делителей числа `n` (без оптимизации)

Для простых чисел этот список будет пуст:

```python
def factors(n):
    for i in range(2, n):
        if not n % i:
            yield i

(i for i in range(2, n) if not n % i)
```

Чтобы в результат попадали и единица и само число `n`, `range()` должен быть `(1, n+1)`.

---
> Напишите генератор всех делителей числа `n` (с оптимизацией; без использования функций библиотеки)
+
Перебор до квадратного корня. Второй `yield` нужен чтобы возвращать все делители:

```python
def factors_opt(n):
    i = 2

    while i * i < n: # while k < sqrt(n)
        if not n % i:
            yield i
            yield n // i

        i += 1
```

Последовательность здесь, в отличие от полного перебора, получится неупорядоченной. Вызовы

```python
n = 34212
print(list(factors(n)))
print(list(factors_opt(n)))
```

выдадут

```python
[2, 3, 4, 6, 12, 2851, 5702, 8553, 11404, 17106]
[2, 17106, 3, 11404, 4, 8553, 6, 5702, 12, 2851]
```

---
> Напишите бесконечный генератор последовательности Фибоначчи

```python
def fibonacci():
    a = b = 1

    while True:
        yield a
        a, b = b, a + b
```

Вызов

```python
gen = fibonacci()
for i in range(12):
    print(next(gen), end=' ')
```

выдаст

```
1 1 2 3 5 8 13 21 34 55 89 144
```

---
> Напишите генератор всех квадратов от единицы до `n` включительно

```python
(x*x for x in range(1, n+1))
[1, 4, 9, 16] # n = 4
```

---
> Как присвоить четырем переменным последовательные значения от `7` до `10` включительно?

Присваивание с распаковкой поддерживает любые итерируемые последовательности:

```python
# 7 8 9 10
a, b, c, d = range(7, 11)
```

---
> Как одновременно получить и целую часть от деления, и остаток?

Встроенная функция `divmod()` + присваивание с распаковкой:

```python
quotient, remainder = divmod(a, b)
```

---
> Как в одну строку инициализировать две переменные разными значениями?

В правой части присваивания с распаковкой могут стоять и константы:

```python
a, b = 0, 1
```

---
> Как в одну команду импортировать из модуля сразу несколько сущностей?

Через запятую можно перечислять не только сами модули:

```python
from math import pi, sqrt
```

---
> Какой генератор псевдослучайных чисел использует Python?

*Вихрь Мерсенна*

---
> Как инициализировать генератор псевдослучайных чисел?

Вызвать

```python
random.seed(hashable)
```

---
> Как выбрать случайный элемент из последовательности? Как случайным образом перемешать последовательность?

Функции модуля `random`:

```python
import random

random.choice(seq)
random.shuffle(seq)
```

---
> Как получить псевдослучайное целое из некоторого интервала? Из стандартного Python-диапазона?

Функции модуля `random`:

```python
import random

random.randint(a, b)
random.randrange(start, stop, step)
```

---
> Напишите функцию `is_multiple(n, m)`, которая проверяет что `n = mi` для некоторого `i`

Первая часть условия - "страж", проверка что `m` ненулевое, что можно делить. `True` если остаток от деления нулевой:

```python
def is_multiple(n, m):
    return m and not n % m

assert is_multiple(12, 4)
assert not is_multiple(13, 4)
```

---
> Напишите функцию, проверяющую число на четность. Функция не должна использовать оператор остатка от деления

Через "побитовое И" с единицей. Четные числа дают при этом `0`, а нечетные `1`:

```python
def is_even(k):
    return not k & 1

assert is_even(4)
assert not is_even(5)
```

---
> Без использования встроенных функций напишите функцию `minmax(data)`, которая принимает последовательность и возвращает пару, состоящую из минимального и максимального элементов

По условию задачи минимальная длина последовательности - единица:

```python
def minmax(data):
    min_ = max_ = data[0]

    for i in data:
        if i > max_: max_ = i
        if i < min_: min_ = i

    return min_, max_

assert minmax([5]) == (5, 5)
assert minmax([1, 2, 3, -7, 5, 5, 1]) == (-7, 5)
```

Интересный момент - условие может быть и `elif`. Если текущее значение больше максимума, то оно не может быть одновременно меньше минимума.

---
> Напишите функцию, которая получает положительное число, и возвращает сумму квадратов чисел, меньших его

```python
def squares_sum(n):
    return sum(x*x for x in range(1, n))

assert squares_sum(3) == 5
assert squares_sum(4) == 14
```

---
> Напишите функцию, которая получает положительное число, и возвращает сумму квадратов *нечетных* чисел, меньших его

Вместо добавления условия (`if x % 2`) в генераторное выражение можно просто изменить `range()`:

```python
def squares_sum_odd(n):
    return sum(x*x for x in range(1, n, 2))

assert squares_sum_odd(3) == 1
assert squares_sum_odd(4) == 10
assert squares_sum_odd(5) == 10
```

---
> Используя только функцию `random.randrange()`, имплементируйте функцию `choice()` - выбор случайного элемента последовательности

```python
import random

def choice(seq):
    return seq[random.randrange(len(seq))]
```

---
> Напишите функцию `has_odd_pair(seq)`, проверяющую что в последовательности есть пара чисел, чье произведение нечетно

Здесь только проверка, не сам поиск (хотя он тривиален, и тоже за линейное время). Произведение двух нечетных чисел нечетно:

```python
def has_odd_pair(seq):
    count = 0

    for i in seq:
        if i % 2: count += 1
        if count == 2: return True

    return False

assert has_odd_pair((1, 2, 3))
assert not has_odd_pair((2, 3, 4))
```

---
> Напишите функцию, проверяющую что все числа в последовательности уникальны

Решение "в лоб", попарное сравнение всех элементов. Дл такого (попарного) сравнения не нужно перебирать элементы после текущего - они будут проверены в последующих итерациях. Поэтому второй цикл берет элементы только до текущего:

```python
def are_unique(seq):
    for k in range(1, len(seq)):
        for j in range(k):
            if seq[j] == seq[k]:
                return False

    return True

assert are_unique((1, 2, 3))
assert not are_unique((1, 2, 2, 3))
```

Решение имеет квадратичную сложность. Пишет, что есть более оптимальное (?)

---
> Напишите списковое включение, генерирующее `[0, 2, 6, 12, 20, 30, 42, 56, 72, 90]`

Запомнить, что ряд, разности которого на каждом шаге возрастают на двойку (`2` -> `4` -> `6` -> `8` ...) - это на самом деле сумма самого числа и его квадрата (`x^2 + x`):

```python
assert [x * (x + 1) for x in range(10)]
  == [0, 2, 6, 12, 20, 30, 42, 56, 72, 90]
```

---
> Напишите списковое включение, генерирующее список букв `['a', 'b', ... 'z']`

```python
[chr(x) for x in range(ord('a'), ord('z') + 1)]
```

---
> Используя только функцию `random.randint()`, имплементируйте функцию `shuffle()` - перемешивания последовательности

`randint()`, в отличие от стандартного `range()`, включает оба своих края. Поэтому здесь `j` принимает значения на единицу больше, чем `i`:

```python
import random

def shuffle(seq):
    last = len(seq) - 1

    for i in range(0, last):
        j = random.randint(i + 1, last)
        seq[i], seq[j] = seq[j], seq[i]
```

В принципе, мешать последовательность можно разными и совершенно произвольными способами. Например, выполняя некоторое количество итераций (напр., зависящее от длины последовательности), выбирать два произвольных индекса и менять их значения местами.

---
> Напишите программу, которая читает из `stdin` строки, пока не нажато `Ctrl+D`. После чего выводит введенные строки в обратном порядке

```python
lines = []

while True:
    try:
        lines.append(input())
    except EOFError:
        break

print('\n'.join(reversed(lines)))
```

---
> Напишите списковое включение покомпонентного произведения двух векторов (списков/кортежей)

```python
n = 4
a = (1, 2, 3, 4)
b = (5, 6, 7, 8)

assert [i * j for i, j in zip(a, b)]   == [5, 12, 21, 32]
assert [a[i] * b[i] for i in range(n)] == [5, 12, 21, 32]
```

---
> Как удалить знаки пунктуации в строке?

```python
import string

assert "Lets try, Mike.".translate({
    ord(char): None for char in string.punctuation
}) == 'Lets try Mike'
```

---
> Напишите функцию, вычисляющую p-норму (и евклидову норму по умолчанию)

```python
def norm(v, p=2):
    return sum(x**p for x in v) ** (1/p)
```

---
> Напишите рекурсивный алгоритм генерации перестановок

```python
def permute(bag, permutation=[]):
    result = []

    if not len(bag):
        result.append(permutation.copy())

    else:
        for k in range(len(bag)):
            permutation.append(bag.pop(k))

            result += permute(bag, permutation)

            bag.insert(k, permutation.pop())

    return result
```

---
> Напишите функцию, вычисляющую сколько раз нужно разделить число на `2` прежде чем значение станет меньше `2`

Из подсказки следует, что здесь не нужно считать через цикл. Таким образом, остается два варианта - через логарифм и рекурсивно:

```python
import math
math.log2(n)

def my_log(n: int) -> int:
    if n < 2:
        return 0
    elif n < 4:
        return 1
    return 1 + my_log(n / 2)
```
