# Общее, `[common]`

---
> Что такое *структуры данных* (DS)?

Это способ представления и организации данных в памяти компьютера. Структура данных используются для представления ADT.

---
> Что такое *абстрактные типы данных* (ADTs)?

Это математическая модель типа с набором операций, определенных в рамках этой модели.

ADT лишь описывает, какие операции допустимы для данного типа. То, как они выполняются на низком уровне, описывается уже в DS.

---
> Какие есть два основных типа структур данных?

- *последовательные* - данные хранятся в памяти непрерывно. Это (динамические) массивы и частично хеш-таблицы
- *основанные на указателях* - данные хранятся в памяти произвольно. Это связанные списки, и графы/деревья

---
> Перечислите основные структуры данных

- *массив*
- *динамический массив* (вектор)
- *(дву)связные списки*
- *графы*, *деревья*, основанные на деревьях *кучи*
- *хеш-таблица*

---
> Перечислите основные ADT

- *строка*, *кортеж* (списки фиксированной длины)
- (сортированный) *список*
- *стек*
- (двусторонняя) *очередь*, *очередь с приоритетом*
- *множество*
- *словарь* (*отображение*)

---

# Структуры данных, `[data-structures]`

---
> Какая сложность у операций доступа в последовательных DS?

Константная, `O(1)`. Доступ к RAM осуществляется по адресу, это единичная операция.

---
> Как Python хранит массивы объектов?

Как массивы ссылок. Сами объекты хранятся разрозненно в куче, а (непрерывный) массив состоит из 64-битных ссылок (указателей) на эти объекты.

Поверхностное копирование, таким образом, создает копии непрерывных в памяти массивов ссылок, не затрагивая сами объекты. Для копирования и самих объектов вместе со ссылками на них нужно использовать `copy.deepcopy()`.

---
> Приведите код DS *массив*

На базовом уровне это массив из `ctypes`:

```python
(capacity * ctypes.py_object)()
```

Можно обернуть в класс, храня при этом размер:

```python
import ctypes

class Array:
    def __init__(self, length):
        self._length = length
        self._array = (self._length * ctypes.py_object)()

    def __len__(self):
        return self._length

    def __getitem__(self, index):
        return self._array[index]

    def __setitem__(self, index, value):
        self._array[index] = value
```

---
> Как удалить элемент из DS "массив"?

Никак, массив имеет фиксированный размер, задаваемый при создании, и меняться в рантайме (в том числе, через удаление элементов), он не может.

---
> Какая сложность у операций работы с DS "массив"?

Константная для доступа (и на чтение, и на запись) элемента: `O(1)`.

Операции вставки/удаления для этой структуры недоступны.

---
> Какие три основные поля содержит класс DS "динамический массив"?

- сам низкоуровневый массив, `._array: ctype.py_objects[]`
- текущая емкость массива: `._capacity: int`
- актуальная длина массива: `._length: int`

---
> Приведите код DS *динамический массив* (вектор), только сигнатуры методов. В чем основные отличия от массива фиксированной длины?

- три метода - `.__len__()`, `.__getitem__()` и `.__setitem__()` - совпадают с таковыми у статического массива
- метод `.__init__()` же уже не получает параметр-длину, она первоначально задается нулевой
- добавляются методы `.insert()`, `.append()`, и `.__delitem__()` - вставка в середину, в конец, и удаление элемента
- два новых служебных метода нужны для изменения размеров массива

```python
import ctypes

class DynamicArray:
    def __init__(self):

    def __len__(self):
    def __getitem__(self, index):
    def __setitem__(self, index, value):

    def insert(self, index, value):
    def append(self, value):
    def __delitem__(self, index):

    def _resize(self):
    def _make_array(self, capacity):
```

В принципе, можно создать класс через композицию - сделать внутреннее свойство `self._array` типа `Array`, и переадресовывать запросы этому классу.

---
> Приведите код метод `.__init__()` для DS "динамический массив"

Начальная длина задается нулевой, а емкость какой-либо произвольной, напр., `1`:

```python
def __init__(self):
    self._length = 0
    self._capacity = 1
    self._array = self._make_array(self._capacity)
```

Стоит обратить внимание, что в отличие от статического массива длина не передается в параметрах, конструктор вообще не получает аргументов:

```python
a = DynamicArray()
```

---
> Чем отличается код метода `.__getitem__()` для DS статический и динамический массивы?

В динамическом массиве, из-за сдвигов при удалении элементов (да и вообще), за границей `self._length` могут остаться неактуальные значения. Поэтому нужно дополнительно проверять выход за границы:

```python
class DynamicArray:
    def __getitem__(self, index):
        if not 0 <= index < self._length:
            raise IndexError

        return self._array[index]
```

---
> Приведите код метод `._make_array(self, capacity)` для DS "динамический массив"

Это просто генерация `ctypes`-массива фиксированной длины:

```python
def _make_array(self, capacity):
    return (capacity * ctypes.py_object)()
```

Происходит при каждом изменении размера вектора, когда она необходима при вставке/добавлении/удалении элемента. Также массив генерируется при создании обхекта. Таким образом, у метода две точки вызова: из `._resize()` и из `.__init__()`.

---
> Приведите код метод `._resize()` для DS "динамический массив"

Генерация массива новой (большей) длины + копирование в него элементов + переприсваивание с заданием новой емкости:

```python
def _resize(self):
    if self._length < self._capacity:
        return

    self._capacity *= 2
    tmp = self._make_array(capacity)

    for index in range(self._length):
        tmp[index] = self[index]

    self._array = tmp
    self._capacity = capacity
```

Ресайз условный: если еще есть место в массиве, то ничего не делать. Здесь же происходит и выбор стратегии аллоцирования. Вызов (безусловный) происходит в методах `.insert()`/`.append()`.

---
> Приведите код метод `.append()` для DS "динамический массив"

Это просто вставка элемента в позицию за последним элементом:

```python
def append(self, value):
    self.insert(self._length, value)
```

Сдвига элементов при этом, разумеется, не происходит: диапазон `range(index, self._length - 1)` в `.insert()` пустой.

---
> Приведите код метод `.insert()` для DS "динамический массив"

(Возможное) изменение размера массива, сдвиг всех элементов, начиная с текущего, на одну позицию вправо, увеличение длины + присваивание:

```python
def insert(self, index, value):
    self._resize()

    for i in range(self._length, index, -1):
        self[i] = self[i - 1]

    self._length += 1
    self[index] = value
```

Необходимость изменения емкости массива (как и само это изменение) происходит в `._resize()`. Два важных момента:

- сдвиг, в отличие от `.__delitem__()`, идет вправо, с отрицательным шагом (иначе будут перетираться элементы)
- изменение длины идет до присваивания, на случай возможных проверок индекса в `.__setitem__()`

---
> Приведите код метод `.__delitem__()` для DS "динамический массив"

Сдвиг влево + уменьшение длины:

```python
def __delitem__(self, index):
    for i in range(index, self._length - 1):
        self[i] = self[i + 1]

    self._length -= 1
```

---
> От чего зависить амортизированная сложность вставки элемента в конец динамического массива?

От аллокатора, от того, какую стратегию увеличения размера вектора он использует:

- для арифметической прогрессии - увеличения всегда на константу - сложность будет квадратичная, `O(n^2)`
- для геометрической прогрессии - увеличения всегда в `N` раз (напр., вдвое) - константная, `O((n + 1 + 1 + ...)/(n + 1)) ~ O(2n/n) = O(1)`

В последнем случае имеется в виду, что вставка `n` элементов требует `n + 1` операций (знаменатель). Суммарная их сложность - `O(n)` на однократное увеличение длины + `n` операций сложности `O(1)` на вставку `n` элементов. Итого, амортизированная (средняя) сложность равна отношению и константна.

---
> Как отличить хвостовой узел связного списка (`tail`)?

Его указатель на следующий элемент равен `None`

---
> Как отличить головной узел связного списка (`head`)?

Никак, на него нужно хранить отдельный указатель

---
> Сколько указателей на узлы связного списка нужно хранить отдельно?

Достаточно одного - `head`: достичь конечного узла можно и последовательным перебором. Но обычно, для удобства, хранят и `tail`.

---
> Как можно организовать класс - связанный список?

Можно сделать два отдельных класса - `Node` и `List`. Второй может хранить, например, ссылки на `head`/`tail`, а также количество узлов в списке `.size`.

---
> Напишите класс - *узел связанного списка* (`Node`)

Т.к. узлов может быть очень много, для экономии памяти используется `.__slots__`:

```python
class Node:
    __slots__ = 'val', 'next'

    def __init__(self, val, next):
        self.val = val
        self.next = next
```

---
> Напишите класс - *связанный список* (`List`)

Он хранит два указателя - `head`/`tail`, и размер. Методы для вставки узла в произвольную позицию и в начало:

```python
class List:
    def __init__(self):
        self.head = self.tail = None
        self.size = 0

    def __len__(self):
        return self.size

    def insert(self, node: Node, after: Node):
        next = after.next
        after.next = node
        node.next = next

        self.size += 1

    def insert_at_head(self, node: Node):
        self.insert(node, self.head)
```

---
> Как можно через кортеж представить DS "связанный список"

Храня значение узла в первом элементе кортежа, а следующий узел - во втором:

```python
(3, (5, (7, None)))
```

С похожим синтаксисом список будет задаваться и через конструкторы класса, если конечно в сигнатуре конструктора идет пара `<val>, <next>`:

```python
Node(3, Node(5, Node(7)))
```

---
> Как можно через кортеж представить DS "бинарное дерево"

Храня значение узла в первом элементе кортежа, а левый/правый узел - во втором и третьем элементах соответственно:

```python
(3, (5, None, None), (7, None, None))
```

С похожим синтаксисом дерево будет задаваться и через конструкторы класса, если конечно в сигнатуре конструктора идет тройка `<val>, <left>, <right>`:

```python
Node(3, Node(5), Node(7))
```

---
> В чем отличие класса - узла двусвязного списка от обычного?

Добавляется указатель на предыдущий узел:

```python
class Node:
    __slots__ = 'val', 'next', 'prev'

    def __init__(self, val, next, prev):
        self.val = val
        self.next = next
        self.prev = prev
```

---
> Напишите метод вставки узла для двусвязного списка

По сравнению с односвязным списком добавятся две строки - замыкания `prev`-указателей:

```python
def insert(self, node: Node, after: Node):
    next = after.next

    after.next = node
    node.next = next

    next.prev = node
    node.prev = after

    self.size += 1
```

---

# Абстрактные типы данных (ADTs), `[abstract-data-types]`

---
> Назовите три основных *последовательных* типа в Python

Это *строка*, *кортеж* и *список*. Первые два неизменяемы. Все они поддерживают доступ по индексу `[]`.

Это абстрактные типы, ADTs, и каждый основан на массиве

---
> Почему ADT "кортеж" более эффективен по памяти, чем "список"?

Они построены на базе разных структур данных, на статическом и динамическом массивах соответственно. Статический массив не требует избыточной емкости, не хранит доп. поля и не выполняет лишние (для неизменяемого типа) операции

---
> Какая у списка сложность доступа по индексу и вставки?

Список реализован на основе DS "динамический массив" ("вектор"), поэтому имеет константное время произвольного доступа, константное же время вставки в конец, и линейное - для вставки в начало/середину (`O(n - k + 1)`, если быть точным)

---
> Какая сложность у операций сравнения и поиска в строке/кортеже/списке?

Линейная, `O(n)` - производятся перебором по последовательности

Это касается всех операций:

- немутирующих методов `.count()` - `O(n)`, `.index()` - `O(k)`
- проверки принадлежности `x in [...]` - `O(k)`
- любого из операторов сравнения: `x <= y`, `x == y` и т.д. - `O(k)`
- получения срезов `x[i:j]` - `O(i-j)`, сложения `x + y` - `O(n1+n2)`, и умножения `c * x` - `O(c*n)`

Таким образом, `.index()` может быть быстрее `.count()`: он прекращает работу, как только элемент найден. Но в худшем случае из производительность одинакова

---
> Какая сложность у сортировки списка?

Логлинейная, `O(n*log(n))`

---
> Какая сложность у мутирующих операций на списке?

Константная `O(1)` для:

- присвоения `x[i] = val`
- вставки в конец `x.append(val)`
- получение элемента с конца `x.pop()`

Линейная для:

- вставки в начало/середину `x.insert()` - `O(n - k + 1)`
- удаления по индексу из начала/середины `x.pop(k)` - `O(n - k)`
- обращения `x.reverse()` - `O(n)`, расширения `x.extend(y)` - `O(n2)`

---
> Какая сложность у операции удаления из списка по значению?

Всегда линейная, `x.remove(val)` - `O(n)`. `O(k)` на поиск элемента + `O(n - k)` на сдвиг оставшихся элементов

---
> Какую сложность имеют большинство методов строк?

Линейную, `O(n)`. Это вполне очевидно:

- методы вроде `.capitalize()`, `.strip()` и т.д. возвращают новую строку. Линейное время на копирование
- методы вроде `.islower()` тестируют всю строку. Линейное время (`O(n-k)`) на проход

---
> Какая сложность у наивной имплементации поиска подстроки в строке?

Квадратичная, `O(n*m)`: для каждого индекса строки длиной `n` нужно делать проверку подстроки длиной `m`. Такое выполняется для методов `.__contains__()`, `.find()`/`.index()`, `.count()`, `.replace()`, `.split()`

Однако существует алгоритм поиска за линейное время (?)

---
> Какую временную сложность имеет этот код?
> 
> ```python
> letters = ''
> for c in some_string:
>     letters += c
> ```

Т.к. строки неизменяемы, на каждом шаге происходит создание новой строки, длиной `1`, `2`, ..., `n`. Сумма ряда натуральных чисел дает квадратичную сложность, `O(n)`.

Поэтому собирать строку нужно через временный массив, это дает линейную сложность `O(n)`:

```python
temp = []
for c in some_string:
    temp.append(c)
letters = ''.join(temp)
# or
''.join(c in some_string if <cnd>)
```

---
> Как представить ADT "матрица"?

Как список списков:

```python
[
  [22, 18, 709, 5, 33],
  [45, 32, 830, 120, 750],
  [4, 880, 45, 66, 61],
]
```

Создавать такие списки через двойное умножение нельзя, нужно через комбинацию умножение + списковое включение:

```python
[[0]*m for _ in range(n)] == [[0, 0, 0], [0, 0, 0]]
```

---
> Какая сложность у операции получения длины списка?

Константная, `O(1)`: список не вычисляет ее, он ее хранит

---
> Почему операция доступа по индексу в строках/кортежах/списках в Python-е имеет константную сложность?

В основе всех этих абстрактных типов лежит DS "массив", у которого произвольный доступ идет за `O(1)`.

У `collections.deque`, основанной на DS "двусвязный список массивов", произвольный доступ (`[i]`) до элементов в середине может давать сложность `O(n)`

---
> Что такое ADT *стек*?

Коллекция с двумя основными операциями, вставки и получения элемента - `.push(e)`/`.pop()`, которые работают по принципу LIFO (Last In First Out). Примеры: стопка тарелок в кафетерии, история браузера и кнопка "Назад", история команд текстового редактора и кнопка "Undo".

---
> Как может быть реализован ADT "стек"?

Как на основе (динамического) массива, так и на основе связного списка. В первом случае используется стандартный класс `list`, завернутый в класс (паттерн "Адаптер").

---
> Приведите код реализации ADT "стек" через массив

Простая обертка, "адаптер":

```python
class Stack:
    def __init__(self): self._data = []
    def __len__(self): return len(self._data)

    def is_empty(self): return len(self) == 0
    def top(self): return self._data[-1]

    def push(self, val): self._data.append(val)
    def pop(self): self._data.pop()
```

Можно определить свой класс исключения - `EmptyError`, проверять длину массива в `.is_empty()`/`.top()` и выбрасывать его (исключение) в случае необходимости (т.к. нативное исключение у `list` - это `IndexError`, а стек не поддерживает доступ по индексу).

---
> Какая сложность у операций в стеке?

У всех - вставки, получения элемента, получения длины, проверки на пустоту - константная, `O(1)`.

У `.push()`/`.pop()` имеется в виду амортизированная сложность, т.к. используется DS "динамический массив"

---
> Для чего может быть использован стек?

Для обращения последовательностей. Для проверки парных элементов (скобок, тегов).
---
> Что такое ADT *очередь*?

Коллекция с двумя основными операциями, вставки и получения элемента - `.enqueue(e)`/`.dequeue()`, которые работают по принципу FIFO (First In First Out). Примеры: очередь (ожидающих) людей, очередь обработки пользовательских запросов (в техподдержку), очереди запросов к серверам/сетевым устройствам.

---
> До каких собственных элементов имеет доступ односторонняя очередь?

Вставка только вв конец. Получение только из начала.

---
> Какой метод очереди соответствует методу `.pop()` стека?

Метод `.first()`. Оба они получают (но не удаляют) первый элемент - из начала очереди или с вершины стека. Оба выбрасывают `EmptyError`, если коллекция пуста.

---
> Какие есть общие методы у очереди и стека?

`.is_empty()` и `.__len__()`, проверка на пустоту и получение длины.

---
> Какой начальный размер у стека и у очереди?

Нулевой, изначально они пустые.

---
> Почему реализация очереди через массив неэффективна?

Каждая операция `.dequeue()` (~ `.pop(0)`) потребует сдвига всех элементов влево, что очень затратно.

Вообще, существуют реализации очереди через массив, с константным временем для всех операций, но они требуют некоторых алгоритмических ухищрений.

---
> Какие основные методы реализует ADT *двусторонняя очередь*?

Добавление и получение элементов с обоих концов:

```python
.add_{first|last}()
.remove_{first|last}()
```

Помимо метода `.first()` также добавляется метод `.last()`.
