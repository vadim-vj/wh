# Table of contents, `[toc]`

- 30.10.2020
  * функции `is_multiple(n, m)`, `is_even(n)`
  * функция `minmax(seq)`, три варианта
  * `float('inf')`, минусы и преобразования
  * удаление всех элементов списка, совпадающих с заданным; наивная и оптимизированная реализации
- 01.11.2020
  * сумма квадратов всех чисел до `n`, три варианта
  * сумма квадратов нечетных чисел, меньших `n`, варианты
  * удаление дубликатов in-place в сортированном списке
  * варианты `range()`, вывод степеней двойки
  * функции модуля `random`, эмуляция `choice()` через `randrange()`, порядок параметров `randint()`
  * рекурсивный и нет методы обращения последовательности (3 варианта), их сложность

---

# Friday `[30.10.2020]`

---
> Напишите функцию `is_multiple(n, m)`, определяющую, делится ли `n` на `m` нацело

```python
def is_multiple(n: int, m: int) -> bool:
    return not n % m
    # return n % m == 0
```

---
> Напишите функцию `is_even(n)`, проверяющую число на четность. Функция не должна использовать операторы умножения, деления и остатка

Через побитовое "и":

```python
def is_even(n: int) -> bool:
    return not n & 1
```

---
> Напишите функцию `minmax(seq)`, которая возвращает (в виде пары) минимальный и максимальный элементы последовательности. Встроенные функции `min()`/`max()` использовать нельзя

```python
from typing import Sequence, Tuple, Optional

def minmax(seq: Sequence[int]) -> Tuple[Optional[int], Optional[int]]:
    min_ = max_ = seq[0] if seq else None
    # min_, max_ = (float('inf'), float('-inf')) if seq else (None, None)

    for e in seq:
        if e < min_: min_ = e
        elif e > max_: max_ = e

    return min_, max_

assert minmax((1, 3, 4, 5, 1, 2, 3, 1, 34, 5, 3, 2, 1, 3)) == (1, 34)
```

---
> Перепишите предыдущую функцию для работы с произвольной итерируемой коллекцией

Тело цикла останется неизменным:

```python
from typing import Iterable, Tuple, Optional

def minmax(seq: Iterable[int]) -> Tuple[Optional[int], Optional[int]]:
    seq = iter(seq)
    first = next(seq)

    min_ = max_ = first if seq else None

    for e in seq:
        ...
```

---
> Что выдаст этот код?
> ```python
> int(float('inf'))
> ```

```
OverflowError: cannot convert float infinity to integer
```

---
> Что выдаст этот код?
> ```python
> float('-inf') == -float('inf')
> ```

```python
True
```

Это альтернативные формы записи.

---
> Напишите наивный алгоритм удаления всех элементов списка, совпадающих с заданным

С квадратичной сложностью:

```python
x = [1, 2, 34, 1, 1, 23, 1, 23, 4, 1, 2, 3, 2, 1, 1, 1, 3, 4]
val = 1

length = len(x)
i = 0

while i < length:
    if x[i] == val:
        del x[i]
        length -= 1

    else:
        i += 1

assert x == [2, 34, 23, 23, 4, 2, 3, 2, 3, 4]
```

---
> Перепишите предыдущую функцию так, чтобы сложность стала линейной

Сдвиг всех значений, совпадающих с указанным, в конец, и удаление среза:

```python
x = [1, 2, 34, 1, 1, 23, 1, 23, 4, 1, 2, 3, 2, 1, 1, 1, 3, 4]
val = 1

last_neq = 0
for i, curr in enumerate(x):
    if val != curr:
        x[i], x[last_neq] = x[last_neq], curr
        last_neq += 1

assert x == [2, 34, 23, 23, 4, 2, 3, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1]
del x[last_neq:]
assert x == [2, 34, 23, 23, 4, 2, 3, 2, 3, 4]
```

---

# Sunday, `[01.11.2020]`

---
> Напишите функцию, принимающую положительное целое и возвращающую сумму квадратов чисел, меньших его

```python
def sqrt_sum(n: int) -> int:
    return sum(i ** 2 for i in range(n))
```

Можно, конечно, и вручную суммировать через `for ... range` или `while i < n`.

```python
def sqrt_sum(n: int) -> int:
    i = 1
    sum_ = 0

    while i < n:
        sum_ += i ** 2
        i += 1

    return sum_

def sqrt_sum(n: int) -> int:
    sum_ = 0

    for i in range(1, n):
        sum_ += i ** 2

    return sum_
```

---
> Дан сортированный массив чисел. Удалить дубликаты in-place

Удаление целиком срезами. Обработка справа налево: так индексы не "прыгают", и удаление сдвигает меньшие части вектора:

```python
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]

end = len(seq) - 1
start = end - 1

while start >= -1:
    if start <= -1 or seq[start] != seq[end]:
        del seq[start+2:end+1]
        end = start

    start -= 1
assert nums == [0, 1, 2, 3, 4]
```

Важным условием является равенство с `-1`: оно дает возможность обрабатывать последовательности дубликатов, соприкасающихся с краем.

---
> Напишите функцию, принимающую положительное целое и возвращающую сумму квадратов *нечетных* чисел, меньших его

Вместо явной проверки остатка от деления на два можно просто задать шаг в `range`:

```python
def sqrt_sum(n: int) -> int:
    return sum(i ** 2 for i in range(1, n, 2))
```

Аналогично, при явном суммировании через `for ... range` или `while i < n`, можно увеличивать `i` на `2`.

---
> Какие параметры должны быть переданы в конструктор `range()`, чтобы получить `[50, 60, 70, 80]`? `[8, 6, 4, 2, 0, -2, -4, -6, -8]`?

```python
range(50, 81, 10)
range(8, -9, -2)
```

---
> Напишите list comprehension, выводящий степени двойки

```python
assert list(2 ** i for i in range(9)) == [1, 2, 4, 8, 16, 32, 64, 128, 256]
```

---
> Сэмулируйте функцию `random.choice()` через другую функцию модуля - `random.randrange()`

```python
from typing import Sequence, Any
import random

def choice(seq: Sequence[Any]) -> Any:
    return seq[random.randrange(len(seq))]
```

---
> Что выведет этот код?
> 
> ```python
> random.randint(10, 0)
> ```

```
ValueError: empty range for randrange() (10, 1, -9)
```

В отличие от `random.uniform()`, здесь важен порядок аргументов.

---
> Напишите рекурсивную функцию обращения последовательности. Какая у нее сложность?

Здесь `start` и `end` - физические индексы:

```python
from typing import MutableSequence, Any

def reverse(nums: MutableSequence[Any], start: int = 0, end: int = None):
    if end is None:
        end = len(nums) - 1

    if start < end:
        nums[start], nums[end] = nums[end], nums[start]
        reverse(nums, start + 1, end - 1)
```

Сложность линейная, `O(n)` - это линейная рекурсия.

---
> Напишите нерекурсивную функцию обращения последовательности

Оптимизация хвостовой рекурсии:

```python
from typing import MutableSequence, Any

def reverse(nums: MutableSequence[Any]):
    for i in range(len(nums) // 2):
        neg = len(nums) - 1 - i
        nums[i], nums[neg] = nums[neg], nums[i]
```

Можно и без деления, а брать два индекса - `start = 0`/`stop = len(txt) - 1`, после чего последовательно их приближать:

```python
from typing import MutableSequence, Any

def reverse(nums: MutableSequence[Any]):
    start, stop = 0, len(nums) - 1

    while start < stop:
        nums[start], nums[stop] = nums[stop], nums[start]
        start, stop = start + 1, stop - 1
```
