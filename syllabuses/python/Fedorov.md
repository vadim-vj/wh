- REPL
- `_` - последний результат
- в вещественных числах важна точность (`....667`, `....665`)
- поэтому сравнивать их нельзя
- `//` - целочисленное деление (отбрасывание, округление вниз)
- `**` - возведение в степень
- `True` (~ 1) / `False` (~ 0) - с большой буквы
- все переменные являются объектами
- переменные объявляются без ключевых слов, присваиванием
- переменные *ссылаются* на объекты, то есть хранят адреса (напр., временных объектов из правой части присваивания)
- `id()` - возвращает адрес объекта
- `type(s)` - возвращает тип объекта
- мелкие (у меня и крупные) целые и булевы литералы могут иметь одинаковый адрес
- присваивание переменных делает их адреса одинаковыми (всегда идет присваивание по ссылке)
- переменные числового типа являются *неизменяемыми*: язык лишь создает новые, но не меняет существующие при присваиваниях
- математические функции типа `abs()` и `round()` идут в общем пространстве имен по дефолту, импортировать ничего не надо
- порядок вычисления слева направо, `and` и `or` - по короткой цепи
- `def <name>(<params>):` + отступы и тело + `return <val>`, новая область видимости
- точка с запятой не используется
- расширения файлов - `.py`
- комментарий только `#`
- 4 пробела - рекомендованный отступ (а для c++ - 2) [Google]
- `print()` может принимать несколько аргументов разных типов, через запятую. Поддерживает, через аргументы, символ разделителя, конца строки, flush и указание потока вывода
- `input()` читает с клавиатуры и возвращает строку
- области видимости: блочной нет, только на уровне функций. Локальные переменные скрывают глобальные (оставляют их неизменными)
- из-за того, что объявлений переменных нет в принципе (объявление через инициализацию), существует ключевое слово `global`. Указав `global <var>` в области видимости (в функции) все последующие присваивания начнут изменять глобальную переменную, а не создавать/менять локальную
- объект `None` - некий аналог `void`, возвращается функцией без `return`
- функции - объекты первого класса, поддерживают присваивание, передачу в функции, и сохранение в переменной
- вызов по строке в переменной - через `getattr()` и `locals/globals()[name]`
- именованные аргументы при вызове: `a=34`. Позиция при этом не важна
- поддерживаются аргументы по умолчанию, довольно гибко комбинируются с именованными при вызовах
- `help(<var|type|anything>)` - вывод справки по объекту языка
- строки могут быть как в одинарных, так и двойных кавычках. Тройные кавычки обоих типов - для многострочных литералов
- глобальная функция `len(<str>)` - длина строки, `+` - конкатенация (также можно просто последовательно расположить строки `'a' 'b' == 'ab'`)
- приведение типов через конструкторы: `'5' == str(5)`, `5 == int('5')`
- складывать строки и числа нельзя, ошибка, нужно приводить явно
- на строки действует операция умножения - повторяет строку N раз
- строки индексированы, `s[N]` возвращает только для чтения символ в позиции. Поддерживаются отрицательные индексы, `-1` - последний символ. Индекс высчитывается как: `len - N`
- строки, как и числа, неизменяемы, изменить один символ через индекс нельзя
- срезы - индексы через двоеточие: `[a:b]`. По номерам это именно индексы. Возвращается новый объект, клон
- любой индекс в срезе может быть опущен. Если опустить оба, то коллекция склонируется целиком
- правый результат не включен (то есть "всё *до* указанного индекса"), интервал полуоткрыт. `'Питон'[:3] == 'Пит'` (3 индекс это 'о', всё до него)
- в срезе можно задать и третий аргумент - шаг: `[a:b:step]`. Он может быть и отрицательным
- сравнение `==` только одно, идет с учетом типов (`3 == '3' --> False`)
- логические связки пишутся словами: `and` / `or` / `not`
- все ненулевые числа (в том числе отрицательные), непустые объекты = True
- нулевые числа, пустые объекты (!) и спец. объект `None` = False
- `and`/`or` возвращают свои операнды, не булево значение. Если все False, то возвращает крайний правый
- `in` для строк проверяет вхождение подстроки (в любой позиции). Сравнение с учетом регистра
- условие в `if` скобками не выделяется. `else if` - ошибка, нужно юзать `elif <cnd>:` (одно слово). Итого: `if <cnd>: ... elif <cnd>: ... else: ...`
- `switch`-а нет
- первая строка в теле функции - документация для `help(<func>)`. Кавычки любые, но принято использовать двойные тройные (`"""Doc string"""`)
- `type(<module>)` вернет спец. класс `module` (в момент  импортирования создается переменная с именем модуля). `help(<module>)` даст справку по модулю
- общий импорт: `import <module>`, использование: `<module>.func()`
- выборочный: `from <module> import <func>` использование: `func()`
- импорты перекрывают локальные объявления и наоборот
- модуль `__builtins__` импортируется неявно, функции добавляются в пространство имен программы напрямую, не нужно указывать какой-либо объект
- `dir(<object>)` выводит список имен всех членов
- файл собственного модуля обязан иметь расширение .py и лежать в одной из папок из `sys.path`
- импорт модуля физически выполняет код в файле. Повторенный импорт ничего не делает, игнорируется
- обновить импортированный модуль (если он был изменен) можно функцией `imp.reload(<module>)` (`import imp` вызвать сначала)
- в любом py-файле доступна "магическая" переменная `__name__`. При запуске файла как скрипта она равна `__main__`, а при импорте - имени модуля
- в документацию (в строки после объявления) к функциям модуля можно добавлять "тесты" - примеры в формате REPL, с вызовами и результатами. Если потом прямо в тот же модуль поместить `import doctest \n doctest.testmod()`, то при запуске скрипта/импорте будут выполняться эти тесты
- методы объектов (напр., строк) могут вызываться как статические через имя класса: `str.capitalize(<string>)`, так и напрямую, на переменных/литералах: `<string>.capitalize()`
- больше десятка методов у класса строки (`str`)
- перегрузка операторов идет через переопределение "магических" методов (`__<name>__`). Например, конкатенация: `<string1> + <string2> ~ <string1>.__add__(<string2>)`
- *список* ~ массив, литерал `[...]` и числовые индексы (пример - строка). Обращение по несуществующему индексу - ошибка. Допускают элементы разных типов
- в отличие от строк списки неконстантны, и можно менять элементы (`list[1] = 'new_val'`). В ячейку пишется новый адрес, а старый объект уничтожается gc
- распространенные глобальные функции: `len()`, `min()/max()`, `sorted()` (возвращает сортированную копию списка). Оператор `del <list>[<index>]` удаляет элемент *или срез (диапазон)*
- списки *изменяемые*, присваиваются по ссылке (как и в js). Оператор `is` позволяет проверить, что переменные ссылаются на один и тот же адрес в памяти (`is` ~ `id(<1>) == id(<2>)`?)
- присваивание срезов (`a = b[:]`) - это shallow copy, объекты становятся разными, но элементы всё еще ссылаются на одни и те же адреса. В модуле `copy` есть функция `a = copy.deepcopy(b)`
- популярные методы списков (`<list>.<method>(<args>)` + эквивалент в JS): `.extend(<list>)` (~ `.concat()`), `.append(<el>)` (~ `.push()`), `insert(<index>, <el>)` (~ `.splice()`), `.count(<el>)` (кол-во вхождений элемента), `index(<el>)` (~ `.indexOf()`), `.pop()`, `.reverse()`, `.clear()` (~ `del <list>[:]`). `.sort([key=<func>])` (как-то соотностится с глобальной `sorted()`?)
- строка в список и обратно: `'<str>'.split('<sep>')` / `'<sep>'.join(<list>)` (`join()` обратный, не как в JS). Такие преобразования можно использовать для изменения строк (они по умолчанию неизменяемые)
- многомерные списки - так же, через несколько индексов: `a = [['a', 'b'], ['c', 'd']] and a[0][1] == 'b'`
- цикл `for <var> in <list>:` перебирает списки (аналог `for ... of` в JS)
- для классического `for (i = 0; ...` используется функция `range(<start>, <end>)`. Она хранит в памяти только начало, конец и шаг, а не физическую последовательность, но может использоваться в `for ... in`
- для перебора списка по индексам используется `for i in range(len(list)): \n\t list[i] ...`
- можно и создавать списки через `range`: `list(range(1, 10))`. Или перебором: `a = [] \n for i in range(1, 10): \n\t a.append(i)`. Или через литерал: `a = [i for i in range(1, 10)]` (т.н. *list comprehension*, списковое включение/встраивание). Последнее позволяет всякие трюки, типа изменения перебора уже существующих списков (`[i for i in <list>`), изменения "на лету" переменной (`[i**3 for i in ...`) или условий (`[i*2 for i in range(1, 10) if i != 3`)
- суммирование проще делать не через циклы, а через builtin-функцию `sum()`: `sum(list(range(1, 100)))`, `sum([1, 12, 0.3, 5])`
- глобальная `map(f, <list>)` возвращает объект типа `map`, для получения списка нужно явное приведение: `list(map(...))`
- синтаксис лямбд: `lambda <arg1>, <arg2>, ...: <expr>`. Поддерживают присваивание (`a = lambda x: x**3`), возврат из функций (`def f(n): \n\t return lambda a: a * n`) и т.д.
- цикл `while <expr>: \n\t <body>` стандартный, `break`/`continue` поддерживаются и в `while` и в `for`, `else:` (на одном уровне с циклом) доступен для обоих, и выполняется если выход произошел "естественным" образом, без `break`
- вложенные циклы допустимы, нужно только следить за отступами
- множество - неупорядоченная коллекция уникальных элементов. Неизменяемая. Конструктор - `set(...)`, литерал - `{'a', 'b', ...}`. (Не) принадлежность - `'a' [not] in <set>`. Можно создавать, например, из списков (`set([1, 1, 3]) == {1, 3}`) или диапазонов (`set(range(10))`). Поддерживает операции объединения (`{...}.union({...})`), пересечения (`{...}.intersection({...})`) и прочие
- кортежи - неизменяемые списки, `<...>[<index>] = 'new_val'` - ошибка. Конструктор - `tuple(...)`, литерал - `('a', 'b', ...)`. Можно создавать, например, из списков (`tuple([1, 1, 3]) == (1, 1, 3)`). Изменять элемент кортежа можно, если он составной, например, список: `(1, ['a', 'b'], 2)[1][0] = 'c'`
- при помощи кортежей можно делать множественное присваивание: `(x, y) = (10, 5)`. Скобки можно опустить. Таким способом можно, например, обменять значения переменных: `x, y = y, x`
- словари - изменяемые ассоциативные массивы (аналог объектов в JS). Ключи могут быть любого *неизменяемого* типа, например стороки или кортежи. В отличие от JS, имена ключей должны быть в кавычках (и `a.b` поэтому недопустим, только `a['b']`). Конструктор - `dict(...)`, литерал - `{'a': 'b'}`. Оператор `'a' in {...}` проверяет, есть ли такой ключ в словаре
- итерация по словарю такая же как в JS: `for key in {...}:` или `for key, value in {...}.items():`
- таким образом, списки (`['a']`) и словари (`{'a': 'b'}`) изменяемы (присваиваются по ссылке), а множества (`{'a'}`) и кортежи (`('a')`) неизменяемы (присваиваются по значению). То же касается и изменения элементов коллекций
- исключения: `try: ... except[ <type>[ as <e>]]: ... else: ... finally: ...`. `else` выполняется если исключения не было, а `finally` всегда. Ручной выброс: `raise Exception('<text>')`
- функции работы файлов - глобальные, из `__builtins__`-модуля, ничего импортировать не надо. `open('<filename>', <mode>)` может выбрасывать исключения, поэтому заключают в блок `try ... except`. Последовательность: `file = open(); content = file.read[lines](); file.close()`
- стандартная идиома работы с файлом: `with open(...) as file: \n\t contents = file.read() \n print(contents)`. Закрывать файл в этом случае не нужно
- относительные пути файлов берутся от текущего каталога (`import os \n os.getcwd()`)
- регулярные выражения: модуль `re`, функция `re.search('<regexp>', '<string>')` возвращает объект типа `match` (`{span=(0,3), match='some-string'}`)
- объявление класса: `class <name>(<BaseClassName>): \n\t ...`. Создание без `new`: `obj = ClassName()`. Методы объявляются с отступом внутри `class ...` как функции с первым аргументом `self`: `class A(): \n\t def test(self): ...`
- конструктор класса определяется как `def __init__(self, <args>):`. Обращение к свойствам класса во всех методах - через `self.<property>`
- вызов родительских методов: `ParentClassName.method(self, args)` (то есть явно, по именам), или через `super([<ClassName>, self]).method(<args>)`. Параметры в `super()` можно и не передавать. Вызов родительского конструктора тоже явный: `super().__init__(<args>)`. Передавать `self` вместе с `super()` не нужно
- поддерживается множественное наследование: `class Derived(Parent1, Parent2, ...)`. Разрешение методов слева направо
- модификаторов доступа для членов класса нет, только (мало распространенное?) соглашение об именах (`_<name>` ~ protected, `__<name>` ~ private). Но физически все методы и свойства доступны всем
- входящая в стандартную поставку библиотека `tkinter` дает графический интерфейс (окна, кнопки, формы и т.д.)
