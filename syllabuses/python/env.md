# Реализации `[implementations]`

---
> Какие (и на каких языках) есть реализации Python?

- *CPython* - на C, самая поддерживаемая (*референсная*)
- *Jython* - на Java, для взаимодействия с кодом на Яве
- *Python for .NET*, *IronPython* - оба для .NET, первая использует CPython, вторая написана на Python
- *PyPy* - полностью на Python, поддерживает stackless и JIT

---
> Для какой реализации Python рассматриваются все вопросы здесь?

Для *CPython*, наиболее распространенной

---
> Какие два самых известных линтера для Python?

PyFlakes (более простой) и PyLint (более тяжелый, но с б*о*льшими возможностями)

---

# Командная строка `[command-line]`

---
> Какие есть способы выйти из REPL?

- `quit()`
- `sys.exit()`
- `raise SystemExit[()]`
- `Ctrl + D` (EOF)
- `Ctrl + Z` (SIGTSTP; не сохраняет историю)

Первые три завершают также любой скрипт

---
> Как получить последний результат в REPL?

Переменная "подчеркивание", `_`

---
> Как выглядят и где задаются строки приглашений в REPL?

Их два уровня, первый и второй. Задаются в модуле `sys`: `sys.ps1 == '>>> '`, `sys.ps2 == '... '`

---
> Что будет, если запустить интерпретатор с именем папки или zip-файла в качестве аргумента?

Будет искать в папке или zip-архиве файл с именем `__main__.py`, и выполнит его с `__name__ == '__main__'`

---
> Сработает ли такая команда: `$ cat test.py | python3`?

Да, она так же выполнит скрипт, как и `python3 test.py`

---
> Как вызвать краткую справку по консольной команде `$ python3`?

Три варианта опции: `-?`/`-h`/`--help`

---
> Как узнать версию интерпретатора?

Не стоит путать с маленькой `-v` (verbose): `-V`/`--version`. Удвоение любой из этих опция дает чуть более подробное описание версии

---
> Для чего служит опция командной строки `-c`?

Выполняется следующая за опцией команда: `python3 -c 'print(3)'`. Текущая директория подставляется в начало `sys.path` (это позволяет импортировать локальные модули)

---
> Что делает опция командной строки `-m`?

Находит в `sys.path` модуль по имени (без расширения `.py`), следующему за опцией, и исполняет его как скрипт - с `__name__ == '__main__'`. Как и для `-c`, текущая директория подставляется в начало `sys.path`

---
> Допустимы ли имена пакетов с cli-опцией `-m`?

Да. В этом случае интерпретатор будет искать (и выполнять как скрипт) модуль `<pkg>.__main__`. Поведение аналогично тому, когда вместо скрипта интерпретатору передается папка или zip-файл

---
> Как получить список всех вкомпилированных (встроенных) в интерпретатор модулей?

`sys.builtin_module_names` возвращает кортеж с именами. Примеры: `sys`, `itertools`, `time`, `zlib`

---
> В каких случаях опция `-m` неприменима?

Для встроенных (`sys.builtin_module_names`) модулей и модулей, написанных на C - выдает ошибку `No code object available for <module>`. Для precompiled-модулей эта опция использоваться может

---
> Как передать модулю, выполняемому в режиме скрипта, параметры?

Просто перечислить их после имени модуля, например:
```shell
$ python3 -m doctest test.py
$ python3 -m venv -h
```

---
> Есть ли у команды `$ python3` длинные варианты опций?

Только две (`--version`, `--check-hash-based-pycs`), для большинства же только короткие

---
> Что делает опция `-s`?

Не добавляет в `sys.path` директорию `~/.local/lib/python3.n/site-packages/` (константа `site.USER_SITE`)

---
> Что делает опция `-S`?

Запрещает авто-импорт модуля `site`. Из-за этого в `sys.path` не попадают все директории `(dist|site)-packages/`, остается только `/usr/lib/python3.n/`. Игнорирует также пользовательский каталог (`~/.local/lib/python3.n/site-packages/`), т.е. неявно подразумевает `-s`

---
> Что делает опция `-E`?

Игнорирует все переменные окружения `PYTHON*`

---
> Что делает опция `-I`?

Запускает интерпретатор в "изолированном" режиме: не учитывает переменные окружения и пользовательский каталог `site-packages` (т.е. неявно включает опции `-sE`, и кроме того не включает в `sys.path` каталог текущий

---
> Что делает опция `-i`?

Интерпретатор переходит в интерактивный режим после выполнения переданного скрипта / команд из `stdin`. В этом интерактивном сеансе доступны все переменные из выполненного скрипта

---
> Что делает опция `-x`?

Пропускает первую строку в выполняемом скрипте (для игнорирования не-NIX shebang-ов)

---
> Какие значения принимает и что делает переменная `PYTHONINSPECT`?

Переменная-флаг, при любом непустом значении переводит интерпретатор в интерактивный режим после выполнения переданного скрипта. Аналогична опции `-i`

---
> Как запретить запись `.pyc`-файлов?

Установить значение переменной окружения `PYTHONDONTWRITEBYTECODE` в непустую строку, или вызывать интерпретатор с опцией `-B`

---
> Как удалить отладочный код при исполнении скрипта?

Удалить все ассерты и весь код, зависящий от значения `__debug__`, можно через опцию `-O` или переменную окружения `PYTHONOPTIMIZE` (равную непустой строке, или целому, равному числу повторений опции `-O`)

---
> Как выводить информацию об импорте/выгрузке всех модулей при выполнении скрипта?

Опция `-v` или переменная окружения `PYTHONVERBOSE` (равная непустой строке, или целому, равному числу повторений опции `-v`)

---
> Сколько раз интерпретатор выводит warning для строчки кода?

По умолчанию - один раз, это соответствует `-Wdefault`/`-Wd`. Можно поменять, например на `-Walways`/`-Wa` или `-Wignore`/`-Wi`

Те же ключи можно присваивать переменной окружения `PYTHONWARNINGS`, например, `PYTHONWARNINGS=module` (once per calling module) или `PYTHONWARNINGS=once` (once per Python process)

---
> Как превратить все warning-и в исключения?

Вызвать интерпретатор с опцией `-Werror`/`-We`, или установить переменную окружения в `PYTHONWARNINGS=error`

---
> Как можно управлять настройками интерпретатора Python?

Через пару десятков переменных окружения `PYTHON*=<some-val>` и через опции (с одним дефисом) `python3 -<OPT>`. Часто переменные дублируют опции (и наоборот). Некоторые переменные, при равенстве непустой строке, соответствуют одной опции, а при равенстве положительному числу - числу повторений этой опции: `PYTHONVERBOSE="some" ~ py3 -v` / `PYTHONVERBOSE=3 ~ py3 -vvv`

---
> Как получить справку модуля по запуску его в режиме скрипта?

Стандартным способом передачи аргументов - `$ python3 -m <module> <params>`, передав `-h/--help`. Например:

- `$ python -m timeit -s 'setup here' 'benchmarked code here'`
- `$ python -m timeit -h # for details` - как раз получение справки

---
> Как выполнить Python скрипт из кода?

В модуле `runpy` есть нужная функция. По умолчанию `run_name='<run_path>'`:

```python
import runpy
runpy.run_path('./test.py', run_name='__main__')
```

---
> Как из командной строки изменить путь поиска модулей (`sys.path`)?

Задать переменную окружения, *дополняющую* путь поиска - `PYTHONPATH`: `PYTHONPATH=/some/dir/ python3 test.py`. По умолчанию она пуста

---
> За что отвечает и какой формат имеет переменная окружения `PYTHONPATH`?

Помогает добавлять свои пути в `sys.path`, для поиска модулей. Ее формат аналогичен стандартной `PATH` - пути, разделенные `os.pathsep`

---
> В какую позицию списка `sys.path` добавляется значение переменной окружения `PYTHONPATH`?

В индекс `1` - после текущей директории, но перед первой системной: `sys.path = ['', <PYTHONPATH dirs>, '/usr/lib/python37.zip', ...]`

---
> Чему равен `sys.path[0]`?

Папке, из которой запускается скрипт, или пустой строке, при выполнении команд через `-c '...'` или из `stdin`. Во втором случае поиск модулей/пакетов всё равно будет вестись начиная с текущего каталога

---
> Чему равна `os.pathsep` на разных системах? Где используется

Двоеточию `:` на *NIX и точке с запятой `;` на Windows. Используется в `PYTHONHOME` (`<prefix>:<exec_prefix>`), `PYTHONPATH` (`<path1>:<path2>:...`) и в системном `PATH`

---
> Как можно выполнить команды Python до показа первого приглашения REPL?

В переменной окружения `PYTHONSTARTUP` указать путь к Python-скрипту. Все импортированные/созданные в нем объекты станут доступны и в сессии REPL. Также можно, например, поменять формат приглашений `sys.ps1`/`sys.ps2`

---
> Что будет, если в переменной среды `PYTHONSTARTUP` указать несуществующий скрипт, или скрипт, для которого нет прав доступа?

Ничего, система проигнорирует значение, даже предупреждения не выдаст

---
> Какая рекомендуемая *shebang*-строка для скриптов?

`#!/usr/bin/env python3`

И нужно не забывать делать скрипт исполняемым: `$ chmod +x script`

---
> Как можно запускать команды shell-а из Python-скрипта?

Есть модуль `subprocess`, и у него функция `run()`. Например:

```python
import subprocess
subprocess.run(['ls', '-l'])
```

---
> Что будет делать команда `$ python3 -`?

Читать инструкции из `stdin`. Это режим по умолчанию, без дефиса будет то же самое. Если ничего на вход нет, то переход в интерактивный режим (`-i`).

Дефис служит для отделения аргументов командной строки от инструкций из `stdin`. Эти аргументы пишутся в `sys. argv`

---
> В каком случае команда `$ python3` читает инструкции из `stdin`?

Если после нее стоит дефис (placeholder) или отсутствует любая лексема. Если в `stdin` инструкций нет, то переход в интерактивный режим

---
> В каких случаях Python компилирует скрипты и сохраняет байткод?

Только при импорте модулей (и только если не установлена `PYTHONDONTWRITEBYTECODE` и не указана опция `-B`). Для обычных скриптов компилирует каждый раз заново

# Установка, файлы и каталоги `[install-and-dirs]`

---
> Где хостится исходный код Python?

На ГитХабе: <https://github.com/python/cpython>. Там же рядом репозиторий с PEPами

---
> Откуда можно установить Python?

- скачать с оф. сайта (<https://www.python.org/downloads/>) исходники и собрать (`./configure; make; sudo make altinstall`)
- те же исходники можно склонировать с ГитХаба - <https://github.com/python/cpython>
- в Ubuntu все пакеты включены в дистрибутив. Есть в APTе, и в SNAPах есть отдельные версии и имплементации (CPython, конечно)

---
> Какие *3 пути* на файловой системе хранят файлы инсталляции?

- `/usr/bin/python3` (--> `./python3.n`) - бинарник интерпретатора
- `/usr/lib/python3.n/` - папка со стандартными модулями
- `/usr/include/python3.n/` - папка с заголовочными `.h`-файлами, нужными для разработки расширений и встраивания интерпретатора

---
> В каких папках хранятся установленные пакеты и модули?

- `/usr/lib/python3/dist-packages/` - пакеты, установленные через глобальный менеджер (напр., `apt`)
- `/usr/local/lib/python3.n/dist-packages/` - установленные глобально через `pip`
- `~/.local/lib/python3.n/site-packages/` - установленные локально через `pip` (без `sudo` и/или с опцией `--user`)

---
> Как узнать *базовую* директорию *пользователя* для пакетов и бинарников?

Это константа в модуле `site` - `site.USER_BASE`. Вывести ее можно через командную строку: `$ python -m site --user-base`

Туда `pip` устанавливает пакеты. Как правило это папка `~/.local/` с тремя подпапками: `bin/` (туда идут бинарники, standalone-утилиты), `lib/` (сами пакеты), `share/`

---
> Являются ли модули `venv` и `pip` частью стандартной библиотеки Python?

`venv` является с v3.3, а `pip` - сторонний проект (<https://pip.pypa.io/en/stable/>), хотя с v3.4 он по умолчанию включается в дистрибутив Python

---
> За что отвечает переменная окружения `PYTHONHOME`?

Она может задавать т.н. *префикс* - базовую директорию для поиска папок с пакетами/модулями: `<prefix>/lib/python3.n/`. В случае, если эта переменная пуста, берется префикс `/usr`. Переменная отвечает именно за каталоги пакетов, не самого интерпретатора

---
> Куда Python сохраняет скомпилированный байткод модулей?

В папку `__pycache__`

---
> Как формируется расширение у файлов со скомпилированным байткодом?

`<implemetation>-<version>.py(c|o)`. `.pyc`/`.pyo` - в зависимости от оптимизации, была ли указана опция `-O`

Примеры: `__pycache__/__init__.cpython-36.pyc`, `__pycache__/testplugin.cpython-37.pyc`

---

# Менеджер пакетов PIP `[pip-manager]`

---
> Какая утилита рекомендована для установки пакетов и модулей? Как ее запустить?

*PIP*, менеджер пакетов, в поставке идет по умолчанию. Две формы ее запуска для установки модуля:

- `$ python3 -m pip install <package>` (предпочтительна, авто-выбор версии языка)
- `$ pip3 install <package>`

---
> Как `pip`-у указать точную и минимальную версию пакета?

- `$ python3 -m pip install SomePackage==1.0.4`
- `$ python3 -m pip install "SomePackage>=1.0.4"` (символы `>`/`<` интерпретируются шеллом, поэтому выражение взято в кавычки)

---
> Какой документ описывает формат номеров версий пактов и правила их сравнения?

PEP 440 - <https://www.python.org/dev/peps/pep-0440/>

---
> Где при вызове `pip` должны располагаться опции команд, а где самого модуля?

Опции команд после самой команды, опции менеджера - после `pip` и перед командой: `$ python3 -m pip -v freeze --user`

Здесь `-v` (verbose) относится к `pip`, а `--user` - к `freeze`

---
> Как `pip`-ом обновить модуль?

`$ python3 -m pip install (--upgrade|-U) SomePackage`

---
> Как установить модуль локально, в домашний каталог пользователя?

Запускать `$ python3 -m pip install` без `sudo` (не хватит прав на запись в общесистемные директории), и/или указывать опцию `--user` (тогда и предупреждения показано не будет)

---
> Как установить модуль для конкретной версии Python?

Запускать интерпретатор именно этой версии для установки: `$ python3.7 -m pip install` или `$ python3.3 -m pip install`, и.д.

---
> Есть ли модуль `pip3`?

Нет, есть только одноименная утилита в `~/.local/bin/`. Поэтому писать `$ pip3 install` можно, а `$ python3 -m pip3` нельзя

---
> Что такое *PyPI*?

*Python Package Index*, открытый репозиторий для открытых же пакетов: <https://pypi.org>. Используется командой `pip` по умолчанию

---
> Что такое *PyPA*?

*Python Packaging Authority*, рабочая группа, разрабатывающая проекты, связанные с Python-пакетами, такие как `pip`, `wheel`, `pipenv` и другие: <https://www.pypa.io>

---
> Почему научные пакеты лучше устанавливать не через `pip`?

Они часто тянут сложные бинарные зависимости. Лучше использовать предназначенные для этого менеджеры, типа *Conda*

---
> Что делает `pip freeze`?

(Построчно) выводит список всех установленных пакетов в формате `<name>==<version>`

---
> Как создать *файл требований*, состоящий только из локально установленных пакетов пользователя?

Использовать опцию `--user`: `$ python3 -m pip freeze --user > requirements.txt`

---
> Как установить все пакеты из *файла требований*?

Использовать опцию `-r`: `$ python3 -m pip install -r requirements.txt`

---
> Назовите 4 основных причины использования *файлов требований*

1. *Воспроизводимые установки* (repeatable installations) - копирование одной среды в другую через `pip freeze/install`
1. *Истинное разрешение зависимостей* (true dependency resolution) - в случае, если два пакета имею в зависимостях один и тот же пакет, но разных версий, `pip` просто установит версию из первой по порядку зависимости. С r-файлом это можно обойти, явно указав в нем версию зависимого пакета для установки
1. *Принудительное указание версии*. Похож на пред. пункт - зависимый пакет указывается в файле явно; но служит лишь для того, чтобы не бралась автоматически последняя версия (напр., в ней баг), а подтягивалась указанная
1. *Получение последней версии из VCS*. Если в репозитории пакетов еще нет нужного (хот)фикса, можно указать в r-файле получение пакета из VCS: `git+https://...@sometag`

---
> Откуда `pip` может ставить пакеты?

Из PyPI по умолчанию, и из других источников:

- из VSC - в т.н. editable-режиме: `$ pip install -e git+https://git.repo/some_pkg.git#egg=SomeProject`
- из произвольного индекса: `$ pip install --index-url http://my.package.repo/simple/ SomeProject`
- поиск в PyPI + произвольный индекс: `$ pip install --extra-index-url http://my.package.repo/simple SomeProject`
- из локальной папки или файла: `$ pip install [-e] <path>`
- из локальных архивов: `$ pip install ./downloads/SomeProject-1.0.4.tar.gz`

---
> Как через `pip` можно установить дополнительные зависимости пакета ("extras")?

Указать их в квадратных скобках после имени: `$ pip install SomePackage[PDF]`

---
> Какая утилита рекомендована для управления зависимостями в процессе разработки Python-приложения?

*Pipenv* (объединяет `pip` и `venv`), а если она не подходит, то pip, pip-tools, или *Poetry*

<https://packaging.python.org/guides/tool-recommendations/>

---
> Как в `pip` показать детали пакета? А список файлов?

- `$ python3 -m pip show <package>`
- `$ python3 -m pip show --files <package>`

---
> Как в `pip` показать все пакеты, для которых есть более новые версии?

`$ python3 -m pip list --outdated`

---
> Как в `pip` называется команда удаления пакета?

`uninstall`

---
> Как в `pip` называется команда поиска пакетов?

`search`

---
> Как в `pip` называется команда скачивания пакета?

`download`

---
> Можно ли использовать `pip` программно?

Чисто технически `import pip` выполняться будет, но это крайне не рекомендуется: `pip` не предназначен для такого использования. Вызов же его как подпроцесса вполне допустим и это полностью рабочий вариант:

```python
import subprocess
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'my_package'])
```

---
> Как сделать автодополнение команд `pip`?

`$ pip completion --bash >> ~/.bashrc` (или вставить туда же `eval "$(pip completion --bash)"`). Работает только для standalone-утилиты (`$ pip ...`)

---
> Как `pip`/`venv` и `conda` рассматривают сам интерпретатор Python?

Для `conda` он такой же пакет - его можно обновить/удалить/выбрать версию, тогда как `pip` занимается только лишь пакетами

---

# Виртуальные среды `[virtual-environments]`

---
> Для чего нужны виртуальные окружения?

Изоляция:

- создания предсказуемого, повторяемого окружения. Это защитит от появления ошибок при переносе программы на другой сервер
- одновременная разработка на одной машине нескольких проектов с разными версиями зависимостей

---
> Какая стандартная утилита для создания виртуальных сред? Как ее запустить?

*VENV*, в поставке идет по умолчанию. Как и `pip`, это модуль Python:

- `$ python3 -m venv <dir>` (больше чем предпочтительна)
- `$ pyvenv <dir>` - выдает предупреждение, что такая форма вызова deprecated

---
> Как активировать среду, созданную `venv`?

Импортировать скрипт активации в текущий шелл: `$ source <dir>/bin/activate`. После этого перед строкой приглашения появится название среды (напр., `(test) [~]$ `)

---
> Как деактивировать среду, созданную `venv`?

Выполнить в консоли `$ deactivate`. Это функция, определенная в скрипте `bin/activate`, не физический скрипт, поэтому дополнительно указывать путь не требуется

---
> Устанавливает ли `venv` отдельную версию Python?

Нет, по умолчанию в папке `<env-dir>/bin` создается лишь ссылка на глобальный бинарник: `./python -> ./python3.n -> /usr/bin/python3.n`. Такое поведение можно изменить опцией `--copies`

---
> Куда в `venv` устанавливаются пакеты?

В (под)папку текущей выбранной среды: `<env-dir>/lib/python3.n/site-packages/`. `pip` полностью корректно работает с виртуальными средами

---
> Как работает `pip install --user` в виртуальной среде?

Игнорируется, всё - и пакеты и бинарники - ставится внутрь `<env-dir>/` (где есть и `bin/` и `lib/`)

---
> Какие пакеты ставятся по умолчанию при создании виртуальной среды?

`pip` и `setuptools` (+ `pkg_resources`). Установку первого можно отменить через `--without-pip`

---
> Какой документ описывает виртуальные окружения?

PEP 405 - <https://www.python.org/dev/peps/pep-0405/>

---
> Как создать сразу несколько виртуальных сред?

Передать команде несколько путей (имен папок): `python3 -m venv test1 test`

---
> Обязательно ли активировать виртуальную среду?

Нет. Активация добавляет папку `bin/` среду в системную переменную `PATH` (и устанавливает `VIRTUAL_ENV`), но это лишь упрощает печать команд. Если использовать полные пути для бинарника интерпретатора, то тоже будет работать

---
> Как интерпретатор определяет, что работа идет в виртуальной среде?

По наличию файла `pyvenv.cfg` на одном уровне с `bin/python[3[.n]]`, даже пустого. Если такой файл есть, `sys.prefix` устанавливается равным директории, в которой он (конф. файл) лежит

---
> Как добавить в `sys.path` путь к пакетам виртуальной среды?

Путь `lib/python3.n/site-packages` добавится автоматически, если он есть. Туда пакеты и устанавливаются

---
> Как ограничить пакеты только теми, что установлены в виртуальной среде?

В файле `pyvenv.cfg` задать `include-system-site-packages = false`. Эта опция пишется в файл кофига по умолчанию при создании виртуальной среды. Дать доступ до системных пакетов можно, передав опцию: `$ python3 -m venv --system-site-packages`

---
> Как задать виртуальной среде кастомное имя для отображения в командной строке?

Передать опцию при создании: `$ python3 -m venv --prompt <some-prompt> <path>`. Скрипт `bin/activate` будет сгенерирован с учетом этого

---
> Какие есть ссылки из виртуальной среды на инсталляцию Python, использованную для создания этой среды?

В конфигурационном файле `pyvenv.cfg` обычно задана переменная `home = /usr/bin`, а в самом интерпретаторе, несмотря на то что он выполняется из среды, переменная `sys.base_prefix` всегда исходный (обычно `/usr`; в отличие от `sys.prefix == <env-path>`)

---
> Почему устанавливаемые при создании виртуальной среды скрипты будут в ней корректно работать?

У шелл-скриптов типа `pip`/`easy_install`, лежащих в `<env-path>/bin/`, shebang-заголовок генерируется корректно - он указывает на интерпретатор внутри самой среды, не на системный

---
> Можно ли менять поведение/создавать свои генераторы сред на основе `venv`?

Да, в отличие от `pip` модуль позволяет импортировать себя и наследовать свой класс `EnvBuilder`, меняя/дополняя функциональность. Создав такой скрипт, в нем можно вызывать `ExtendedBuilder().create(<options>)`

---
> Какая может быть нативная альтернатива `venv`?

Задание переменной окружения `PYTHONPATH`. Пути поиска пакетов будут подставлены в `sys.path` раньше системных

---
> Как обновить виртуальную среду при появлении новой версии Python?

Через вызов на той же папке с опцией `--upgrade`: `$ python3 -m venv --upgrade <path>`
