# Реализации [implementations]

---
> Какие (и на каких языках) есть реализации Python?

- *CPython* - на C, самая поддерживаемая (*референсная*)
- *Jython* - на Java, для взаимодействия с кодом на Яве
- *Python for .NET*, *IronPython* - оба для .NET, первая использует CPython, вторая написана на Python
- *PyPy* - полностью на Python, поддерживает stackless и JIT

---
> Для какой реализации Python рассматриваются все вопросы здесь?

Для *CPython*, наиболее распространенной

---

# Командная строка [command-line]

---
> Какие есть способы выйти из REPL?

`quit()`, `Ctrl + D` (EOF) или `Ctrl + Z` (SIGTSTP; не сохраняет историю)

---
> Что будет, если запустить интерпретатор с именем папки или zip-файла в качестве аргумента?

Будет искать в папке или zip-архиве файл с именем `__main__.py`, и выполнит его с `__name__ == '__main__'`

---
> Сработает ли такая команда: `$ cat test.py | python3` ?

Да, она так же выполнит скрипт, как и `python3 test.py`

---
> Как вызвать краткую справку по консольной команде `$ python3` ?

Три варианта опции: `-?`/`-h`/`--help`

---
> Как узнать версию интерпретатора?

Не стоит путать с маленькой `-v` (verbose): `-V`/`--version`. Удвоение любой из этих опция дает чуть более подробное описание версии

---
> Для чего служит опция командной строки `-c` ?

Выполняется следующая за опцией команда: `python3 -c 'print(3)'`. Текущая директория подставляется в начало `sys.path` (это позволяет импортировать локальные модули)

---
> Что делает опция командной строки `-m` ?

Находит в `sys.path` модуль по имени (без расширения `.py`), следующему за опцией, и исполняет его как скрипт - с `__name__ == '__main__'`. Как и для `-c`, текущая директория подставляется в начало `sys.path`

---
> Допустимы ли имена пакетов с cli-опцией `-m` ?

Да. В этом случае интерпретатор будет искать (и выполнять как скрипт) модуль `<pkg>.__main__`. Поведение аналогично тому, когда вместо скрипта интерпретатору передается папка или zip-файл

---
> Как получить список всех вкомпилированных (встроенных) в интерпретатор модулей?

`sys.builtin_module_names` возвращает кортеж с именами. Примеры: `sys`, `itertools`, `time`, `zlib`

---
> В каких случаях опция `-m` неприменима?

Для встроенных (`sys.builtin_module_names`) модулей и модулей, написанных на C - выдает ошибку `No code object available for <module>`. Для precompiled-модулей эта опция использоваться может

---
> Что делает опция `-s` ?

Не добавляет в `sys.path` директорию `~/.local/lib/python3.n/site-packages/` (константа `site.USER_SITE`)

---
> Что делает опция `-S` ?

Запрещает авто-импорт модуля `site`. Из-за этого в `sys.path` не попадают все директории `(dist|site)-packages/`, остается только `/usr/lib/python3.7/`

---
> Что делает опция `-E` ?

Игнорирует все переменные окружения `PYTHON*`

---
> Что делает опция `-I` ?

Запускает интерпретатор в "изолированном" режиме: не учитывает переменные окружения и пользовательский каталог `site-packages` (т.е. неявно включает опции `-sE`, и кроме того не включает в `sys.path` каталог текущий

---
> Как запретить запись `.pyc`-файлов?

Установить значение переменной окружения `PYTHONDONTWRITEBYTECODE` в непустую строку, или вызывать интерпретатор с опцией `-B`

---
> Как удалить отладочный под при исполнении скрипта?

Удалить все ассерты и весь код, зависящий от значения `__debug__`, можно через опцию `-O` или переменную окружения `PYTHONOPTIMIZE` (равную непустой строке, или целому, равному числу повторений опции `-O`)

---
> Как выводить информацию об импорте/выгрузке всех модулей при выполнении скрипта?

Опция `-v` или переменная окружения `PYTHONVERBOSE` (равная непустой строке, или целому, равному числу повторений опции `-v`)

---
> Сколько раз интерпретатор выводит warning для строчки кода?

По умолчанию - один раз, это соответствует `-Wdefault`/`-Wd`. Можно поменять, например на `-Walways`/`-Wa` или `-Wignore`/`-Wi`

Те же ключи можно присваивать переменной окружения `PYTHONWARNINGS`, например, `PYTHONWARNINGS=module` (once per calling module) или `PYTHONWARNINGS=once` (once per Python process)

---
> Как превратить все warning-и в исключения?

Вызвать интерпретатор с опцией `-Werror`/`-We`, или установить переменную окружения в `PYTHONWARNINGS=error`

---
> Как можно управлять настройками интерпретатора Python?

Через пару десятков переменных окружения `PYTHON*=<some-val>` и через опции (с одним дефисом) `python3 -<OPT>`. Часто переменные дублируют опции (и наоборот). Некоторые переменные, при равенстве непустой строке, соответствуют одной опции, а при равенстве положительному числу - числу повторений этой опции: `PYTHONVERBOSE="some" ~ py3 -v` / `PYTHONVERBOSE=3 ~ py3 -vvv`

---
> Как получить справку модуля по запуску его в режиме скрипта?

Стандартным способом передачи аргументов - `$ python3 -m <module> <params>`, передав `-h/--help`. Например:

- `$ python -m timeit -s 'setup here' 'benchmarked code here'`
- `$ python -m timeit -h # for details` - как раз получение справки

---
> Как выполнить Python скрипт из кода?

В модуле `runpy` есть нужная функция. По умолчанию `run_name='<run_path>'`:

```python
import runpy
runpy.run_path('./test.py', run_name='__main__')
```

---
> Как из командной строки изменить путь поиска модулей (`sys.path`)?

Задать переменную окружения `PYTHONPATH`: `PYTHONPATH=/some/dir/:$PYTHONPATH python3 test.py`

---
> За что отвечает и какой формат имеет переменная окружения `PYTHONPATH` ?

Помогает добавлять свои пути в `sys.path`, для поиска модулей. Ее формат аналогичен стандартной `PATH` - пути, разделенные `os.pathsep`

---
> Чему равна `os.pathsep` на разных системах?

Двоеточию `:` на *NIX и точке с запятой `;` на Windows

---
> Как можно выполнить команды Python до показа первого приглашения REPL?

В переменной окружения `PYTHONSTARTUP` указать путь к Python-скрипту. Все импортированные/созданные в нем объекты станут доступны и в сессии REPL. Также можно, например, поменять формат приглашений `sys.ps1`/`sys.ps2`

---
> Какая рекомендуемая *shebang*-строка для скриптов?

`#!/usr/bin/env python3`

И нужно не забывать делать скрипт исполняемым: `$ chmod +x script`

---
> Как можно запускать команды shell-а из Python-скрипта?

Есть модуль `subprocess`, и у него функция `run()`. Например:

```python
import subprocess
subprocess.run(['ls', '-l'])
```

---

# Установка, файлы и каталоги [install-and-dirs]

---
> Где хостится исходный код Python?

На ГитХабе: <https://github.com/python/cpython>. Там же рядом репозиторий с PEPами

---
> Откуда можно установить Python?

- скачать с оф. сайта (<https://www.python.org/downloads/>) исходники и собрать (`./configure; make; sudo make altinstall`)
- те же исходники можно склонировать с ГитХаба - <https://github.com/python/cpython>
- в Ubuntu все пакеты включены в дистрибутив. Есть в APTе, и в SNAPах есть отдельные версии и имплементации (CPython, конечно)

---
> Какие 3 пути на файловой системе хранят файлы инсталляции?

- `/usr/bin/python3` (--> `./python3.7`) - бинарник интерпретатора
- `/usr/lib/python3.n/` - папка со стандартными модулями
- `/usr/include/python3.n/` - папка с заголовочными `.h`-файлами, нужными для разработки расширений и встраивания интерпретатора

---
> В каких папках хранятся установленные пакеты и модули?

- `/usr/lib/python3/dist-packages/` - пакеты, установленные через глобальный менеджер (напр., `apt`)
- `/usr/local/lib/python3.n/dist-packages/` - установленные глобально через `pip`
- `~/.local/lib/python3.7/site-packages/` - установленные локально через `pip` (без `sudo` и/или с опцией `--user`)

---
> Как узнать *базовую директорию* пользователя для пакетов и бинарников?

Это константа в модуле `site` - `site.USER_BASE`. Вывести ее можно через командную строку: `$ python -m site --user-base`

Туда `pip` устанавливает пакеты. Как правило это папка `~/.local/` с тремя подпапками: `bin/` (туда идут бинарники, standalone-утилиты), `lib/` (сами пакеты), `share/`

---

# Менеджер пакетов PIP [pip-manager]

---
> Какая утилита рекомендована для установки пакетов и модулей? Как ее запустить?

*PIP*, менеджер пакетов, в поставке идет по умолчанию. Две формы установки модуля:

- `$ python3 -m pip install <package>` (предпочтительна, авто-выбор версии языка)
- `$ pip3 install <package>`

---
> Как `pip`-у указать точную и минимальную версию пакета?

- `$ python3 -m pip install SomePackage==1.0.4`
- `$ python3 -m pip install "SomePackage>=1.0.4"` (символы `>`/`<` интерпретируются шеллом, поэтому кавычки)

---
> Как `pip`-ом обновить модуль?

`$ python3 -m pip install --upgrade SomePackage`

---
> Есть ли модуль `pip3` ?

Нет, есть только одноименная утилита в `~/.local/bin/`. Поэтому писать `$ pip3 install` можно, а `$ python3 -m pip3` нельзя

---
> Что такое *PyPI*?

*Python Package Index*, открытый репозиторий для открытых же пакетов: <https://pypi.org>

---
> Почему научные пакеты лучше устанавливать не через `pip` ?

Они часто тянут сложные бинарные зависимости. Лучше использовать предназначенные для этого менеджеры, типа *Conda*

---
> Что делает `pip freeze` ?

(Построчно) выводит список всех установленных пакетов в формате `<name>==<version>`

---
> Как создать *файл требований*, состоящий только из локально установленных пакетов пользователя?

Использовать опцию `--user`: `$ python3 -m pip freeze --user > requirements.txt`

---
> Как установить все пакеты из *файла требований*?

Использовать опцию `-r`: `$ python3 -m pip install -r requirements.txt`

---
> Назовите 4 основных причины использования *файлов требований*

1. *Воспроизводимые установки* (repeatable installations) - копирование одной среды в другую через `pip freeze/install`
1. *Истинное разрешение зависимостей* (true dependency resolution) - в случае, если два пакета имею в зависимостях один и тот же пакет, но разных версий, `pip` просто установит версию из первой по порядку зависимости. С r-файлом это можно обойти, явно указав в нем версию зависимого пакета для установки
1. *Принудительное указание версии*. Похож на пред. пункт - зависимый пакет указывается в файле явно; но служит лишь для того, чтобы не бралась автоматически последняя версия (напр., в ней баг), а подтягивалась указанная
1. *Получение последней версии из VCS*. Если в репозитории пакетов еще нет нужного (хот)фикса, можно указать в r-файле получение пакета из VCS: `git+https://...@sometag`

---

# Виртуальные среды [virtual-environments]

---
> Какая стандартная утилита для создания виртуальных сред? Как ее запустить?

*VENV*, в поставке идет по умолчанию. Как и `pip`, это модуль Python:

- `$ python3 -m venv <dir>` (больше чем предпочтительна)
- `$ pyvenv <dir>` - выдает предупреждение, что такая форма вызова deprecated

---
> Как активировать среду, созданную `venv` ?

Импортировать скрипт активации в текущий шелл: `$ source <dir>/bin/activate`. После этого перед строкой приглашения появится название среды (напр., `(test) [~]$ `)

---
> Устанавливает ли `venv` отдельную версию Python?

Нет, в папке `<env-dir>/bin` создается лишь ссылка на глобальный бинарник: `./python -> ./python3.n -> /usr/bin/python3.n`

---
> Куда `venv` устанавливает пакеты?

В (под)папку текущей выбранной среды: `<env-dir>/lib/python3.n/site-packages/`

---
> Как работает `pip install --user` в виртуальной среде?

Игнорируется, всё - и пакеты и бинарники - ставится внутрь `<env-dir>/` (где есть и `bin/` и `lib/`)
