1. Распаковка фиксированной длины

  - длина и кол-во переменных должны совпадать, иначе `ValueError`
  - неиспользуемые переменные: `_` или `ign`
  - распаковывать можно любую итерируемую последовательность, в том числе, например, строку: `a, b, c, d, e = 'Hello'`
  - распаковывать можно и вложенные структуры: `name, shares, price, (year, mon, day) = ['ACME', 50, 91.1, (2012, 12, 21)]`

2. Распаковка произвольной длины

  - `first, *middle, last` - достаточно, чтобы длина последовательности справа была равна двум
  - переменная со звездочкой всегда будет списком, проверять тип не нужно
  - деление списков: `*leading, tail` или `head, *trailing`
  - удобно делить строки: `uname, *fields, homedir, sh = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'.split(':')`
  - можно делить сложные структуры: ` name, *_, (*_, year) =  ('ACME', 50, 123.45, (12, 18, 2012))`
  - функция рекурсивного суммирования: `head, *tail = items; return head + sum(tail) if tail else head`

3. Оставляем `N` последних элементов

  - задача хранения ограниченной истории - `collections.deque(maxlen=Infinity)`
  - пример генератора, который и возвращает строку/историю, и пишет ее: `yield line, previous_lines; previous_lines.append(line)`
  - 4 метода `collections.deque`: `.append[Left]()`, `.pop[Left]()` выполняются за `O(1)`, тогда как вставка или удаление элемента в начале списка имеет сложность `O(N)`

4. Поиск `N` максимальных и минимальных элементов

  - модуль `heapq`, методы `.nlargest(N, seq, key=)`/`.nsmallest(N, seq, key=)`
  - обе эти функции неявно преобразуют последовательность в кучу (`heap = heapq.heapify(seq)`), и `heap[0]` всегда будет минимальным элементом
  - метод `heapq.heappop(heap)` последовательно возвращает (и удаляет) минимальный элемент из кучи
  - эти методы подходят, когда макс./мин. элементов нужно немного. Иначе лучше через срез: `sorted(items)[:N]`/`sorted(items)[-N:]`
  - если нужен один макс./мин. элемент, то лучше использовать функции `max()`/`min()`

5. Реализация очереди с приоритетом

  - через класс, с использованием модуля `heapq`

6. Мультисловарь

  - реализация через `collections.defaultdict` с конструктором `list` или `set`
  - это приводит к созданию (пустых) элементов даже при обращении на чтение, так что альтернативный вариант - использовать обычный словарь с `.setdefault()`
  - можно и вообще вручную, но добавляется проверка `if key not in d: d[key] = []`

7. Упорядоченный словарь, `OrderedDict`

8. Вычисления со словарями

  - `zip(dict.values(), dict.keys())` даст список кортежей. Т.к. кортежи при упорядочивании сравниваются по первому элементу, то такую последоватльность (полученную из `zip()`) можно подставлять в `min()`/`max()`/`sorted()`
  - плюс такого подхода - сразу получаются пары "значение"-"ключ", и не нужно строить сложные конструкции вроде `dict[min(dict, key=lambda k: dict[k])]`
  - выполнение прямо на словаре - `min(dict)` - будет сортировать ключи. `dict.items()` вернет пары с обратным порядком - сначала ключ, потом значение
  - такой подход - на основе пар "значение"-"ключ" - будет сортировать ключи во вторую очередь. Если встретятся два одинаковых значения, то буде возвращено `min`/`max` по ключу

9. Поиск общих элементов в двух словарях

  - через операции над множествами, используя один из двух методов словаря: `d1.keys() & d2.keys()`, `d1.items() - d2.items()`
  - результат метода `.values()` не поддерживает операции над множествами: значения могут и не быть уникальными. Их нужно явно приводить к `set()`
  - через такие операции можно строить и новые словари. Например, удаление двух ключей: `{key:a[key] for key in a.keys() - {'z', 'w'}}`

10. Удаление дубликатов из последовательности с сохранением порядка элементов

  - решается через вспомогательное множество `seen` уже просмотренных элементов
  - реализуется как отдельная функция-генератор `dedupe`, в цикле проходящая исходную последовательность, и если элемент еще не в `seen`, то возвращая его и добавляя в множество просмотренных: `if item not in seen: yield item; seen.add(item)`
  - для не-хешируемых элементов (напр., словарей) функция `dedupe` получает аргумент-функцию `key`, которая извлекает из элемента хешируемое значение

11. Присваивание имен срезам

  - если в программе присутствуют трудночитаемые срезы, вроде `record[20:32]`/`record[40:48]`, то лучше их заменить на именованные: `SHARES = slice(20,32); record[SHARES]`. Это позволят избегать "магических" констант
  - у объекта класса `slice` есть поля `.start`/`.stop`/`.step`

12. Определение частоты элементов в последовательности

  - конструктор класса `collections.Counter` получает последовательность. Результирующий объект - словарь, где ключи - это элементы последовательности, а значения - частота вхождения
  - метод `Counter.most_common(N)` без аргументов аналогичен `.items()`, а с `N` возвращает только часть кортежей-пар "элемент"-"частота"
  - при вызове на строке можно считать количество букв: `Counter('Lorem ipsum').most_common(2) == [('m', 2), ('L', 1)]`
  - метод `Counter.update(seq)` увеличивает счетчики в словаре за счет обработки новой последовательности
  - класс `Counter` поддерживает арифметические операции - сложение/вычитание счетчиков: `Counter(seq1) + Counter(seq1)` даст словарь, где соответствующие частоты складываются/вычитаются

13. Сортировка списка словарей по общему ключу

  - через `sorted|min|max(seq, key=itemgetter('<key>'))`. Функция не встроенная: `from operator import itemgetter`
  - `itemgetter()` может принимать несколько ключей, тогда сортируются кортежи
  - `itemgetter()` принимает в качестве аргумента любое значение, которое может быть передано `.__getitem__()`
  - аналог функции - `key=lambda r: r['fname'])`/`key=lambda r: (r['lname'],r['fname'])`

14. Сортировка объектов, не поддерживающих сравнение

  - на примере пользовательских классов - передача в `sorted|min|max()` параметра `key=lambda x: x.attr` или `key=operator.attrgetter('attr')`
  - можно использовать сразу несколько атрибутов

15. Группировка записей на основе полей

  - группируется список словарей. Используется функция `itertools.groupby(seq, key=itemgetter('key'))`. Получается список кортежей `[(key, <list-of-dicts>), ...]`
  - перед группировкой `seq` нужно отсортировать: `seq.sort(key=itemgetter('key'))`. Без этого работать не будет, т.к. `itertools.groupby()` проверяет только последовательные элементы
  - без сортировки такое можно сделать и через `collections.defaultdict`: `for row in rows: rows_by_date[row['date']].append(row)`

16. Фильтрация элементов последовательности

  - через list/generator comprehension - `(n for n in mylist if n > 0)`
  - для более сложных случаев можно использовать встроенную `filter(func, seq)` (возвращает итератор)
  - есть еще `itertools.compress(seq1, seq2)`, которая фильтрует первую последовательность по `True`/`False` соответствующих элементов из второй последовательности

17. Извлечение подмножества из словаря

  - с помощью генератора словаря (dictionary comp­rehension): `{ key:value for key,in value dict.items() if key not in some_set }`
  - в принципе, это аналог конструктора, получающего список кортежей: `dict((key, value) for key, value in d1.items() if value > 200)`
  - того же можно добиться и через операции с множествами, используя `d1.keys()` + `&`/`-`

18. Отображение имен на последовательность элементов

  - `collections.namedtuple()` позволяет использовать имена вместо чисел-индексов. Возвращает подкласс стандартного `tuple`
  - параметры его конструктора - имя нового класса и список полей: ` Subscriber = namedtuple('Subscriber', ['addr', 'joined']); sub = Subscriber('jonesy@example.com', '2012-10-19'); sub.addr`
  - кортежи неизменяемы, но можно создать новый, заменив поле: `s = s._replace(shares=75)`. Через вызов `._replace(**s)` на неком кортеже-прототипе можно преобразовывать словари в именованные кортежи

19. Преобразование и сокращение (свертка) данных

  - функция сокращения - это, напр., `sum|min|max`. Решение - выражение­-генератор в аргументе: `sum(x * x for x in nums)`
  - есть ли Python-файлы в каталоге: `any(name.endswith('.py') for name in files)`
  - преобразование гетерогенного кортежа в CSV: `(','.join(str(x) for x in s)`
  - два альтернативных варианта: `min(s['key'] for s in seq)` ~ `min(seq, key=lambda s: s['key'])`

20. Объединение словарей

  - конструктор `collections.ChainMap` получает несколько словарей, но не сливает их, а просто переопределяет операции. Например, обращение по ключу последовательно просматривает словари
  - операции, которые изменяют отображение, всегда действуют на первое отображение в списке
  - альтернатива - слияние словарей через `.update()`
