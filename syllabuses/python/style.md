- Common: <https://www.python.org/dev/peps/pep-0008/>
- Docstrings: <https://www.python.org/dev/peps/pep-0257/>
- Type Hints: <https://www.python.org/dev/peps/pep-0484/>
- Variable Annotations: <https://www.python.org/dev/peps/pep-0526/>

---
> Что наиболее важно в стилистике кода?

Последовательность ее применения

---
> Каков рекомендованный отступ?

4 пробела. Табы могут использоваться только в коде который уже из использует. И в этом случае только они: Python 3 запрещает смешение пробелов и табов в одном файле

> Допустимо смешивать табы и пробелы в одном файле, но отступы должны совпадать. `Tab = 8 Spaces`. По умолчанию выполняется чисто. Добавление опции `-t` при вызове интерпретатора выведет предупреждение, а `-tt` превратит это предупреждение в ошибку

---
> Как переносить длинные последовательности (напр., аргументов функций или выражений в `if`)?

Заключая в скобки. Это предпочтительней явного соединения строк обратным слешем `\`

---
> Какие отступы должны быть у частей длинной последовательности при переносе (напр., у аргументов функций или выражений в `if`)?

Часть аргументов можно оставлять на первой строке (со скобкой), но тогда отступ следующей строки должен совпадать с первым оставленным аргументом:

```python
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
```

В любом случае, отступ переноса не должен сливаться со следующей инструкцией. Если она сдвинута, то переносу нужно добавить еще уровень:

```python
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
```

Последний вариант в случае `if` дискуссионный, и вместо отступа можно разграничить выражения комментарием или даже оставить отступ на том же уровне

---

> Какой отступ может быть у закрывающей скобки при переносе длинной последовательности?

Допустим как отступ по сдвинутому аргументу:

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
```

так и расположение на одном уровне со всем выражением:

```python
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

---
> Какова максимальная длина строки для кода?

*79* символов. Это улучшает читаемость при отображении файлов бок о бок и в инструментах для code review. Возможно увеличение лимита до 100 символов, но, например, стандартная библиотека консервативна, и не допускает такого

---
> Какова максимальная длина строки для комментариев и docstrings?

*72* символа для длинных слабоструктурированных текстов. Это ограничение более жесткое, чем для длины строк кода

---
> Когда обратный слеш `\` всё же может использоваться для переноса длинных строк?

Для конструкций, не поддерживающих скобки. В основном это оператор запятая `,` в конструкциях `with` и `assert`:

```python
with open(), open(): # взять в скобки нельзя: синтаксическая ошибка
assert cnd1, cnd2 # взять в скобки нельзя: изменение смысла, непустой кортеж всегда True
```

---
> Где располагать бинарный оператор при переносе строк?

В начале строки:

```python
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

---
> Как отделяются классы и функции верхнего уровня от остального кода?

Двумя пустыми линиями

---
> Как отделяются друг от друга методы внутри класса?

Одной пустой линией

---
> Когда могут использоваться дополнительные пустые строки?

Для отделения групп связанных функций, и внутри самих функций, для отделения логически связанных секций. В обоих случаях - нечасто

---
> Когда блоки можно не разделять пустыми линиями?

Например, если это группа логически связанных однострочников (напр., dummy implementations)

---
> Когда скрипт должен указывать кодировку в заголовке (encoding declaration)?

Никогда, во всяком случае до тех пор пока код написан в UTF-8 (а это жесткое требование)

> То же самое, только вместо юникода ASCII: файл не должен указывать кодировку, если написан в ASCII

В стандартной библиотеке, начиная с Python v3.0, требования совсем жесткие: всё только в ASCII, английскими словами (исключение только имена авторов в комментариях, да и то рекомендуют транслитерировать)

---
> Можно ли импортировать несколько модулей в одну строку?

Нет, каждый импорт должен быть отдельно:

```python
import os
import sys
```

---
> Можно ли импортировать несколько сущностей из одного модуля в одну строку?

Да, это допустимо:

```python
from subprocess import Popen, PIPE
```

---
> Где в файле должны располагаться импорты?

В начале, после комментариев / docstring-ов уровня модуля, и перед глобальными константами и функциями

---
> Как должны быть сгруппированы импорты?

В группы, разделенные пустой строкой:

1. из стандартной библиотеки
2. third-party
3. локальные

---
> Какая форма импорта предпочтительней?

Абсолютная:

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

Относительные импорты могут использоваться, если расположение модулей в пакете достаточно сложное:
```python
from . import sibling
from .sibling import example
```

В стандартной библиотеке поощряется простая структура пакетов, и разрешены только абсолютные импорты

---
> Можно ли использовать `*` при импорте?

Крайне нежелательно. Единственный случай, когда это разрешено, - публикация в пакете внутреннего интерфейса в качестве внешнего

---
> Где в модуле должны объявляться *магические* (*dunder*) константы?

После docstring-ов верхнего уровня и перед любыми импортами

---
> Где в модуле должны объявляться импорты из `__future__`?

После docstring-ов верхнего уровня и перед "магическими" константами и импортами

---
> Какие кавычки использовать, одинарные или двойные?

Не важно, нужно только не смешивать их, использовать последовательно

---
> Когда можно смешивать одинарные и двойные кавычки?

Когда строка текста содержит кавычку, желательно использовать для нее кавычки другого типа: это повышает читабельность

---
> Какой тип тройных кавычек использовать?

Двойные тройные, для совместимости с docstring-ами (PEP 257)

---
> Как отделять элементы от фигурных, квадратных и круглых скобок?

Отделяться пробелом не должны:

```python
# Correct
spam(ham[1], {eggs: 2})
foo = (0,)
# Wrong
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
```

---
> Как использовать пробелы с запятыми?

Ставить после и не ставить до

---
> Как использовать пробелы в срезах?

Не использовать в основном. Исключение - когда в срезе есть выражение:


```python
# Correct
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

---
> Ставится ли пробел перед круглыми или квадратными скобками при обращении к функции или структуре данных?

Нет, не ставится, скобка пишется слитно с текстом:

```python
# Correct
spam(1)
dct['key'] = lst[index]
```

---
> Можно ли выравнивать операторы "равно" в группе присваиваний?

Нет:

```python
# Correct
x = 1
long_variable = 2
# Wrong
x             = 1
long_variable = 2
```

---
> Нужно ли окружать пробелами бинарные операторы?

Да, это всегда обязательно. Исключениями могут быть операторы с разными приоритетами, тогда можно отделять только низкоприоритетные:

```python
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

Отделять нужно и стрелки/двоеточия в аннотациях функций (двоеточия только справа)

---
> Нужно ли отделять пробелом оператор "равно" в именованных параметрах и аргументах по умолчанию?

Нет, вот здесь его отделять не нужно, пишется слитно:

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

---
> Как объявлять кортежи из одного элемента?

Всегда использовать скобки:

```python
# Correct
FILES = ('setup.cfg',)
# Wrong
FILES = 'setup.cfg',
```

---
> Когда нужны (и не нужны) trailing-запятые?

Нужны только когда расположение кода в несколько линий. Для кода в одну строку их указывать не следует:

```python
# Correct
FILES = [
    'setup.cfg',
    'tox.ini',
]
# Wrong
FILES = ['setup.cfg', 'tox.ini',]
```

---
> Когда комментарий можно начинать с маленькой буквы?

Только когда это идентификатор. Комментарий - это законченное предложение, и оно должно начинаться с большой буквы

---
> Как отделять предложения в многострочном комментарии?

Каждое предложения должно заканчиваться точкой. После каждой точки, кроме последней, ставятся два пробела

---
> Для каких функций и методов нужны docstring-и?

Для всех публичных обязательны. Для закрытых тоже нужны, но там можно ограничиться кратким комментарием

---
> На какой строке должны быть закрывающая кавычка у docstring?

На новой для многострочных:

```python
"""Return a foobang

Optional plotz says to frobnicate the bizbaz first.
"""
```

Для однострочных должна быть на той же строке

---
> Какие однобуквенные переменные переменные не рекомендуется использовать?

Те, которые можно спутать с цифрами или между собой: `I`, `l`, `O`

---
> Какое соглашение по именам модулей и пакетов?

Все в нижнем регистре. В именах модулей можно использовать подчеркивания (если они улучшают читаемость), в именах пакетов нет. Имена низкоуровневых модулей (напр., написанных на C/C++), идущих в комплекте с Python-модулями, должны начинаться с подчеркивания (напр., `_socket`)

---
> В какой нотации пишутся имена классов?

В *CamelCase*

---
> Как должны именоваться классы исключений?

Как и остальные классы, в CamelCase. Кроме того, к имени класса нужно добавлять суффикс `Error`

---
> Как именуются функции переменные?

В нижнем регистре, слова разделяются подчеркиваниями

---
> Как предотвратить конфликт с зарезервированным / ключевым словом?

Добавить в конец имени подчеркивание: `class_`. А еще лучше использовать синоним

---
> Каков формат имен констант?

В верхнем регистре, слова разделены подчеркиваниями

---
> Как сравнивать с `None`?

Как и со всеми синглетами - через `is [not]`. Оператор "равно" использоваться не должен. Порядок должен быть `is not`:

```python
# Correct
if foo is not None:
# Wrong
if not foo is None:
```

---
> Стоит ли присваивать лямбды именованным переменным?

Нет. Это затрудняет отладку и не дает никакого преимущества. Лучше использовать функции:

```python
# Correct
def f(x): return 2*x
# Wrong
f = lambda x: 2*x
```

---
> От какого класса следует наследовать классы исключений?

От `Exception`, не от `BaseException` (перехват последних не предполагается)

> Используйте синтаксис `raise ValueError('message')` вместо устаревшего `raise ValueError, 'message'`

---
> Как следует оформлять `except:`?

Всегда указывать в нем класс исключения. Пустой `except:` эквивалентен `except BaseException:`, и будет перехватывать даже `SystemExit`/`KeyboardInterrupt`. Если тип неизвестен, пишите `except Exception:`

---
> Допустимо ли смешивать пустые и непустые `return`-ы в функции?

Нет. Если хоть один из них возвращает значение, то и остальные должны: вместо просто `return` нужно писать `return None`

---
> Какой способ проверки строки на суффикс/префикс предпочтительней?

Через функции `startswith()` / `endswith()`:

```python
# Correct
if foo.startswith('bar'):
# Wrong
if foo[:3] == 'bar':
```

---
> Как сравнивать типы объектов?

Через `isinstance()`, не `type()`:

```python
# Correct
if isinstance(obj, int):
# Wrong
if type(obj) is type(1):
```

---
> Как правильно проверять, что коллекция пустая?

Через неявное приведение к `bool`, не через длину:

```python
# Correct
if not seq:
if seq:
# Wrong
if len(seq):
if not len(seq):
```

---
> Как правильно проверять булевы значения?

Неявно; сравнение с `True`/`False` использовать не нужно:

```python
# Correct
if greeting:
# Wrong
if greeting == True:
if greeting is True:
```

---
> Можно ли использовать `return`/`break`/`continue` в блоке `finally` у `try`?

Нет, это отменит проходящее через блок `finally` исключение
