---
> Что наиболее важно в стилистике кода?

Последовательность ее применения

---
> Каков рекомендованный отступ?

4 пробела. Табы могут использоваться только в коде который уже их использует. И в этом случае только они: Python 3 запрещает смешение пробелов и табов в одном файле

> Допустимо смешивать табы и пробелы в одном файле, но отступы должны совпадать. `Tab = 8 Spaces`. По умолчанию выполняется чисто. Добавление опции `-t` при вызове интерпретатора выведет предупреждение, а `-tt` превратит это предупреждение в ошибку

---
> Как переносить длинные последовательности (напр., аргументов функций или выражений в `if`)?

Заключая в скобки. Это предпочтительней явного соединения строк обратным слешем `\`

---
> Какие отступы должны быть у частей длинной последовательности при переносе (напр., у аргументов функций или выражений в `if`)?

Часть аргументов можно оставлять на первой строке (со скобкой), но тогда отступ следующей строки должен совпадать с первым оставленным аргументом:

```python
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
```

В любом случае, отступ переноса не должен сливаться со следующей инструкцией. Если она сдвинута, то переносу нужно добавить еще уровень:

```python
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
```

Последний вариант в случае `if` дискуссионный, и вместо отступа можно разграничить выражения комментарием или даже оставить отступ на том же уровне

---

> Какой отступ может быть у закрывающей скобки при переносе длинной последовательности?

Допустим как отступ по сдвинутому аргументу:

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
```

так и расположение на одном уровне со всем выражением:

```python
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

---
> Какова максимальная длина строки для кода?

*79* символов. Это улучшает читаемость при отображении файлов бок о бок и в инструментах для code review. Возможно увеличение лимита до 100 символов, но, например, стандартная библиотека консервативна, и не допускает такого

---
> Какова максимальная длина строки для комментариев и docstrings?

*72* символа для длинных слабоструктурированных текстов. Это ограничение более жесткое, чем для длины строк кода

---
> Когда обратный слеш `\` всё же может использоваться для переноса длинных строк?

Для конструкций, не поддерживающих скобки. В основном это оператор запятая `,` в конструкциях `with` и `assert`:

```python
# взять в скобки нельзя: синтаксическая ошибка
with open(), open():
# взять в скобки нельзя: изменение смысла, непустой кортеж всегда True
assert cnd1, cnd2
```

---
> Где располагать бинарный оператор при переносе строк?

В начале строки:

```python
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

---
> Как разбивать и переносить длинные строковые литералы?

Без операторов конкатенации, без обратных слешей, заключая всё в скобки:

```python
x = ('This will build a very long long '
     'long long long long long long string')
```

---
> Как отделяются классы и функции верхнего уровня от остального кода?

Двумя пустыми линиями

---
> Как отделяются друг от друга методы внутри класса?

Одной пустой линией

---
> Когда могут использоваться дополнительные пустые строки?

Для отделения групп связанных функций, и внутри самих функций, для отделения логически связанных секций. В обоих случаях - нечасто

---
> Когда блоки можно не разделять пустыми линиями?

Например, если это группа логически связанных однострочников (напр., dummy implementations)

---
> Когда скрипт должен указывать кодировку в заголовке (encoding declaration)?

Никогда, во всяком случае до тех пор пока код написан в UTF-8 (а это жесткое требование)

> То же самое, только вместо юникода ASCII: файл не должен указывать кодировку, если написан в ASCII

В стандартной библиотеке, начиная с Python v3.0, требования совсем жесткие: всё только в ASCII, английскими словами (исключение только имена авторов в комментариях, да и то рекомендуют транслитерировать)

---
> Можно ли импортировать несколько модулей в одну строку?

Нет, каждый импорт должен быть отдельно:

```python
import os
import sys
```

---
> Можно ли импортировать несколько сущностей из одного модуля в одну строку?

Да, это допустимо:

```python
from subprocess import Popen, PIPE
```

---
> Где в файле должны располагаться импорты?

В начале, после комментариев / docstring-ов уровня модуля, и перед глобальными константами и функциями

---
> Как должны быть сгруппированы импорты?

В группы, разделенные пустой строкой:

1. из стандартной библиотеки
2. third-party
3. локальные

---
> Какая форма импорта предпочтительней?

Абсолютная:

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

Относительные импорты могут использоваться, если расположение модулей в пакете достаточно сложное:
```python
from . import sibling
from .sibling import example
```
Хотя гугл не рекомендует совсем, говорит использовать имя пакета (?)

В стандартной библиотеке поощряется простая структура пакетов, и разрешены только абсолютные импорты

---
> Можно ли использовать `*` при импорте?

Крайне нежелательно. Единственный случай, когда это разрешено, - публикация в пакете внутреннего интерфейса в качестве внешнего

---
> Где в модуле должны объявляться *магические* (*dunder*) константы?

После docstring-ов верхнего уровня и перед любыми импортами

---
> Где в модуле должны объявляться импорты из `__future__`?

После docstring-ов верхнего уровня и перед "магическими" константами и импортами

---
> Какие кавычки использовать, одинарные или двойные?

- PEP8, Google: не важно, нужно только не смешивать их, использовать последовательно
- CKAN: предпочитать одинарные

---
> Когда можно смешивать одинарные и двойные кавычки?

Когда строка текста содержит кавычку, желательно использовать для нее кавычки другого типа: это повышает читабельность

---
> Какой тип тройных кавычек использовать?

- Двойные тройные, для совместимости с docstring-ами (PEP 257)
- Google: одинарные тройные могут использоваться, если везде в проекте используются (обычные) одинарные. Docstring-и всегда в двойных тройных, независимо от этого

---
> Как отделять элементы от фигурных, квадратных и круглых скобок?

Отделяться пробелом не должны:

```python
# Correct
spam(ham[1], {eggs: 2})
foo = (0,)
# Wrong
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
```

---
> Как использовать пробелы с запятыми?

Ставить после и не ставить до

---
> Как использовать пробелы в срезах?

Не использовать в основном. Исключение - когда в срезе есть выражение:


```python
# Correct
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

---
> Ставится ли пробел перед круглыми или квадратными скобками при обращении к функции или структуре данных?

Нет, не ставится, скобка пишется слитно с текстом:

```python
# Correct
spam(1)
dct['key'] = lst[index]
```

---
> Можно ли выравнивать операторы "равно" в группе присваиваний?

Нет:

```python
# Correct
x = 1
long_variable = 2
# Wrong
x             = 1
long_variable = 2
```

---
> Нужно ли окружать пробелами бинарные операторы?

Да, это всегда обязательно. Исключениями могут быть операторы с разными приоритетами, тогда можно отделять только низкоприоритетные:

```python
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

Отделять нужно и стрелки/двоеточия в аннотациях функций (двоеточия только справа)

---
> Нужно ли отделять пробелом оператор "равно" в именованных параметрах и аргументах по умолчанию?

Нет, вот здесь его отделять не нужно, пишется слитно:

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

Это не относится к аргументам с аннотациями:

```python
def func(a: int = 0) -> int:
```

---
> Как объявлять кортежи из одного элемента?

Всегда использовать скобки:

```python
# Correct
FILES = ('setup.cfg',)
# Wrong
FILES = 'setup.cfg',
```

---
> Когда нужны (и не нужны) trailing-запятые?

Нужны только когда расположение кода в несколько линий. Для кода в одну строку их указывать не следует:

```python
# Correct
FILES = [
    'setup.cfg',
    'tox.ini',
]
# Wrong
FILES = ['setup.cfg', 'tox.ini',]
```

---
> Когда комментарий можно начинать с маленькой буквы?

Только когда это идентификатор. Комментарий - это законченное предложение, и оно должно начинаться с большой буквы

---
> Как отделять предложения в многострочном комментарии?

Каждое предложения должно заканчиваться точкой. После каждой точки, кроме последней, ставятся два пробела

---
> Для каких функций и методов нужны docstring-и?

Для всех публичных обязательны. Для закрытых тоже нужны, но там можно ограничиться кратким комментарием

---
> На какой строке должны быть закрывающая кавычка у docstring?

На новой для многострочных:

```python
"""Return a foobang.

Optional plotz says to frobnicate the bizbaz first.
"""
```

Для однострочных должна быть на той же строке

---
> Какие однобуквенные переменные не рекомендуется использовать?

Те, которые можно спутать с цифрами или между собой: `I`, `l`, `O`

---
> Какое соглашение по именам модулей и пакетов?

Все в нижнем регистре. В именах модулей можно использовать подчеркивания (если они улучшают читаемость), в именах пакетов нет. Имена низкоуровневых модулей (напр., написанных на C/C++), идущих в комплекте с Python-модулями, должны начинаться с подчеркивания (напр., `_socket`)

---
> В какой нотации пишутся имена классов?

В *CamelCase*

---
> Как должны именоваться классы исключений?

Как и остальные классы, в CamelCase. Кроме того, к имени класса нужно добавлять суффикс `Error`

---
> Как именуются функции и переменные?

В нижнем регистре, слова разделяются подчеркиваниями

---
> Как предотвратить конфликт с зарезервированным / ключевым словом?

Добавить в конец имени подчеркивание: `class_`. А еще лучше использовать синоним

---
> Каков формат имен констант?

В верхнем регистре, слова разделены подчеркиваниями:

```python
MAX_HOLY_HANDGRENADE_COUNT
```

---
> Как сравнивать с `None`?

Как и со всеми синглетами - через `is [not]`. Оператор "равно" использоваться не должен. Порядок должен быть `is not`:

```python
# Correct
if foo is not None:
# Wrong
if not foo is None:
```

---
> Стоит ли присваивать лямбды именованным переменным?

Нет. Это затрудняет отладку и не дает никакого преимущества. Лучше использовать функции:

```python
# Correct
def f(x): return 2*x
# Wrong
f = lambda x: 2*x
```

---
> От какого класса следует наследовать классы исключений?

От `Exception`, не от `BaseException` (перехват последних не предполагается)

> Используйте синтаксис `raise ValueError('message')` вместо устаревшего `raise ValueError, 'message'`

---
> Как следует оформлять `except:`?

Всегда указывать в нем класс исключения

Пустой `except:` эквивалентен `except BaseException:`, и будет перехватывать даже `SystemExit` / `KeyboardInterrupt`. Если тип неизвестен, пишите `except Exception:`

---
> Допустимо ли смешивать пустые и непустые `return`-ы в функции?

Нет. Если хоть один из них возвращает значение, то и остальные должны: вместо просто `return` нужно писать `return None`

---
> Какой способ проверки строки на суффикс/префикс предпочтительней?

Через функции `startswith()` / `endswith()`:

```python
# Correct
if foo.startswith('bar'):
# Wrong
if foo[:3] == 'bar':
```

---
> Как сравнивать типы объектов?

Через `isinstance()`, не `type()`:

```python
# Correct
if isinstance(obj, int):
# Wrong
if type(obj) is type(1):
```

---
> Как правильно проверять, что коллекция (не)пустая?

Через неявное приведение к `bool`, не через длину:

```python
# Correct
if not seq:
if seq:
# Wrong
if len(seq):
if not len(seq):
```

---
> Как правильно проверять булевы значения?

Неявно; сравнение с `True`/`False` использовать не нужно:

```python
# Correct
if greeting:
# Wrong
if greeting == True:
if greeting is True:
```

---
> Можно ли использовать `return`/`break`/`continue` в блоке `finally` у `try`?

Нет, это отменит проходящее через блок `finally` исключение

---
> Какие способы передачи аргументов в функцию предпочтительней?

Позиционные (`x, y`) и именованные (`a=3, b=4`) аргументы лучше произвольных (`*args`) и произвольных в словаре (`**kwards`)

---
> Почему один аргумент-список лучше запакованных параметров `(*args)`?

Можно передавать структуры, которые не могут быть распакованы. Например, итераторы

---
> Что говорит принцип YAGNI об именованных параметрах функций?

Что не стоит добавлять их на все случаи жизни, просто "чтобы были"

---
> Как обозначаются закрытые члены классов и модулей?

Их имена начинаются с подчеркивания - `_method`

---
> Какое имя давать неиспользуемой переменной?

Подчеркивание, одно `_` или два `__`. Второе может быть полезно, чтобы не спутать с `gettext()` или последним результатом в REPL

---
> Как проверять, что в словаре есть ключ?

```python
# Correct
'hello' in d # через оператор `in`
d.get('hello', 'some') # через `.get()` с дефолтным аргументом
# Wrong
d.has_key('hello') # но не через `.has_key()`
```

---
> Когда стоит предпочитать генераторы спискам?

Когда сам список физически не нужен, например, передать данные в функцию: `max(_ for ...)` лучше, чем `max([_ for ...])`

---
> Почему запись
> 
> ```python
> [print(x) for x in sequence]
> ```
> плоха?

List comprehension используется не по назначению (создание списков), а для side effect-ов. Лучше переписать на обычный цикл

---
> Когда не стоит удалять элементы из коллекции?

При итерации по этой коллекции. Вместо этого можно, например, итерировать по shallow-клону (`[:]`)

---
> Какой предпочтительный способ получения индекса при итерации по коллекции?

Через `enumerate()`. Это более наглядно, чем считать вручную, и функция оптимизирована

---
> Какой предпочтительный способ открыть файл?

Через менеджеры контекста, `with open()`. Автоматически закрывает файл, даже если внутри блока выброшено исключение

Для объектов, которые не поддерживают `with` явно, можно использовать обертку `with contextlib.closing(...):`

---

> Какой линтер рекомендует Google в своём style guide-е?

*pylint*, с подавлением предупреждений через комментарии (`# pylint: disable=redefined-builtin`) в случае необходимости

---
> Какие типы сущностей лучше импортировать а какие нет?

Импортировать следует только пакеты и модули, не отдельные классы/функции в них. При использовании это наглядно показывает, к какому пространству имен относится сущность

---
> Допустимо ли использовать псевдонимы при импорте?

Да, вполне, для сокращения длинных имен или предотвращения конфликтов

---
> Допустимо ли использовать `assert` для проверки данных из внешних источников?

Нет, он только для проверки внутренней логики

---
> Какие рекомендации по использованию глобальных переменных?

Избегать: при импортах идет их присваивание, и это может приводить к непредсказуемому поведению

---
> Допустимы ли вложенные функции/классы?

Да, вполне, например для декораторов. Не стоит только объявлять функцию вложенной лишь для того, чтобы скрыть ее при импорте. Вместо этого лучше добавить подчеркивание к ее имени

---
> Для каких случаев рекомендуется использовать list comprehensions?

Только для простых и однострочных. Нежелательны множественные `for`-ы и условия фильтрации

То же условие простоты касается и лямбд, и псведо-тернарного оператора

---
> Какого типа объекты можно использовать в качестве значений аргументов по умолчанию?

Только неизменяемые:

```python
# Correct
def foo(a, b=None):
def foo(a, b=()):
# Wrong
def foo(a, b=[]):
def foo(a, b={}):
```

---
> Когда list comprehensions лучше связки `map()`/`filter()`?

Всегда, когда функции - однострочные лямбды. То же касается и `reduce()` - циклы `for` всегда предпочтительней

---
> Можно ли использовать `@staticmethod`?

В гугловом руководстве запрещается, лучше писать функцию уровня модуля. Использование `@classmethod` рекомендуется ограничить именованными конструкторами или методами класса, модифицирующими глобальные переменные

---
> Использовать ли в коде типизацию (type annotations)?

Да, сильно поощряется

---
> С чего должен начинаться файл?

С docstring-а, описывающего назначение и использование этого модуля

---
> В каком наклонении должен быть текст в docstring-ах?

- PEP257: в повелительном (`"""Return the ...`)
- Google: (наоборот) В описательном (`"""Fetches from`)

---
> Что должны описывать docstring-и у функций/методов?

Назначение и синтаксис вызова, не реализацию

---
> Что можно указать в строке документации у метода дочернего класса, перекрывающего метод родительского класса?

Слово `override`, если родительский метод не вызывается, и `extend` иначе. Описание не должно дублировать docstring базового класса

---
> Какие секции могут быть у docstring функции/метода?

`Args`, `Returns`, `Raises`

---
> Какие секции могут быть у docstring класса?

`Attributes`, описывающая параметры конструктора. Причем в `__init__()` эти параметры уже не описываются

---
> Какой отступ у inline-комментариев?

По Google style guide - 2 пробела после строки кода и 1 - после символа комментария:

```python
if i & (i-1) == 0:  # True if ...
```

---
> Какой предпочтительный способ собрать строку из частей в цикле?

Не использовать `+`/`+=`: т.к. строки неизменяемы, это приведет к созданию слишком большого числа временных объектов и квадратичной сложности вместо линейной

Лучше добавлять подстроки в список, а после цикла вызвать `''.join([...])`

---
> Как использовать TODO-комментарии?

Только для временного кода, оставляя свой идентификатор (имя, ник, почту) в скобках:

```python
# TODO(kl@gmail.com): Use a "*" here for string repetition.
# TODO(Zeke) Change this to use relations.
```

---
> Можно ли располагать несколько инструкций в одной строке?

Нежелательно, разве что очень короткие `if/while`. Использование точки с запятой `;` также нежелательно

---
> Какое расширение должно быть у Python-файлов?

`.py`

---
> Можно ли использовать дефис/тире в именах файлов и в коде?

Нет, только подчеркивание

---
> Когда можно использовать однобуквенные имена переменных?

Только для счетчиков/итераторов. Можно использовать `e` для имен исключений. В остальных случаях нежелательно

---
> Отделяется ли docstring пустыми строками от окружающего кода?

В функции не отделяется, ни с одной из сторон. В классе нужна пустая строка перед первым методом

---
> Должна ли ставиться точка в конце первой строки в docstring?

Да, должна:

```python
"""Return the pathname of the KOS root directory."""
```

---
> Каков общий формат для многострочных docstrings?

Однострочная summary -> пустая строка -> более подробное описание:

```python
def complex(real=0.0, imag=0.0):
    """Form a complex number.

    Keyword arguments:
    ...
```

Отступ внутри - по первой кавычке
