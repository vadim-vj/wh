- не забывать писать имена в `snake_case`
- проверка делимости (кратности): `n % m == 0` или `not n % m`
- проверка четности - как в предыдущем с `m = 2` или через битовые операции: `k & 1 == 0` или `not k & 1`
- перебор только четных/нечетных/кратных в цикле решается не явной проверкой, а выставлением нужного шага в `range()`
- нахождение минимума/максимума: можно за начальное значение брать первый элемент последовательности, не (минус) бесконечность, после чего перебирать остаток. Но для `.pop()` обязательно проверять, что массив не пуст
- точно представлять границы и шаги диапазонов:

  * в диапазон попадает первый его элемент: `range(3) == range(0, 3, 1) == [0, 1, 2]`
  * в диапазон не попадает элемент, равный второму параметру среза:`range(3) == [0, 1, 2]`, `range(-2, -1, -1) == [2, 1, 0]`

- где возможно использовать comprehension syntax
- задачи на поиск пар в последовательности. Квадратичная сложность, если отдельные элементы пары не могут быть найдены отдельно, через алгоритм типа "разделяй и властвуй"
- список просмотренных/уникальных элементов - на основе множества, не словаря
- перебор последовательности в два цикла: `for i, item_outer in enumerate(seq)` + `for item_inner in seq[i+1:]`. Квадратичная сложность
- примеры распространенных последовательностей: квадраты и кубы натуральных чисел, степени двойки, факториал, простые числа, числа Фиббоначи, арифметические и геометрические прогрессии
- перебирать два массива по совпадающему индексу можно:

  * через `enumerate(a)` одного и обращение по индексу ко второму
  * через `range(len(a))` одного и обращение по индексу к обоим
  * через `for x, y in zip(a, b)`

- для разбивки строки на буквы можно использовать `list`, а вот для сборки обратно из генератора использовать `str()` нельзя, нужно `''.join()`
