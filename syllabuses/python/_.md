
---
> Соединяет ли Python строки такого вида: `... # ... \`?

Нет, обратный слеш находится за комментарием и игнорируется

---
> В каких случаях смежные строки кода объединяются в одну логическую?

Если открыта любая из скобок `(`/`[`/`{` или тройная кавычка

Физические строки, входящие в одну логическую строку, называются *строками продолжения*. Соображения, касающиеся отступов, относятся к первой физической строке каждой логической строки, а не к строкам продолжения

---
> Как указать кодировку файла с исходным кодом?

Нужен комментарий в начале файла - *директива кодировки*, например, `# coding: iso-8859-1`

---
> Какие символы могут содержать файлы с исходным кодом?

Любые символы Unicode в кодировке UTF-8. ASCII-символы (коды 0-127) - их часть

> По умолчанию только ASCII. Кодировку можно сменить через `# coding: utf[-8]` в начале файла. Использовать юникод в v2 можно только в строковых литералах и комментариях

---
> Какие символы разрешается использовать в именах идентификаторов?

Любые символы, интерпретируемые Юникодом как буквы / цифры / символы подчеркивания. Не может начинаться с цифры. Вполне допустимы, например, имена переменных из русских букв:

```python
фф = 3
```

> Только `[a-zA-Z0-9_]`

---
> Имеет ли регистр значение в Python?

Да, язык регистр-чувствительный. Как для идентификаторов, так и для ключевых слов

---
> Допускается ли использование знаков пунктуации в именах идентификаторов?

Нет, ничего вроде `@`/`$`/`!` использовать нельзя

---
> В каком регистре пишутся ключевые слова?

Все в нижнем. Т.к. язык регистр-чувствительный, то изменение регистра любого символа в них приведет к синтаксической ошибке (`SyntaxError: invalid syntax`)

---
> Чем являются `exec` и `print`?

Функциями

> Ключевыми словами. Хотя, если включить в код `from __future__ import print_function`, то станет функцией

---
> Чем являются в языке лексемы `True`, `False`, `None`?

Ключевыми словами. Например, при попытке их использования в качестве переменной будет выброшена ошибка `SyntaxError: can't assign to keyword`

---
> Есть ли в Python объявления (функций, переменных, и т.д.)?

Нет, есть только инструкции

---
> Чем является операция присваивания?

Инструкцией. И поэтому не возвращает значения и не может входить в выражения

---
> Что является признаком конца блока?

Возврат к отступу, равному или меньшему отступу заголовка блока

---
> Как получить тип объекта?

Встроенная функция

```python
type(obj)
```

возвращает класс (напр., `<class 'float'>`)

---
> Как проверить принадлежность объекта классу?

Встроенная функция `isinstance(obj, type)` возвращает `True`, если `type` находится в базовых классах `obj`

---
> Какие есть встроенные числовые типы?

Их три:

- целочисленные `int`
- с плавающей точкой `float`
- комплексные `complex`

> Есть еще `long`

---
> Чем являются все числа в Python?

Неизменяемыми объектами. Поэтому любая операция с ними порождает новый объект (в том числе, составные присваивания)

---
> Какие есть литералы для записи чисел в не-десятичных системах счисления?

Двоичный `0b`, восьмеричный `0o`, шестнадцатеричный `0x`

> Восьмеричный можно писать без `o`, просто ноль

---
> Какое максимальное целое число можно записать литералом?

Любое, верхняя граница не определена

> Граница между `int` и `long` определяется константой `sys.maxint`

---
> Каков формат литерала для чисел с плавающей точкой?

Первый ноль может опускаться (`.1`), может использоваться научная нотация: `e|E` (в любом регистре), за ней необязательный `+/-`, потом цифры показателя степени (`.1E+2 == 10.0`)

---
> Как получить информацию о представлении чисел с плавающей точкой на текущей машине?

Кортеж `sys.float_info` хранит подробности реализации типа `float` в данном интерпретаторе 

---
> Какой формат у литерала комплексного числа?

Два числа с плавающей точкой, соединенные символом `+`/`-`. Вторая часть (мнимый литерал) записывается с суффиксом `j`:

```python
4-.1e3j == (4-100j)
```

Сложение/вычитание выполняется в момент компиляции

---
> Можно ли разделять разряды в числовых литералах?

Да, с v3.6 можно использовать подчеркивания:

```python
100_000.000_0001 == 100000.0000001
0x_FF_FF == 65535
0o7_777 == 4095
0b_1010_1010 == 170
```

---
> Чем являются строки в Python?

Неизменяемыми объектами, последовательностями символов Unicode. Любая операция с ними порождает новый объект

> Недекодированные литералы являются байтовыми строками (не Unicode)

---
> Какие кавычки предпочтительней для строк?

Одинарные

---
> Как преобразуется перенос в строках в тройных кавычках?

В символ новой строки `\n`:

```python
"""1
2
3""" === "1\n2\n3"
```

---
> Как избежать переносов строк и отступов внутри тройных кавычек?

Использовать обратный слеш `\`:

```python
"""\
2\
3""" === "23"
```

---
> В чем основная особенность "сырых" строковых литералов?

В них обратный слеш `\` не имеет специального значения - он сам и все следующие за ним символы просто копируются в строку. Такой литерал обозначается буквой `r|R` перед открывающей кавычкой (кавычками)

---
> Какими символами не может заканчиваться литерал "сырой" строки?

Нечетным количеством обратных слешей. В таком случае последняя косая черта будет восприниматься как будто она экранирует закрывающую кавычку

---
> Как можно задать в строке символ Юникода через его числовое значение?

- указав 4 цифры после `\u` (напр., `"\u3421"`)
- указав 8 цифр после `\U`
- указав имя в фигурных скобках после `N` (напр., `"\N{Copyright Sign}"`)

---
> Что произойдет, если просто записать два строковых литерала рядом?

Компилятор соединит их в одну строку. Пробелы между литералами опциональны. Если один из литералов - байтовая строка (`[r]b'...'`), а второй Юникод, то ошибка

> При слиянии байтовой строки (`br`) и строки Юникода результат приводится к Unicode

---
> Чем являются кортежи в Python?

Неизменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов. Любая операция с ними порождает новый объект

Элементом кортежа может быть изменяемый объект (напр., список), но в соответствии с установившейся практикой этого лучше избегать

---
> Сколько элементов в кортеже `(1,2,)`?

Два. Последняя запятая не добавляет пустой элемент, она вообще опциональна. Это же касается и остальных коллекций, вроде списка, множества и словаря

---
> Что такое *пара*?

Кортеж из двух элементов, `(a, b)`

---
> Какой тип у (позиционного) аргумента `x` конструктора `tuple/set/list`?

Любой итерируемый (иначе ошибка `TypeError: 'int' object is not iterable`)

---
> Чем являются списки в Python?

Изменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов

---
> На какую другую коллекцию Python больше всего похожи списки?

На кортежи: такой же тип (итерируемый объект) у конструктора `list(x)`, такая же необязательная trailing-запятая `[1,2,]`, такой же доступ к элементам по индексу

---
> Чем являются множества в Python?

Могут быть как изменяемыми (`set`/`{}`), так и неизменяемыми (`frozenset`) объектами, *неупорядоченными* последовательностями уникальных объектов

---
> Какое ограничение накладывается на элементы множеств?

Они должны быть хешируемыми (неизменяемыми) объектами: должны иметь методы `.__hash__()` и `.__eq__()` (для сравнения с другими элементами)

Хешируемые элементы могут быть ключами словарей и элементами множеств. Объекты пользовательских классов хешируемые по дефолту

---
> В каком случае объекты типа `tuple` и `frozenset` являются хешируемыми?

Только когда их элементы хешируемые (неизменяемые)

---
> Как записать литерал пустого множества?

Это сделать нельзя, из-за неразличимости с литералом пустого словаря - `{}`. Нужно писать через конструктор класса - `set()`

----
> Как записать литерал пустого кортежа?

Парой круглых скобок `()`

----
> Как записать литерал пустого словаря?

Парой фигурных скобок `{}` (получается именно словарь, не множество)

---
> Чем являются словари в Python?

Изменяемыми неупорядоченными объектами, отображениями (map) множества ключей на множество объектов. Аналогичны ассоциативным массивам

---
> Какие ограничения накладываются на ключи и значения словарей?

На значения ограничений не накладывается, а ключи должны быть хешируемыми (неизменяемыми) объектами

---
> Какое из значений будет выбрано при наличии повторяющихся ключей в словаре?

Последнее; указанное последним в литерале или последнее добавленное (переписывает существующее). До версии v3.7 это не гарантируется, и выбирается произвольное значение (UB)

---
> Как можно создать словарь через конструктор `dict()`?

Используя именованные параметры или список кортежей:

```python
dict(x=42, у=3.14, z=7) == {'x': 42, 'у': 3.14, 'z': 7}
dict([(1, 'za'), ('br',23)]) == {1: 'za', 'br': 23}
```

---
> Что будет, если конструктору словаря передать одновременно и итерируемый (позиционный) параметр, и один или несколько именованных?

Отработает нормально, создаст словарь. Именованные аргументы здесь имеют более высокий приоритет, так что они перепишут ключи-дубликаты в позиционном параметре (если есть):

```python
dict([(1, 'za'), ('br',23)], br='ddd') == {1: 'za', 'br': 'ddd'}
```
---
> Как создать словарь из набора ключей и одного (общего для всех) значения?

Воспользоваться методом `dict.fromkeys()`. Первый параметр - любая итерируемая последовательность, второй опционален - значение-заполнитель (если не указано, то `None`):

```python
dict.fromkeys('hello', 2) == {'h': 2, 'e': 2, 'l': 2, 'o': 2}
dict.fromkeys([1, 2, 3]) == {1: None, 2: None, 3: None}
```

---
> Что такое `None`?

Встроенный объект, синглет. Не имеет неспециальных методов и атрибутов. Возвращается функцией, если в ней нет инструкции `return`

---
> Какие есть *вызываемые типы*?

- функции/методы (`def`)
- генераторы (`def` + `yield`)
- все классы (встроенные и пользовательские; `class`)
- экземпляры классов, предоставляющие спец. метод `__call__()`

---
> К какому типу относятся `True`/`False`?

Это объекты класса `bool`, который сам является подклассом `int`

---
> Чему равны `True`/`False`?

`1`/`0` соответственно

---
> Каковы правила преобразования объектов к `True`/`False`?

К `False` приводятся:

- `None`
- `0`
- пустая строка и все пустые коллекции: `[]`, `{}`, `()`
- объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно

Всё остальное `~ True`

---
> Как создать и освободить переменную (ссылку)?

Объявлений переменных в Python нет, они создаются в момент инициализации (как правило присваивания). Явное удаление ссылки можно сделать оператором `del`

---
> Что такое *сборка мусора*?

(Автоматическое) удаление объектов, на которые не указывает ни одна ссылка (переменная). Такие свободные объекты могут оставаться в памяти, например, при переприсваивании переменным других значений

---
> Какие идентификаторы можно использовать в качестве имен переменных?

Любые, кроме (~ 30 штук) ключевых слов языка

---
> Чем отличается обращение к *атрибуту* и *элементу* объекта-коллекции?

К атрибуту обращение идет через точку (`x.y`), тогда как к элементу коллекции - через оператор квадратных скобок `[]`. Вызываемые атрибуты класса называются *методами*

---
> Что такое *LHS* и *RHS*?

*Lefthand side* и *righthand side*, левая и правая части присваиваний. Т.к. в Python функции/методы являются объектами первого класса, они могут быть RHS

---
> Можно ли присваивать значение срезу списка?

Да, вся указанная в левой части присваивании часть будет заменена на то, что справа от "равно" (с возможным изменением размера списка). Присваивать можно только итерируемый объект

---
> Что такое *групповое присваивание*?

Присваивание ссылки на объект сразу нескольким переменным. RHS здесь вычисляется ровно один раз

Все переменные после этого ссылаются на один объект, но не на друг друга:

```python
x = y = 3; x = 4; print(x, y) # 4 3
x = y = []; x.append(4); print(x, y) # [4] [4]
```

---
> Что такое *присваивание с распаковкой*?

Форма записи, когда в LHS переменные перечисляются через запятую, а в RHS находится итерируемый объект: `а, b, с = х`

Элементов в распаковываемом объекте должно быть *ровно столько* (не больше и не меньше), сколько и переменных в LHS, иначе ошибка

---
> Для чего часто используется присваивание с распаковкой?

Для обмена значений и в циклах:

```python
a, b = b, a
a, b in enumerate(...):
```

---
> Что такое *расширенное присваивание с распаковкой*?

Используется символ звездочка `*`. Он указывает элемент, который станет списком-"остатком" - в который будут записаны все лишние элементы из правой части (RHS):

```python
x, *y, z = [1, 3, 5, 6, 5]
print(x, y, z) # 1 [3, 5, 6] 5
# аналог:
first, *middle, last = х 
first, middle, last = х[О], x[1:-1], х[-1]
```

Правая часть может быть произвольным итерируемым объектом

> Нет такой конструкции. Ее можно только эмулировать через индексы, как в примере выше

---
> Каково минимальное число элементов в правой части расширенного присваивания с распаковкой?

На единицу меньше кол-ва элементов в LHS:

```python
x, *y, z = [1, 5]
print(x, y, z) # 1 [] 5
```

---
> Что такое *составное присваивание*? Сколько всего таких операторов есть?

Семь для арифметических операций: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=` и пять для бинарных битовых: `|=`, `>>=`, `<<=`, `&=`, `^=`. В v3.5 появился еще оператор умножения матриц `@=`

В левой части составного присваивания допускается только одна целевая ссылка; множественные целевые ссылки не поддерживаются

> Оператора `@=` естественно нет

---
> Как физически реализуется составное присваивание?

Через специальные методы объекта (как правило, начинающиеся с `i`). Если такого метода нет, выполняется обычная операция, ее результат пишется во временный объект, после чего этот объект присваивается левой части.

Так, например, для `x += y` сначала проверяется, есть ли у `x` метод `__iadd__()`, и если есть, вызывается `x = x.__iadd__(y)`. Если метода нет, выполняется `x = x + y`

---
> Можно ли вызывать составное присваивание на еще не определенной переменной?

Нет, ссылка к этому моменту должна существовать. Инструкция

```python
<non-existing-var> += 1
```

вызовет ошибку

---
> Что делает инструкция `del`?

Не удаляет объекты физически, а лишь открепляет ссылки на них, разрывает связь между идентификатором (ссылкой) и физическим объектом в памяти

Также в списках ей можно удалять элементы и срезы

---
> Какой формат у инструкции `del`?

После самой инструкции следует имя переменной (идентификатор), одно или несколько, разделенные запятыми. Все переменные должны быть определены, иначе ошибка

---
> Какие методы управляют поведением инструкции `del` на объектах классов?

`.__delattr__()` для атрибутов класса и `.__delitem__()` для удаления элемента коллекции. Каждый из них может запретить удаление, сгенерировав исключение

---
> Может ли выполнение инструкции `del` сопровождаться побочными эффектами? Приведите примеры

Да, может. Например, при удаление по ключу из словаря (`del C[2]`) больше обращаться к удаленному элементу нельзя (чистое удаление, без побочных эффектов), тогда как такое же удаление из списка (`del C[2]`) оставит второй индекс валидным (удаление со сдвигом, который и является побочным эффектом)

---
> Какой приоритет у логических операторов?

`not` самый приоритетный, затем `and`, у `or` самый низкий приоритет

---
> У чего выше приоритет, у логических связок или у операторов сравнения?

У операторов сравнения:

```python
(2 == 2 and 0 == 0) == True
```

---
> Какой минус/плюс приоритетней, унарный или бинарный?

Унарные операторы приоритетней

---
> Где в таблице приоритетов находятся битовые операторы?

Их приоритет ниже арифметических, но выше операторов сравнения

---
> Каков приоритет у операторов `[not] in` / `is [not]`?

Такой же, как у операторов сравнения, и одинаковый между собой

---
> Что такое *цепочки сравнений*?

Особая форма записи условий в Python, позволяющая обходиться без логических связок:

```python
a < b < c
a != b != c
```

Вычисления идут по короткой цепи, третье и последующее выражения могут и не вычисляться

---
> Какие операторы допускают объединение в цепочки?

`[not] in`, `is [not]`, `<`, `<=`, `>`, `>=`, `!=`, `==`

У всех у них одинаковый приоритет

---
> Как раскрываются цепочки сравнений?

Через логическую связку `and`:

```python
a < b < c # a < b and b < c
"bc" in "abcde" == True # "bc" in "abcde" and "abcde" == True
```

По сути, это просто синтаксический сахар

---
> В какой момент вычисление логического выражения останавливается?

Вычисления идут *по короткой цепи*: слева направо и останавливаются, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

---
> Что возвращают логические связки `and`/`or`?

Свои операнды, не булевы значения. Это позволяет использовать их (связки) в более общих, а не только булевых контекстах

---
> Как в Python выглядит тернарный оператор?

```python
<if-true> if <condition> else <if-not-true>
```

---
> Чем являются унарные `-`/`+` в записи обычных чисел, и бинарные `-`/`+` в записи комплексных? Почему это важно?

Являются обычными операторами, не частью литералов чисел. Важно это потому, что на них распространяются приоритеты операторов. Так, например, `-2**2 == -4`, т.к. возведение в степень имеет более высокий приоритет, чем унарный минус

---
> Как в Python идет неявное преобразование числовых типов?

Оно *повышающее* - если операнды различаются, то тип "меньшего" неявно приводится к типу "большего". Самый "маленький" тип `int`, потом `float`, самый большой `complex`

---
> Как можно преобразовать комплексное число в другой числовой тип?

Никак, не существует однозначных ("сужающих") преобразований

---
> Как привести строку к числу?

Вызвать конструктор соответствующего типа с этой строкой:

```python
int('33') == 33
float('33.44') == 33.44
complex('3+.2j') == (3+0.2j)
```

---
> Как распарсить строку в число в не-десятичной системе счисления?

Работает только для целых чисел. Передать основание системы (от 2 до 36) счисления вторым параметром конструктору `int`:

```python
int('10101', 2) == 21
```

---
> Какие ограничения на операнды `/`, `//`, `%`?

Правый их операнд не может быть равен нулю, иначе runtime-ошибка

---
> Какой тип возвращаемого значения у оператора `/`?

Всегда число с плавающей точкой (истинное деление)

> Если оба операнда - целые числа, то округляет вниз (`5/3 == 1`, `-5/3 == -2`). Чтобы поведение было такое же, как в v3, нужно указать опцию командной строки для интерпретатора - `-Qnew`, умножать на `float` - `1.0*а/b`, или (что лучше) указать в начале файла `from __future__ import division`. Не помешает также опция `-Qwarn`, которая предупредит о возможных несоответствиях при использовании оператора `/`

---
> Какой тип возвращаемого значения у оператора `//`?

Совпадает с типом самого "широкого" операнда. То есть, если хотя бы один операнд - это число с плавающей точкой, то результат `float`. И только если и делимое и делитель целые, то результат `int`

---
> Как оператор `//` вычисляет значение?

Округляет вниз:

```python
5//3 == 1
-5//3 == -2
```

Тип всегда берется по самому "широкому" операнду:

```python
5//3 == 1
5.0//3 == 1.0
```

---
> Как можно в одно действие получить и целую часть, и остаток от деления?

Использовать встроенную функцию `divmod(a, b)` - она вернет пару `(int, int)` с нужными значениями

---
> Как можно выполнить возведение в степень?

Оператором `a**b` или встроенной функцией `pow(a, b)`

---
> Что будет, если возвести в дробную степень отрицательное число?

Будет возвращено комплексное число:

```python
(-4)**.5 == (1.2246467991473532e-16+2j)
```

> Будет выброшено исключение

---
> За что отвечает третий параметр функции `pow()`

С ним функция начинает возвращать остаток от деления результата возведения в степень на это параметр:

```python
pow(а, b, с) == (а**b)%с
```

Функция работает немного быстрее последовательности операторов

---
> Можно ли сравнивать комплексные числа?

Только на равенство/неравенство. Иначе выбрасывается исключение

---
> Что возвращают операторы сравнения?

В отличие от логических связок - булевы значения, не свои операнды

---
> Можно ли сравнивать числа с плавающей точкой?

Нет, из-за возможных ошибок представления/округления

---
> Можно ли использовать битовые операторы с целыми числами?

Да. Положительные целые числа концептуально расширяются влево неограниченной строкой битов `0`. Отрицательные числа, для представления которых используется дополнительный код, концептуально расширяются влево неограниченной строкой битов `1`

---
> Как получить длину последовательности, минимальный/максимальный элементы, как вычислить сумму элементов?

Всё - через встроенные (built-in) функции: `len()`, `min()`, `max()`, `sum()` соответственно

Это работает для списков, кортежей, множеств и словарей (списка их ключей)

---
> Как можно конкатенировать и повторить последовательность?

Операторами сложения и умножения соответственно:

```python
[1, 2] + [3, 4] == [1, 2, 3, 4]
[1, 2] * 2 == [1, 2, 1, 2]
```

---
> Что будет при "умножении" последовательности на отрицательное число?

Будет возвращена последовательность того же типа, но нулевой длины:

```python
[1, 2, 3] * -2 == []
```

---
> Как проверить принадлежность элемента коллекции?

Оператором `[not] in`: `х in S`. Эквивалентная запись для `not`: `x not in S` ~ `not (x in S)`

Это работает для всех: для строки, списка, кортежа, множества и словаря

---
> Какой тип значения возвращает оператор `[not] in`?

Логическое:

```python
("bc" in "abcde") == True
(1 in []) == False
```

---
> В чем особенность использования оператора `[not] in` со строками?

Он может проверять вхождения сразу по подстроке, не только по одному символу:

```python
("bc" in "abcde") == True
```

---
> Каков допустимый диапазон отрицательных индексов последовательности длиной `L`?

От `-1` до `-L` включительно:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == 3
x[-3] == 1
```

---
> Как из отрицательного индекса последовательности получить положительный?

Сложить отрицательный с длиной - `L + -n`:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == x[len(x) - 1] == x[2] == 3
x[-3] == x[len(x) - 3] == x[0] == 1
```

---
> Что происходит при попытке доступа на чтение к элементу последовательности по несуществующему индексу? При попытке присвоения?

В обоих случаях выбрасывается исключение

---
> Как можно вставить элемент в список в позицию `n`, не прибегая к методу `.insert()`?

Используя срез `[n:n] = [val]`:

```python
x = [1, 2, 3]
x[1:1] = [4]
x == [1, 4, 2, 3]
```

---
> Каким типом интервала является срез?

Полуоткрытым: первый индекс включается в срез, а второй нет - `[i, j)`

---
> Какую подпоследовательность вернет срез с одинаковыми индексами?

Пустую. Так как `[i:i]` ~ `[i, i)`, т.е. конечный индекс не включается, то и длина среза равна нулю

---
> Какое ограничение на значение шага в срезе?

Не должен быть нулем, иначе `ValueError: slice step cannot be zero`

---
> Чем являются числа в обозначении среза?

Реальными индексами элементов. Например:

```python
[1, 2, 3][1:2] == [2]
[1, 2, 3][1:3] == [2, 3]
```

Индекс `1` указывает на второй элемент, индекс `2` на последний, а `3` - на индекс за последним элементом списка. Вторые индексы среза не включаются в результирующую последовательность

---
> Чему равны пропущенные индекс в срезе?

Левый нулю, а правый длине последовательности:

```python
[:n] ~ [0:n]
[n:] ~ [n:len(seq)]
```

Таким образом, правый дефолтный индекс указывает на элемент за последним элементом последовательности

---
> В каких случаях срез `[i:j]` даст пустую последовательность?

Когда первый индекс больше или равен второму (`i >= j`), или первый индекс больше или равен длине последовательности (`i >= len(seq)`)

---
> Что будет, если второй индекс в срезе больше длины последовательности?

Ничего, корректно отработает. Возьмет длину вместо слишком большого индекса

---
> Как сделать shallow copy последовательности через срез?

Опустить оба индекса: `seq[:]`

---
> Как привести отрицательные индексы в срезе к положительным?

Так же, как приводятся отрицательные индексы при доступе к элементам последовательности - вычесть из длины:

```python
[1, 2, 3][-2:-1] == [1, 2, 3][1:2] == [2]
```

---
> Что задает третий параметр среза?

Шаг. По умолчанию равен `1`

---
> Что происходит, если шаг среза отрицательный?

Элементы выбираются в обратном порядке (справа налево) начиная со второго индекса среза

---
> Какое условие для индексов среза должно выполняться при отрицательном шаге?

Второй индекс должен быть больше первого, иначе срез будет пустой:

```python
x = list(range(10))
x[8:4:-1] == [8, 7, 6, 5]
x[4:8:-1] == []
```

---
> Какой тип имеет элемент последовательности "строка"?

Тоже строка, только длиной `1`. В Python не предусмотрен специальный тип для одиночных символов

---
> Можно ли вставить в строку элемент(ы) через присваивание срезу?

Нет, нельзя, как и нельзя поменять отдельный символ: строка - это неизменяемый объект. Обе этих инструкции:

```python
"abcde"[1:1] = ["f"]
"abcde"[1] = ["f"]
```

выбросят исключение: `TypeError: 'str' object does not support item assignment`

То же верно и для кортежа, только он уже может хранить изменяемые элементы

---
> Чем являются срезы списков?

Тоже списками

---
> При присваивании значения срезу списка чем должно являться RHS?

Итерируемым объектом произвольной длины

---
> Какие существуют варианты присвоения срезу?

```python
# присвоение непустому срезу перезаписывает элементы
[i:j] = [a, b, ...]
# присвоение пустого списка непустому срезу приводит к удалению элементов
[i:j] = []
# присвоение списка пустому срезу - это вставка элементов
[i:i] = [a, b, ...]
```

В случае перезаписи размер списка может увеличиваться/уменьшаться

---
> В какую позицию идет вставка в список при указании в LHS среза нулевой длины?

Вставляемый список начинается с (единственного совпадающего) индекса из среза в LHS:

```python
x = [1, 2, 3]
x[1:1] = [5, 6]
# начало [5, 6] теперь под индеком 1
x == [1, 5, 6, 2, 3]
```

---
> Что происходит, если размер присваиваемого списка не совпадает с размером среза в LHS?

Размер результирующего списка увеличивается/уменьшается

---
> Что будет, если присвоить новое значение срезу `[:]`?

Список будет полностью перезаписан (по тому же адресу):

```python
x = [1, 2]
addr = id(x)
x[:] = [3, 4]

x == [3, 4]
addr == id(x)
```

---
> Как можно применять оператор `del` к списку? Что при этом происходит с размером списка?

Можно применять как к отдельному индексу, так и к срезу:

```python
x = [1, 2, 3, 4, 5]
del x[1] # [1, 3, 4, 5]
del x[::2] # [3, 5]
```

Размер списка при этом автоматически уменьшается

---
> Какие есть составные операторы для списков?

- `L += L1` аналогична методу `L.extend(L1)`
- умножение на число `n` добавляет в конец `n-1` копию списка:

```python
x = [1,2]
x *= 2
x == [1, 2, 1, 2]
```

---
> Что будет, если умножить кортеж или список на неположительное число?

Получим пустую последовательность:

```python
(1,2) * -2 == ()
```

---
> Как можно очистить список без использования метода `.clear()`?

```python
del x[:]  # оператором `del`
x[:] = [] # присвоением пустого списка полному срезу
x *= 0    # n <= 0
```

---
> Какие есть *немутирующие* методы у списка?

- `.count(a)` - подсчет количества вхождений элемента `a`
- `.index(a)` - возврат индекса первого встретившегося элемента `a`

---
> Что возвращает метод `list.index(a)` если `a` не найден в списке?

Выбрасывает исключение `ValueError: <a> is not in list`

---
> Что возвращает метод `list.count(a)` если `a` не найден в списке?

Ноль `0`, в отличие от `.index()` исключения не выбрасывает

---
> Какие есть аналоги `list.append(a)`?

Через срез или через составное сложение:

```python
L[len(L):] = [a]
L += [a]
```

---
> Какие есть аналоги `list.extend(s)`?

Через срез или через составное сложение:

```python
L[len(L):] = s
L += s
```

---
> Какой есть аналог `list.insert(i, a)` через срез?

Вставка элемента в позицию `i`, сдвиг всех остальных вправо и увеличение длины списка на единицу:

```python
L[i:i] = [x]
```

---
> Что делает метод `list.remove(a)`?

Удаляет из списка первый встретившийся элемент равный `a`, или выбрасывает исключение, если такой элемент не найден

---
> Что делает метод `list.pop(i=-1)`?

Удаляет элемент по индексу и возвращает его значение.Без аргумента возвращает последний элемент (`[-1]`). На пустом списке или недопустимом индексе выбрасывает исключение

---
> Как обратить список?

- метод `.reverse()` (in-place)
- через срез: `[::-1]` (возвращает shallow-клон)
- встроенная функция `reversed()` возвращает (новый) итератор

---
> Какая сигнатура у метода `list.sort`?

Сортировка in-place, метод ничего не возвращает. Аргументы только именованные:

- `key=None` - функция, применяемая к каждому элементу. Если задана, то сравниваются не `x1 <=> x2`, а `key(x1) <=> key(x2)`
- `reverse=False` - обратный порядок

> Есть еще аргумент `cmp=func`, но он признан устаревшим даже в v2

---
> Что возвращают мутирующие методы классов `list` и `set`?

Все, кроме `.pop()`, возвращают `None`: это in-place операции

---
> Какой алгоритм используется в `list.sort()`?

Устойчивый (равные элементы не меняются местами в процессе) *Timsort*, названный в честь Тима Петерса. Гибрид сортировки вставками и сортировки слиянием

---
> Почему в общем случае `list.sort()` + `list.reverse()` не то же самое, что `list.sort(reverse=True)`?

Алгоритм сортировки в методе `.sort()` *устойчивый*, он не меняет местами равные элементы

---
> В чем сходства и отличия встроенной функции `sorted()` и метода `list.sort()`?

Аргументы одинаковы (`key=None, reverse=False`), но `sorted()` возвращает значение, а `.sort()` выполняет сортировку in-place

---
> Какие есть хелперы для сортировки списков объектов и списков списков?

В модуле `operator` есть функции `attrgetter()` и `itemgetter()`, которые можно использовать в качестве `key=` в `.sort()`/`sorted()`:

```python
sorted(items, key=operator.attrgetter('price'))
items.sort(key=itemgetter(1))
```

---
> Как можно создать shallow copy для коллекции?

- классы `list`, `set`, `frozenset`, `dict` имеют метод `.copy()`. У `tuple` его нет
- класс `list` можно клонировать через срез `[:]` или `* 1` (`tuple` так не клонируется, дает ссылку на тот же объект)

---
> Назовите 7 основных математических операции над множествами и их вызов для `[frozen]set`

```python
a | b | c ~ a.union(b, c)
a & b & c ~ a.intersection(b, c)
a - b - c ~ a.difference(b, c)
a ^ b ~ a.symmetric_difference(b)
a <[=] b ~ a.issubset(b)
a >[=] b ~ a.issuperset(b)
a.isdisjoint(b) ~ a & b == set() # empty
```

---
> Как добавить элемент в множество?

Методом `.add()`. Он не выполняет никаких действий и не выводит никаких ошибок, если такой элемент уже есть

---
> Как удалить элемент из множества?

- `set.discard(a)` не выполняет никаких действий и не выводит никаких ошибок, если элемента нет
- `set.remove(a)` генерирует исключение `KeyError`, если элемента нет

---
> Как можно очистить множество или словарь (удалить все элементы)?

Методом `.clear()`. В отличие от списка, срезы и `*= 0` здесь неприменимы

---
> Что делает метод `set.pop()`?

Возвращает произвольный элемент, удаляя его из множества

---
> Когда может быть полезен метод `set.pop()`?

Когда нужно одновременно обходить множество и удалять его элементы. Обход через `for` не позволяет удалять элементы (инвалидируются итераторы), а

```python
while s:
    e = s.pop()
```

отлично работает. Кроме того, такой вариант сильно экономит память для больших множеств

---
> Применима ли встроенная функция `len()` к словарям?

Да, она возвращает количество пар "ключ-значение" (= количеству ключей и значений)

---
> Что вернут функции `min()`/`max()` для словаря?

Наименьший/наибольший из *ключей*

Вообще, для любой функции, принимающей итератор, при передаче словаря работа будет идти с его ключами

---
> Что попадет в переменную `d` цикла `for d in dict():` (итерация по словарю)?

Ключи словаря, не пары

---
> Что будет при обращении к несуществующему ключу словаря на чтение? На запись? На удаление?

- `x['a']` - при чтении несуществующего ключа будет выброшено исключение `KeyError`
- `x['a'] = 1` - а вот запись - валидная операция
- `del x['a']` - при удалении то же, что и при чтении - ошибка

---
> Какой есть безопасный способ получения значения по ключу в словаре?

Метод `dict.get(<key>[, None])`. Аргумент по умолчанию не обязательный, без него вернет `None`, если ключ не существует

---
> Как у словаря получить все ключи или значения? Как получить список их пар?

Методы `.keys()`/`.values()`, и общий метод `.items()`

> Все эти методы имеют префикс `iter`, и возвращают не итераторы класса `dict_*`, а списки

---
> Назовите 2 отличия `dict.pop()` от `dict.get()`

1. `.pop(<key>)` не только возвращает значение по ключу, но и удаляет его из словаря
2. `.pop(<key>[, a])` также имеет опциональный аргумент, но если он не указан при вызове и ключа нет, будет выброшено `KeyError` (у него нет значения по умолчанию)

---
> Как из словаря получить произвольную пару "ключ-значение"?

Метод `dict.popitem()`

В отличие от `.items()`, этот метод удобно использовать для деструктивного итерирования по словарю

---
> Как отличаются сигнатуры `list.pop()` и `dict.pop()`?

У списка этот метод не требует аргумента, если не указан - возвращает последний элемент. Ключи же словаря не упорядочены, так что нужно обязательно указывать, какой возвратить:

```python
dict.pop('a')
```

---
> Что делает метод `dict.update()`?

Объединяет объекты по равенству ключей. `D1.update(D2)` перезапишет все значения в `D1` значениями из `D2` при равенстве ключей. Некий аналог `Object.assign()` в JS

---
> Какие типы аргумента может принимать метод `dict.update()`?

Те же, что и конструктор `dict`:

- другой словарь или литерал словаря
- итерируемую последовательность пар
- именованные параметры (`<key>=<val>`), отдельно или в дополнение к позиционному аргументу

---
> Что делает метод `dict.setdefault()`?

У него 2 параметра: `<key>[, None]`:

- если ключа нет, то устанавливает его со значением из второго параметра (или `None`, если он не указан)
- возвращает значение по ключу

---
> Какая есть альтернатива методу `dict.setdefault()`?

Встроенный `dict.get()` (но в нем может не хватить функционала), и более быстрый и удобный класс `collections.defaultdict`

---
> В каком случае порядок ключей в словаре может нарушаться?

С v3.6 порядок ключей из литерала / порядок вставки в словарь сохраняется. Но это сохранение не гарантировано, если к словарю применялся мутирующий in-place метод (напр, `.pop[item]()`)

---
> Чего следует избегать при итерации по словарю?

Вставки/удаления (вообще изменения) ключей

---
> Могут ли `break`/`continue` принимать аргументы?

Нет, прерывают/продолжают только ближайший цикл

---
> Как можно перебрать строку посимвольно?

Строка - это просто последовательность, ее вполне допустимо использовать в цикле:

```python
for letter in 'ciao':
    pass
```

---
> Можно ли в цикле использовать расширенное присваивание с распаковкой?

Да, можно. Ровно один элемент может быть указан со звездочкой, ему будут присвоены все "лишние" элементы распаковываемого элемента:

```python
for a, *b, c in seq:
    pass
```

> Нет такой распаковки, ни в цикле ни вообще

---
> Как перебрать словарь в цикле `for`, получая сразу и ключ и значение?

Использовать метод словаря `.items()`. Он возвращает пары "ключ-значение", и в цикле они распаковываются:

```python
for key, value in d.items():
    pass
```

---
> Что может являться целевой переменной для `for`?

Всё, что поддерживает присваивание, даже, например, элемент списка:

```python
for test[1] in seq:
    pass
```

---
> Какая хорошая практика при итерации по изменяемому объекту?

Не изменять сам этот объект, будь то словарь, список или множество

---
> Можно ли присваивать целевым переменным цикла другие значения в его (цикла) теле?

Да, но перед следующей итерацией они всё равно будут автоматически переприсвоены

---
> В каких случаях целевой переменной цикла вообще не присваивается значение?

В случае пустой последовательности:

```python
for i in []:
    pass
```

---
> Какая область видимости у целевой переменной цикла?

Она доступна и вне цикла, конечно, если итерируемая последовательность не пуста:

```python
for i in [...]:
    pass
# i здесь имеет последнее назначенное в цикле значение
print(i)
```

---
> Напишите код, эквивалентный циклу `for`

Функция `iter()` получает сам итератор, а функция `next()` забирает следующее значение в итерируемой последовательности (или выбрасывает исключение `Stopiteration`, если элементы закончились):

```python
_temporary_iterator = iter(c)
while True:
    try:
        х = next(_temporary_iterator)
    except Stopiteration:
        break
    <instructions>
```

---
> Как сделать объект пользовательского класса итерируемым?

Объявить методы `.__iter__()` и `.__next__()`. Именно их будут искать встроенные функции `iter()`/`next()`, неявно вызываемые при попытке итерации в циклах

Альтернативный вариант - объявить метод `.__getitem__()`. Тогда, для итерации, над классом будет синтезироваться обертка, последовательно перебирающая значения

---
> Что возвращает функция `range()`?

Легковесный объект, поддерживающий итерацию *по целочисленным диапазонам* (в том числе и по отрицательным)

> Объект списка. Для получения итерируемого объекта нужно использовать функцию `xrange()`

---
> Какие аргументы принимает функция `range()`?

Аналогичны числам в обозначении среза:

- начальный индекс, включается в диапазон
- конечный индекс, не включается в диапазон
- шаг, не должен быть нулем

Как и в срезе, при отрицательном шаге второй индекс должен быть больше первого

---
> Как получить итератор по диапазону или последовательности?

Вызвать builtin-функцию `iter()` на итерируемом объекте:

```python
iter(range(...)) # <range_iterator object at 0x7f...>
iter([...]) # <list_iterator object at 0x7f...>
```

> То же, только диапазон задается другим классом: `iter(xrange(...))`

---
> Как получить список - последовательность целых чисел?

```python
list(range(i, j))
```

---
> Где можно использовать list comprehension (генератор списка)?

Поскольку это не инструкция, его можно использовать везде, где допустимы выражения. Например, в качестве аргумента функции (`f([x for x in ...])`) или как значение в `return`

---
> В чем особенность распаковки значений в списковых включениях?

Кортеж, в который идет распаковка, всегда нужно заключать в скобки, иначе ошибка:

```python
[(key, value) for x in {}.items()]
```

---
> Какой формат может иметь filter-часть в списковом включении?

Может быть стандартным условием или аналогом вложенного цикла:

```python
if <cnd>
for <e> in <seq>
```

Второй вариант можно развернуть как вложенный цикл, в котором вполне можно использовать переменную верхнего уровня:

```python
[х for sublist in <seq> for х in sublist]
# equals to
res = []
for sublist in <seq>:
    for х in sublist:
        res.append(x)
```

---
> Какая область видимости у целевой переменной в генераторе списка (list comprehension)?

Локальная. В отличие от цикла `for`, переменная `x` из `[x for x in ...]` недоступна извне, после генерации

> А здесь доступна, поведение аналогично `for`, поэтому стоит помнить и не перекрывать внешние переменные

---
> Какой синтаксис у генераторов множеств (set comprehension)?

Такой же как и у списков, но вместо квадратных скобок используются фигурные:

```python
{n//2 for n in range(10)} == {0, 1, 2, 3, 4}
```

Порядок элементов здесь не сохраняется, а дубликаты игнорируются

---
> Какой синтаксис у генераторов словарей (dict comprehension)?

Похож на генераторы множеств и списков, обрамляющие скобки - фигурные, а значение в map-части записывается через двоеточие:

```python
{n:n//2 for n in range(5)} == {0: 0, 1: 0, 2: 1, 3: 1, 4: 2}
```

---
> Можно ли использовать `break`/`continue` вне цикла?

Нет, будет выброшена `SyntaxError`

---
> Как меняется поведение `break`/`continue`, если они вызваны внутри `if`?

Не меняется, эти инструкции не реагируют на дополнительную вложенность и всё так же прерывают/продолжают ближайший цикл

---
> Какой частый кейс использования `continue`?

Уменьшение вложенности `if`-ов внутри цикла. Это может быть одной из реализаций принципа из дзен Python-а "плоское лучше чем вложенное"

---
> При каких условиях выполняется `else` после циклов?

Если цикл завершился "естественным" образом: исчерпался итератор в `for` или условие в `while` стало ложным

В случае выхода из цикла по `break` код в `else` не выполнится

---
> Для каких циклов доступен блок `else`?

Для обоих, и для `for` и для `while`

---
> Выполнится ли блок `else:` после цикла `for` с пустой последовательностью?

Да, т.к. выход был по исчерпанию (пустого) итератора, не по `break`:

```python
for x in []:
    pass
else:
    print('Это будет напечатано')
```

---
> Какое есть альтернативное применение инструкции `pass`?

В качестве заглушки в сложной системе условий `if`. В случае, если в некоторых внутренних `if` не нужны никакие действия, но сами эти условия из цепочки убрать трудно, можно записать в них `pass`: Python не допускает пустого тела для составных инструкций

---
> Какие есть альтернативы использованию `pass` в пустых объявлениях функций (`def`) и классов (`class`)?

Строки документации (docstring). Если такая строка есть, добавлять `pass` уже не нужно (хотя ошибкой и не будет)

Некоторые рекомендуют именно docstring-и в качестве заглушек

---
> Назовите 5 ключевых слов языка, относящихся к обработке исключений

```python
try
except
finally
else
raise
```

---
> Какую инструкцию можно использовать вместо `try`/`finally`?

Менеджер контекста `with`

---
> Что вернет функция без инструкции `return`?

`None`. Это не Groovy, результат последнего выражения Python не возвращает

---
> Можно ли передавать функцию как аргумент в другую функцию?

Да, можно. Функции в Python являются объектами первого класса

---
> Можно ли использовать функцию в качестве ключа в словаре?

Да, можно. У ее класса определен метод `.__hash__()`

---
> Что такое *именованные параметры*?

Фактически это аргументы по умолчанию: они обязаны иметь дефолтное значение, иметь синтаксис `<name>=<value>`. Также они обязаны идти после позиционных (обязательных) параметров

---
> В какой момент определяется значение именованного параметра?

Единожды, в момент объявления функции (в момент выполнения инструкции `def`). Это может приводить к неожиданному поведению для изменяемых объектов, например, для списков

---
> Как правильно использовать изменяемые объекты в качестве значений именованных параметров?

Не задавать их в сигнатуре функции, а присваивать каждый раз в теле:

```python
def f(x, y=None):
    if y is None: y = []
    ...
```

----
> В каких случаях всё же может понадобится использование изменяемых объектов в качестве значений именованных параметров?

Например, для *мемоизации* - кеширования результатов затратных операций:

```python
def cached_compute(x, cache={}):
    if х not in cache:
        cache[x] = costly_computat1on(x)
    return cache[x]
```

Хотя даже в этом случае лучше использовать декорирование с помощью функции `functools.lru_cache`

---
> Что означают параметры `*args` и `**kwargs` в сигнатуре функции?

Позволяют передавать любое количество дополнительных параметров:

- `*args` - позиционных; кортеж
- `**kwargs` - именованных; словарь

---
> В каком порядке в сигнатуре функции должны идти `*args` и `**kwargs`?

Сначала кортеж позиционных (`args`), потом словарь именованных (`kwargs`):

```python
def f(..., *args, **kwargs):
    pass
```

---
> Фиксированы ли имена для `*args` и `**kwargs`?

Нет, имена могут быть любыми. Так, например, вместо `**kwargs` часто используют `**kwds`

---
> Сохраняется ли порядок ключей в `**kwargs`?

Да, с v3.6, как и для любых словарей. Ключи идут в том порядке, в котором именованные параметры указаны при вызове

---
> Как задать параметры, которые могут быть указаны *только как именованные*?

Указать их в объявлении функции после `*[args]` (но до `**kwargs`). Такие параметры не обязаны иметь значение по умолчанию:

```python
def f(a, *, b, с=56):
def g(x, *а, b=23, **k):
```

Последовательность `*args`, либо хотя бы звездочка от нее, присутствовать обязана

---
> Какие у функции есть "магические" (dunder) атрибуты?

- `__name__` - собственно имя функции, указанное при объявлении (после `def`)
- `__defaults__` - кортеж значений по умолчанию для необязательных параметров (`None` если нет необязательных параметров)
- `__doc__` - строка документации (`None` если не указана)
- `__code__` - объект-код функции

---
> Как расшифровывается *docstring*?

*Documentation string*

---
> Для чего могут использоваться docstrings?

- в качестве комментариев для разбирающих код
- для показа при вызове `help()` и генерации документации вообще
- для хранения тестов в формате doctest

---
> Каков рекомендуемый формат docstring?

- первая строка содержит краткое описание функции, начинается с большой буквы и заканчивается точкой. Само имя функции в ней не упоминается
- потом пустая строка-разделитель
- дальше более подробное описание в виде текста, разделенного пустыми строками на несколько абзацев
- оно содержит описание параметров функции, предусловий, возвращаемого значения, побочных эффектов
- в конце могут размещаться примеры использования в формате doctest, и любая другая вспомогательная информация

---
> Можно ли задать пользовательской функции произвольный атрибут?

Да, можно привязать его прямо к имени. Например:

```python
def counter():
    counter.count += 1
    return counter.count

counter.count = 0
```

Вообще, такой подход не рекомендуется, лучше использовать ООП

---
> Что такое *аннотации* в сигнатуре функции (в общем случае)?

Произвольные выражения, которые можно указать после каждого параметра после двоеточия (`a: 'some'`) и для возвращаемого значения - после закрывающей круглой скобки со стрелкой (`) -> 'some'`). При таком объявлении аннотации окажутся в атрибуте-словаре `__annotations__` функции:

```python
def f(a:'foo', b)->'bar':
    pass

f.__annotations__ == {'a': 'foo', 'return': 'bar'}
```

Сам по себе Python никак не использует эти аннотации, а лишь создает атрибут

---
> Зачем нужны аннотации типов?

Сам Python не проверяет типы, и рассматривает аннотации просто как произвольные выражения. Но IDE, статические анализаторы и линтеры могут их использовать, проверяя корректность кода


---
> Какой пакет отвечает за аннотацию типов?

Модуль стандартной библиотеки `typing`. Доступен с v3.5. Для встроенных типов его импортировать не нужно

---
> Как пишутся аннотации типов для переменных и полей класса?

Двоеточие с выражением после имени, но перед значением:

```python
price: int = 5
title: str
...
class Book:
    title: str
    author: str
```

---
> Как указать аннотацию опционального типа?

Импортировать `typing.Optional` и указать тип в квадратных скобках:

```python
from typing import Optional

amount: int
amount = None  # Error

price: Optional[int]
price = None # Ok
```

---
> Как указать в аннотации, что тип переменной - любой?

Импортировать `typing.Any` и указать его:

```python
from typing import Any

unknown_item: Any = 1
```

---
> Как в аннотации указать, что переменная может быть нескольких (разных) типов?

Импортировать `typing.Union` и перечислить типы в квадратных скобках:

```python
from typing import Union

x: Union[int, float]
```

---
> Как в аннотации указать тип коллекции?

Импортировать `typing.<type>` и указать тип элементов коллекции в квадратных скобках:

```python
price_with_title: Tuple[int, str] = (1, "hello")
book_authors: Dict[str, str] = {"Fahrenheit 451": "Bradbury"}
def generate_two() -> Iterable[int]:
```

---
> Как в аннотации указать, что функция не возвращает значение?

```python
def forever() -> NoReturn:
```

`NoReturn` нужно импортировать из `typing`

---
> Можно ли использовать `return` вне функций?

Нет, это синтаксическая ошибка:

`SyntaxError: 'return' outside function`

---
> Какое есть стилистическое соглашение о `return None`?

Использовать его только если в функции есть другие `return`, возвращающие значение. Таким образом достигается единообразие в инструкциях возврата

Кроме того, функцию не рекомендуется завершать пустой инструкцией `return`

---
> В какой позиции относительно `*args` должны идти аргументы со значениями по умолчанию?

Могут идти как до, так и после. Только в первом случае они просто позиционные с дефолтными значениями, и могут указываться как угодно, а во втором могут быть указаны исключительно как именованные:

```python
def f(a, b, c=23, d=42, *x):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 3 4 (5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()

# но

def f(a, b, *x, c=23, d=42):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 23 42 (3, 4, 5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()
```

---
> Можно ли указывать позиционный аргумент как именованный?

Да, вполне:

```python
def f(x):
    print(x)

f(1) # 1
f(x=1) # 1
```

---
> Как можно передать в функцию словарь именованных аргументов?

Через оператор распаковки:

```python
def f(a, b, **kwards):
    pass

f(**{'a': 1, 'b': 2, ...})
```

---
> Сколько пространств имен в Python?

Три:

- встроенное (автоматически импортируемый модуль `builtins`)
- глобальное (весь скрипт)
- локальное (внутри функций)

Пространства вложены одно в другое, имена текущего скрывают имена окружающего ("вышестоящего"). Иногда также выделяют четвертое пространство - окружающих фунций

---
> Как внутри функции интерпретатор различает локальные и глобальные переменные?

Просматривается *вся* функция:

- все переменные, для которых внутри функции есть обращение и на чтение и на запись, должны быть инициализированы до первого обращения на чтение (иначе выбрасывается исключение `UnboundLocalError: local variable '<var>' referenced before assignment`)
- если обращения только на чтение, то ищется глобальная переменная с таким именем
- если обращения только на запись, то переменная считается локальной

Для любого из этих случаев указание `global <var>` для этой переменной сделает ее глобальной. Для обращений только на чтение/запись это избыточная директива, а вот для смешанного случая она *может* отменить исключение (если одноименная переменная объявлена в глобальной области)

Обращений на чтение всегда больше и они безопасны. Таким образом, Python и не принуждает постоянно писать `global` (а делает неявный поиск если нужно), но и не дает случайно перезаписать глобальную переменную - для этого нужно явно выразить намерение инструкцией `global <var>`

---
> Что такое *LEGB*-правило?

То, как Python разрешает имена в областях видимости. Они (области) просматриваются в порядке:

- *L*ocal (function) - область видимости текущей функции или лямбды
- *E*nclosing (nonlocal) - (только для вложенных функций) область функций, "окружающих" текущую
- *G*lobal (module) - глобальная область видимости, модуля/скрипта
- *B*uilt-in - пространство имен автоматически импортируемого модуля `builtin`

---
> Как просмотреть все имена в глобальном пространстве имен?

`globals()` вернет словарь с именами и значениями, а `dir()` без аргументов - список только имен

---
> Что делает ключевое слово `global`?

Указывает интерпретатору, что внутри функции нужно использовать для записи переменную из глобальной области видимости, а не локальную - т.е. связывает указанное имя с глобальной областью. Использование этой директивы не рекомендуется

В этой директиве могут быть указаны несколько переменных (через запятую):

```python
global <var1>, <var2>, ...
```

---
> Что делает ключевое слово `nonlocal`?

Открывает на запись переменную из внешней функции, из той, внутри которой объявлена текущая функция. Функции перебираются в порядке вложенности. Глобальная область видимости при разрешении имен при этом не просматривается

> Такого ключевого слова нет. Его можно сымитировать, сделав внешнюю переменную изменяемым объектом, и записывая в один из ее элементов (напр., `count[O] += 1`)

---
> Как создать глобальную переменную внутри функции?

Указав ее имя в директиве `global` и присвоив значение:

```python
def f():
    global x
    x = 1

f()
print(x) # 1
```

Присваивание обязательно: `global <var>` не является "объявлением" переменной

---
> Что происходит, если в функции инициализирована переменная, одноименной глобальной?

Она *скрывает* глобальную, все обращения идут к локальной

---
> Что будет, если в `global` указать имя переменной, которой не существует в глобальной области видимости?

Ничего, ошибок не будет, как не будет и создана переменная. Для создания нужно после указания в `global` еще и инициализировать эту переменную. До инициализации переменной не существует, даже проверять ее нельзя

---
> Что такое нелокальные и глобальные переменные?

- *нелокальные* - (также *свободные*) переменные из внешней функции, внутри которой объявлена текущая функция
- *глобальные* - переменные, созданные вне функций, в скрипте

---
> Внутри вложенной функции, чем отличаются и чем схожи нелокальные и глобальные переменные?

Сходства:

- могут скрываться локальными переменными
- неявно доступны на чтение
- требуют явного разрешения на запись через директивы

Различия:

- директивы, разрешающие их запись, разные: `global` и `nonlocal`
- в отличие от `global`, создать нелокальную переменную (переменную внешней функции) через `nonlocal` + присваивание нельзя

---
> Что называется *замыканием*?

Вложенная функция, получающая значения из внешних локальных переменных:

```python
def make_closure(x):
    def g(n):
        return x + n

    return g

closure7 = make_closure(7)
closure11 = make_closure(11)

print(closure7(3), closure11(4)) # 10 15
```

Нелокальные переменные (свободные переменные внешней функции) могут быть как параметрами, так и просто переменными внутри функции. Внутренняя функция "захватывает" их в момент объявления. Немного напоминает каррирование

---
> В каком порядке ищется переменная при указании директивы `nonlocal`?

Изнутри наружу, перебирая вложенные функции, начиная с ближайшей. Если не найдена, то выбрасывается исключение `SyntaxError: no binding for nonlocal '<var>' found`. Глобальная область не просматривается, одноименные переменные в ней не учитываются

---
> В чем сходство ООП и замыканий?

Внешняя функция замыкания, как и объект, хранит некоторые данные, состояние. Таким образом, функция-фабрика позволяет создавать независимые варианты других функций-замыканий

```python
def make_counter():
    _count = 0
    def counter():
        nonlocal _count
        _count += 1
        return _count

    return counter

c1 = make_counter()
c2 = make_counter()

print(c1(), c1(), c1()) # 1 2 3
print(c2(), c2()) # 1 2
```

---
> Что возвращает функция `filter()`?

Генератор

> Список

---
> Что такое *генератор*?

Функция, содержащая одно или несколько ключевых слов `yield`. Такая функция при вызове не выполняется, а лишь возвращает специальный *объект генератора*, обертывающий саму функцию, ее переменные и текущую точку выполнения. По вызову метода `next` с этим возвращенным объектом функция выполняется от текущей точки до следующего `yield`

---
> Какие есть преимущества у генераторов?

- генераторы гибче списков, и могут использоваться везде, где и итерируемые объекты
- генераторы выполняют "ленивые" вычисления, что может вести к сокращению расхода памяти
- могут возвращать неограниченный итератор для использования в циклах, прерываемых по `break`

Генератор в любой момент можно преобразовать в список через `list(g(<args>))`

---
> Когда завершается выполнение генератора?

По достижению конца функции или вызову `return`. Выбрасывается исключение `StopIteration`, которому, в качестве аргумента, передается значение из `return`

> Инструкции `return` в генераторе не могут содержать выражения, допустимы только пустые

---
> Что возвращает пустой `yield`?

То же, что и пустой `return` - `None`

---
> Напишите генератор - аналог `range()` для чисел с плавающей точкой

```python
def frange (start, stop, stride=1.0):
    while start < stop:
        yield start
        start += stride

for i in frange(1.0, 10):
    print(i)
```

---
> Для чего используется инструкция `yield from`?

Синтаксический сахар для возврата очередного значения из итератора:

```python
for x in <iter>:
    yield x
# ~
yiled from <iter>
```

> Такой инструкции нет

---
> Что такое выражения-генераторы?

То же, что списковое включение (list comprehension), только без физического создания списка. Вместо внешних квадратных скобок используются круглые, которые даже не нужны, например, при передаче в функцию:

```python
sum([х*х for х in range (10)]) # список
sum(х*х for х in range (10)) # генератор
```

Они выполняются "лениво", и требуют меньшего объема памяти, хотя и могут выполняться медленнее

---
> Как передать значение генератору?

Вызовом функции `send():`

```python
<gen-obj>.send(<val>)
```

Это значение будет возвращено `yield` при следующем вызове:

```python
<val> = yield <...>
```

---
> Какая по дефолту глубина рекурсии в Python? Как ее можно изменить?

Глубина стека по умолчанию - 1000 (тысяча) вызовов, можно получить через `sys.getrecursionlimit()`. Можно поменять вызовом функции `sys.setrecursionlimit()`

При исчерпании стека выбрасывается исключение `RecursionError` (потомок `Exception` -> `RuntimeError`)

---
> Как Python работает с хвостовой рекурсией?

Оптимизации хвостовой рекурсии в языке нет

---
> Какой структурой данных можно представить в Python бинарное дерево? Каким типом алгоритма его обходить?

Например, кортежем, где нулевой элемент - значение узла, а первый и второй - такие же кортежи для левого/правого узлов:

```python
(23, (42, (5, None, None), (55, None, None)), (94, None, None))
```

Обойти такое дерево можно рекурсивным алгоритмом ([p.145])

---
> Что такое *класс* в Python?

Это пользовательский тип и одновременно экземпляр объекта. Его атрибуты могут иметь произвольные имена и быть переменными (свойства) или функциями (методы)

Класс можно передать в и возвратить из функции, можно сделать его атрибутом объекта или ключом словаря. Класс в Python является *вызываемым* объектом первого класса

---
> Обязательны ли скобки в объявлении класса после имени?

Нет, не обязательны, что с пустыми скобками что без, наследование будет от `object`

Для более лучшего стиля лучше не писать пустые скобки или `(object)`

> Без скобок класс будет считаться классом старого стиля. Поэтому, для указания на то что класс нового типа, можно всегда писать `class <C>(object)`

---
> Как проверить, что один класс наследуется от другого?

Встроенная функция `issubclass(derived, base) == True|False`

---
> Допускаются ли вложенные классы?

Да, вполне. Класс может иметь в качестве атрибута что угодно, в том числе и другой класс

---
> Допустимо ли объявлять статические атрибуты вне тела класса?

Да, вполне:

```python
class A:
    pass

A.x = 'some'
print(A.x) # some
```

Но такой стиль не рекомендуется: ухудшает читаемость. Лучше задавать атрибут в теле

---
> Какие основные атрибуты *класс* создает неявно?

- `__name__` - имя класса (то, что после `class` в объявлении)
- `__bases__` - кортеж базовых классов (по дефолту `(object)`)
- `__doc__` - строка документации (`None` если не задана)

---
> Какие основные атрибуты *экземпляр класса* создает неявно?

- `__class__` - ссылка на объект класса
- `__dict__` - словарь со всеми атрибутами экземпляра

Вызов `x.attr = 'some'` эквивалентен вызову `x.__dict__['attr'] = 'some'`, если конечно установка атрибута не перехватывается методом `.__setattr__()` самого класса, или методом `.__set__()` его атрибута

---
> Можно ли в статических атрибутах класса ссылаться на другие такие же атрибуты?

Да, это допустимо. Например, такой код вполне рабочий:

```python
class A:
    x = 23
    y = x + 23
```

Здесь, в отличие от функций, имена используются напрямую, без уточнений

---
> Доступно ли в методах класса обращение к его свойствам напрямую, без уточнения?

Нет, нужно писать `<C>.<prop>` или `self.<prop>`

---
> Фиксировано ли имя `self` для первого параметра методов класса?

Нет, это просто общеприянтое соглашение. Использоваться может любое имя

---
> Обязана ли docstring быть в тройных кавычках?

Нет, это просто стилистическое соглашение. Python вообще проигнорирует любую отдельностоящую строку в кавычках

---
> Что компилятор делает с членами класса, начинающимися с двух подчеркиваний `__`?

Переименовывает в `_<C>__<name>`:

```python
class A:
    __x = 1

A._A__x == 1
A.__x # ошибка
```

---
> Что компилятор делает с членами класса, начинающимися с одного подчеркивания `_`?

Ничего, они считаются "закрытыми" лишь по соглашению об именах

---
> Что такое *дескриптор*?

Это любой объект, класс которого определяет dunder-метод `.__get__()`. Если определен еще и `.__set__()`, то это *дескриптор данных* (или *перекрывающий дескриптор*)

Дескрипторы важны тогда, когда они являются атрибутами другого класса:

```python
DescriptorClass:
    def __init__(self, value):
        self.value = value
    def __set__(self, *_):
        pass
    def __get__(self, *_):
        return self.value

class C:
    x = DescriptorClass()
```

В этом случае они управляют доступом к атрибутам: вызываются при установке/получении значения атрибута. Например, при установке атрибута `C().x = 'some'` вызывается метод `.__set__()` объекта `C.x`

---
> Каким дескриптором является объект функции?

*Неперекрывающим*: он определяет метод `.__get__()`, но не определяет `.__set__()`

---
> Может ли метод `.__init__()` возвращать значение?

Нет, только `None`, иначе будет выброшено исключение `TypeError`

---
> Какой "магический" метод управляет установкой атрибута объекта?

`.__setattr__(self, name, value)` вызывается и при создании нового атрибута, и при (пере)записи значения существующего

Этот метод вызывается только для объектов класса, не для статических атрибутов

---
> Что такое *идиома функции-фабрики*?

Когда нужно выбирать, экземпляр какого класса создать, делать это следует через отдельную функцию. Через модификацию `.__init__()` это не получится: язык запрещает возвращать этому методу что-либо кроме `None`

Обычно реализуется через "магический" метод `.__new__()`

---
> Что делает метод `.__new__()`? Какая у него сигнатура?

`.__new__(С, *args, **kwds)`. Автоматически вызывается при создании экземпляра класса (через `C()`), до вызова `.__init__()`

Этот метод возвращает значение - созданный *неинициализированный* экземпляр. Если он действительно является экземпляром класса - первого аргумента (или любого из его подклассов), то вызывается `.__init__()`

---
> Напишите код - аналог создания экземпляра класса

```python
x = C.__new__(C, 23)
if isinstance(x, C): type(x).__init__(x, 23)
```

---
> Как можно перекрыть метод `.__new__()`?

Стандартным способом, указывать декоратор `@classmethod` не нужно: интерпретатор сам распознает имя метода

Вот для перекрытия вне тела класса уже нужно писать

```python
C.__new__ = classmethod(<method>)
```

Но перекрытия вне тела класса рекомендуется избегать

---
> Нужны ли функции `super()` аргументы?

Не обязательны

> Да, нужно передавать класс

---
> Можно ли в рантайме менять "магические" атрибуты `__class__`/`__bases__` экземпляра класса?

Да, можно, на `__class__` только есть ограничения (`__class__ assignment only supported for heap types or ModuleType subclasses`)

---
> Какие шаги выполняет интерпретатор при разрешении имени *статического атрибута класса* `C`?

1. Если имя `name` - ключ в словаре `C.__dict__`, то берем `v = C.__dict__['name']`
   - если `v` - дескриптор, то вызываем его метод `.__get__()`: `type(v).__get__(v, None, C)`
   - иначе возвращаем сам `v`
2. Иначе перебираем в цикле все родительские классы и выполняем п.1 для них
3. Если ничего не найдено, выбрасываем `AttributeError: type object 'C' has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение

---
> Какие шаги выполняет интерпретатор при разрешении имени *атрибута экземпляра класса* `x`?

1. Ищем в *классе* `C` и его предках одноименный перекрывающий (с методами `.__get__()`/`.__set__()`) дескриптор (т.е. идет поиск статического члена с таким именем). Если найден, вызываем его: `type(v).__get__(v, x, C)`
2. Если такой дескриптор не найден, но имя `name` - ключ в словаре `x.__dict__`, то берем `v = x.__dict__['name']`
3. Если не найдено и в словаре, то делегируем поиск классу, с теми же шагами 1-2 (дескриптор -> словарь)
4. Если ничего не найдено, но у класса есть метод `.__getattr__()`, то вызываем его
5. Иначе выбрасываем `AttributeError: 'C' object has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение
---
> Что такое *связанный метод*?

Объект-функция, атрибут класса, связанный с его (класса) экземпляром: `C().x`

Вызывать такой метод нужно без явного указания аргумента: экземпляр класса будет передан первым параметром автоматически

---
> Можно ли вызвать нестатический метод класса не на экземпляре, а на самом классе?

Можно, но передавать первый параметр (`self`) всё равно придется, вручную:

```python
C.x(C(), ...)
```

Так (явно) лучше не вызывать, но иногда можно, например, для передачи метода как параметра:

```python
list('...').sort(key=str.lower)
```

---
> Что такое *MRO*? Как осуществляется в Python?

*Method resolution order*, порядок разрешения имен при поиске метода/атрибута в классе, текущем и базовых

Классы-потомки всегда просматриваются раньше предков. В Python родительские классы просматриваются слева направо

---
> Как происходит устранение проблемы ромба в MRO?

Родительские классы просматриваются слева направо. Всегда берется крайнее справа вхождение любого класса (?)

Посмотреть последовательность классов можно через read-only атрибут `C.__mro__` (только у класса, не у экземпляра)

---
> Какие атрибуты разрешено перекрывать в дочерних классах?

Любые, как вызываемые атрибуты, так и атрибуты данных:

```python
class A:
    x = 1
    def y(self): pass

class B:
    x = 2
    def y(self): pass
```

---
> Обязательно ли перекрывать методы родительского класса?

Нет, они будут вызываться автоматически

Более того, перекрытие лишь для вызова родительского метода считается плохим стилем

---
> Как можно вызвать метод родительского класса без `super()`?

Явно указав имя родительского класса, вызвав на нем метод как статический, и явно же передав ему `self`:

```python
class A:
    def x(self):
        pass

class B(A):
    def x(self):
        A.x(self)
```

---
> Какие есть преимущества у функции `super()` по сравнению с явным указанием имени базового класса?

- автоматически решает проблему ромба, формирует "суперобъект", вызов метода на котором не приведет к дублированию вызова в родительских классах
- позволяет меньше писать, аргументы можно не указывать

> Нужно передавать имя *текущего* (не базового) класса и `self`: `super(C, self).method()`

---
> В каких случаях может понадобиться вызов метода родительского класса не через `super()`, а явным указанием имени?

Когда сигнатуры методов в суперклассе и подклассах не совпадают

Но такое несовпадение - это грубое нарушение принципов ООП, в частности полиморфизма

---
> Назовите 3 способа удалить атрибут в дочернем классе

- (для вызываемых атрибутов) перекрыть метод и в нем генерировать исключение
- хранить атрибуты не в `.__dict__`, а где-либо еще, и описать логику доступа в `.__getattr__()`
- перекрыть метод `.__getattribute__()`

---
> Назовите 3 группы "магических" методов класса `object`

- методы создания: `__new__`, `__init__`
- работа с атрибутами: `__delattr__`, `__setattr__`, `__getattribute__`
- представление в строковом/числовом виде: `__hash__`, `__repr__`, `__str__`

---
> Можно ли непосредственно создать экземпляр класса `object`?

Да, без проблем:

```python
x = object()
```

Его конструктор не принимает никаких аргументов

---
> Что такое *статический метод* класса?

Это обычная функция, просто сделанная атрибутом класса. На ее сигнатуру не накладывается никаких ограничений, в том числе не нужно передавать `self` первым параметром. Такую функцию можно вызывать не только на классе (`C.x()`), но и на экземпляре (`C().x()`); при этом ошибок о несовпадении числа аргументов не возникает

В принципе, ничто не мешает сделать такую функцию отдельной, но некоторые предпочитают связывать ее с классом

---
> Как задается *статический метод* класса?

Через конструктор встроенного типа `staticmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(): pass
    x = staticmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое (статический) *метод класса*?

Метод, получающий при вызове первым параметром сам класс. Этим он отличается от *статического метода* (простой функции в качестве атрибута), и гораздо удобнее его: перекрывать в подклассах значительно проще

Такой метод можно вызывать как на самом классе, так и на его экземпляре

---
> Как задается (статический) *метод класса*?

Через конструктор встроенного типа `classmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(cls): pass
    x = classmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое *свойство* класса?

Метод, к которому можно обращаться как к read-only атрибуту данных, без скобок. В нем доступен первый параметр `self`:

```python
class A:
    def x(self): return 1
    x = property(x, doc='Some docstring.')

A().x # 1
```

Или (предпочтительно) через декоратор

---
> Какая сигнатура конструктора у встроенного типа `property`?

Обычно указывают только один позиционный параметр, но есть и сеттер/делитер, и строка документации:

```python
property(fget=None, fset=None, fdel=None, doc=None)
```

Функция `fset` вызывается при попытке присваивания свойству, а `fdel` - при вызове на нем оператора `del`. Параметр `doc` устанавливает атрибут `__doc__`

В случае, если `fset`/`fdel` не указаны, свойство ведет себя как read-only атрибут

---
> Как через декоратор указать setter/deleter для свойства?

Указать `@<prop-name>.setter|deleter` у отдельных *одноименных* методов:

```python
class A:
    @property
    def x(self): return 1
    @x.setter
    def x(self, val): pass
    @x.deleter
    def x(self): pass

a = A()
a.x = 2
del a.x
```

---
> Какой есть более удобный аналог геттеров/сеттеров?

*Свойства* - декорированные через `property` методы класса

---
> Наследуется ли декоратор свойства (`@property`) класса?

Нет, его нужно повторять для дочерних классов. Вот здесь `B.x` будет методом, не свойством:

```python
class A:
    @property
    def x(self): return 1

class B(A):
    def x(self): return 2

B().x() # не B().x
```

---
> Что представляет собой и что делает атрибут `__slots__` у класса?

Это кортеж строк-идентификаторов, ограничивающий набор возможных атрибутов *экземпляра* класса. Позволяет немного экономить память, не создавая динамический словарь атрибутов `__dict__`. Определяться может только в теле класса

Использовать его нужно лишь тогда, когда количество экземпляров может быть очень велико (миллионы), иначе экономия может оказаться несущественной, а удобство/читабельность снижены

---
> В чем отличие `__getattr__` от `__getattribute__`?

`__getattribute__` вызывается *до* поиска атрибута в экземпляре (до начала разрешения имен), тогда как `__getattr__` вызывается лишь в случае, если атрибут не найдет (fallback)

Из-за такой логики их оба, в принципе, можно использовать для удаления атрибутов в дочерних классах. Только в случае `__getattr__` атрибуты нужно хранить где-то помимо `__dict__`

---
> Можно ли наследоваться от встроенных типов?

Да, это разрешено. Но совместимость не безусловная, может оказаться, что множественное наследование от двух разных типов невозможно

Так, например, нельзя одновременно наследовать класс от `dict` и `list`

---
> Как сделать экземпляр класса *вызываемым объектом*?

Определить у его класса метод `.__call__()`:

```python
class A():
    def __call__(self, text):
        print(text)

A()('It works') # It works
```

---
> Существуют ли в Python *деструкторы*?

Да, класс может определить метод `.__del__(self)`, который автоматически будет вызван сборщиком мусора

Определению этого метода стоит предпочитать использование `try`/`finally`, а еще лучше `with`

---
> Сколько всего специальных методов сравнения есть у класса?

Шесть:

```python
.__eq|ge|gt|le|lt|ne__()
```

---
> Каков наилучший подход в определении методов сравнения для класса?

Определить только два метода и применить к классу декоратор:

```python
import functools

@functools.total_ordering
class A():
    def __lt__(self, obj): pass
    def __eq__(self, obj): pass
```

---
> Какой негативный эффект может быть от использования метода `.__getattribute__()`?

Снижение производительности. Этот метод будет вызываться каждый раз при обращении к любому атрибуту, для разрешения имен

---
> Какие требования накладываются на специальный метод класса `.__hash__()`?

- он должен возвращать целое число
- такое, что из `x = y` следует эквивалентность двух объектов
- для любого заданного объекта это значение должно быть одним и тем же

---
> Что вернет вызов `hash(x)` на экземпляре, если у его класса не определен метод `.__hash__()`?

Зависит от того, определен ли также метод `.__eq__()`:

- если не определен, то возвращается `id(x)`
- иначе генерируется исключение

---
> В каких случаях объект пользовательского класса будет *хешируемым*?

В случаях, если вызов `hash(x)` на экземпляре не выбрасывает исключения. Класс удовлетворяет этому условию, если:

- он определяет специальный метод `.__hash__()`
- или не определяет ни его, ни метод `.__eq__()` - в этом случае в качестве хеша берется `id(x)`

---
> Где должна происходить инициализация неизменяемых пользовательских объектов?

В методе `.__new__()`, ведь после создания экземпляра изменить его уже нельзя

Во всех остальных случаях всегда следует инициализировать экземпляр в `.__init__()`

---
> Какой специальный метод класса используется для проверки экземпляра в логических выражениях?

Метод `.__bool__()`

> Он называется `.__nonzero__()`

---
> В чем различие методов `.__str__()` и `.__repr__()`?

- `.__repr__()` должен возвращать полное строковое представление, желательно такое, что `eval(repr(x)) == x`
- `.__str__()` должен возвращать компактное, неформальное представление

---
> Какой метод класса будет вызываться при вызове на экземпляре `str(x)` или `print(x)`?

`.__str__()`, а если его нет - `.__repr__()`

---
> В чем отличие вызова `.__getattr__()` от `.__setattr__()`?

`.__setattr__()` вызывается всегда, тогда как `.__getattr__()` - только если атрибут не найден (fallback)

---
> Как можно описать форматирование текстового представления экземпляров класса?

Определив специальный метод:

```python
__format__(self, format_string=''):
```

Если класс унаследован от `object`, то он делегирует вызов методу `.__str__()` и не принимает непустую строку формата

---
> Какие три типа коллекций есть в языке?

*Последовательность*, *отображение* и *множество*. Они взаимоисключающие

---
> Как желательно проектировать классы пользовательских коллекций?

Они должны быть *полиморфны встроенным* коллекциям: определять тот же интерфейс, те же специальные методы, выбрасывать исключения нужного типа, и т.д.

---
> Что такое встроенный класс `slice`? Какая сигнатура у его конструктора?

Экземпляры этого класса используются в качестве индекса-среза. Конструктор принимает три параметра:

```python
slice(start, stop, step=None)
```

---
> Какие требования налагаются на индексы пользовательских последовательностей?

При длине последовательности `L`:

- допустимый интервал индексов: `-L <= i < L`
- для отрицательных индексов (`0 > i >= -L`) должно выполняться `i ~ i + L`
- если индекс имеет недопустимый тип, выбрасывать `TypeError`
- если индекс выходит за допустимый интервал, выбрасывать `IndexError`
- принимать в качестве индекса экземпляр встроенного класса `slice`

---
> Какие специальные методы должен определять класс пользовательской последовательности, чтобы допускать конкатенацию и повторение через операторы?

Методы `.__[r|i]add__()` и `.__[r|i]mul__()`

Методы с префиксом `i` нужны для составных (in-place) операций

---
> Перечислите 11 неспециальных методов класса `list`

- `.append()`, `.insert()`, `.extend()`, `.remove()`, `.pop()` - 5 методов добавления/удаления
- `.count()`, `.index()` - 2 немутирующих метода поиска/подсчета
- `.sort()`, `.reverse()` - 2 мутирующих метода изменения порядка элементов
- `.clear()`, `.copy()` - 2 оставшихся метода, очистка и поверхностное копирование

---
> Какие неспециальные методы нужно определять вручную при создании класса пользовательской последовательности?

При наследовании от абстрактных классов `[Mutable]Sequence` - только `.sort()`

При создании с нуля - `.index()`/`.count()` обязательно, и 7 мутирующих методов (таких же как в `list`) если последовательность изменяемая

---
> В каких случаях коллекция будет хешируемой?

Тогда и только тогда, когда все ее элементы хешируемые

---
> Какую ошибку должен выбрасывать класс пользовательского отображения (словаря) при запросе несуществующего ключа?

В отличие от списка - `KeyError` (не `IndexError`)

---
> Перечислите 10 неспециальных методов класса `dict`

- `.keys()`, `.values()`, `.items()` - 3 способа получения последовательностей для итерирования
- `.get()`, `.setdefault()`, `.pop()`, `.popitem()` - 4 метода получения произвольного элемента
- `.clear()`, `.copy()`, `.update()` - 3 оставшихся метода, очистка, поверхностное копирование и обновление

> Методы первой группы имеют префикс `iter`

---
> Какому специальному методу эквивалентен `dict.keys()`?

Методу `.__iter__()`

Этот подход следует соблюдать и при проектировании классов пользовательских словарей

> Метод отличается на префикс: `dict.iterkeys()`

---
> Перечислите 7 неспециальных методов класса `set` (кроме операций теории множеств)

- `.add()`, `.remove()`, `.discard()` - 3 метода удаления/добавления
- `.pop()` - 1 метод получения произвольного элемента
- `.clear()`, `.copy()`, `.update()` - 3 оставшихся метода, очистка, поверхностное копирование и обновление

Одно из основных действий - проверка принадлежности множеству - делается оператором `[not] in`, а не методом

---
> Какой метод класса `dict` (и с какими аргументами) будет вызван при выполнении инструкции `del x[:3]`?

Будет вызыван

```python
x.__delitem__({'start': None, 'stop': 3, 'step': None})
```

---
> Напишите реализацию метода `.__getitem__()` пользовательской коллекции с поддержкой срезов

Распространенная рекурсивная идиома:

```python
class A:
    def __getitem__(self, index):
        if isinstance(index, slice):
            return self.__class__(
                self[х] for х in range(*index.indices(len(self)))
            )

        if not isinstance(index, numbers.Integral):
            raise TypeError

        if index < 0:
            index += len(self)

        if not (0 <= index < len(self)):
            raise IndexError

        # Теперь индекс является корректным целым числом
        # из диапазона от 0 до range(len(self))
```

---
> Какой специальный метод коллекций обеспечивает поддержку оператора `[not] in`?

Булева операция `y in x` вызывает метод `х.__contains__(у)`

---
> Как интерпретатор выполняет оператор `[not] in` для коллекций, не определяющих метод `.__contains__()`?

Перебором брутфорсом, сложность `O(n)`:

```python
for z in х:
    if y == z: return True

return False
```

---
> Назовите 3 специальных метода работы с элементами коллекций

- `.__getitem__(self, key)` - получение элемента по индексу или ключу (для всех кроме множеств)
- `.__setitem__(self, key, value)` - установка элемента/среза (только для изменяемых)
- `.__delitem__(self, key)` - удаление элемента/среза оператором `del` (только для изменяемых)

---
> Назовите 2 специальных метода для поддержки итерации в коллекциях

- `.__iter__(self)`
- `.__len__(self)`

---
> Какой тип коллекций не должен определять специальный метод `.__getitem__()`?

Множества и подобные: там нельзя получить элемент по ключу или индексу

---
> Какой тип коллекций не должен определять специальные методы `.__setitem__()` и `.__delitem__()`?

Неизменяемые: в них нельзя добавить/изменить/удалить элемент/срез

---
> В каких случаях вызывается специальный метод коллекций `.__len__()`?

- при вызове встроенной функции `len(x)` с экземпляром
- при использовании экземпляра коллекции в булевых выражениях, если не определен метод `.__bool__()`

---
> Что произойдет при вызове встроенной функции `iter(x)` на экземпляре коллекции, у которой не определен метод `.__iter__()`?

Интерпретатор синтезирует специальный объект-обертку над `x`, который последовательно возвращает `x[0], x[1], ...` до тех пор, пока обращение по индексу не выбросит `IndexError` (исчерпание контейнера)

Лучше всё же явно задавать `.__iter__()`, это хорошая практика

---
> Обязан ли объект - пользовательская коллекция, обязательно определять метод `.__len__()`?

Нет, хотя это очень рекомендуется. Разве что в случае очень дорогой операции определения количества элементов можно его не определять

---
> Как сделать класс абстрактным базовым?

Унаследовать его от `abc.ABC` или явно указать ему метакласс `abc.ABCMeta`:

```python
import abc

class A(abc.ABC):
class A(metaclass=abc.ABCMeta):
```

> Класса `abc.ABC` нет, так что только второй вариант

---
> Что делает метод `abc.ABCMeta.register()`?

Регистрирует переданный ему класс в качестве виртуального подкласса для вызываемого абстрактного класса:

```python
import abc

class A(abc.ABC): pass
class B: pass

A.register(B)
print(issubclass(B, A), B.__mro__)
```

Этот код выведет `True (<class '__main__.B'>, <class 'object'>)`. То есть функция `issubclass()` считает виртуальный подкласс наследником, но физически методы базового он не наследует, и базовый класс в разрешении имен не участвует

---
> Какая есть альтернатива вызову метода `.register()` на базовом абстрактном классе?

Переопределение статического метода `__subclasshook__`:

```python
import abc

class A(abc.ABC):
    def __subclasshook__(C):
        return C == B
class B: pass

print(issubclass(B, A), B.__mro__)
```

Этот код выведет `True (<class '__main__.B'>, <class 'object'>)` - в точности то же, что и вариант с `A.register(B)`

---
> Как объявить метод класса абстрактным? Что это даст?

Оба условия должны быть выполнены:

- класс должен иметь `abc.ABCMeta` в качестве метакласса (напр., наследоваться от `abc.ABC`)
- для метода должен быть указан декоратор `@abc.abstractmethod`

Такой класс нельзя инстантиировать. Код

```python
import abc

class A(abc.ABC):
    @abc.abstractmethod
    def x(self): pass

A()
```

выведет `TypeError: Can't instantiate abstract class A with abstract methods x`

> Есть еще декоратор `@abc.abstractproperty`, который в v3 устарел и эквивалентен там `@abc.abstractmethod`

---
> Может ли абстрактный метод иметь реализацию?

Да, вполне. И его можно вызывать из дочерних классов через `super()`

Наличие метода с декоратором `@abc.abstractmethod` лишь запрещает создавать экземпляры такого класса, и требует перекрыть такой метод в дочернем классе, но не запрещает иметь в этом методе код

---
> В каком модуле хранятся абстрактные базовые классы коллекций?

В `collections.abc`

До v3.4 доступ до этих классов возможен напрямую из `collections`, но это устаревшее поведение и вскоре будет убрано

---
> Назовите пять основных абстрактных базовых классов коллекций, определяющих лишь один специальный метод абстрактным

Все из модуля `collections.abc`:

- `Callable` - `.__call__()`
- `Container` - `.__contains__()`
- `Hashable` - `.__hash__()`
- `Iterable` - `.__iter__()`
- `Sized` - `.__len()__`

---
> Перечислите некоторые абстрактные базовые классы коллекций

Все находятся в модуле `collections.abc`. Это, например, `Iterator`, `[Mutable]Sequence|Set|Mapping`, `(Keys|Values|Items)View`

Все они расширяют разные комбинации пяти базовых абстрактных классов одного метода, расширяют друг друга, а также определяют разные комбинации специальных методов (`.__...__()`) в качестве абстрактных и примесных

---
> Какие абстрактные базовые классы определяются в модуле `numbers`?

В порядке наследования: `Number` -> `Complex` -> `Real`-> `Rational` -> `Integral`

`Number` - самый базовый класс, корень иерархии. Его потомки требуют определять всё больше и больше специальных методов для поддержки соответствующих операторов

---
> Как на уровне класса поддерживается перегрузка математических операторов?

При помощи пары десятков специальных методов (указаны только части между `.__...__()`):

- `invert`, `neg`, `pos`, `abs` - для унарных `~`/`-`/`+`/`abs()`
- `add`, `sub`, `mul`, `mod` - для бинарных `+`/`-`/`*`/`%`
- `truediv`, `floordiv` - для двух операторов деления
- `and`, `or`, `xor`, `(l|r)shift` - для битовых операторов
- `complex`, `int`, `float` - для применения конструкторов
- `pow`, `divmod` для встроенных функций
- а также версии с префиксами `r` и `i` для всех бинарных

Вообще, специальные методы работают также и со встроенными функциями, вроде `abs()`, или конструкторами числовых типов, вроде `int()`

---
> Зачем нужны специальные методы с префиксом `r`, вроде `.__radd__()`?

Такой метод будет вызван в случае, если в выражении `x + y` у `x` нет `.__add__()` (или он возвращает `NotImplemented`), но у `y` есть `.__radd__()`

Инверсия по сути

---
> Что такое *декоратор* по сути? Приведите примеры декораторов

Функция *высшего порядка* - она получает функцию как параметр и функцию же возвращает

Встроенные декораторы: `@propery`, `@classmethod`, `@staticmethod`

---
> Какие есть способы записи декораторов для методов класса?

Можно вызывать либо явно, либо через аннотацию:

```python
class A:
    def f(cls): pass
    f = classmethod(f)

    @classmethod
    def g(cls): pass
```

Второй способ предпочтительней

---
> Можно ли декорировать классы целиком?

Да, вполне. Аннотация декоратора `@...` в этом случае пишется над ключевым словом `class ...`

---
> Что может быть именем декоратора `@name`?

В общем случае это вычисляемое выражение, не обязательно имя функции

---
> Можно ли применять декораторы к инструкциям `def` вне тела класса?

Да, можно применять к любым функциям (и классам), в том числе и не-методам:

```python
@showdoc
def x(): pass
```

---
> Какие есть варианты вызова встроенной функции `type()`?

В зависимости от количества параметров она возвращает либо тип аргумента, либо создает класс:

```python
# возвращает тип
type(MyClass()) == MyClass
type('MyClass') == str
# создает класс
type(
    'MyClass',
    (<кортеж родительских классов>),
    {<словарь атрибутов нового класса>},
) == MyClass
```

Во втором варианте параметры задают поля `.__name__` и `.__base__` в новом классе

---
> Что такое *метакласс*?

Классы в Python сами являются объектами. Метаклассс - это класс объекта-класса:

```python
Class = MetaClass()
object = Class()
```

Дефолтным метаклассом является `type` - вызов его конструктора с тремя аргументами порождает классы

---
> Как можно задать метакласс?

Через последний (именованный) параметр в инструкции `class`, после перечисления базовых классов:

```python
class A(B, C, metaclass=M):
    pass
```

---
> Какая сигнатура у специального метода `.__prepare__()` метаклассов?

```python
class Meta:
    def __prepare__(name, *bases, **kwargs):
        return {}
```

Метод получает имя создаваемого класса, кортеж базовых классов, и произвольное число произвольных именованных параметров-атрибутов

Возвращает словарь, содержащий описание пространства имен, в котором выполняется тело класса

---
> Как вызывается специальный метод метакласса `.__prepare__()` при создании класса?

Встретив инструкцию вида

```python
class A(B, C, metaclass=MC, x='some'):
```

интерпретатор выполнит

```python
MC.__prepare__('A', B, C, x='some')
```

где

```python
class MC:
    def __prepare__(name, *bases, **kwargs):
        return {}
```

---
> Какие именованные параметры могут передаваться при объявлении класса после списка базовых классов?

- если метакласс = `type`, то никакие, будет `TypeError`
- если же метакласс кастомный, то произвольные

---
> Для чего могут использоваться исключения?

- для остановки программы при возникновении ошибки
- для индикации особой ситуации; например, встроенная `next()` выбрасывает `StopIteration` при исчерпании итератора

---
> Сколько может быть блоков `except` после `try`? Сколько `else`/`finally`?

`except` может быть несколько

Каждый из `else` и `finally` может быть только один

---
> Какой синтаксис у `except:`?

Можно указать тип и объект исключения. Для объекта нужно ключевое слово `as`:

```python
except:
except Exception:
except Exception as e:
```

---
> Можно ли в `except:` указать несколько классов исключений?

Да, можно указать кортеж классов, но он обязательно должен писаться в скобках (иначе `SyntaxError`):

```python
except (Exception, BaseException) as e:
```

---
> Как в блоке `except:` получить объект исключения?

- указав его после класса - `... as e`
- через `sys.exc_info()`

Для второго случая будет возвращен кортеж. Код

```python
import sys

try:
    1/0
except:
    print(sys.exc_info())
```

выведет

```shell
(
    <class 'ZeroDivisionError'>,
    ZeroDivisionError('division by zero'),
    <traceback object at 0x7f...>
)
```

---
> Как желательно располагать обработчики исключений (блоки `except:`)?

Обработчики специфичных исключений всегда должны предшествовать обработчикам более общих

Несоблюдение этого правила приведет к тому, что более специфичные исключения никогда не будут перехвачены

---
> Каких блоков `except:` следует избегать?

"Пустых" без `raise` - тех, у которых не указан тип исключения, и внутри которых исключение не выбрасывается вручную

"Пустые" `except:` могут приводить к неправильному поведению в случае лексически (в коде) или динамически (в стеке вызываемых функций) вложенных блоков `try:`. Например, такие общие обработчики маскируют специфические. Код

```python
try
    try:
        1/0
    except:
        print('common')
except ZeroDivisionError:
    print('specific')
```

выведет `common` вместо `specific`

---
> В каких случаях выполняется блок `else:` у `try`/`except`?

В случае успешного выполнения блока `try` - тогда, когда в нем не было выброшено исключение, и не было вызвано `break`/`continue`/`return`

---
> Что такое *обработчик очистки* для исключений?

Блок `finally:` после `try:`. Он выполняется всегда, независимо от того, было в `try:` исключение (или `break`/`continue`/`return`) или нет

В отличие от `except`, после `finally:` исключение продолжает распространяться

---
> Для чего обычно используется `finally`?

Это надежный способ закрытия файлов, закрытия соединений с базами данных, освобождения ресурсов - любых операций очистки

Но всё же предпочтительнее делать это через менеджеры контекста `with`

---
> Какие инструкции не должны использоваться в `finally:`?

`continue` там запрещено использовать на уровне языка

`break` и `return` в этом блоке разрешены, но их стоит избегать: большинство людей не будут ожидать, что распространение исключения может прерваться в `finally`

---
> Напишите через `try` код эквивалентный `with`

Код

```python
with <expr> as e:
    <instrs>
```

будет эквивалентен (`else` можно заменить на `finally`, но нужен флаг)

```python
e = <expt>.__enter__()
try:
    <instrs>
except:
    if not <expr>.__exit__(*sys.exc_info()):
        raise
else:
    <expr>.__exit__(None, None, None)
```

Объект, возвращаемый выражением `<expr>` и имеющий методы `.__enter__()` и `.__exit__()`, называется менеджером контекста

---
> Что называется *менеджером контекста*?

Объект, возвращаемый выражением `<expr>` в `with`

```python
with <expr> as e:
```

и имеющий методы `.__enter__()` и `.__exit__()`

---
> Какую идиому воплощает инструкция `with`?

*RAII* (Resource Acquisition Is Initialization) - "получение ресурса есть инициализация"

Методы `.__enter__()` и `.__exit__()` захватывают и освобождают ресурсы (некий аналог конструкторов/деструкторов и `try`/`finally`)

---
> Как в менеджере контекста можно подавить распространение исключения?

Возвратить `True` из `.__exit__()` (`raise` внутри `except:` не будет выполнено)

---
> Как создать менеджер контекста через декоратор?

Использовать модуль `contextlib`:

- указать `@contextlib.contextmanager` у генератора
- создать свой класс-потомок `contextlib.AbstractContextManager`

---
> Разрешена ли инструкция `yield` в блоках `try`/`catch`?

Да, разрешена, в отличие от `break`/`continue`/`return`

---
> Какие есть 2 метода генераторов для взаимодействия с исключениями и менеджерами контекста?

Если `g` - объект, возвращенный функцией-генератором:

- `g.throw(exc_val)` - эквивалентен вызову `raise exc_val` в точке последнего `yield`
- `g.close()` ~ `g.throw(GeneratorExit())`

---
> Как получить ссылку на файл стандартного потока ошибок `stderr`?

В модуле `sys` есть все потоки:

```python
import sys

sys.stderr
```

В `stderr` выводятся все неперехваченные исключения

---
> Где у Python находится стандартный системный обработчик неперехваченных исключений?

Это функция `sys.excepthook`, управляющая выводом сообщений об ошибке

Ее можно заменить на свою. Копия системной при этом сохранится в `sys.__excepthook__`

---
> В каких случаях сообщения об ошибке не выводятся при завершении программы?

Если было выброшено исключение класса `SystemExit`

В этом случае также происходит выход из интерактивного режима

---
> Где разрешено вызывать `raise` без аргументов?

Только в обработчике исключений (блоке `except:`), или функции, прямо или косвенно им вызываемой. В таком случае происходит выброс того же, существующего, исключения (re-throw)

В этих случаях смысл `raise` без аргументов - "я не могу обработать это исключение, возможно кто-то по стеку выше может"

---
> Что может быть аргументом `raise`?

Объект класса-потомка `BaseException`, конструктору которого можно передать сообщение об ошибке:

```python
raise ValueError('some text')
```

иначе будет выброшено `TypeError: exceptions must derive from BaseException`

---
> Можно ли передать `raise` класс исключения, не экземпляр?

Да, будет выброшено то же исключение, с пустым сообщением об ошибке:

```python
raise ValueError
```

---
> Как объекты исключений получают и хранят свои параметры?

Конструктор потомков `BaseException` получает произвольное количество позиционных аргументов, которые сохраняются в кортеж `.args`:

```python
try:
    raise ValueError(2,3,4,5)

except ValueError as e:
    print(e.args) # (2, 3, 4, 5)
```

---
> Какие 3 класса исключений не наследуются от `Exception`?

Напрямую от `BaseException` наследуются

```python
KeyboardInterrupt
GeneratorExit
SystemExit
```

---
> Какой стандартный способ возбуждения исключений класса `SystemExit`?

Через вызов

```python
sys.exit(N)
```

Целое число - параметр функции - становится параметром конструктора `SystemExit` и кодом завершения программы

---
> Какой стандартный способ возбуждения исключений класса `KeyboardInterrupt`?

Нажатие `Ctrl + C` на клавиатуре

---
> Обрисуйте общий вид иерархии классов исключений

```python
BaseException
  Exception
    ...
    OSError
    StopIteration
    SyntaxError
    ValueError
    Warning
  KeyboardInterrupt
  GeneratorExit
  SystemExit
```

---
> Перечислите несколько базовых (псевдо-абстрактных) классов, наследующихся от `Exception`?

- `ArithmeticError` - ошибки арифметических операций
- `OSError` (синоним `EnvironmentError`) - ошибки, обусловленные внешними причинами (ввод-вывод)
- `LookupError` - ошибки, генерируемые контейнером (коллекцией) при получении недопустимого ключа или индекса
- `Warning` - большой класс, много потомков; предупреждения

---
> Перечислите классы исключений - потомков `ArithmeticError`

- `OverflowError` (не может возникать; только для обратной совместимости)
- `FloatingPointError` (не используется)
- `ZeroDivisionError`

> Из-за наличия типа `long` исключения типа `OverflowError` могут возникать при переполнении `int`

---
> Перечислите несколько классов исключений - потомков `OSError`

Например, `FileNotFoundError`, `ConnectionError` (базовый класс для всех ошибок, связанных с соединениями), `InterruptedError` (прерывание по внешнему сигналу)

---
> Перечислите классы исключений - потомков `LookupError`

- `IndexError` - для последовательностей
- `KeyError` - для отображений (словарей)

---
> Какие типы исключений могут быть выброшены при обращении к элементу последовательности по индексу?

- `TypeError` - в качестве индекса передан объект, не являющийся целым числом
- `IndexError` - выход за границы диапазона

У них разные базовые классы. `TypeError` наследуется напрямую от `Exception`, тогда как `IndexError` - через промежуточный базовый класс `LookupError`

---
> Какой класс исключения используется для индикации того, что метод не имеет реализации в данном классе?

`NotImplementedError`. Является подклассом `RuntimeError` (а тот уже наследуется от `Exception`)

---
> Что означает исключение типа `SystemError`?

Внутреннюю ошибку интерпретатора Python, но не настолько серьезную, чтобы аварийно завершаться

Такие ошибки следует отправлять разработчикам

---
> Какого типа исключения выбрасываются при использовании несовместимых типов?

`TypeError`, здесь вам не JavaScript

---
> В каких четырех случаях выбрасывается исключение `ZeroDivisionError`?

Ноль в правой части операторов `/`, `//`, `%` и ноль вторым аргументом функции `divmod(x, y)` (= `(x//y, x%y)`)

---
> Какие есть 2 способа выбросить исключение с traceback-ом другого исключения?

Используя метод `Exception.with_traceback(tb)`:

```python
except SomeException:
    raise OtherException(...).with_traceback(sys.exc_info()[2])
```

В консоли появится текст `During handling of the above exception, another exception occurred:`

Используя конструкцию языка `raise from`:

```python
except SomeException as e:
    raise OtherException(...) from e
```

В консоли появится текст `The above exception was the direct cause of the following exception:`

---
> Как обрабатываются подклассы указанных в `except:` классов исключений?

Для перехвата достаточно, чтобы класс был базовым, не обязательно чтобы совпадал

Обработчик выбирается по порядку, не по специфичности. Следующий код выведет `1`:

```python
try: 1/0
except ArithmeticError: print(1)
except ZeroDivisionError: print(2)
```

---
> Какая хорошая практика объявления пользовательских исключений, похожих на стандартные?

Использовать множественное наследование - наследоваться и от базового класса своих исключений, и от того стандартного, поведение которого нужно повторить:

```python
class MyAttributeError(MyModuleBaseError, AttributeError):
    ...
```

---
> Какие есть две стратегии контроля ошибок?

- *LBYL* (Look Before You Leap) - проверки перед выполнением операции
- *EAFP* (Easier to Ask Forgiveness than Permission) - выполнение кода в блоках `try:`

LBYL громоздкая и не гарантирует покрытие всех кейсов, EAFP на основе механизма исключений (с частым использованием `else:`) предпочтительней

---
> Какие есть хорошие практики обработки ошибок в длительно выполняющихся программах?

- журналировать возникающие ошибки, и потом внимательно изучать логи
- (?) реализовать систему контрольных точек, с возможностью восстановления в некое рабочее состояния
- (?) организовать обработку транзакций

---
> Когда допустимо ослаблять требования к блокам `try`/`except`?

В программах, которые должны сохранять работоспособность даже в самых критических случаях

В таких программах можно делать достаточно "широкие" секции `try:` и указывать более общие классы в `except:`

---
> Где лучше реализовывать журналирование неперехваченных исключений?

Переопределив атрибут `sys.excepthook` своей функцией, и уже в ней перенаправляя сообщения об ошибках (вместо `stderr`), например, в файл. Программа завершится только после завершения функции `sys.excepthook()`

Для форматирования отладочной информации можно использовать, например, модуль `traceback`

---
> Какие системные средства можно использовать для журналирования исключений?

Модуль стандартной библиотеки `logging`

Базовый его функционал - набор функций

```python
logging.(debug|info|warning|error|critical)('foo is %r', foo)
```

пишущих (или не пишущих) в журнал форматированные строки в зависимости от текущего уровня

```python
logging.getLogger().setLevel(logging.ERROR)
```

---
> Какой дефолтный уровень для вывода сообщений у модуля `logging`?

```python
logging.WARNING
```

Т.е. по умолчанию функции (`logging.<>`) `warning()`, `error()` и `critical()` пишут информацию в журнал, а функции `debug()` и `info()` - нет

---
> Как задаются настройки модуля `logging`?

Через именованные параметры функции `logging.baseConfig()`

Функция обязана быть вызвана до первой записи в журнал (`debug()`, `info()` etc.), так что стандартная идиома - задавать конфиг логгера сразу после импорта модуля:

```python
import logging

logging.baseConfig(
    format='%(asctime)s %(levelname)8s %(message)s',
    filename='/tmp/logfile.txt',
    filemode='w'
)
```

В примере выше каждое сообщение в файле будет снабжено временной меткой в указанном формате

---
> Куда по умолчанию пишет ошибки модуль `logging`?

В `stderr`

Для перенаправления, например, в файл, нужно в начале программы вызвать

```python
logging.baseConfig(filename='/tmp/logfile.txt', filemode='w')
```

---
> Каков синтаксис инструкции `assert` в общем случае?

```python
assert <condition>[, <expression>]
```

Если условие верно, то ничего не делается. Если же нет, то выбрасывается исключение с выражением после запятой в качестве параметра:

```python
raise AssertionError(<expression>)
```

---
> В каких случаях `assert` не будет выполнен совсем?

Если установлена переменная окружения `PYTHONOPTIMIZE` или у интерпретатора указана одна или несколько опций `-O`

Компилятор в этом случае генерирует на месте `assert` нулевую инструкцию

---
> Какое возможно альтернативное использование инструкции `assert`?

Для документирования программ, вместо комментариев, проверяя любые неочевидные условия (*инварианты* программы)

В отличие от комментария, такая "документация" сама известит, если какое-либо условие не выполняется

---
> Какая область видимости у глобальных переменных в модуле?

Ограничена самим этим модулем, такие переменные не видны в других пакетах/модулях. Глобальные переменные являются атрибутами класса модуля

Таким образом, связь между модулями в Python всегда должна устанавливаться явно

---
> Что такое *модули расширения*?

Модули, написанные на других языках, не на самом Python

Для вызывающей стороны язык реализации модуля не имеет значения, импорт идет как обычно

---
> Что такое *модуль*?

Объект Python с произвольно именованными атрибутами, которые можно связывать и на которые можно ссылаться. Таким образом, модуль является объектом первого класса

Обычно код модуля, носящего имя `name`, хранится в файле `name.py`

---
> Что происходит при выполнении инструкции `import <module>`?

Интерпретатор ищет файл `<module>.py` в `sys.path`, импортирует его, и связывает *переменную* `<module>` с объектом модуля

До начала исполнения тела модуля его объект уже создан, и добавлен в `sys.modules`

---
> Какие есть специальные атрибуты у объекта модуля?

- `__dict__` - хранит все атрибуты (переменные, функции, классы) заданные на верхнем уровне
- `__name__` - имя модуля
- `__file__` - файл с кодом модуля

---
> В каком модуле хранятся встроенные функции?

В `builtins`

> Он называется `__builtin__`

---
> Как подменить встроенную функцию?

Нужно явно импортировать модуль `builtins`, и явно же переназначить нужный его атрибут:

```python
import builtins

_abs = builtins.abs
def my_abs():
    ...
    return _abs()

builtins.abs = my_abs
```

После такой подмены новая функция станет использоваться всеми другими модулями

> Имя модуля другое, и нужно писать `import __builtin__ as builtins`

---
> Как задается и куда сохраняется docstring модуля?

Первая непустая строка, содержащая строковый литерал, считается строкой документации, и пишется в атрибут `__doc__` объекта модуля

---
> Будут ли после импорта доступны атрибуты модуля, начинающиеся с подчеркивания?

Да, будут:

```python
import <module>

<module>._x # ok
```

Подчеркивание в именах здесь - лишь соглашение, для лучшей читаемости кода

---
> Какие есть 2 формы импорта?

```python
import <module>[ as <alias>][, ...]
from <module> import <attribute>[ as <alias>][, ...]
```

Во второй форме вместо конкретного атрибута может стоять `*`

---
> Как раскрывается "звездочка" в инструкции `from <module> import *`?

- если модуль определяет "магический" атрибут `__all__`, то берутся имена из этого списка
- иначе импортируются все атрибуты, чьи имена не начинаются с подчеркивания

---
> Какие ограничения есть на переменные в `<attr> as <alias>` в инструкциях импорта?

Не могут быть выражениями, обязаны быть простыми идентификаторами

---
> Как динамически загрузить модуль, по строке с его именем?

С помощью функции

```python
import importlib

importlib.import_module('<module-name>')
```

Этот код неявно вызовет встроенную функцию `__import__()`. Ее можно вызвать и напрямую, но в современном коде так делать категорически не рекомендуется

---
> Как функция `__import__()` выполняет импорт модуля?

Эта встроенная функция получает строку `M` с именем модуля своим аргументом, и ищет в словаре `sys.modules` ключ `M`. Если не найден, то она создает пустой объект модуля с `.__name__ = M`, инициализирует его, и добавляет в словарь

Таким образом происходит кеширование модуля в `sys.modules[M]`, и при повторном его импорте не происходят ни создание объекта, ни выполнение кода (инициализация)

---
> В какую позицию списка `sys.path` вставляются значения из `PYTHONPATH`?

Под индексом `1`: после текущей директории, но перед всеми остальными:

```python
sys.path = ['', *PYTHONPATH.split(os.pathsep), '/usr/lib/python38.zip', ...]
```

---
> Для чего используются файлы с расширением `.pth`?

Файл может содержать список путей (по одному в строке) и операции импорта, которые выполняются перед программой. Если расположить такой файл в папке `PYTHONHOME`, то пути из него будут добавлены в `sys.path`

Пустые строки и строки, начинающиеся с `#`, в таких файлах игнорируются

---
> Кешируется ли при выполнении объект скрипта?

Да, он рассматривается как модуль с именем `__main__`, и так же кешируется в `sys.modules['__main__']`

---
> Можно ли импортировать скрипт из самого себя?

Да, технически это возможно, но делать так очень не рекомендуется

При таком импорте в `sys.modules` появятся два ключа - `<module-name>` и `__main__`, а тело скрипта будет выполнено дважды

---
> Как перезагрузить модуль?

Функцией из `importlib`:

```python
import importlib

importlib.reload('<module-name>')
```

> Встроенной функцией `reload('<module-name>')`

---
> Какие ссылки (идентификаторы) обновляет `importlib.reload('module-name')` при вызове?

Только переменные, чьи имена совпадают с `<module-name>` в инструкциях

```python
import <module-name>
```

Это еще один аргумент "за" использование `import <name>` вместо `from <name> import ...`

---
> Выполняет ли `importlib.reload()` рекурсивную перезагрузку модулей?

Нет, модули, импортируемые перезагружаемым модулем, не перезагружаются сами

Нужно писать `.reload()` явно для каждого модуля

---
> Разрешен ли циклический импорт модулей?

Чисто технически он возможен, но его следует избегать

Последовательность действий при циклическом импорте:

- выполняется тело модуля `A`, он добавляется в словарь `sys.modules` и словарь его атрибутов начинает заполняться
- в коде модуля `A` встречается инструкция `import B`
- выполняется тело модуля `B`, он добавляется в словарь `sys.modules` и словарь его атрибутов начинает заполняться
- в коде модуля `B` встречается инструкция `import A`
- из кеша - словаря `sys.modules` достается частично инициализированный объект модуля `A`. Его код не выполняется: модуль считается уже импортированным
- (проблемы возможны здесь) продолжается выполнение модуля `B` до конца
- продолжается выполнение модуля `A` до конца

Как видно, в модуле `B` будут доступны лишь те атрибуты `A`, которые связаны до инструкции `import B`. Попытка обращения к другим атрибутам вызовет ошибку

---
> Можно ли изменять вручную записи в `sys.modules`?

Да, технически это возможно, хотя прием редкий. Функция `__import__()` не проверяет тип объекта в словаре, и вернет установленный пользователем

В частности, можно заменить запись (напр., `sys.modules['__main__']`) на объект, чей класс реализует специальные методы типа `.__(g|s)etattr__()`, и управлять атрибутами псевдо-"модуля" динамически

---
> Для чего могут потребоваться пользовательские функции - импортеры модулей?

Например, для импорта из архивов, отличных от ZIP, для импорта из баз данных, для импорта по сети

---
> Как можно установить пользовательские функции - импортеры модулей?

- (не рекомендуется) через подмену функции `builtin.__import__()`
- (?) с использованием `sys.meta_path`
- (?) с использованием мощных возможностей `importlib`
- добавив свой класс в список `sys.path_hooks`

В последнем случае пишется свой класс (совмещающий импортер и загрузчик) с методами `.find|create|exec|load_module()`, и добавляется в хуки:

```python
sys.path_hooks.append(ImporterAndLoader)
sys.path.append(ImporterAndLoader.fake_path)
```

После этого в конструкторе этого класса проверять текущий путь на совпадение с `.fake_path`, и выполнять кастомные действия, если нужно

---
> Что такое *пакет*?

Модуль, объединяющий другие модули

Физически представляет из себя папку или ZIP-архив с файлом `__init__.py` (возможно пустым) в корне

---
> Что является телом пакета?

Содержимое файла `__init__.py`, возможно пустое

Этот файл выполняется при импорте пакета

---
> Какой тип переменных имеют `P`/`M`/`V` в импортах пакетов `import P.M[ as V]`?

- без алиаса `P` связывается с объектом пакета, `M` становится атрибутом `P` и имеет тип объекта модуля
- с алиасом `V` имеет тип модуля

---
> Как разделять общие (глобальные) переменные между модулями одного пакета?

Выносить такие переменные в файл `common.py`. Это позволит писать в модулях

```python
from . import common

common.<attr>
```

---
> Как внутри пакета импортировать модуль на том же уровне вложенности?

Использовать *относительный* импорт:

```python
from . import <module-name>
```

---
> Перечислите основные специальные атрибуты пакета

- `__file__` - путь к файлу `P/__init__.py` (телу пакета)
- `__package__` - строка, имя пакета
- `__all__` - глобальная переменная, определяемая в теле пакета, перечисляет то, что импортируется под `*`
- `__path__` - список путей, в которых ищутся модули и подпакеты `P`

---
> Можно ли расположить модули и подпакеты пакета в разрозненных каталогах?

Да, можно, но для этого нужно вручную модифицировать атрибут `.__path__`

---
> Что такое *пакеты пространств имен*?

*Непосредственные* подкаталоги директорий из `sys.path`, не содержащие файла `__init__.py`

Импортировать их можно стандартным импортом, и для них создаются объекты в `sys.modules[P]`, только без атрибута `.__file__`

---
> Что такое *абсолютный импорт*?

Стандартный импорт, запись вида

```python
import <package>
import <package>.<module>
from <package> import <module>
```

Поиск при таком синтаксисе производится в каталогах из `sys.path`

> Сначала идет поиск в текущем модуле/пакете. Чтобы этого избежать, нужно указывать
> 
> ```python
> from __future__ import absolute_import
> ```

---
> Что такое *относительный импорт*?

При таком импорте поиск не ведется в `sys.path`, а только в текущем пакете. Синтаксис только через `from`, и нужно указывать точку `.`:

```python
from . import M
```

Можно указать модуль/подпакет на текущем уровне, внутри которого осуществлять поиск:

```python
from .SP import M
```

---
> Как сделать относительный импорт из модуля на несколько уровней выше?

Точек в записи относительного импорта должно быть столько, сколько уровней вверх + 1. Например, импорт из директории на один уровень выше (из родительской):

```python
from .. import M
from ..SP import M
```

---
> Какой объект называется *встроенным*?

Обращение к которому возможно без явной инструкции `import`

Встроенными бывают типы, а также функции из модуля `builtins`

---
> Что называется *байтом* в Python?

Целое число в диапазоне от `0` до `255`

В байтовых последовательностях (`bytes` и `bytearray`) байты как правило записываются в шестнадцатеричном представлении:

```python
b'\xff ...'
```

---
> В чем отличие типов `bytes` и `bytearray`?

- `bytes` - неизменяемая последовательность, гибрид `list` и `str`
- `bytearray` - то же, только последовательность изменяемая

> `bytes` синоним `str`

---
> Какой литерал у типов `bytes` и `bytearray`?

- у `bytes` - строка с префиксом `b`
- у `bytearray` нет своего литерала, нужно вызывать конструктор  

```python
b'\x01\x02\x03'
bytearray(b'\x01...')
```

---
> Как преобразовать строку в последовательность байтов?

Вызвать на строке метод `.encode()` с опциональной строкой - именем кодека:

```python
'test'.encode() == b'test'
'test'.encode('utf8') == b'test'
```

Преобразование идет в (неизменяемую) последовательность `bytes`. Для преобразования в `bytearray` нужно еще обернуть всё в его конструктор

---
> Как преобразовать список целых чисел в байтовую строку `bytes`? В `bytearray`?

Конструкторы обоих типов принимают списки, так что напрямую:

```python
bytes([1,2]) == b'\x01\x02'
bytearray([1,2]) == bytearray(b'\x01\x02')
```

---
> Какие аргументы принимает конструктор `complex()`?

Их два:

```python
complex(real=0, imag=0)
```

---
> Как конструктор коллекции копирует переданную ему в качестве аргумента (другую) коллекцию?

Делает shallow copy в случае изменяемых последовательностей и возвращает ссылку на ту же коллекцию в случае неизменяемой:

```python
dict(x) ~ x.copy()
list(x) ~ x.copy() ~ x[:]
set(x) ~ x.copy()
str(x) == x
frozenset(x) == x.copy() == x
tuple(x) == x == x[:]
```

---
> Как работает копирование для неизменяемых коллекций?

Возвращается та же коллекция:

```python
x = tuple([1, 2])
x[:] == x == tuple(x)

x = frozenset([1, 2])
x.copy() == x == frozenset(x)
```

Это верно не только для shallow-клонов, но и для `copy.deepcopy`: в памяти не хранится два одинаковых неизменяемых объекта, видимо нет смысла в этом

---
> Что такое `memoryview`?

Встроенный тип данных:

- его конструктор получает аргумент, объект, который должен поддерживать интерфейс `buffer`. Это, например, `bytes` и `bytearray`
- возвращает объект - точное внутренне представление участка памяти, в котором хранится эта байтовая последовательность
- поддерживает атрибут `.itemsize` - размер элемента в байтах, как правило `1`
- на экземпляре `memoryview` можно вызвать `len(m)`

---
> В каком качестве можно использовать экземпляр `object` в сравнениях?

Как некий "страж", объект, отличающийся от любого другого:

```python
(C() != object()) == True
```

---
> Какие значения по умолчанию у аргументов конструктора `slice`?

Для всех трех `None`, не числа

---
> Где можно вызывать `super()`?

Только в коде методов класса. В этом случае, через интроспекцию, конструктор суперобъекта сам определит текущий класс и объект, и параметры можно не передавать

---
> Какой специальный атрибут экземпляра `x` возвращает вызов `type()`?

Атрибут `__class__`:

```python
type(x) == x.__class__
```

---
> Как проверять типы в Python?

Через `type(x) is <type>` лучше не проверять: не будут учитываться полиморфные типы. Лучше использовать одну из двух стратегий:

- "утиную" типизацию - в блоках `try:`/`except:` выполнять действия так, как будто переменная имеет нужный тип
- "гусиная" типизация - проверять типы через встроенную функцию `isinstance()`

---
> Что возвращает встроенная функция `abs()` для комплексного числа?

Так называемый *модуль комплексного числа* - длину гипотенузы на комплексной плоскости:

```python
import math

abs(x) == math.sqrt(x.imag**2 + x.real**2)
abs(2 + 2j) = sqrt(2**2 + 2**2) = sqrt(8) = 2.8284...
```

---
> Как идет процесс вычислений во встроенных функциях `all()`/`any()`?

По короткой цепи, от начала последовательности

Вычисления останавливаются как только:

- для `all()` - найден элемент `~ False`
- для `any()` - найден элемент `~ True`

---
> Как перевести число в строку в разных системах счисления?

Через конструктор `str` или группу встроенных функций:

```python
str(3) == '3'

bin(3) == '0b11'
oct(3) == '0o3'
hex(3) == '0x3'
```

---
> Как преобразовать строку в целое число в разных системах счисления?

Через конструктор типа `int(str, base)`:

```python
int('3') == 3

int('0b11', 2) == 3
int('0o3', 8) == 3
int('0x3', 16) == 3
```

---
> Как проверить, что объект вызываемый?

Лучше не полагаться на проверку специального атрибута `x.__call__()`, а использовать встроенную функцию `callable(x)` (возвращает булево значение)

---
> Как получить символ по его Unicode-коду?

Через встроенную функцию `chr()`. Она возвращает строку единичной длины:

```python
chr(112) == 'p'
chr(1092) == 'ф'
```

> Работает только для кодов `< 256`, для Юникода нужно использовать `unichr()`

---
> Какое промежуточное действие функции `eval()`/`exec()` выполняют неявно?

Компиляцию строки кода, делают неявный вызов встроенной функции `compile` с нужным третьим аргументом:

```python
compile('<code>', None, 'eval')
compile('<code>', None, 'exec')
```

---
> Как на объекте получить доступ к атрибуту, чье имя задано строкой/переменной?

Через группу встроенных функций:

```python
getattr(obj, 'x', None) ~ obj.x
setattr(obj, 'x', 1) ~ obj.x = 1
delattr(obj, 'x') ~ del obj.x
hasattr(obj, 'x') ~ 'x' in obj
```

Как видно из примера выше, `getattr()` поддерживает также значение по умолчанию, если атрибут не найден

---
> За что отвечает второй параметр встроенной функции `enumerate()`?

Он не усекает сам список, он задает стартовый индекс для нумерации пар:

```python
# len() == 2
list(enumerate([1, 2], 3)) == [(3, 1), (4, 2)]
```

По умолчанию равен нулю:

```python
enumerate(iterable, start=0)
```

---
> Какая сигнатура у функций `eval()`/`exec()`?

- первым аргументом идет или строка, или предварительно скомпилированный объект кода. В случае строки компиляция выполняется неявно, через встроенную `compile()`
- вторым и третьим аргументами идут словари пространств имен, по умолчанию это `globals()` и `locals()` соответственно

> `exec` работает аналогично, но является инструкцией, не функцией

---
> Каков порядок аргументов в функциях `filter()`/`map()`? Что они возвращают?

Сначала идет функция, потом итерируемый объект

Возвращают итератор

> Возвращают список

---
> Что возвращает встроенная функция `globals()`?

Атрибут `.__dict__` вызывающего модуля, словарь "имя-значение" текущего глобального пространства имен в точке вызова

В скрипте этот словарь будет содержать

```python
globals()['__name__'] == '__main__' == __name__
```

---
> Чему равна переменная `__name__` в интерактивном сеансе?

```python
'__main__'
```

---
> Чему равен словарь `locals()` вне функций?

И вне функций он равен текущему пространству имен, то есть совпадает с `globals()`

---
> Как будут сравниваться два экземпляра класса, у которого не определена операция сравнения `.__eq__()`?

По `id()`:

```python
x == y ~ id(x) == id(y)
```

А вот проверка идентичности

```python
x is y
```

эквивалентна сравнению по `id()` всегда

---
> Какая сигнатура у встроенной функции `input()`?

Один параметр - `prompt=''`. Функция всегда возвращает строку

> Эквивалентна `eval(raw_input(prompt))`

---
> Какой тип у второго аргумента `isinstance()`?

Он может быть классом или кортежем классов

В случае кортежа функция вернет `True` если первый аргумент - экземпляр *любого из* классов в кортеже

---
> В чем сходства и различия функций `isinstance()` и `issubclass()`?

Сходства:

- обе они - встроенные функции
- у обеих второй аргумент может быть кортежем, обе возвращают булево значение

Различия:

- но первая работает на уровне экземпляров, а вторая - классов
- соответственно различаются и сигнатуры в первом аргументе (экземпляр и класс)

---
> Напишите функцию-генератор, которая будет синтезирована при вызове `iter()`, если у класса последовательности нет метода `.__iter__()`

Именно для последовательности, не для других типов коллекций:

```python
def iter_seq(obj):
    i = 0

    while True:
        try:
            yield obj[i]

        except IndexError:
            raise StopIteration

        i += 1
```

Это обертка, которая просто обращается к индексам последовательно до тех пор, пока не выйдет за границу

---
> Как через литерал записать кортеж из одного элемента?

Обязательно указывать запятую, лучше со скобками:

```python
x = (1,)
x = 1,
```

Без запятой в обоих случаях в примере выше будет создан не кортеж, а объект-число

Это, в некотором роде, противоположность литерала пустого кортежа: там запятая не требуется и вызывает ошибку

---
> Какая сигнатура у встроенных функций `min()`/`max()`?

```python
min|max(s, *args, key=None[, default=...])
```

- могут получать либо один итерируемый аргумент, либо несколько, среди которых и будет искаться максимум
- два именованных аргумента: `key=` - геттер ключа/индекса, аналогичен одноименному в `sort`; и `default=` - допустимый только с итерируемой последовательностью, результат, возвращаемый когда она пуста

---
> Какова роль второго аргумента встроенной функции `next()`?

Это параметр `default`, который (если задан) будет возвращен по исчерпанию итератора

Обычно этот параметр не задается, и функция `next()` выбрасывает исключение `StopIteration`

---
> Какая функция обратна `chr()`?

Встроенная функция `ord()` возвращает целое число - код символа Unicode

---
> Какие параметры есть у встроенной функции `print()`?

Помимо произвольного количества позиционных, есть несколько именованных:

- разделитель `sep=` и конец строки `end=`: `sep.join(args) + end`
- поток `file=sys.stdout` и флаг сброса буфера `flush=False`

> Для того, чтобы `print()` стала функцией и имела аналогичную v3 сигнатуру, нужно указывать `from __future__ import print_function`

---
> Где расположено объявление функции `reduce()`?

В модуле `functools`

> Функция встроенная

---
> Какая сигнатура у `functools.reduce()`?

```python
def reduce(func, seq[, init]):
```

Применяет функцию к последовательности слева направо, обновляя на каждом шаге аккумулятор:

- первым аргументом идет функция, принимающая два аргумента - аккумулятор и очередной элемент: `func(acc, seq[N])`
- вторым аргументом - сама итерируемая последовательность
- третьим - параметр `init`. Если передан, им (а не первым элементом последовательности) будет инициализирован аккумулятор: `acc = init or seq[0]`

---
> Напишите код, эквивалентный функции `functools.reduce()`

Проход по последовательности, на каждом шаге функция - первый параметр - получает аккумулятор первым аргументом и текущий элемент вторым:

```python
def reduce(func, seq, init=None):
    seq = iter(seq)

    if init is None:
        init = next(seq)

    for item in seq:
        init = func(init, item)

    return init

seq = list(range(1, 10))

assert reduce(lambda accum, x: accum * x, seq) \
    == reduce(operator.mul, seq) \
    == 362880
```

Начальное значение аккумулятора равно третьему параметру `init`, а если он не передан - то первому элементу последовательности

---
> Как получить первый элемент списка (4 способа)?

```python
# через нулевой индекс с проверкой
a[0] if a else None
# через итератор без выброса StopIteration
next(iter(a), None)
# через логический оператор
(a or [None])[0]
# с изменением списка
a.pop(0)
```

---
> Что делает и какие параметры принимает функция `importlib.import_module()`?

Импортирует модуль его имени (по строке)

Первый параметр - собственно имя модуля, а второй опционален, и нужен только для относительных импортов - `package=None` - имя базового пакета

---
> В чем сходства и отличия `repr()` и `str()`?

Оба они возвращают текстовое представление объекта. Оба они вызывают одноименные специальные (`.__...__()`) методы на переданном им объекте

Но `repr()` - это встроенная функция, тогда как `str()` - конструктор типа

---
> Как получить итератор перебора в обратном порядке?

Вызвать встроенную функцию `reversed()` на последовательности

Эта функция дополняет встроенную `iter()`, которая возвращает итератор для прямого порядка перебора

---
> Как в Python округлить дробное число?

Встроенной функцией `round(n, digits=0)`. Параметр `digits` показывает, сколько цифр после запятой оставлять

- округление идет до ближайшего четного (т.н. "банковское округление"): `round(3.75, 1) == 3.8`, `round(3.65, 1) == 3.6`
- из-за особенностей представления дробных чисел в памяти это работает не всегда: `round(3.85, 1) == 3.9` (когда?)

Для простого усечения дробной части нужно использовать конструктор типа `int()`

> Округление идет до числа, дальше отстоящего от нуля: `0.5 -> 1`

---
> Для чего служит второй параметр встроенной функции `sum()`?

Это "начальное значение", просто число, которое будет приплюсовано к результату:

```python
sum(seq, start=0)
```

---
> В чем различия вызова `dir()` и `vars()` на объекте?

- разный тип возвращаемого значения: `dir(obj)` вернет список, тогда как `vars(obj)` словарь
- `vars(obj)` возвращает только связанные с экземпляром поля, и вообще падает, если атрибута `.__dict__` нет
- `dir(obj)` будет просматривать еще и атрибуты класса

---
> Какая сигнатура у встроенной функции `zip()`?

Она должна получать как минимум одну итерируемую последовательность:

```python
zip(seq, *seqs)
```

Возвращает она итератор - список кортежей:

```python
list(zip([1, 2])) == [(1,), (2,)]
```

---
> Что делает встроенная функция `zip()`?

Из полученных на вход последовательностей формирует список кортежей, по одному элементу из каждой последовательности:

```python
list(zip([1, 2])) == [(1,), (2,)]
list(zip([1, 2, 3, 4], [8, 9])) == [(1, 8), (2, 9)]
```

Как видно из примера выше:

- длина результирующего списка равна длине самой короткой последовательности
- количество элементов в каждом кортеже равно числу переданных аргументов (зипуемых последовательностей)

---
> Как получить список аргументов командной строки, переданных скрипту?

Из переменной в модуле `sys`, списка строк:

```python
sys.argv == ['']
```

В чем-то вроде `sys.argc` необходимости нет, количество аргументов равно длине списка

---
> Как узнать порядок байтов в системе?

```python
import sys

assert sys.byteorder in ['big', 'little']
```

На моей системе это `'little'`

---
> Для чего служит функция `sys.displayhook()`? Напишите эквивалентный ей код

Отображает результат операций в REPL-е:

```python
import builtins

def displayhook(value):
    if value is not None:
        builtins._ = value
        print(repr(value))
```

Значения `None` не приводят ни к каким действиям: ни к выводу в терминал, ни к изменению последнего результата `_`

---
> Как можно изменить функцию отображения результатов в REPL-е?

Присвоить свою функцию атрибуту `sys.displayhook`. Исходная системная функция останется доступной в `sys.__displayhook__`

---
> Почему не рекомендуется присваивать результат вызова `sys.exc_info()` долгоживущим переменным?

Третьим элементом кортежа, возвращаемого этой функцией, является traceback-объект, хранящий ссылки на все переменные стека вызовов. Его неявное связывание (через присвоение своей переменной) не даст сборщику удалить все эти, уже ненужные, объекты

Таким образом, все связывания объекта трассировки должны быть кратковременными. Стоит помнить об областях видимости переменных (у `except:`/`finally:` не своих) и, возможно, удалять свою привязку вручную

---
> Что будет, если в качестве параметра передать `sys.exit()` не целое число, а объект какого-нибудь другого типа?

Переданный аргумент будет выведен в поток `stderr`, а программа завершится с кодом `1` (типовой код "неудачного завершения")

---
> Как получить количество ссылок на объект?

В модуле `sys` есть функция:

```python
sys.getrefcount()
```

---
> Как безопасно получить размер объекта в байтах?

Через

```python
sys.getsizeof(obj, 0)
sys.getsizeof(obj, None)
```

Второй опциональный аргумент - `default` - предотвращает `TypeError` в случае, если объект не предоставляет способа определить размер

---
> Какое значение хранится в `sys.maxsize`?

Наибольшее возможное количество байтов в объекте в данной версии Python

---
> Как в коде узнать текущую платформу?

Краткую строку, вроде `'linux'` или `'win32'`, хранит переменная

```python
import sys

sys.platform
```

> Могут храниться не только короткие строки, нужно проверять через `sys.platform.startswith('linux')`

---
> Как можно динамически формировать строки приглашения в REPL?

Значения `sys.ps1|2` не обязаны быть строками, на них автоматически вызывается `str(sys.ps1 := x)`. Задав свой класс и поместив его экземпляр в нужную переменную в `sys`, можно, например, сделать строку приглашения с состоянием (хранящимся в объекте):

```python
import sys

class PS1:
    def __init__(self):
        self.p = 0

    def __str__(self):
        self.p += 1

        return '[' + str(self.p) + ']: '

sys.ps1 = PS1()
```

Подобный код можно поместить в скрипт, путь к которому указать в переменной окружения `PYTHONSTARTUP`

---
> Когда может понадобиться изменить максимальную глубину стека рекурсивных вызовов? Как это сделать?

- увеличить: для предотвращения падений программы. Слишком сильно увеличить может не получиться, платформа не поддержит
- уменьшить: для отладки, в проверочных целях, при тестировании рекурсивных алгоритмов

Изменения в любую сторону можно сделать через вызов

```python
sys.setrecursionlimit(N)
```

---
> Как можно перенаправить стандартный поток (например, из/в файл)?

Просто связав нужный атрибут модуля `sys` с файловым объектом, открытым на чтение/запись:

```python
import sys

with open('./log.txt', 'w') as fout:
    sys.stdout = fout
    print('Hello world')
```

Строка будет записана в файл `log.txt`, а в терминал ничего выведено не будет

---
> Как задать количество уровней трассировки при отображении неперхваченных исключений?

Задав параметр `sys.tracebacklimit`:

- по умолчанию он даже не существует как атрибут. Ограничений в этом случае нет
- значение больше нуля = количеству отображаемых уровней стека вызовов
- при значении меньшем или равном нулю трассировочная информация вообще не отображается, только тип и текст исключения

---
> Как в коде получить длинную и краткую версию Python?

Полная информация есть в модуле `sys`:

```python
sys.version == '3.8.2 (default, Apr 27 2020, 15:53:34) \n[GCC 9.3.0]'
```

Короткая - номер версии - это всегда 3 первых символа:

```python
sys.version[:3] == '3.8'
```

---
> Как создать shallow-копию коллекции? Какой метод предпочтительнее?

На примере списка. Некоторые из других коллекций тоже имеют метод `.copy()`:

```python
y = list(x)
y = x.copy()
y = x[:]
```

Мартелли и ко пишут, что лично они считают лучшей идиомой первый вариант - копирование через вызов конструктора типа, но единого мнения в сообществе на это счет нет

---
> Как создать shallow-копию для объекта, у которого нет своего метода `.copy()`?

Использовать одноименную функцию из модуля `copy`:

```python
import copy

class A:
    def __init__(self):
        self.lst = [[1], [2]]

x = A()
y = copy.copy(x)

x.lst[0][0] = 3
x.lst == y.lst
```

- класс при этом может определить свой метод `.__copy__()`, который будет автоматически вызван
- для неизменяемых объектов, из-за оптимизации, как правило будет возвращен сам объект

---
> Что делает второй параметр функции `copy.deepcopy()`?

Как правило, в параметр `memo` передается пустой словарь. В процессе глубокого копирования он заполняется элементами `<адрес>: <объект>` - сопоставляет идентификаторы уже скопированных объектов с новыми объектами, являющимися их копиями

(?) Что-то вроде кеша, мемоизации

---
> Какие специальные методы может объявить класс для поддержки глубокого копирования? Какие на них налагаются требования?

Основной метод - `.__deepcopy__(self, memo)`, который должен возвращать глубокую копию `self` (текущего экземпляра). Требование - копирование своих атрибутов выполнять только через `copy.deepcopy(subobj, memo)`

Если метода `.__deepcopy__()` нет, то идет также попытка вызвать специальные методы `.__getinitargs__()`, `.__getnewargs__()`, `.__getstate__()` и `.__setstate__()`

---
> Как организованы конкретные и абстрактные классы в модуле `collections`?

- конкретные классы - на верхнем уровне
- абстрактные - (с v3.4) в подмодуле `.abc`

Абстрактные также (для обратной совместимости) сохранены на верхнем уровне, но будут удалены в v3.9

---
> Для чего служит класс `collections.ChainMap`?

Представляет цепочку словарей (отображений), в которой:

- операции доступа на чтение просматривают в поисках ключа сначала первый словарь, а потом и все последующие, пока ключ не будет найден
- операции доступа на запись/удаление работают только с первым словарем

Конструктор класса получает произвольное число словарей:

```python
class ChainMap(collections.abc.MutableMapping):
    def __init__(self, *maps):
        self.maps = list(maps)

    def __setitem__(self, key, value):
        self.maps[0][key] = value 
```

> Этого класса нет, но есть отдельный пакет в PyPI

---
> Что делает класс `collections.Counter`?

Подсчитывает количество элементов в итерируемом объекте, и формирует словарь с парами `<элемент>: <кол-во его вхождений>`:

```python
import collections

dict(collections.Counter([1,2,1])) == {1: 2, 2: 1}
dict(collections.Counter('foo')) == {'f': 1, 'o': 2}
```

Все операции (получение/присваивание/удаление элемента) с объектом класса аналогичны стандартным с `dict`

---
> Какие 3 специфичных метода есть у `collections.Counter`, помимо стандартных методов `dict`?

```python
# возвращает итератор по ключам, значения которых > 0
# повторяет элементы: {'a': 2, 'b': 1} --> ['a', 'a', 'b']
.elements()
# возвращает список длиной n кортежей в порядке убывания частотности
# 'abracadabra'(3) --> [('a', 5), ('b', 2), ('r', 2)]
.most_common([n])
# аналогичен .update(), только идет вычитание вместо сложения
.subtract(iterable)
```

---
> В чем отличия классов `collections.OrderedDict` и `dict` в v3.7-8?

Порядок ключей сохраняется в обоих, но:

- сравнения в `OrderedDict` идут с учетом порядка, тогда как в обычном словаре без: `{2: 2, 1: 1} == {1: 1, 2: 2}`
- у `OrderedDict` есть метод `.move_to_end(<key>)`, перемещающий ключ в конец словаря
- до v3.8 встроенная функция `reversed()` не применима к стандартному словарю `dict`

---
> Опишите класс `collections.defaultdict`

Похож на стандартный словарь `dict`, но:

- первым аргументом конструктора принимает вызываемый объект, и только потом словари/списки
- этот объект-функция устанавливается в атрибут `.default_factory`, и вызывается каждый раз при обращении к несуществующему ключу
- при вызове `.default_factory()` идет не просто возврат значения, а запись его в запрашиваемый ключ (некий аналог `.setdefault()`)

---
> Напишите код, эквивалентный методам `.__init__()` и `.__getitem__()` класса `collections.defaultdict`

Практически (кроме разве `str()`/`repr()`) только эти методы и отличаются от стандартного `dict`:

```python
class defaultdict(dict):
    def __init__(self, default_factory, *а, **k):
        super().__init__(*а, **k)

        self.default_factory = default_factory

    def __getitem__(self, key):
        # проверка на существование ключа
        if key not in self and self.default_factory is not None:
            self[key] = self.default_factory()

        return super().__getitem__(key)

x = defaultdict(lambda: False)
x['some'] == False
```

---
> Какое есть типичное применение класса `collections.defaultdict`?

Трансформация списков пар в словарь: первый элемент становится (уникальным) ключом, а вторые элементы всех элементов формируют список. Для этого фабрикой дефолтных значений устанавливается конструктор стандартного `list`:

```python
import collections

def make_multi_dict(items):
    d = collections.defaultdict(list)
    
    for key, value in items:
        d[key].append(value)
        
    return d 
```

Для получения в ключах коллекций уникальных элементов, можно использовать конструктор `set` и метод `.add()` в цикле

---
> Какой тип данных представляет класс `collections.deque`? Какие у этого класса особенности?

ADT, является *двусторонней очередью*: вставка в любой из концов происходит быстро

В терминах Python это изменяемая последовательность неуникальных элементов: она допускает доступ к элементам по индексу через оператор `[]`, изменение элемента, удаление его через `del deq[N]`

В отличие от списков класс не поддерживает срезы, ни на чтение ни на запись

---
> Какая сигнатура у конструктора класса `collections.deque`?

```python
deque(seq=(), maxlen=None)
```

- первым параметром может быть любая итерируемая последовательность
- второй параметр ограничивает длину очереди: при добавлении новых элементов в конец предупреждения не выводятся, но элементы с другого конца удаляются

---
> Назовите 5 методов класса `collections.deque`

- `.append[left](item)`, `.extend[left](seq)` - добавление элементов в очередь
- `.pop[left]()` - "выталкивает" и возвращает крайний элемент. Метод возбуждает `IndexError` на пустой очереди
- `.clear()`, `.rotate(n=1)`. Второй метод делает циклический сдвиг очереди влево или вправо, в зависимости от знака `n`

---
> Какой тип имеет `collections.namedtuple` и для чего он используется?

Это функция-фабрика (`<function namedtuple at 0x7f...>`), не объект. Она возвращает класс-потомок стандартного `tuple`

Этот класс аналогичен `tuple` - может быть распакован (присвоен нескольким переменным), поддерживает итерацию и обращение к элементам по индексам и срезам. Но, кроме того, к его элементам можно обращаться как к атрибутам - по имени:

```python
import collections

Point = collections.namedtuple('Point', 'x,y,z')
p = Point(1, 2, 3)
print(p.x, p.y, p.z) # 1 2 3
```

---
> Какая сигнатура у функции `collections.namedtuple` и возвращаемого ей конструктора?

```python
namedtuple(typename, fieldnames)
```

Функция первым аргументом получает валидный идентификатор имени будущего класса, а вторым - список или строку (разделенную пробелами или запятыми) имен полей, атрибутов именованного кортежа:

```python
Point = collections.namedtuple('Point', 'x,y,z')
Point = collections.namedtuple('Point', ['x', 'y', 'z'])
```

Возвращенный конструктор может вызываться как с позиционными, так и с именованными аргументами:

```python
p = Point(1, 2, 3)       # (x=1, y=2, z=3)
p = Point(x=1, y=2, z=3) # (x=1, y=2, z=3)
```

---
> Какие у (результата) `collections.namedtuple` есть методы, не начинающиеся с подчеркивания?

Их два, и они стандартные, как для других коллекций:

- `.index(item)` ищет элемент в кортеже и возвращает его индекс (или выбрасывает `ValueError`, если не найден)
- `.count(item)` считает количество вхождений элемента (или возвращает `0`, если не найден)

---
> Какие у (результата) `collections.namedtuple` есть методы, начинающиеся с подчеркивания?

Они не считаются закрытыми, просто именуются так чтобы не пересекаться с именами элементов:

- `._asdict()` превращает кортеж в словарь - имена полей кортежа в ключи
- `._fields` возвращает кортеж строк - идентификаторов полей (того, что было передано в конструктор) - `('x', 'y', 'z')`
- `._make(seq)` создает именованный кортеж такого же типа, инициализируя его из переданной последовательности
- `._replace(**kwargs)` - возвращает копию именованного кортежа с частью ключей, замененными на переданные именованные параметры

---
> Чем является `functools.lru_cache`?

Функцией, *декоратором мемоизации*, подходит для функций, все аргументы которых хешируемые:

```python
lru_cache(max_size=128, typed=False)
```

- `max_size` - количество записей в кэше. Должно быть степенью двойки или `None`
- с включенным `typed` проверки аргументов станут различать типы, например, `23` и `23.0`, при формальном равенстве, будут считаться разными вызовами (ключами кэша)

> По дефолту нет, нужно устанавливать из PyPI

---
> Как получить *каррированную* функцию?

Через `functools.partial`. Это класс, конструктор которого получает функцию и произвольное число позиционных и/или именованных аргументов, и возвращает вызываемый объект:

```python
functools.partial(func, *a, **k)
```

У созданного объекта будет три атрибута:

- `.func` - обернутая функция
- `.args` - кортеж позиционных параметров
- `.keywords` - словарь именованных аргументов

---
> Напишите 3 способа заменить все отрицательные числа в списке `L` на ноль с использованием функции `max()`

Все способы - через сравнение с нулем в `max()`:

```python
# каррирование в map()
map(functools.partial(max, 0), L)
# лямбда в map()
map(lambda х: max(0, х), L)
# предпочтительный - через списковое включение
[max(0, х) for х in L]
```

Это пример нескольких аналогов каррирования

---
> Зачем нужна функция `functools.wraps`?

Эта функция в основном предназначена для декораторов, которые возвращают другие, отличные от исходных, функции:

```python
def mydeco(func):
    def wrapper(*args, **kwargs):
        return f'{func(args, **kwargs)}'

    return wrapper
```

Возвращенная таким декоратором функция будет иметь атрибуты `.__name__`, `.__doc__` и `.__module__`, отличные от одноименных атрибутов исходной функции `func`. В частности это приведет к тому, что для декорированной функции станет некорректно отображаться `help()`

Для решения этой проблемы можно задекорировать саму возвращаемую функцию, передав исходную `func` в качестве параметра декоратору, который и установит нужные атрибуты:

```python
from functools import wraps

def mydeco(func):
    @wraps(func)
    def wrapper(*args, *kwargs):
        ...
```

---
> Для чего используется модуль `heapq`?

Для поддержания списков в "почти отсортированном состоянии", используя алгоритм *min heap*. Это работает быстрее сортировки после каждой вставки/удаления, и гораздо быстрее бисекции

Модуль может использоваться, например, для реализации очередей с приоритетом. Ни в чем не уступает полностью отсортированному порядку, но работает быстрее и проще в обслуживании

С этим модулем может использоваться и идиома "декорирование-сортировка-отмена декорирования" (decorate-sort-undecorate - DSU), так называемое *преобразование Шварца*

---
> Что пишется в `sys.argv[0]`?

Имя самого запускаемого скрипта, параметры это только

```python
sys.argv[1:]
```

---
> Какой основной аргумент у конструктора `argparse.ArgumentParser()`?

Именованный `description=`

```python
parser = argparse.ArgumentParser(description='Program description goes here')
```

краткое описание программы

---
> Какой метод `argparse.ArgumentParser` собственно парсит аргументы командной строки?

Вызывается без параметров

```python
parser.parse_args()
```

и возвращает экземпляр класса `argparse.Namespace`, содержащий разобранные параметры в виде своих атрибутов

---
> Какая сигнатура у метода `argparse.ArgumentParser.add_argument()`?

Первые аргументы позиционные, они обязательны. Это имя параметра или опции, или несколько альтернативных имен. Остальные параметры именованные, их довольно много. Наиболее популярные это, например, строка подсказки, метаимя для опции или ее тип:

```python

parser.add_argument('file', metavar='<file-name>', type=str, help='name of a file to parse')
parser.add_argument('--tags', metavar='<tags1,tag2,...>', help='comma separated tags list')
parser.add_argument('--no-markdown', action='store_true', help='do not produce markdown')
```

---
> Как в `argparse` создать опцию, имеющую и короткое и длинное имя одновременно?

Указать в `.add_argument()` несколько позиционных параметров:

```python
parser.add_argument('-f', '--foo')
```

---
> У `argparse.ArgumentParser.add_argument()` есть параметр `action=`. Какие значения он принимает?

Этот параметр управляет поведением опций (`-f`/`--foo`):

- `store` по умолчанию, сохраняет значение опции в атрибут в `argparse.Namespace`
- `store_true|false` устанавливает атрибут в одно из булевых значений, в зависимости от того, была ли указана опция при вызове
- `append` добавляет каждое значение в список, позволяя таким образом указывать опцию несколько раз

---
> Как в `argparse.ArgumentParser.add_argument()` задать список допустимых значений и значение по умолчанию для параметра? В какую переменную будет записан параметр?

- `choices=` задает список допустимых
- `default=` дает значение по умолчанию; `None` если не указан
- `dest=` - назначение, имя атрибута в `argparse.Namespace`. По умолчанию - строка первого позиционного аргумента после удаления из нее начальных символов дефиса

---
> Какой порядок символов `>` и `=` в составных операторах сравнения?

Как в их словесных описаниях. "Равно" всегда идет последним:

- "меньше или равно" - `<=`
- "больше или равно" - `>=`

При неправильно порядке (`=>`, `=<`) выбрасывается `SyntaxError: invalid syntax`

---
> Какой псевдоним импорта можно использовать для модуля `itertools`?

`it`:

```python
import itertools as it
```

---
> Какая сигнатура у `itertools.chain()`? Напишите списковое включение, аналогичное этой функции

Принимает неограниченное количество итерируемых последовательностей в качестве позиционных параметров:

```python
chain(*iterables)
```

Формирует итератор единой последовательности, в котором аргументы перебираются один за другим:

```python
(item for iterable in iterables for item in iterable) 
```

То есть это простая конкатенация последовательностей, не приведение многомерных массивов к одномерным

---
> Что использовать в v3 вместо `i`-функций модуля `itertools`?

Генераторные выражения можно использовать вместо `it.imap()`, `it.ifilter()`, `it.ifilterfalse`

```python
(item for item in iterable if func(item)) 
```

---
> Напишите код, эквивалентный `itertools.compress()`

Функция получает две последовательности: собственно элементов, и условий. Элемент попадает в результирующий итератор только если соответствующее ему условие истинно:

```python
# compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F
(item for item, cond in zip(data, conditions) if cond) 
```

---
> Чем отличается `itertools.islice()` от обычных срезов?

- возвращает не список, а итератор
- не поддерживает отрицательные значения для начала, конца и шага

```python
islice(iterable, start, stop[, step])

islice('ABCDEFG', 2) # A B
islice('ABCDEFG', 2, 4) # C D
islice('ABCDEFG', 2, None) # C D E F G
islice('ABCDEFG', 0, None, 2) # A C E G
```

---
> Как бесконечно повторять один и то же объект?

Через итератор, они не ограничены в "размере":

```python
while True:
    yield item
```

Аналогичную функциональность предоставляет `itertools.repeat(item)` - вызванная как здесь, без второго аргумента

---
> Какая сигнатура у `itertools.repeat()`? Напишите эквивалентный ей код

Объект, который нужно повторять, и (необязательное) количество повторений:

```python
repeat(item[, times])

(item for _ in range(times))
```

Если второй аргумент опущен, то повторение будет идти бесконечно

---
> Какая сигнатура у `itertools.starmap()`? Напишите эквивалентный ей код

Похожа на стандартную `map()`, но еще и распаковывает каждый элемент при вызове:

```python
starmap(func, iterable)

for args in iterable:
    yield function(*args)
```

Используется для последовательностей уже упакованных ("pre-zipped") в кортежи элементов

---
> Как отличаются строковые типы в v2 и v3?

В v3:

- строки `str` - это последовательности символов Unicode
- последовательности байтов - это `bytes`/`bytesarray`, произвольные двоичные данные

В v2:

- строки `str` - это последовательности байтов
- строки Юникода представлены отдельным типом - `unicode`

Это одно из значительных различий версий

---
> Какие у `str` есть 3 метода для перевода всей строки в нижний/верхний регистр?

- `.upper()`/`.lower()` стандартные
- `.casefold()` переводит в нижний регистр (похожа на `.lower()`), но учитывает все эквивалентности Юникода для языка строки. Это метод для регистр-независимого сравнения строк

> `.casefold()` нет

---
> Какие методы строк `str` встречаются и в других коллекциях?

Два немутирующих метода `.index()` и `.count()`. Поведение аналогично другим последовательностям

---
> Для какого типа строк определен метод `.decode()`? Какая у него сигнатура?

Только для `bytes`. Возвращает, соответственно, `str`:

```python
bytes.decode(encoding='utf-8', errors='strict')

b'\x61\x62'.decode() == 'ab'
```

---
> Для какого типа строк определен метод `.encode()`? Какая у него сигнатура?

Только для `str`. Возвращает, соответственно, `bytes`:

```python
str.encode(encoding=None, errors='strict')

'ab'.decode() == b'ab'
```

---
> Что задает второй аргумент методов `bytes.decode()` и `str.encode()`?

Параметр `errors='strict'` определяет способ обработки ошибок кодирования/декодирования:

- `'strict'` - выбрасываются исключения `UnicodeError`
- `'ignore'` - ошибки игнорируются
- `'replace'` - некорректные символы заменяются вопросительными знаками

---
> В чем сходства и отличия методов `str.index()` и `str.find()`?

Оба они ищут вхождение подстроки и возвращают наименьший индекс. У них одинаковая сигнатура, позволяющая ограничивать область поиска срезом:

```python
str.find(sub, start=0, end=sys.maxsize)
str.index(sub, start=0, end=sys.maxsize)
```

Единственное отличие - `.index()` выбрасывает `ValueError` если подстрока не найдена, а `.find()` возвращает `-1`

---
> Какие есть 3 метода `str` для проверки того, что строка представляет собой число?

- `.isdigit()` возвращает `True` если все символы в строке - цифры
- `.isdecimal()` - все цифры могут быть использованы для образования числа в десятичной системе
- `.isnumeric()` похож на `.isdigit()`, но трактует символы шире. Например, символы дробей в Юникоде также считаются цифрами

Есть еще `.isalnum()`, он проверяет что все символы строки - буквы или цифры

---
> Как проверить, что вся строка записана в верхнем или нижнем регистре?

Два метода класса:

```python
str.isuppper()
str.islower()
```

---
> Как проверить что строка является валидным идентификатором?

Через метод

```python
str.isidentifier()
```

Ключевые слова также соответствуют этому определению, и поэтому, например,

```python
'class'.isidentifier() == True
```

---
> Как дополнить строку слева иди справа символом-заполнителем до нужной длины?

Возвращают строку длиной `max(len(s), n)`:

```python
s.ljust(n, fillchar=' ')
s.rjust(n, fillchar=' ')
```

Заполнитель по умолчанию - пробел

---
> Какая сигнатура у метода `str.replace()`?

```python
replace(old, new, count=-1)
```

Заменяет неперекрывающиеся вхождения `old` на `new` максимум `count` раз

---
> Как можно искать вхождения подстроки начиная с правого края?

Для обоих стандартных методов поиска в `str` есть их `r`-аналоги:

```python
str.rfind(sub, start=0, end=sys.maxsize)
str.rindex(sub, start=0, end=sys.maxsize)
```
---
> Какая сигнатура у метода `str.split()`?

```python
split(sep=None, maxsplit=-1)
```

---
> Что делают методы `str.swapcase()` и `str.title()`?

Меняют регистр букв:

```python
# всех на противоположный
'Test'.swapcase() == 'tEST'
# первую букву в каждом "слове" в верхний
'test some'.title() == 'Test Some'
```

Не стоит путать с `.lower()`/`.upper()` (смена регистра всей строки) и `.capitalize()` (первую букву в верхний, остальные в нижний)

---
> Как можно получить список всех ASCII-букв, цифр или знаков препинания?

В модуле `string` есть несколько атрибутов, возвращающих строки с наборами символов:

```python
import string

string.ascii_letters
string.digits
string.punctuation
string.whitespace
```

Так, например, список всех печатаемых символов `string.printable` будет выглядеть так:

```python
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
  '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
```

---
> Какая сигнатура у `str.format()`?

Метод получает произвольное число позиционных и/или именованных аргументов:

```python
format(*args, **kwargs)

'... {0} + {1}'.format(1, 3) == '... 1 + 3'
'... {k}'.format(k=2) == '... 2'
```

Плейсхолдеры замен пишутся в фигурных скобках (и без доллара)

---
> Допустимо ли в `... {} ....format()` оставлять фигурные скобки пустыми?

Да, позиционные аргументы будут сопоставлены по своим относительным позициям:

```python
'{} {}'.format(1, 2) == '1 2'
```

Но подстановки с явной и неявной нумерацией нельзя смешивать, это приведет к ошибке. Смешивать можно только с подстановками именованных аргументов:

```python
'{} {1}'.format(1, 2)   # ValueError
'{} {k}'.format(1, k=2) # ok, == '1 2'
```

---
> Как в плейсхолдерах `str.format()` ссылаться на атрибуты объектов и элементы коллекций?

Стандартным способом, через операторы `.` и `[]`:

```python
'{0[0]} {1[0]}'.format([1], [2]) == '1 2'
'{0.k} {1.m}'.format(obj1, obj2) == '1 2'
'{[0]} {[0]}'.format([1], [2]) == '1 2'
```

Как видно из примера, для неявных позиционных подстановок это тоже работает

---
> Какие есть преобразования в плейсхолдерах `str.format()`?

Их три, пишутся через восклицательный знак `!` и определяют, какой метод будет применен к подстановке:

```python
'{!s}' ~ .__str__()
'{!r}' ~ .__repr__()
'{!a}' ~ ascii()
```

> Преобразования `!a` и встроенной функции `ascii()` нет

---
> Какова общая структура поля замены для `str.format()`? Приведите пример

Состоит из трех необязательных частей:

```python
'{[селектор][!преобразование][:спецификация_формата]}'.fоrmаt(vаl)

'{0!s:.>6s}'.format('Test') == '..Test'
```

Любая из частей может быть опущена

---
> Какова общая структура спецификатора формата для `str.format()`? Приведите примеры

```
[заполнитель[выравнивание]][знак][#][ширина][,[.точность][тип]

.>10s
```

В группах подстановки:

```python
# выравнивание по правому краю, дефолтный заполнитель (пробел)
'{:>10}'.format('some') == '..Test' == '      some'
```

---
> Какие есть варианты выравнивания в спецификаторе формата для `str.format()`?

Можно запомнить по направлению острого конца:

- `<` - по левому краю
- `>` - по правому краю
- `^` - по центру
- `=` - только для цифровых символов, добавление заполнителя между знаком и первой цифрой числа

По умолчанию строки выравниваются по левому краю, а числа по правому

---
> Как через `str.format()` вывести число с разрядами, разделенными запятой?

Указать в спецификаторе формата запятую:

```python
'{:,}'.format(1231) == '1,231'
```
---
> Как через `str.format()` вывести дробное число с нужным количеством цифр после запятой?

Указать это количество между точкой и буквой `f|F`:

```python
'{:.2f}'.format(1.345) == '1.34'
```

Если указать `g|G` вместо `f`, то будет производится округление до целого с нужным порядком:

```python
'{:.2g}'.format(123.45) == '1.2e+02'
```

---
> Можно ли в вызов `'... {} ...'.format(obj)` передать объект своего класса?

Да, но он должен реализовывать специальный метод `.__format__()`:

```python
class A:
    def __format__(self, fmstr):
        fmstr == 'format_string'

        return '42'

'str is {:format_string}'.format(A()) == 'str is 42'
```

---
> Какой класс стандартной библиотеки можно использовать для форматирования строк в собственных классах?

Класс `string.Formatter`

---
> Что такое f-строки?

Новый (с v3.6) тип литерала строк, `f'...'`. Выражения форматирования, подстановки и спецификаторы формата в таких строках аналогичны тем, что используются с `str.format()`:

```python
f'{name!r} is {len(name)} characters long' == "'Dawn' is 4 characters long"
f'{3.14159:{width}.{precision})' == '   3.1416'
```

Во втором примере видно, что f-строки допускают подстановки внутри других групп подстановок


---
> Какой синтаксис у операции форматирования через `%`?

Строка формата + `%` + кортеж значений. Синтаксис строки формата аналогичен функции `printf()` языка С:

```python
'a1 %d b2' % (3,) == 'a1 3 b2'
```
Такое форматирование считается устаревшим, и вместо него должны использоваться f-строки (или `str.format()`)

---
> Где используется устаревший способ форматирования через `%`?

Только в модуле `logging`:

```python
import logging

# ERROR:root:result = 1
logging.error('result = %d', 1)
# ERROR:root:answers: 1 2.000000
logging.error('answers: %d %f', 1, 2.0)
# ERROR:root:hello world
logging.error('hello %r', 'world')
```

Здесь `%r` - специальный спецификатор, который нужно использовать для строк, содержащих ошибки (использует преобразование `repr()` вместо `%s`/`str()`)

---
> Какие 2 самые распространенные функции модуля `textwrap`?

Эти функции разбивают длинные строки на части, не превышающие указанной длины. Разбиение идет по словам - фактически, формируется текст указанной ширины:

```python
import textwrap

textwrap.wrap('test1 test2 test3', 12) == ['test1 test2', 'test3']
textwrap.fill('test1 test2 test3', 12) == 'test1 test2\ntest3'
```

Кроме того, можно создать экземпляр класса `textwrap.TextWrapper`, предоставляющий более широкие возможности

---
> Какие 2 самые распространенные функции модуля `pprint`?

Это функции красивого отображения (pretty print) объектов, одна возвращает строку, вторая ее печатает:

```python
import pprint

pprint.pformat({1: 2, 3: 4}) == '{1: 2, 3: 4}
pprint.pprint({1: 2, 3: 4}) # {1: 2, 3: 4}
```

Для простых объектов форматирование может быть идентично выводу встроенной `print()`, но, например, длинный списки эти функции печатают с новым элементом в каждой строке (а не единой строкой, как `print()`)

Кроме того, можно создать экземпляр класса `pprint.PrettyPrinter`, предоставляющий более широкие возможности

---
> Какая самая распространенная функция модуля `reprlib`?

Эта функция выдает строковое представление объекта, но накладывает разумные ограничения на длину возвращаемой строки. Для небольших объектов будет аналогична встроенной `repr()`:

```python
import reprlib

reprlib.repr({1: 2, 3: 4}) == '{1: 2, 3: 4}'
reprlib.repr(list(range(30))) == '[0, 1, 2, 3, 4, 5, ...]'
```

Кроме того, можно создать экземпляр класса `reprlib.Repr`, предоставляющий более широкие возможности

> Модуль называется `repr`

---
> Какие два пакета используются для интернационализации программ?

Это пакет стандартной библиотеки `encodings` и модуль `codecs`

---
> Как задать собственный обработчик ошибок (де)кодирования строк?

В модуле `codecs` есть для этого функция:

```python
import codecs

codecs.register_error('handler_name', func)
```

Устанавливаемая функция-обработчик получает один аргумент типа `UnicodeDecodeError`, и возвращает кортеж - строку для вставки и индекс для продолжения с

---
> Как можно узнать информацию о символе Юникода?

Использовать модуль `unicodedata`. Например, функцию `name()`:

```python
import unicodedata

unicodedata.name('a') == 'LATIN SMALL LETTER A'
unicodedata.name('Ф') == 'CYRILLIC CAPITAL LETTER EF'
```

---
> Как можно проверить, является ли символ Юникода "буквой"?

При помощи модуля `unicodedata` и оператора `in`:

```python
('LETTER' in unicodedata.name('a')) == True
```

Функция `name(char)` возвращает и другую информацию о символе (`'LATIN SMALL LETTER A'`), поэтому через `in` можно проверять и другие свойства

---
> Как создать объект - регулярное выражение?

Литерала для паттернов в Python нет, нужно создавать из строки:

```python
x = re.compile(r'(.+)')
```

Строка может быть любого типа, не обязательно "сырая" (хотя и рекомендуется)

---
> Как в регулярных выражениях задается нежадный режим?

В самом паттерне, указанием вопросительного знака `?` после `*`/`+`/`?`:

```python
re.findall(r'a+', 'aa') == ['aa']
re.findall(r'a+?', 'aa') == ['a', 'a']
```

---
> Как задать флаги регулярного выражения прямо в его шаблоне?

Добавив группу с одним или нескольким из `(?iLsmux)`:

```python
re.findall(r'(?i)a+', 'AA') == ['AA']
```

Группа может располагаться где угодно, но начиная с v3.6, если она не в начале, выводится предупреждение

`DeprecationWarning: Flags not at the start of the expression`

---
> Нужно ли экранировать дефисы внутри квадратных скобок в регулярных выражениях?

Это не обязательно, если, например, дефис стоит в конце, но рекомендуется для улучшения читаемости:

```python
r"[а-zA-Z'\-]+"
```

---
> Как можно динамически сформировать регулярное выражение с альтернативами `|` из списка?

С помощью подстановок в f-строках или с использованием `str.format()`:

```python
'|'.join(fr'text_{word}_around' for word in ['a', 'b']) == 'text_a_around|text_b_around'
'|'.join(r'text_{}_around'.format(word) for word in ['a', 'b']) == 'text_a_around|text_b_around'
```

В случае произвольных строк в списке может потребоваться их экранировать через

```python
re.escape(s)
```

---
> Как в регулярных выражениях ссылаться на группы (найденные соответствия в скобках)?

Обратный слеш + цифра:

```python
r'some \1 text'
```

---
> Как задать флаги регулярного выражения?

- вторым параметром `re.compile()`
- третьим параметром `re.findall()`
- указав прямо в паттерне через `(?...)`

```python
import re

re.compile(r'(?i)hello', re.I | re.IGNORECASE)
re.findall(r'(?i)hello', 'HELLO', re.I | re.IGNORECASE)
```

Явное указание как параметра с полным именем `re.IGNORECASE` предпочтительней: оно наиболее удобочитаемо

---
> В чем сходство и различие функций `re.match()` и `re.search()` между собой и с `re.findall()`?

- у всех одинаковые сигнатуры параметров - `(pattern, string, flags=0)`
- в отличие от `re.findall()` оба метода возвращают объект `re.Match`, не список
- `match()` ищет совпадения только в начале строки, `search()` везде

---
> Какой тип возвращаемого значения у `re.compile()`?

Экземпляр класса `re.Pattern`. Некоторые из его атрибутов:

- `.flags` - целое число (`32 == re.UNICODE` по умолчанию), битовая маска флагов. Способ задания флагов - через параметры или в паттерне - на значение поля не влияет
- `.groupindex` - словарь (только) именованных групп (`(?P<id>...)`)
- `.pattern` - строка, из которой был скомпилирован объект

> `.flags` по умолчанию `0`

---
> На каких объектах можно вызывать методы `match()`, `search()` и `findall()` модуля `re`?

Как на скомпилированном паттерне, так и через объект модуля:

```python
re.compile(r'aa', re.I).match('AA') ~ re.match(r'aa', 'AA', re.I)
```

Как видно из примера, количество параметров у этих методов в зависимости от способа вызова может различаться

---
> Какая есть более производительная альтернатива функции `re.findall()`?

Функция `re.finditer()` (с теми же параметрами) возвращает итератор, не список

---
> Какие дополнительные параметры принимают функции `re.Pattern.match()` и `re.Pattern.search()`?

Индексы, в пределах которых буде просматриваться строк:

```python
start=0
end=<inf>
```

Параметры только именованные, и доступны только на скомпилированном объекте, не на `re.search|match()`

---
> Как разбить строку на части по регулярному выражению?

Функция

```python
import re

re.split(regexp, string, maxsplit=0, flags=0) # и re.Pattern.split()
```
Третий параметр ограничивает количество разбиений

---
> Как сделать замену в строке по регулярному выражению?

Функция

```python
import re

re.sub[n](regexp, repl, string, count=0, flags=0) # и re.Pattern.sub()
```

Четвертый параметр ограничивает количество замен. Функция `subn()` возвращает не строку, а кортеж `('...', n)`, где `n` - количество сделанных замен

---
> Какой способ вызова функций модуля `re` предпочтительней?

Сначала компилировать шаблоны, и вызывать методы объекта `re.Pattern`

Вызов функций непосредственно на объекте модуля (напр., `re.search`) может рассматриваться только как разовая мера

---
> Что будет, если в строке регулярного выражения обнаружится ошибка?

Будет выброшено исключение класса `re.error` (потомок `Exception`)

---
> Дайте определения *файлу* и *файловой системе*

- *файл* - поток текста или байтов, который программа может читать и/или записывать
- *файловая система* - иерархическое хранилище файлов в компьютерной системе

---
> По каким критериям можно классифицировать файлы и потоки?

Они могут:

- произвольные байты или текст
- предназначаться только для чтения, или только для записи данных, или для того и другого одновременно
- использовать *буферизацию* или нет
- разрешать или не разрешать прямой (произвольный) доступ к содержащимся в них данным (напр., потоки, работающие через сокеты, допускают лишь последовательный доступ к данным с продвижением только вперед)

---
> Где располагаются средства ввода/вывода?

В модуле `io` стандартной библиотеки

Так, например, встроенная функция `open()` является просто псевдонимом `io.open()`

> Нужно явно импортировать `from io import open`

---
> Какой модуль предоставляет средства работы с файловой системой?

`os`. Самым известным модулем пакета является `path`

---
> Какой тип возвращаемого значения у функции `io.open()`?

Зависит от типа файла, а также параметров `mode` и `buffering`:

- `io.TextIOWrapper` для текстовых
- `io.Buffered(Reader|Writer|Random)` для бинарных

---
> Какого типа исключения выбрасываются при ошибках работы с файлами?

`IOError` ~ `OSError`

Примеры: неудачная попытка открытия файла, вызов неприменимого метода (напр., `.writе()` для readonly-файла или `.seek()` для файла, не допускающего выполнение опера­ции поиска)

> Эти классы не синонимы

---
> Как создать объект "файла" Python?

Вызвать функцию

```python
io.open()
```

Она вернет объект, с которым и можно работать

---
> Какого типа может быть первый параметр функции `io.open()`?

- строкой - путем к файлу. Файл открывается/создается
- целым числом - дескриптором файла, возвращаемым функцией `os.open()`/`f.fileno()`. Файл должен быть открыт
- функцией, переданной в качестве аргумента `opener=os.open` (?)

> Последнее не поддерживается

---
> Какие значения принимает аргумент `mode` функции `io.open()`?

- `r` - только чтение
- `w` - только запись, усечение до нулевой длины
- `a` - только запись, до-запись в конец

Добавление `+` к каждому режиму откроет файл еще и в парном режиме ("чтение + запись")

Для `w[+]`/`a[+]`, если файл не существует, он будет создан

---
> Как открыть файл в *двоичном* и *текстовом* режимах?

В параметре `mode` функции `io.open()` указать суффикс - `b` или `t` соответственно. Режим по умолчанию - текстовый, напр., `r` ~ `rt`

Двоичные файлы позволяют читать и/или записывать строки типа `bytes`; текстовые файлы позволяют читать и/или записывать текстовые строки Unicode (`str`)

> Строки Юникода имеют тип `unicode`

---
> За что отвечает параметр `buffering` функции `io.open()`?

За размер буфера. Значения:

- по умолчанию равен `-1` - а при отрицательных числах используется системное значение `io.DEFAULT_BUFFER_SIZE`
- если равен нулю, то запись без буферизации
- если равен `1`, то буферизация построчная - сброс идет каждый раз при записи в файл `\n`. Это режим интерактивных консолей (`f.iasatty()`)

---
> Какую внутреннюю структуру имеет файл?

Последовательную (поток байтов или текст). При выполнении операции чтения вы последовательно получаете байты или текст в том порядке, в каком они представлены. При выполнении операции записи записываемые байты или текст добавляются в том порядке, в каком вы их записываете.

---
> Как проверить, что файл поддерживает произвольный доступ?

Открыть (через `io.open()`) и вызвать на полученном объекте `f.seekable() = True|False`

---
> Какие два метода файловых объектов служат для произвольного доступа?

`.tell()` сообщает текущую позицию, а `.seek(pos)` ее изменяет

---
> Как узнать кодировку файла?

Открыть (через `io.open()`) и вызвать на полученном объекте readonly-свойство `.encoding`

Двоичные файлы не имеют этого атрибута

---
> Как узнать имя (путь) и режим, в котором файл был открыт?

Readonly-свойства `f.name` и `f.mode`

---
> Какие 3 функции читают содержимое файла?

- `read(size=-1)` - читает `size` байт или весь файл целиком
- `readline(size=-1)` - читает построчно (до `\n`)
- `readlines(size=-1)` - возвращает список всех строк

---
> Как усечь файл до некоторого размера?

Метод

```python
f.truncate(size=f.tell())
```

---
> Какие 2 функции записывают содержимое в файл?

- `write(string)` - пишет текстовую или битовую строку
- `writelines(lines)` - аналогичен инструкции `for line in lst: f.write(line)`. Не добавляет `\n` к каждой строке (!)

---
> Какой аналог есть для файлового метода `f.readline()`?

Непосредственная итерация на файловом объекте:

```python
for line in f:
```

Такой подход повышает производительность

---
> Как можно создать временный файл или каталог?

Используя модуль `tempfile`. Оба метода принимают аргументы `(suffix=None, prefix=None, dir=None)` и возвращают абсолютный созданному путь к объекту ФС:

```python
import tempfile

tempfile.mkdtemp()
tempfile.mkstemp(suffix='.txt', text=True)
```

Ответственность за удаление объекта возлагается на программиста. В том же модуле есть функции `[Named|Spooled]TemporaryFile()`, которые самостоятельно удаляют созданные файлы

---
> Какой способ чтения нескольких файлов более оптимальный?

Использование модуля `fielinput`. Основная его функция `input()` читает строки из файлов, заданных последовательностью имен (или из `sys.аrgv[1:]`):

```python
import fileinput

for line in fileinput.input(inplace=True):
    print(line.replace('foo', 'bar'), end='') 
```

Модуль оптимизирован под подобные задачи (вроде поиска и замены в файлах)

---
> Что делает модуль `linecache`?

Его функции `.getline[s]()` кешируют в памяти строки (по номеру) из файлов. Это позволяет не открывать файл каждый раз (?)

---
> Для чего служит модуль `struct`?

Позволяет упаковать двоичные данные в байтовую строку, которую потом можно будет распаковать для преобразования в исходные дан­ные. Такие операции полезны для многих целей в низкоуровневом программирова­нии

Чаще всего модуль используется для интерпретации данных из двоичных файлов, записанных с использованием определенного формата, или для подготовки данных к записи в двоичные файлы (?)

---
> Какие классы реализуют "файлы в памяти"?

Два класса модуля `io`, для строк Юникода и байтовых строк:

```python
io.StringIO
io.BytesIO
```

Это полиморфные файловым объекты, могут использоваться там же, где и результат вызова функции `io.open()`

---
> Перечислите 6 модулей для работы со сжатыми файлами

`gzip,` `bz2`, `tarfile`, `zipfile`, `zlib`, `lzma`

> Последнего нет

---
> За что отвечает модуль `os`?

Это зонтичный модуль, обеспечивающий в достаточной степени унифицированный кросс-платформенный интерфейс к часто используемым службам различных операционных систем. Он обеспечивает выполнение низкоуровневых операций над файлами и каталогами, а также создание, управление и уничтожение процессов

---
> Как в коде определить текущую систему?

Строка

```python
os.name
```

- `posix` - Линукс и MacOS
- `nt` - Windows
- `java` - Jython

---
> Какого типа исключения выбрасывает модуль `os`?

Объекты класса `OSError`. Синоним - `os.error`

---
> Для чего служит модуль `errno`?

Определяет несколько десятков символических имен для целочисленных кодов ошибок, возвращаемых системными вызовами. Пример:

```python
errno.ENOENT
```

Их использование для избирательной обработки возможных системных ошибок позволяет улучшить переносимость и удобочитаемость программы

---
> Где хранится информация об атрибутах файловых путей для текущей платформы?

В свойствах модуля `os`:

- `curdir` - строка, означающая текущий каталог (`'.'` везде)
- `defpath` - каталог по умолчанию для поиска программ, если `PATH` не задана
- `linesep` - символ конца строки (`'\n'` в Linux и `'\r\n'` в Windows)
- `extsep` - строка, отделяющая расширение файлов (`'.'` везде)
- `pardir` - строка, обозначающая родительский каталог (`'..'` везде)
- `pathsep` - разделитель в списках путей, напр., в `PATH` (`':'` в Linux, `';'` в Windows)
- `sep` - разделитель элементов пути (`'/'` в Unix, `'\\'` в Windows)

---
> Как указывать права (permissions) при работе с файлами?

Функции модуля `os` как правило принимают целочисленный аргумент `mode` - стандартные NIX-овые 9 битов прав (3 группы по 3)

---
> Где находятся функции работы с файлами и каталогами?

В модуле `os`, на верхнем уровне. Примеры:

- `getcwd()`, `chdir()` - получить/сменить текущий каталог
- `makedirs()`/`mkdir()`, `removedirs()`/`rmdir()` - создать/удалить каталог(и)
- `rename()`, `remove()` - переименовывает/удаляет файлы
- `scandir()`, `walk()` - обход каталога
- `stat()` - системный вызов, информация о файле

---
> Где хранятся функции анализа и преобразования строк путей?

В модуле `os.path`. Примеры:

- `abspath()`, `relpath()` - абсолютный и относительный пути к файлу
- `basename()`, `dirname()` - базовое имя файла и его каталога
- `is{file|dir|link}()` - проверка типа объекта
- и другие

---
> Как можно сравнить два файла или каталога?

Воспользоваться функциями из модуля `filecmp`, такими как `cmp()`, `cmpfiles()`, `dircmp()`

---
> Как можно сопоставить строку - путь к файлу, с шаблоном оболочки *NIX?

В модуле `fnmatch` есть функции для этого, такие как `filter()` и `fnmatch()`. Они проверяют строку/строки на соответствие шаблону с wildcard-ами, такими как `*` или `?`

Функции `[i]glob()` модуля `glob` уже возвращают список путей по шаблону

---
> Как можно копировать, перемещать и удалять файлы на файловой системе?

С помощью функций модуля `shutils` ("shell utilities"):

- `copy[2|File[Obj]|mode|stat|tree]()` - разные варианты копирования
- `move()` - перемещение файла
- `rmtree()` - рекурсивное удаление каталога

---
> Какие есть 2 типа объектов, позволяющих работать с файлами?

- объекты типа "файл", возвращаемые значения функции `io.open()` - `f`
- файловые дескрипторы - целые числа, непрозрачные указатели, используемые ОС для ссылок на файлы - `fd`

Для вторых так же есть свои функции `os.read()`/`ow.write()`

Получение:

- `fd = f.fileno()`
- `f = os.fdopen(fd)`
- `fd = os.open('path')`

Обычно для задач ввода-вывода лучше использовать объекты "файлов" Python, но иногда работа на уровне файловых дескрипторов позволяет ускорить выполнение операций или (за счет потери переносимости) сделать то, чего нельзя сделать непосредственно с помощью функции `io.open()`

---
> Куда пишет данные функция `print()`?

В `stdout`. В этом она является более удобным аналогом метода `sys.stdout.write()`

> Чтобы сделать ее функцией, нужно указывать `from __future__ import print_function`

---
> Как перенаправить вывод функции `print()` в файл?

- у функции есть параметр `file=sys.stdout`, можно указать вместо него файловый объект
- временно подменив `sys.stdout` на файловый объект

---
> Как получить значение из `sys.stdin`?

Использовать встроенную функцию `input()`

> Она называется `raw_input()`

---
> Как получить число из консольного ввода? Объект?

- применить к результатам вызова `input()` конструкторы `int()`/`float()`
- вызвать на тех же результатах `ast.literal_eval()` (`'[2,3]'` -> `[2, 3]`)

---
> Как запросить ввод с клавиатуры, не отображая вводимые символы?

Обычно используется для ввода пароля:

```python
import getpass

getpass.getpass()
```

Также у модуля есть функция, возвращающая имя текущего пользователя: `getuser()`

---
> Какие есть расширенные средства чтения клавиатурного ввода?

Модуль `readline` обертывает библиотеку GNU Readline, которая позволяет редактировать строки в процессе ввода и поддерживает историю

---
> Какой модуль обеспечивает псевдографический оконный интерфейс?

Модуль `curses` с довольно богатым функционалом

---
> Что делает модуль `cmd`?

Позволяет реализовывать командный интерпретатор. Определив свой класс с методами `.do_<verb>()`, можно вызывать эти методы, набирая в строке приглашения соответствующий глагол

---
> Какие модули в Python обеспечивают интернационализацию?

`locale` (региональные форматы дат, времени, чисел и т.д.) и `gettext` (переводы)

---
> Что такое *локаль*?

Региональные настройки, с которыми работает программа

---
> Какие категории есть у модуля `locale`?

Константы, влияющие на результаты функций самого модуля `locale` или других модулей:

- `LC_COLLATE` - сортировка строк
- `LC_CTYPE` - типы символов (что-то про различение регистра)
- `LC_MESSAGES` - отображение сообщений через `os.strerror()` и модуль `gettext`
- `LC_MONETARY` - форматирование денежных значений. Влияет на функцию `locale.localeconv()`
- `LC_NUMERIC` - форматирование чисел
- `LC_TIME` - форматирование значений времени и даты. Влияет на функцию `time.strftime()`

Категория `LC_ALL` объединяет их все

---
> Что такое *локализация*?

Отображение текстов на языке пользователя

Для этого обычно используется модуль `gettext`, устанавливающий функцию `_('<str>')` во встроенном модуле `__builtin__`

---
> Как узнать точное количество ключевых слов в текущей версии языка?

Модуль `keywords`:

```python
import keywords

len(keywords.kwlist)
```

---
> Как узнать, записано ли в строке ключевое слово?

Модуль `keywords`:

```python
import keywords

keywords.iskeyword('...')
```

---
> Назовите два способа получить список всех ключевых слов языка

```python
help('keywords')
```

или

```python
import keywords

keywords.kwlist
```

---
> Как получить длину списка? Как это реализовано внутри?

Встроенной функцией `len()`. Она обращается к dunder-методу `.__len__()`

---
> Как вычислить квадратный корень числа?

```python
a**.5
```

---
> Как получить список всех разделов справки?

```python
help('topics')
```

Имена этих разделов пишутся целиком заглавными буквами

---
> Как программно выйти в отладчик?

```python
import pdb

pdb.set_trace()
```

---
> Как обозначаются команды отладчика `pdb`?

Командами-словами, достаточно вводить одну букву:

- `h[elp]` - вывести список всех доступных команд
- `n[ext]` - выполнить следующую инструкцию
- `c[ont[inue]]` - продолжить до следующей точки прерывания
- и т.д.

---
> Как проверить, что строка непуста?

Неявно:

```python
if string:
    pass
```

Использовать `len(string) > 0` считается плохим стилем

---
> В каком модуле располагаются `int`, `float`, `str`, `bool` и прочие?

В `builtins`:

```
>>> help(str)
Help on class str in module builtins:

class str(object)
...
```

Эти классы не используют CamelCase

---
> Как предпочтительнее сравнивать синглеты (и с синглетами)?

Через опреатор `is [not]`:

- он работает быстрее `==`
- он точнее выражает намерения программиста и указывает типы сравниваемых переменных

Проверку на истинность/ложность лучше вести так же, как обычно - неявно:

```python
if not a:
    pass
```

---
> Какая временная сложность у операций вставки в список?

Список реализован как массив указателей. Сложность - `O(1)` в начало и конец, и `O(n)` в середину

Если нужно часто вставлять/извлекать элементы в начале, лучше воспользоваться классом `collection.deque` (?)

---
> Можно ли записывать литерал кортежа без скобок?

Да, вполне:

```python
x = 'One',
y = 1, 2, 3[,]
```

---
> Какие два основных применения множеств?

Множества `set()` оптимизированы для двух операций:

- проверка принадлежности (`.__contains__()`)
- удаление дубликатов

---
> Какие бинарные операторы реализуют операции из теории множеств?

Побитовые и арифметические:

- объединение (`|`)
- пересечение (`&`)
- вычитание (`-`)
- исключающее ИЛИ (`^`)

---
> Как в двух текстах найти слова, встречающиеся в обоих? Уникальные для каждого?

Разбивкой на слова (может быть более интеллектуальной) и операциями с множествами:

```python
set(text1.split(' ')) & set(text2.split(' ')) # пересечение
set(text1.split(' ')) ^ set(text2.split(' ')) # исключающее или
```

---
> Как найти все атрибуты (класса) списка, отсутствующие у кортежа?

Через `dir()` и операции с множествами:

```python
set(dir(list)) - set(dir(tuple))
```

---
> Как получить список кортежей <индекс, элемент> для списка? Список кортежей <ключ, значение> для словаря?

```python
enumerate([...]) # возвращает итератор
{...}.items()
```

---
> Чем отличается кодирование строк от декодирования?

Кодирование переводит человекочитаемую строку Юникода в байтовое представление. Декодирование наоборот, переводит последовательность байтов в читаемую строку:

```python
x_sq = 'x\u00b2'
x_sq.encode('utf-8') == b'x\xc2\xb2'
```

То есть метод `.encode()` существует только для обычных строк (строк Юникода), а метод `.decode()` - только для байтовых

---
> Что такое *модзибакэ* и *тофу* для символов?

Модзибакэ - искажение символов, "кракозябры" - неверно декодированные строки

Тофу - пустой прямоугольник или ромб с вопросительным знаком - отображается если шрифт не поддерживает нужный глиф

---
> Как открыть файл на чтение в кастомной кодировке?

Передать параметр `encoding=`:

```python
with open('/tmp/sq.cp949', 'w', encoding='cp949') as fout:
    pass
```

---
> Как класс хранит список своих родителей?

В кортеже `Class.__bases__`

---
> В какой ситуации подход LBYL может не сработать?

В многопоточных программах, в условиях гонки (race condition) - ресурс может уже изменить состояние после проверки

---
> Как задаются метаданные модуля?

Глобальными dunder-переменными:

```python
__author__ = 'Matt Harrison'
__date__ = 'Jan 1, 2017'
__contact__ = 'matt_harrison <at> someplace.com'
__version__ = '0.1.1'
```

Формат номеров версий описывается в PEP 396

---
> Как выполнить код doctest, записанный в отдельном файле?

Функция `.testfile()`:

```python
import doctest

doctest.testfile('module_docs.txt')
```

---
> Какая стандартная идиома выхода из программы с указанием кода завершения?

Если `main()` ничего не вернет (`None`), то выход с нулем (успешное завершение):

```python
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]) or 0)
```

---
> Как соединять физические строки в логические?

Используя обратный слеш `\` или скобки - круглые, квадратные или фигурные (предпочтительнее):

```python
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:
       pass
```

---
> От какого класса наследуется `TabError`?

Исключение, выбрасываемое при непоследовательном использовании пробелов и табов.

```
SyntaxError
  |  +-- IndentationError
  |    +-- TabError
```

`IndentationError` - базовый класс, самостоятельно вроде не используется.

---
> Какой тип у этих результатов?
> 
> ```python
> 1 + 2
> 1 + 2.0
> 2 / 1
> 2 // 2.0
> ```

```python
int
float
float
float
```

Арифметические операции, включая целочисленное деление, расширяют результат до самого "широкого" операнда. Обычное деление всегда дает дробное число

---
> Как можно округлить число?

Встроенной функцией

```python
round()
```

---
> Какой порядок аргументов у встроенной `map()`?

Сначала функция, потом последовательность:

```python
map(lambda e: len(e), lst)
```

---
> Какого типа исключения выбрасывает это выражение?
> 
> ```python
> int('str')
> ```

```
ValueError: invalid literal for int() with base 10: 'str'
```

---
> Как вывести дробное число с заданной точностью?

Через f-строки. Например:

```python
f'{x:.2f}'
```

выведет 2 разряда после десятичной точки

---
> Какого типа исключения выбрасывают эти преобразования дробных чисел?
> 
> ```python
> float('str')
> decimal.Decimal('str')
> ```

У модуля свой класс исключений:

```
ValueError
decimal.InvalidOperation
```

---
> В чем разница между этими двумя вызовами в REPL?
> 
> ```python
> >>> 1
> >>> print(1)
> ```

`displayhook()` использует для отображения `repr()`, тогда как `print()` - `str()`. Если они реализованы по-разному (как например для дробных чисел в ранних версиях v2), то результат может быть разный

---
> Какой тип элементов у последовательности "строка"?

Односимвольная строка, отдельного типа "символ" нет

---
> Как называется и через какие переменные доступен модуль встроенных функций и типов?

Модуль называется `builtins`, импортируется автоматически, но переменная `builtins` в коде недоступна: импорт идет через алиас

```python
import builtins as __builtins__
```

Полагаться на алиас нельзя: это деталь реализации CPython. Если, например, нужно обернуть встроенную функцию, то модуль нужно импортировать явно:

```python
import builtins

builtins.open(...)
```

При этом он будет взят из кеша, т.к. уже есть в `sys.modules['builtins']`

---
> В чем особенности вызова `help()` на строке?

Только на пустой строке будет выдана справка по классу `str`. На непустых строках будет искать раздел справки по этой теме

---
> Какие "арифметические" операции применимы к строкам?

Сложение (конкатенация) и умножение (повторение):

```python
'ab' + 'cd' == 'abcd'
'ab' * 2 == 'abab'
```

Реализуются методами `.__add__()` и `.__mul__()`

Те же операции есть и для другой неизменяемой последовательности - кортежей

---
> Какие методы строк отвечают за поиск и замену?

Первый возвращает индекс начала подстроки. Второй заменяет *все* вхождения:

```python
'abcd'.find('bc') == 1
'abababab'.replace('ab', '1') == '1111'
```

---
> В чем отличие встроенных функций от методов класса для коллекций?

Встроенные функции вроде `len(X)` или оператора `X[0]` охватывают все типы коллекций, они универсальны. Методы, вроде `.join()` или `.split()` специфичны для конкретной коллекции (типа)

---
> В чем отличие результатов `globals()` от `dir()` без аргументов?

`globals()` возвращает словарь, а `dir()` - список имен. При вызове в глобальной области видимости результат `dir()` совпадет со списком ключей `globals()`

---
> Как преобразовать символ в его численный код и обратно?

Встроенные функции `ord()`/`chr()` соответственно

---
> Что такое "сырые" строки?

Строки, в которых обратный слеш не имеет специального значение. Литерал - через префикс `r`:

```python
r'С:\text\new'
```

---
> Как проверить строку на соответствие регулярному выражению?

Модуль `re`:

```python
import re

matcher = re.match('.*(bc).*', 'abcd')

if (matcher):
    matcher.groups()
    matcher.group(1) == 'bc'
```

---
> Как разбить строку на части по регулярному выражению?

```python
re.split('[/:]', '/usr/home/lumberjack') == ['', 'usr', 'home', 'lumberjack']
```

---
> Принимает ли `list.pop()` аргументы?

Да, индекс элемента - `.pop(index=-1)`:

```python
[1, 2].pop(0) == 1
```

Метод аналогичен оператору `del x[N]`, только еще и возвращает элемент. При отсутствии элемента (и на пустом списке) выбрасывается `IndexError`

---
> В чем отличие обращения (`'ab' -> 'ba'`) строки и списка?

Т.к. списки изменяемы, у них есть inplace-метод `.reverse()`. Неизменяемые строки можно обращать только создавая новые последовательности (итераторы), через срезы или встроенную функцию `reversed()`. То же касается и `.sort()`/`sorted()`

При этом неизменяемые типы вполне могут иметь собственные методы, но разумеется только немутирующие. Так, например, у кортежей есть методы `.index()` и `.count()`

---
> Какой тип возврашает list comprehension, заключенное в круглые скобки?

Объект генератора:

```python
G = (sum(row) for row in M)

next(G)
next(G)
```

---
> Что происходит при обращении к несуществующему индексу списка? Несуществующему ключу словаря?

В обоих случаях выбрасывается исключение:

```python
IndexError # для списка
KeyError   # для словаря
```

---
> Как проверить что в списке есть нужный индекс? В словаре есть нужный ключ?

В Python списки не бывают разреженными:

```python
if len(x) > N: x[N] # для списка
if K in x: x[K]     # для словаря
```

---
> Для какой из основных коллекций нет пустого литерала?

Только для множества:

```python
[]    # список
()    # кортеж
{}    # словарь
set() # множество
```

---
> Как безопасно обратиться к ключу в словаре?

```python
x.get('a')
x['a'] if 'a' in x else None

try:
    x['a']
except KeyError:
    pass
```

---
> Какой объект считается итерируемым?

Который представляет собой либо физическую коллекцию в памяти, либо "виртуальную" - объект класса, поддерживающего протокол итерации. Такой, что:

- он отвечает на вызов `iter()` - возвращает объект
- который, в свою очередь, отвечает на вызов `next()` - возвращает следующий объект либо генерирует исключение `StopIteration`, когда значений не осталось

---
> Чем по сути являются объекты файлов?

Итераторами. Содержимое файла - не список, оно извлекается построчно, по требованию

---
> Какое значение по умолчанию у аргумента `sep` метода `str.split()`?

`None`. Означает:

- разбиение по любому пробельному символу
- удаление пустых строк из результата

Второй аргумент `maxsplit=-1` указывает максимальное количество разбиений (`-1` ~ неограничено)

---
> Какие основные типы коллекций поддерживают оператор `in`?

Все четыре

---
> Чем обусловлен выбор литерала для множеств?

Они напоминают ключи словарей без значений - неупорядоченные уникальные коллекции:

```python
{'a', 'b'}
{'a': 1, 'b': 2}
```

---
> Какие типы могут применяться для обхода ограничений, связанных с точностью арифметики для чисел с плавающей точкой?

- `decimal.Decimal(x)` - числа с фиксированной точностью
- `fractions.Fraction(x, y)` - обыкновенные дроби (рациональные числа)

---
> В чем суть "утиной" типизации?

Работа идет с *интерфейсами*, не с *типами*. Важно лишь что объект *делает*, а не чем он *является*

Это реализация идеи полиморфизма в Python - смысл вызываемой операции (напр., `+`, `*`) зависит от объектов, на которых она выполняется

---
> Что такое *литерал*?

Специальный синтаксис - без явного использования конструктора класса - создания объектов встроенного типа

---
> Какой тип имеет литерал `1e2`?

`float`. Запись через научную нотацию даже целых чисел приводит к результату в виде числа с плавающей точкой

---
> Чувствительны ли к регистру буквы в записи числовых литералов?

Нет, никакие не чувствительны. Все эти записи допустимы и эквивалентны:

```python
1+2j ~ 1+2J
0x1 ~ 0X1
1e2 ~ 1E2
...
```

---
> Как проверить два объекта на неравенство?

```python
a != b
```

> Доступна и вторая форма, `a <> b`

---
> Как узнать длину числа в битах?

```python
x.bit_length() == len(bin(x)) - 2
```

---
> Какой есть аналог оператора `**`?

Встроенная функция `pow()`

---
> Как вычислить квадратный корень числа?

В модуле `math` есть нужная функция:

```python
import math

math.sqrt(x)
```

Ну и всегда можно возвести число в степень `0.5`:

```python
x ** .5
pow(x, .5)
```

---
> Где заданы такие константы, как `e` и `pi`?

В модуле `math`:

```python
import math

math.e, math.pi
```

---
> Какие в модуле `math` есть виды округления?


```python
import math

math.floor() # в меньшую сторону, аналог //
math.trunc() # усечение, аналог int()
math.round() # "банковское" округение
```

---
> Назовите 3 популярные функции модуля `random`

- `randint(a, b)` возвращает случайное целое в интервале `[a, b]` (включает `b`)
- `choice(X)` выбирает случайны элемент последовательности
- `shuffle(X)` тасует последовательность случайным образом

---
> Где можно использовать экземпляры классы `fractions.Fraction`?

Во всех выражениях, где допустимы числа. :

```python
3 + fractions.Fraction(1, 2) == fractions.Fraction(7, 2) == 3.5
3 / fractions.Fraction(1, 2) == fractions.Fraction(6, 1) == 6

# но результатом операций всё же будет обыкновеная дробь
type(3 + fractions.Fraction(1, 2)) is fractions.Fraction
```

По сути тип просто хранит числитель и знаменатель отдельно

---
> Как преобразовать число с плавающей точкой в обыкновенную дробь?

Встроенными средствами (в кортеж) или через модуль:

```python
(1.25).as_integer_ratio() == (5, 4)
fractions.Fraction(1.25) == fractions.Fraction(5, 4)
```

---
> Для типа `set`, в чем отличие вызова операций через операторы и через методы класса?

С бинарными операторами оба операнда должны быть типа `set`, тогда как методы допускают любые итерируемые коллекции:

```python
X | []      # ошибка
x.union([]) # ok
```

---
> Какие 3 шага выполнит интерпретатор, встретив инструкцию `a = 3`?

- создаст объект `3`
- создаст переменную `a`
- свяжет созданные переменную и объект

---
> Могут ли переменные ссылаться друг на друга?

Нет, они могут лишь ссылаться на один и то же объект, но не друг на друга. Такие ссылки называются *разделяемыми*:

```python
a = b = [] # 1
a = b = () # 2
```

В первом случае inplace-изменение `a` приведет к изменению `b`, во втором нет (inplace-модификации неизменяемых объектов вообще недоступны), но в обоих случаях это лишь результат операций с (не)изменяемыми объектами в памяти, на которые ссылаются переменные

---
> Чем внутренне являются переменные?

Указателями на область памяти, где хранится объект

Можно рассматривать переменные как автоматически разыменовываемый указатель на `void*`, или как ссылку (`&`) в C++

---
> Какие два основных поля имеет объект-значение?

Тип и счетчик ссылок. Таким образом, типы "обитают" в объектах, не в переменных (именах/ссылках)

---
> Что такое *сборка мусора*?

Автоматическое освобождение памяти, выделенной под объект

Объект удаляется если на него не ссылается никакая переменная или другой объект. По умолчанию также включен поиск и удаление циклических ссылок

---
> Как определить разделяемые ссылки?

Оператором `is`:

```python
a = b = [1, 2]
c = [1, 2]
d = [1, 2]

(a is b) == True
(c is d) == False
```

---
> Где находятся инструменты для работы со "слабыми" ссылками?

В модуле стандартной библиотеки `weakref`

---
> Сколько существует строковых типов?

Три: строки Юникода `str`, изменяемые (`bytearray`) и неизменяемые (`bytes`) последовательности байтов

> Для Юникода отдельный тип `unicode`, `str` - это ASCII-строки, и с 2.6 доступен еще `bytearray`

---
> Интерпретируется ли нулевой символ в строках как завершающий?

Нет, Python хранит и содержимое строки, и ее длину:

```python
len('a\0bc') == 4
```

---
> Как создать аналог многострочного комментария?

Обрамить блок кода тройными кавычками:

```python
X = 1
"""
import os
print(os.getcwd())
"""
Y = 2
```

---
> В чем отличие `str.find()` от `in`?

Метод возвращает позицию символа, тогда как оператор только лишь проверяет факт вхождения

---
> Как еще называется шаг (третий параметр) в срезах?

*Страйд*, "большой шаг"

---
> Как удалить из строки завершающий символ `\n`?

Можно через `line[:-1]`, но `line.rstrip()` предпочтительней (особенно при чтении строк из файлов): символа новой строки в конце может и не быть

---
> К каким коллекциям применим оператор `del`?

И к спискам и словарям (оба изменяемые)

---
> Какой тип у возвращаемого значения `dict.keys()`?

Это тип, подобный множеству - к нему применимы операции из теории множеств, вроде объединения и пересечения:

```python
dict_keys
```

Причем эти операции применимы как к однотипным операндам `dict_keys`, так и к `dict_keys | dict` / `dict_keys & set`

- `dict.values()` также возвращает специальный итератор типа `dict_values`, а не просто список. Хотя `dict_values` уже операции над множествами не поддерживает
- `dict.items()` также возвращает специальный итератор типа `dict_items`, он может участвовать в операциях теории множеств вместе с `dict_keys`/`dict`/`set`

---
> Какие три шага нужны для создания *именованного кортежа*?

```python
from collections import namedtuple               # 1. импорт

Rec = namedtuple('Rec', ['name', 'age', 'jobs']) # 2. создание класса
bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr'])  # 3. создание экземпляра

bob == Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])
```

---
> Как преобразовать именованный кортеж в словарь?

```python
collections.namedtuple()._asdict()
```

---
> Какого типа объекты допустимы в правой части распаковывающего присваивания?

Любого итерируемого, не обязательно обычные кортежи

Например, допустимы там и множества, и `dict_items`, и именованные кортежи

---
> Какие файловые объекты итерируются по строкам?

Только текстовые. Файлы, открытые как бинарные (`'b'` в вызове `open()`), не транслируют символ новой строки

При чтении бинарных файлов возвращаются байтовые строки (тип `bytes`), не `str`

---
> Как сериализовать объекты Python для хранения в файлах на диске?

Используя модуль стандартной библиотеки `pickle`, в частности его функции `dump(<object>, <fout>)`/`load(<fin>)`. Файлам можно задавать расширение, например, `.pkl`

Независимым от языка форматом сериализации можно считать, например, JSON

---
> Как осуществляется сравнение вложенных объектов?

Рекурсивно, обход вложенных структур (напр., коллекций) идет слева направо и настолько глубоко, насколько нужно, до тех пор пока не будет найдено отличие или не достигнут конец:

```python
([1, ('a', 2)] < [1, ('a', 3)]) == True
```

Из-за такого правила (больше/меньше по первому отличию), в частности при сравнении строк не учитывается длина:

```python
('abc' < 'ac') == True
```

---
> Какие объекты поддерживаются в левой части присваивания с распаковкой?

Не только кортежи, но и списки:

```python
a, b = <iterator>
[a, b] = <iterator>
```

---
> Как в Python можно создать аналог перечислимого типа?

Распаковать последовательность целых чисел в именованные переменные:

```python
red, green, blue = range(3)

(red, green, blue) == (0, 1, 2)
```

---
> Почему в Python нет операторов инкремента/декремента (`++`/`--`)?

Числа - неизменяемые объекты, и не поддерживают inplace-операции

---
> Какая из этих инструкций вызовет ошибку?
> 
> ```python
> L = []
> 
> L = L + 'abc'
> L += 'abc'
> L.extend('abc')
> ```

Первая. `+=` и `.extend()` - это один и тот же метод, он допускает слияние с последовательностью произвольного типа. Оператор же `+` выбросит

```
TypeError: can only concatenate list (not "str") to list
```

---
> Какие 3 ключевых слова записываются не целиком в нижнем регистре?

```python
True, False, None
```

---
> Какой разделитель использует `print()` по умолчанию?

Пробел, `sep=' '`

---
> Как можно перехватывать весь вывод `print()`?

Т.к. вызов `print()` эквивалентен вызову `sys.stdout.write()`, можно объявить свой класс с методом `.write()`, и присвоить `sys.stdout` экземпляр этого класса

Это показывает, что `print()` полиморфна: ее не заботит, чем является `sys.stdout`, а только лишь то, есть ли у него метод `.write()`

Вариантом является присваивание экземпляра такого фейкового класса параметру `file` функции `print()`

---
> Чем можно заменить `switch`?

Множественными `elif:` или выборкой по словарю (вплоть до словарей, содержащих функции в качестве значений). В последнем случае второй аргумент `.get()` будет аналогом ветки `default`

---
> Может ли отступ в коде состоять из двух пробелов?

Да, интерпретатору не важно количество пробелов/табов. Важно лишь их согласованное и последовательное использование в коде

---
> Какие есть 2 способа записать тернарный оператор?

```python
X if Y else Z
Y and X or Z
[Z, X][bool(Y)]
```

Во втором случае порядок важен. В третьем идет приведение к эквиваленту целого числа-индекса. В третьем случае `X`/`Z` вычисляются всегда, вычислений по короткой цепи не происходит

---
> Что можно использовать вместо `pass` и `None`?

Три точки `...`, объект ellipsis

---
> Назовите два возможных применения встроенной функции `zip()`

- параллельный (одновременный) перебор нескольких последовательностей
- создание словарей по списку ключей и списку значений

---
> Какие типы входных/выходных данных у встроенной функции `sorted()`?

Получает любую итерируемую коллекцию (даже словарь). Возвращает всегда список, не итератор

---
> Какой объект называется *итерируемым*?

Такой, который производит по одному элементу за раз. Физически хранящаяся последовательность - частный случай

---
> Как выглядит ручной аналог итерации `for`?

```python
I = iter(L)
while True:
    try:
        X = next(I)
    except StopIteration:
        break
        
    # some code with X
```

---
> Можно ли итерировать по словарю?

Да, причем без дополнительных усилий:

```python
for x in D:
    pass
```

Итерация идет по ключам

---
> Что возвращает `enumerate()`?

Итератор, можно по нему итерировать и вручную. Либо (через вызов `list(...)`) привести к списку кортежей

---
> Где хранится docstring объекта?

В атрибуте `__doc__`

---
> Как получить список всех атрибутов объекта?

Вызвать на нем функцию `dir()`

---
> Что выводит вызов `help()`?

Строку документации + информация, собранная самим PyDoc, например, шаблоны вызова функций

---
> Как запустить сервер PyDoc?

```
$ python3 -m pydoc -b
```

---
> Как получить PyDoc-справку по модулю прямо из командной строки?

Передать имя модуля параметром, например:

```
$ python3 -m pydoc sys
```

---
> Чем по сути является `def`?

Исполняемым оператором. Он создает объект и присваивает его имени. Может быть вложен в управляющие структуры (`if`/`else`, `while` etc)

---
> Что общего у `else:` в блоках `try:` и у циклов `for:`/`while:`?

В обоих случаях `else:` вызывается, если не было преждевременного выхода из блока, из-за исключения или вызова `break`

Этим они схожи, и гораздо больше похожи друг на друга, чем на `else:` после `if:`

---
> В чем недостаток реализации ADT "очередь" через массив?

Получение (или даже вставка) элемента из начала очереди - медленная операция, если используемая структура данных это список (массив): требуется сдвиг всех элементов вектора

Лучше использовать `collections.deque`

---
> Какие члены модуля на будут импортированы при вызове `from <module> import *`?

Начинающиеся с подчеркивания `_`. Такие определения считаются закрытыми, и в масс-импорте не участвуют

Это если явно не задана `__all__`

---
> Когда допустимо использовать масс-импорт `from <module> import *`?

В интерактивных сеансах. В скриптах и модулях он замусоривает пространства имен

---
> Зачем к файлам байт-кода (`.pyc`) добавляется расширение с версией интерпретатора (вроде `.cpython-33.`)?

Это позволяет сосуществовать кешу от разных версий. Интерпретатор сравнивает свою версию с версией кеша, и либо использует ее, либо компилирует модуль заново

---
> Можно ли запустить программу без файлов с исходным кодом (`.py`), только по файлам кеша (`.pyc`)?

Да, вполне. Это называется "non-source (compiled only) distribution". Единственное условие - `.pyc`-файлы должны лежать на месте исходников, а не в `__pycache__/`-папках

---
> Какое шутливое название имеет срез `[::-1]`

"Марсианский смайлик"

---
> В каких случаях значение из `.__getattribute__()` будет проигнорировано?

Только если он выбрасывает `AttributeError`, явно или через вызов родительского метода. Тогда в классе будет вестись поиск метода `.__getattr__()`. Если его нет, то упадет с выброшенным исключением

Если же `.__getattribute__()` не выбрасывает (любого типа) исключения, то объект класса будет отвечать на запрос любого произвольного атрибута

---
> Какими частями речи называются методы `set()` - операции из теории множеств?

Существительными, не глаголами:

- `.intersection()` ~~(не `intersect`)~~
- `.union()` ~~(не `unite`)~~
- `.difference()` ~~(не `distract`)~~
- и т.д.

---
> Каким операторам соответствуют методы `set()` `.issubset()`/`.issuperset()`?

Оба оператора - с "равно":

```python
a <= b ~ a.issubset(b)
a >= b ~ a.issuperset(b)
```

Для операторов `>`/`<` именованных методов нет, как нет и отдельного оператора для `.isdisjoint()`:

```python
c & d == set() ~ c.isdisjoint(d)
```

---
> Какой суффикс у inplace-методов `set()` - операций из теории множеств?

`_update`:

- `a.union_update(b)` ~ `a |= b`
- `a.intersection_update(b)` ~ `a &= b`
- и т.д.

---
> Какими вызываются методы `set()` - операции из теории множеств, для нескольких (>2) операндов?

Множества просто передаются им в качестве аргументов. Альтернатива - соединять вызовы в цепочки:

```python
a | b | c
a.union(b, c)
a.union(b).union(c)
```

---
> Может ли класс быть ключом словаря?

Да, может. Классы - хешируемые (вызываемые) объекты:

```python
class A:
    pass

hash(A) == 1192073
```

---
> Что такое *файлы в памяти*?

Объекты, интерфейс которых совпадает с файловыми объектами, но содержимое которых задается прямо в коде, в виде (байтовых) строк:

```python
import io

output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)

# Retrieve file contents -- this will be
# 'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
```

Классы `io.{String|Bytes}IO` могут использоваться везде, где ожидаются файлы. Например, в них можно записывать результаты сетевых запросов

---
> Как "файлу в памяти" задать значение? Как его получить?

Задается в конструкторе, через `.write()` или `print()`:

```python
output = io.StringIO()
output.write('First line.\n')
print('Second line.', file=output)
```

Получение так же - через `.read[line[s]]()` и итераторы, плюс есть метод `.getvalue()`:

```python
contents = output.getvalue()
```

---
> Как у pylint отключать предупреждения прямо в коде?

Через комментарии:

```python
def meth2(self, arg):
    # pylint: disable=unused-argument
    ...
```

---
> В каком формате распространяется утилита pylint?

Как исполняемый Python-скрипт `/usr/bin/pylint`, подключающий модули внутри. Формат вызова:

```shell
$ pylint [options] modules_or_packages
```

---
> Какой базовый класс у `FileNotFoundError`?

```python
OSError
```

У него вообще с десяток потомков

---
> Перечислите шесть не-абстрактных класса модуля `collections`

1. `ChainMap` - цепь словарей
2. `Counter` - словарь частот
3. `deque` - двусторонняя очередь
4. `defaultdict` - словарь с фабрикой для значения по умолчанию
5. `namedtuple()` - (не класс, функция-фабрика) кортеж с именованными элементами
6. `OrderedDict` - словарь с упорядоченными ключами

Три доп. класса `User{Dict|List|String}` служат только для расширения стандартных классов

---
> Сэмулируйте объект-словарь - текущую область видимости

Через `collections.ChainMap`:

```python
import builtins, collections
collections.ChainMap(locals(), globals(), vars(builtins))
```

---
> Какая сигнатура у конструктора `collections.ChainMap`?

Получает произвольное количество позиционных аргументов-словарей:

```python
ChainMap(*maps)
```

Вызов конструктора возможен и без аргументов. Тогда создается единственный пустой словарь

---
> Как `collections.ChainMap` хранит свои словари?

Как список, в открытом атрибуте `.map`

Все словари хранятся по ссылке, так что изменение одного затронет и `ChainMap`

---
> Как в скрипте реализовать объект-словарь, учитывающий и параметры командной строки, и переменные окружения, и дефолтные значения внутри самого скрипта?

Через `collections.ChainMap`, с учетом приоритета:

```python
import os, collections

collections.ChainMap(
  parser.parse_args()
  os.environ,
  {'color': 'red', 'user': 'guest'}
)
```

---
> Для чего обычно используется `collections.ChainMap`?

Для эмуляции вложенных областей видимости. А в Django, например, похожий класс `Context` используется в шаблонаторе

---
> Можно ли в `collections.ChainMap` установить/удалить элемент в словарях помимо первого?

Нет, стандартными средствами нельзя. Только субклассированием, и переопределением методов `.__{set|del}item__()`

---
> В каком случае у элемента `collections.Counter` может быть нулевое значение?

Только при ручной установке или при вызове `.subtract()`. При автоматическом подсчете частот минимальное возможное число - `1`

```python
import collections

c1 = collections.Counter()
c1['a'] = 0

c2 = collections.Counter({'a': -1})
c3 = collections.Counter(a=-1)
```

---
> Как у списка взять `n` элементов с конца?

Срез:

```python
[...][-n:]
[1, 2, 3, 4][-2:] == [3, 4]
```
---
> Как у списка взять `n` элементов с конца в обратном порядке?

Срез с отрицательным шагом:

```python
[...][:-n-1:-1]
[1, 2, 3, 4][:-2-1:-1] == [4, 3]
```

---
> Как у `collections.Counter` вывести самые редко встречающиеся элементы?

Берем `n` элементов с конца в обратном порядке:

```python
c.most_common()[:-n-1:-1]
```

---
> Какая сигнатура у конструктора `collections.Counter`?

Принимает итерируемый объект (и считает в нем частоты), либо вызов аналогично конструктору словаря:

```python
Counter()                      # a new, empty counter
Counter('gallahad')            # a new counter from an iterable
Counter({'red': 4, 'blue': 2}) # a new counter from a mapping
Counter(cats=4, dogs=8)        # a new counter from keyword args
```

---
> В чем отличие `dict.update()` и `collections.Counter.update`?

Первый принимает словарь и перезаписывает ключи, второй принимает итерируемую коллекцию и обновляет частоты (подсчитывает и суммирует)

---
> Какая сложность у операции вставки элемента в начало `collections.deque`? В конец?

В обоих случаях `O(1)`

---
> Каково типичное применение `collections.deque` фиксированной длины?

Отслеживание операций/данных, где важна только последняя активность / последние элементы. Этим напоминает `tail`

---
> Как узнать длину `collections.deque`?

Read-only атрибут `.maxlen`. Равен `None` для неограниченных очередей

---
> Можно ли для `collections.deque` вставить элемент в середину?

Да, у класса есть метод

```python
.insert(index, val)
```

Нужно помнить, что если длина очереди ограничена, и вставка делает длину больше допустимой, то будет выброшено `IndexError`

---
> С какого конца очереди возвращает элемент `collections.deque.pop()`?

С правого. Запомнить это можно по имени противоположной функции - `.popleft()`

---
> Как можно сдвинуть очередь `collections.deque` на один шаг вправо, не используя `.rotate()`? На один шаг влево?

Комбинациями `.append()`/`.pop()`:

```python
.appendleft(d.pop()) # ~ .rotate(1)
.append(d.popleft()) # ~ .rotate(-1)
```

---
> Поддерживает ли очередь `collections.deque` доступ по индексу?

Да, поддерживает:

```python
collections.deque([1, 2, 3])[1] == 2
```

Сложность такого (произвольного) доступа к элементам в середине - `O(n)`, но уменьшается до `O(1)` для обоих концов очереди

---
> Поддерживает ли `collections.deque` отрицательные индексы? Проверку элемента через `in`?

Да и да. Вообще, это полноценная последовательность, она поддерживает всё, что и остальные: `.index()`/`.count()`, `len()`, `reversed()` и всё прочее

---
> Что делает функция `collections.namedtuple._make()`?

Получает итерируемый объект *такой же длины*, как и именованный кортеж, и заполняет его (кортежа) поля по этой последовательности:

```python
import collections

a = collections.namedtuple('A', ['x', 'y'])
a._make([1, 2])

a == A(x=1, y=2)
```

---
> Для чего обычно используется `collections.namedtuple`?

Для вычитки в именованный кортеж полей CSV-файла или полей таблиц БД:

```python
EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade')

import csv
for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))):
    print(emp.name, emp.title)

import sqlite3
conn = sqlite3.connect('/companydata')
cursor = conn.cursor()
cursor.execute('SELECT name, age, title, department, paygrade FROM employees')
for emp in map(EmployeeRecord._make, cursor.fetchall()):
    print(emp.name, emp.title)
```

---
> Какая сигнатура у метода `collections.namedtuple._asdict()`?

Аргументов не принимает, возвращает словарь:

```python
p = Point(x=11, y=22)
p._asdict() == {'x': 11, 'y': 22}
```

---
> Какая сигнатура у метода `collections.namedtuple._replace()`?

Принимает неограниченное количество именованных аргументов, чьими значениями и заменяет поля в именованном кортеже:

```python
p = Point(x=11, y=22)
p._replace(x=33)

p == Point(x=33, y=22)
```

---
> Какие есть два способа расширить класс `collections.namedtuple`?

Через стандартное субклассирование и через расширение списка полей:

```python
class Point(namedtuple('Point', ['x', 'y'])):
    @property
    def hypot(self):
        return <...>

Point3D = namedtuple('Point3D', Point._fields + ('z',))
```

---
> Сколько байт в памяти занимает символ Юникода?

Два.

---
> Как в Python реализована поддержка *компактных массивов*?

Через модуль `array`. Он позволяет хранить простые типы в виде настоящих массивов (непрерывных участков в памяти) вместо массивов ссылок на `ctypes.py_object`:

```python
primes = array('i', [2, 3, 5, 7, 11, 13, 17, 19])
```

Суффикс означает тип данных (зд. `i` = signed int)

---
> Позволяет ли модуль `array` создавать компактные массивы пользовательских данных?

Нет, только примитивных, вроде `u` - Unicode char, или `f`/`d` - `float`

Для создания компактных массивов пользовательских типов нужно использовать модуль `ctype`:

```python
arr = (N * ctype.py_object)()
```

---
> Какому классу в других языках соответствует `float`?

Типу `double[ precision]`, числу с плавающей точкой двойной точности, не одинарной

---
> Что генерирует конструктор `bool()` без аргументов?

```python
False
```

---
> Что генерируют конструкторы `int()`/`float()` без аргументов?

```python
0
0.0
```

---
> Можно ли составить множество из множеств?

Только из `frozenset`. Обычное множество - изменяемый объект, и потому нехешируемо. Базирующееся на хеш-мапе множество не может состоять из нехешируемых объектов

---
> Как можно создать список фиксированной длины, заполненный одним значением?

Два способа, list comprehension и умножение:

```python
[None for _ in range(N)]
[None] * N
```

---
> Что выведет этот код?
> 
> ```python
> sys.getsizeof('ab') - sys.getsizeof('a')
> sys.getsizeof('аб') - sys.getsizeof('а')
> ```

```python
1
2
```

В отличие от ASCII, символы юникода требуют 2 байта для хранения

---
> Что выведет этот код?
> 
> ```python
> sys.getsizeof('ab') - sys.getsizeof('a')
> sys.getsizeof(['a', 'b']) - sys.getsizeof(['a'])
> ```

```python
1
8
```

Строки, в отличие от списков, внутренне хранятся как компактные массивы символов, а не как массивы ссылок (64-битных указателей) на объекты

---
> Что выведет этот код?
> 
> ```python
> {[]}
> ```

```
TypeError: unhashable type: 'list'
```

Элементами множеств `[frozen]set` могут являться только хешируемые объекты

---
> Что выведет этот код?
> 
> ```python
> int('hello')
> ```

```
ValueError: invalid literal for int() with base 10: 'hello'
```

---
> Что выведет этот код?
> 
> ```python
> dict.fromkeys(x for x in 'abc', '')
> ```

```
SyntaxError: Generator expression must be parenthesized
```

Когда генераторное выражение - не единственный аргумент в вызове функции, его нужно заключать в скобки

---
> Что выведет этот код?
> 
> ```python
> x = [[]]*2; x[0].append(1); x
> x = [[] for _ in range(2)]; x[0].append(1); x
> ```

Это имеет значение только для изменяемых объектов:

```python
[[1], [1]]
[[1], []]
```
Генерация списка изменяемых объектов через умножение и через списковое включение - не одно и то же. В первом случае "размножаются" лишь ссылки на единственный объект, во втором же элементы ссылаются на разные списки

---
> Что выведет этот код?
> 
> ```python
> class Array:
>    def __init__(self):
>        self._array = [None] * 10
> 
>    def __getitem__(self, index):
>        return self._array[index]
> 
> Array()[0] = 1
> ```

```
TypeError: 'Array' object does not support item assignment
```

Как ни странно, без `.__setitem__()` будет работать доступ только на чтение (?)

---
> Что выведет этот код?
> 
> ```python
> import collections
> 
> x = collections.defaultdict(int)
> 
> x['a']
> x.get('b')
> ```

```python
0
None
```

Внутренний метод `.__missing__()` (запускающий `.default_factory()`) вызывается только через `.__getitem__()`, не через `.get()`

---
> Как вернуть 10 последних строк из текстового файла?

Используя двустороннюю очередь фиксированной длины:

```python
import collections

with open(filename) as f:
    return collections.deque(f, 10)
```

---
> Как найти 10 самых часто встречающихся слов в текстовом файле?

Разбивкой по регулярному выражению и использованием класса `Counter`:

```python
import re, collections

collections.Counter(re.findall(r'\w+', open('hamlet.txt').read().lower())).most_common(10)
```

Выдаст список пар:

```python
[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),
 ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]
```

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [1, 2, 1, 3]
> x.remove(1)
> ```

```python
[2, 1, 3]
```

Для всех последовательностей `.remove()` удаляет по значению, и *только первый элемент слева*

---
> Что выведет этот код?
> 
> ```python
> from collections import Counter
> 
> Counter([1, [], 3])
> ```

```
TypeError: unhashable type: 'list'
```

`Counter` должен формировать словарь с ключами из элементов последовательности, но не-хешируемый тип (список `[]`) не может служить ключом

---
> Что вернет этот код?
> 
> ```python
> c = Counter(a=2, b=2, c=2)
> c.subtract(Counter(a=2, b=3))
> 
> c.most_common(3)
> list(c.elements())
> ```

```python
[('c', 2), ('a', 0), ('b', -1)]
['c', 'c']
```

`.most_common()` возвращает пары независимо от значений частот. А вот `.elements()` повторяет только те ключи, чьи значения больше нуля

---
> Что выведет этот код?
> 
> ```python
> import collections
> 
> c = collections.Counter()
> d = collections.defaultdict(int)
> 
> c['a'] == 0
> d['a'] == 0
> dict(c) == dict(d)
> ```

```python
True
True
False
```

Для обоих классов идет обращение по несуществующему ключу. В обоих случаях возвращается ноль. Но `defaultdict` создаст новый (нулевой) элемент, а `Counter` нет:

```python
{} != {'a': 0}
```

---
> Что выведет этот код?
> 
> ```python
> import collections
> 
> collections.Counter()['a']
> collections.defaultdict(int)['a']
> dict()['a']
> ```

```python
0
0
KeyError: 'a'
```

В этом плане `Counter` - обращение к несуществующему ключу - `Counter` похож на `defaultdict(int)`, а не на дефолтный словарь. Отличие же от `defaultdict(int)` - элемент не создается, просто возвращается ноль

---
> Что выдаст этот код?
> 
> ```python
> list({'a': 1, 'b': 2})
> ```

```python
['a', 'b']
```

Конструктор списка приводит словари к списку ключей

---
> Чему равен `x.maps` после выполнения этого кода?
> 
> ```python
> import collections
> 
> a = {'a': 1}
> b = {'b': 2}
> 
> x = collections.ChainMap(a, b)
> a['a'] = 3
> ```

```python
x.maps == [{'a': 3}, {'b': 2}]
```

Словари в `.maps` хранятся по ссылкам, изменения затрагивают и коллекцию

---
> Что выведет этот код?
> 
> ```python
> class A:
>    pass
> 
> print(hash(A) == id(A))
> ```

```python
False
```

Класс - хешируемый объект

---
> Что выведет этот код?
> ```python
> class A:
>    x = 3
> 
>    def __getattr__(self, name):
>        return 1
> 
>    def __getattribute__(self, name):
>        super().__getattribute__(name)
>        return 2
> 
> print(A().y)
> ```

```python
1
```

Вызов родительского `.__getattribute__()` для несуществующего атрибута приведет к выбросу `AttributeError`, и `return 2` не выполнится. А вот `.__getattr__()` (fallback) выполнится, и именно его значение будет возвращено

---
> Чему равна `b` во всех трех случаях?
> 
> ```python
> a, *b = 'abcd'
> a, *b = 'a', 'bcd'
> a, b = 'a', 'bcd'
> ```

```python
['b', 'c', 'd']
['bcd']
'bcd'
```

---
> Что выведет этот код?
> ```python
> 0 == False
> ```

```python
True
```

Сравнивать их можно, ошибки типов нет

---
> Что выведет этот код?
> ```python
> bool()
> int()
> ```

```python
False
0
```

---
> Напишите однострочник транспонирования матрицы

```python
[[row[i] for row in matrix] for i in range(len(matrix[0]))]
# или
list(zip(*matrix))
```

---
> Как вывести список всех не-dunder методов объекта (напр., списка)?

```python
[_ for _ in dir([]) if not _.startswith('__')]
```

---
> Что выдаст этот код?
> 
> ```python
> next(range(10))
> ```

Ошибку:

```
TypeError: 'range' object is not an iterator
```

Объект класса `range` не является сам итератором, нужно предварительно на нем вызывать `iter()`

---
> Что выведет этот код?
> 
> ```python
> M = map(lambda e: e ** 2, range(2))
> for x in M: print(x)
> for x in M: print(x)
> ```

```python
0
1
```

`map()` возвращает не список, а итератор, и он исчерпается после первого прохода. Чтобы этого избежать, нужно сразу обернуть вызов `map()` в конструктор `list()`

---
> Что выведет этот код?
> 
> ```python
> f = open('some-file')
> l = [1, 2, 3]
> 
> iter(f) is f
> iter(l) is l
> ```

```python
True
False
```

Файловые объекты сами являются итераторами, а вот списки нет, напрямую вызывать `next()` на списке нельзя

Таким образом файлы поддерживают только одну позицию итерации, а списки (и другие последовательности) могут участвовать сразу в нескольких одновременно открытых итерациях

---
> Дан список целых чисел. Как inplace увеличить все его элементы на единицу?

Это тот случай, когда уместен обход по `range()`:

```python
for i in range(len(L)):
    L[i] += 1
```

Списковое включение / `map()` пришлось бы переприсваивать, хотя не факт, что это медленнее

---
> Как в цикле перебрать каждый второй элемент последовательности?

Лучше итерировать по срезу, а не по `range()`:

```python
for item in L[::2]:
    pass
```

---
> Напишите однострочник создания двух переменных, ссылающихся на разные списки

```python
a, b = [], []
```

Групповое присваивание `a = b = []` здесь приведет к созданию двух разделяемых ссылок на изменяемый объект, что может быть нежелательно

---
> Чему равна переменная после присваивания?
> ```python
> *а = [1]
> ```

Ничему, будет выброшена синтаксическая ошибка:

```
SyntaxError: starred assignment target must be in a list or tuple
```

---
> Чему равны переменные после присваивания?
> ```python
> а, *Ь, с, *d = [1, 2, 3, 4]
> ```

Ничему, будет выброшена синтаксическая ошибка:

```
SyntaxError: two starred expressions in assignment
```

---
> Что выведет этот код?
> 
> ```python
> a, *b = 'abcd'; type(b)
> ```

```
<class 'list'>
```

Расширенное присваивание с распаковкой, в отличие от срезов, всегда возвращает список, а не объект того же типа, что стоит в правой части

---
> Как, не используя `.pop()` деструктивно перебрать список, выделяя на каждом шаге его первый элемент?

Через присваивание с распаковкой и срезы:

```python
while L:
    front, L = L[0], L[1:]
    # или
    front, *L = L
    # или для выборки с конца
    *L, front = L
    ...
```

---
> Чему равны переменные после выполнения этого кода?
> 
> ```python
> (a, b), c = 'ab', 'cd'
> ```

```python
(a, b, c) == ('a', 'b', 'cd')
```

Это так называемая *вложенная распаковка*

---
> Что выведет этот код?
> 
> ```python
> a, b = 'abc'
> a, b = 'a'
> ```

`ValueError` для обоих присваиваний:

```python
ValueError: too many values to unpack (expected 2)
ValueError: not enough values to unpack (expected 2, got 1)
```

---
> С каким `if` связан блок `else`?
> 
> ```python
> if х:
>     if у:
>         op1
> else:
>     op2
> ```

С первым, внешним. В отличие от C-подобных языков, где он был бы связан с последним `if` в цепочке, здесь определение принадлежности идет по отступам

---
> Какое значение `L` выведет этот код?
> 
> ```python
> L = ['abc']
> L.append(L)
> L
> ```

```
['abc', [...]]
```

Три точки в квадратных скобках представляют собой бесконечный цикл в объекте

---
> Как можно реализовать DT "разреженная `N`-мерная матрица"?

На основе словаря, ключами которого являются кортежи индексов:

```python
M = {}
M[(1, 3, 8)] = 1
M[(12, 2, 1)] = 2
...
```

---
> Как можно реализовать DT "список с контролем границ"?

На основе словаря с целочисленными ключами. Получится объект, подобный списку

---
> Какого типа исключение будет выброшено?
> 
> ```python
> {}.popitem()
> ```

```
KeyError: 'popitem(): dictionary is empty'
```

Даже несмотря на то, что это не обращение по ключу, словарь выбрасывает `KeyError`

---
> Как можно реализовать ADT "стек"?

Через список и его методы `.pop()` - получение последнего с конца, и `.append()` - добавления в конец

---
> Как отсортировать список строк без учета их регистра?

```python
[...].sort(key=str.lower)
sorted(x.lower() for x in [...])
```
---
> Что выведет этот код?
> 
> ```python
> '1'.find('1')
> ['1'].find('1')
> ```

```
0
AttributeError: 'list' object has no attribute 'find'
```

У списка нет метода `.find()`. Есть `.index()`, и он, в отличие от `.find()`, возвращает не минус единицу, а выбрасывает исключение `ValueError: x is not in list`

---
> Как получить следующий в алфавите символ?

```python
chr(ord(char) + 1)
```

---
> Как напечатать строку, вставляя пробелы между символами?

```python
for с in string: print(с, end=' ')
```

---
> Как создать строку из `N` одинаковых символов?

```python
char * N
'-' * 80 = '---...---'
```

---
> Что будет выведено?
> 
> ```python
> 'ab\cd'
> ```

```python
'ab\\cd'
```

Если символ после обратного слеша не удалось распознать как управляющую последовательность, то сам обратный слеш не будет иметь специального значения, будет вставлен в строку как обычный символ

Полагаться на такое поведение не следует, лучше явно экранировать backslash или использовать r-строки:

```python
'ab\\cd' == r'ab\cd' == 'ab\cd'
```

---
> Какой результат у сравнения?
> 
> ```python
> [1, 2] is [1, 2]
> ```

```python
False
```

В отличие от небольших целых чисел, более сложные объекты не кешируются, не становятся синглетами, их адреса разные. Сравнение значений на равенство при этом, как и ожидается, истинно:

```python
([1, 2] == [1, 2]) == True
```

---
> Чему равно `b` после этих манипуляций?
> 
> ```python
> a = b = {1, 2}
> a.add(3)
> ```

```python
{1, 2, 3}
```

Множества, как и списки и словари, являются изменяемыми объектами - inplace-операции затрагивают разделяемые ссылки

---
> Что выведет это код?
> 
> ```python
> True == 1
> True is 1
> ```

```python
True
False
```

Значения равны, но это разные объекты

---
> Каков результат операции?
> 
> ```python
> 2 + 1j * 3
> ```

```python
(2+3j)
```

На литерал комплексного числа распространяется приоритет операций

---
> Какой результат у сравнения?
> 
> ```python
> -5 // 2 == 5 // -2 == -3
> ```

```python
True
```

Порядок (отрицательных) операндов деления не важен, всегда идет округление вниз

---
> Какой результат у сравнения?
> 
> ```python
> repr('abcd') == str('abcd')
> ```

```python
False
```

`repr()` заключает строки в одинарные кавычки:

```python
repr('abcd') == "'abcd'"
str('abcd') == 'abcd'
```

---
> Какой результат у сравнения?
> 
> ```python
> -5 // 2 == int(-5 / 2)
> ```

```python
False
```

Целочисленное деление всегда округляет в сторону меньшего значения, тогда как конструктор `int` просто отбрасывает дробную часть:

```python
-5 // 2 == -3
int(-5 / 2) == -2
```

---
> Как получить последний элемент в последовательности?

```python
x[-1]
'abcd'[-1] == 'd'
```

---
> Как сравнить что две строки содержат те же символы, но сравнить без учета порядка?

Через приведение строк к множествам:

```python
set(str1) == set(str2)
(set('spam') == set('asmp')) == True
```

Второй вариант проверки - сравнить отсортированные коллекции:

```python
sorted(str1) == sorted(str2)
(sorted('spam') == sorted('asmp')) == True
```

---
> Как найти все буквы, встречающиеся в одной строке, но не встречающиеся в другой?

Через операции с множествами:

```python
set(str1) - set(str2)
set('spam') - set('ham') == {'s', 'p'}
```

---
> Как устранить дубликаты в списке?

```python
list(set([1, 2, 1, 3, 1])) == [1, 2, 3]
```

Возможно не сохранится порядок

---
> Как создать словарь из двух списков/кортежей - ключей и значений?

Конструктор класса `dict` может принимать пары ключ-значение:

```python
dict(zip(('a', 'b', 'c'), (1, 2, 3))) == {'a': 1, 'b': 2, 'c': 3}
```

---
> Как вставить символ в строку?

Строки неизменяемы, поэтому только через создание новой строки. Через срезы, индексы совпадают с позицией вставки:

```python
x = 'abcd'
N = 3
char = '1'

x[:N] + char + x[N:]
```

Результат - вставка после `N`-ного элемента, новый элемент оказывается под индексом `N`:

```
'abc1d'
```

---
> Как заменить символ в строке?

Строки неизменяемы, поэтому только через создание новой строки. Через срезы, в отличие от вставки, второй срез здесь начинается с `N+1` - заменяемый элемент отбрасывается:

```python
x = 'abcd'
N = 2
char = '1'

x[:N] + char + x[N+1:]
```

Результат - замена `N+1`-ного элемента, новый элемент оказывается под индексом `N`:

```
'abc1d'
```

В случае большого числа операций лучше преобразовывать строки в список и выполнять операции с ним: это повысит производительность, не будут постоянно создаваться новые временные объекты

---
> Что выведет этот код?
> 
> ```python
> io.open == __builtins__.open == open
> ```

```python
True
```
Это всё одна и та же функция


---
> Что выведет этот код?
> 
> ```python
> 0.1 + 0.2
> ```

```python
0.30000000000000004
```

---
> Что выведет этот код?
> 
> ```python
> lengths = (float('inf'), 0)
> lengths[0] += 1
> ```

Бесконечность тут не при чем:

```
TypeError: 'tuple' object does not support item assignment
```

---
> Что выведет это код?
> 
> ```python
> try:
>     x = 1
>     x === x
> except SyntaxError:
>     print(x)
> ```

```
x === x
    ^
SyntaxError: invalid syntax
```

Интерпретатор парсит весь скрипт целиком перед выполнением, так что перехватить `SyntaxError` можно только в операциях `eval`, `exec`, или `import`

---
> Что выведет это код?
> 
> ```python
> 'x\u00b2'.encode('ascii')
> ```

Кодировка ASCII не поддерживает символы Юникода:

```
UnicodeEncodeError: 'ascii' codec can't encode
  character'\xb2' in position 1: ordinal not in range(128)
```

Ошибку можно подавить, передав параметр:

```python
.encode('ascii', errors='ignore')  # игнорировать неизвестные символы
.encode('ascii', errors='replace') # заменить их на знаки вопроса
```

Стоит помнить, что `ignore` может приводить к потере данных

---
> Чему равен `idx` после выполнения этого кода?
> 
> ```python
> idx = [1, 2, 3, 4]
> for i in idx:
>     if i > 2:
>         idx.remove(i)
> ```

```python
[1, 2, 4]
```

Текущий индекс отслеживается, и на каждой итерации сравнивается с длиной списка. Дойдя до третьего элемента и удалив его, индекс инкрементируется, станет равным 3, и достигнет длины нового списка (после удаления). Четвертого элемента - с индексом `3` - уже не существует. Итерации с `i = 4`, таким образом, не произойдет

Решение - предварительно отобрать элементы для удаления в другой список, либо итерировать по shallow-клону

А вот словари вообще нельзя менять во время итерации по ним, будет выброшена

```
RuntimeError: dictionary changed size during iteration
```

---
> Что выведет это код?
> 
> ```python
> (1, 2, 4) < (2, 3)
> '124' < '23'
> (1, 2, 3) < (1, 2)
> '123' < '12'
> ```

```python
True
True
False
False
```

И кортежи и строки сравнивают последовательно элементы, длина не влияет при их равенстве

---
> Что выведет этот код?
> 
> ```python
> x = [[1, 2], [3, 4]]
> id(x[0]) == id(sorted(x)[0])
> ```

```python
True
```

`sorted()` возвратит новый список, но состоящий из тех же элементов

---
> Что выведет этот код?
> 
> ```python
> x = [1, 2]
> id(x) == id(sorted(x))
> ```

```python
False
```

`sorted()` всегда вовращает новый список, даже если сортировка не требуется

---
> Что выдаст этот код?
> 
> ```python
> [2, 'abc', 'Zebra', '1'].sort()
> ```

```
TypeError: '<' not supported between instances of 'str' and 'int'
```

Сортировка гетерогенных коллекций по умолчанию не поддерживается - нужно передать параметр, приводящий типы элементов:

```python
[2, 'abc', 'Zebra', '1'].sort(key=str)
```

---
> Что выведет этот код?
> 
> ```python
> not 2 == 3
> ```

```python
True
```

Приоритет `not` ниже оперторов сравнение и `[not] in`/`is [not]`

---
> Что выведет этот код?
> 
> ```python
> bool('0')
> bool('False')
> bool(0)
> bool(0.0)
> ```

```python
True
True
False
False
```

Непустые строки = истина, а вот ноль = ложь

---
> В какой точке и почему упадет этот код?
> 
> ```python
> x = 1
> 
> def f():
>     if x == 1:
>         x = 2
> 
> f()
> ```

На сравнении, с `UnboundLocalError: local variable 'x' referenced before assignment`:

```python
if x == 1:
```

Функция просматривается целиком, в ней находится операция присваивания (`x = 2`), но нет ключевых слов `global`/`nonlocal`. Переменная `x` поэтому считается локальной, а `x = 2` считается ее инициализацией. Но в сравнении `== 1` идет попытка доступа до локальной переменной до ее создания

---
> Что выведет этот код?
> 
> ```python
> import re
> 
> re.findall(r'abc', 'abcabc')
> re.findall(r'a(b)c', 'abcabc')
> re.findall(r'(a)b(c)', 'abcabc')
> ```

```python
['abc', 'abc']
['b', 'b']
[('a', 'c'), ('a', 'c')]
```

`re.findall()` выводит список:

- строк полного соответствия, если групп нет
- строк соответствия группе, если она одна
- кортежей соответствия группам, если их несколько

---
> Что выведет этот код?
> 
> ```python
> import re
> 
> re.findall(r'\w+', 'città')
> ```

```python
['città']
```

В v3 спецификатор `\w` захватывает все "буквы" Юникода

> Нужно указывать префикс у строки и флаг: `re.findall(r'\w+', u'città', re.U)`

---
> Что выведет этот код?
> 
> ```python
> 1 in [1, 2] == True
> (1 in [1, 2]) == True
> ```

```python
False
True
```

Несмотря на одинаковый приоритет операторов `[not] in` и `==` и вычисление выражения слева направо, такая запись это не то, чем может казаться. Без скобок это всего лишь два сравнения, соединенные связкой `and`:

```python
1 in [1, 2] and [1, 2] == True
```

Сравнение во второй части идет с учетом типов, поэтому и получается `False`

---
> Допустим ли этот код?
> 
> ```python
> '{!a}'.format('тест')
> ```

Да, вполне. В подстановке не указан номер позиционного аргумента, он будет выбран неявно (первый)

```python
"'\\u0442\\u0435\\u0441\\u0442'"
```

На аргументе происходит вызов встроенной функции `ascii()`

---
> Что выведет этот код?
> 
> ```python
> 'Test'.translate({
>     'e': '_',
> })
> 'Test'.translate({
>     ord('e'): '_1_',
>     ord('t'): ord('2'),
>     ord('s'): None,
> })
> ```

В первом случае замена вообще не сработает: ключами должны быть коды символов, не сами строки с ними

```python
'Test'
'T_1_2'
```

Значениями же ключей могут быть как строки, так и коды символов. `None` в качестве значения удаляет символ

---
> Что выведет этот код?
> 
> ```python
> 'a'.split('a')
> 'aa'.split('a')
> ```

```python
['', '']
['', '', '']
```

Так `.split()` делит строки - включает в результирующий список и пустые строки по краям от разделителя

---
> Что выведет этот код?
> 
> ```python
> 'a  b'.split()
> 'a  b'.split(' ')
> ```

Между `a` и `b` в строке два пробела, поэтому:

```python
['a', 'b']
['a', '', 'b']
```

В первом случае деление идет по (непрерывной) строке пробельных символов. Во втором - по одиночному пробелу, и таким образом, между двумя одиночными пробелами оказывается пустая строка

---
> Что выведет этот код?
> 
> ```python
> '1\t2\t3\t4'.split(None, 2)
> ```

При `sep=None` деление идет по строке пробельных символов (здесь по одиночному символу табуляции):

```python
['1', '2', '3\t4']
```

Длина результирующего списка - не больше `maxsplit + 1 = 2 + 1 = 3` элементов. Последним элементом следует остаток строки, на котором было прервано деление

---
> Что выведет этот код?
> 
> ```python
> 'test'.split()
> ```

```python
['test']
```

С разделителем по умолчанию - `sep=None` - деление происходит по строке пробельных символов. В строке в примере пробелов нет, и она остается целиком

---
> Что выведет этот код?
> 
> ```python
> 'testest'.replace('test', '_')
> ```

```python
'_est'
```

Поиск идет слева направо, подходящие (до замены) перекрывающиеся подстроки не учитываются

---
> Что выведет этот код?
> 
> ```python
> 'banana'.lstrip('ab')
> 'banana'.rstrip('ab')
> 'banana'.strip('ab')
> ```

```python
'nana'
'banan'
'nan'
```

Все `strip`-методы трактуют свой аргумент-строку как список символов, а не как цельную подстроку для удаления

---
> Что выведет этот код?
> 
> ```python
> 'King Lear'.istitle()
> '1900'.istitle()
> 'Troilus and Cressida'.istitle()
> 'Troilus 1900 Cressida'.istitle()
> ```

```python
True
False
False
True
```

Метод `.istitle()` проверяет, что все "слова" (здесь - непрерывные последовательности букв) в строке начинаются с большой буквы. Если строка целиком не содержит букв, или хотя бы одно слово начинается с маленькой, то `False`

---
> Что выведет этот код?
> 
> ```python
> '011'.isdecimal()
> ```

```python
True
```

По определению `.isdecimal()` всё верно - все цифры могут быть использованы для образования числа в десятичной системе

---
> Что выведет этот код?
> 
> ```python
> '0b11_11'.isalnum()
> ```

```python
False
```

Как и все `str.is*()`-методы, *все* символы должны удовлетворять критерию. Здесь подчеркивание не является буквой или цифрой, и поэтому результат `False`

---
> Что выведет этот код?
> 
> ```python
> ''.islower()
> ```

```python
False
```

Как и все `str.is*()`-методы, этот возвращает `False` на *пустой строке*

---
> Что выведет этот код?
> 
> ```python
> 'teST'.capitalize()
> ```

```python
'Test'
```

Метод `str.capitalize()` не только переводит первую букву в верхний регистр, но и все остальные в нижний

Не стоит путать с `str.upper()` - та переводит всю строку в верхний регистр

---
> Что выведет этот код?
> 
> ```python
> 0 == []
> ```

```python
False
```

Сравнение с учетом типа

---
> Что выведет этот код?
> 
> ```python
> 23 == 23.0
> ```

```python
True
```

Неявное приведение типов

---
> Чему равен `list(x)` после выполнения этого кода?
> 
> ```python
> import collections
> 
> x = collections.deque([0, 1, 2])
> x.rotate()
> ```

```python
[2, 0, 1]
```

По умолчанию аргумент у `.rotate()` - `n=1`, положительное число. Сдвиг начала очереди идет на одну позицию вправо, а освободившееся место занимает элемент из конца

---
> Что выведет этот код?
> 
> ```python
> import collections
> 
> for n in (2, -2):
>     x = collections.deque(range(5))
>     print(list(x))
>     x.rotate(n)
>     print(list(x))
> ```

```python
[0, 1, 2, 3, 4]
[3, 4, 0, 1, 2]
# ---
[0, 1, 2, 3, 4]
[2, 3, 4, 0, 1]
```

Положительный `n` в `.rotate(n)` сдвигает первый элемент очереди на `n` позиций вправо, дописывая в освободившееся начало элементы с конца

Отрицательный параметр приводит к тому, что очередь теперь начинается с `n`-ного индекса, а элементы, удаленные из начала, дописываются в конец. В обоих случаях обращения порядка элементов не происходит

---
> Чему равен `dict(x)` после выполнения этого кода?
> 
> ```python
> import collections
> 
> x = collections.Counter('moo')
> x.update('foo')
> ```

```python
{'o': 4, 'm': 1, 'f': 1}
```

Метод `collections.Counter.update()` не переписывает начальные частоты, а складывает их с новыми

---
> Что выведет этот код?
> 
> ```python
> from collections import ChainMap
> 
> x = ChainMap({1: 2}, {3: 4})
> print(x[3])
> del x[3]
> ```

```shell
4
KeyError: 'Key not found in the first mapping: 3'
```

Как и с установкой нового ключа, удаление в `collections.ChainMap` работает только для первого словаря. Последующие словари в цепочке просматриваются только при запросах на чтение

---
> Что выведет этот код?
> 
> ```python
> import copy
> 
> sublist = [1, 2]
> orig = [sublist, sublist]
> thecopy = copy.deepcopy(orig)
> 
> print(orig[0] is orig[1])
> print(thecopy[0] is thecopy[1])
> ```

```python
True
True
```

Функция `copy.deepcopy` сохраняет ту же форму графа ссылок, что и в исходном объекте. Это же позволяет избежать бесконечных ссылок при глубоком копировании

---
> Что выведет этот код?
> 
> ```python
> sublist = [1, 2]
> orig = [sublist, sublist]
> 
> print(orig[0] is orig[1])
> ```

```python
True
```

Адрес у двух элементов списка, созданных из одного и того же объекта, одинаковый. Ссылки указывают на один и тот же объект в памяти

---
> Что выведет этот код?
> 
> ```python
> import sys
> 
> try:
>     1/0
> except:
>     e1 = sys.exc_info()[2]
> finally:
>     e2 = sys.exc_info()[2]
> 
> print(e1, e2)
> ```

`<traceback object at 0x7f...> None`

В блоке `except:` нет `raise`, исключение не распространяется дальше обработчика, поэтому в `finally:` весь кортеж "пуст" - состоит из трех `None`

---
> Что выведет этот код?
> 
> ```python
> locals() == vars()
> ```

```python
True
```

При вызове без аргументов эти функции эвивалентны, и возвращают read-only словарь всех имен, доступных в текущей области видимости

---
> Что выведет этот код?
> 
> ```python
> max([], default=True)
> max(default=True)
> max(0, default=True)
> max(0, 0, default=True)
> ```

```shell
True
TypeError: max expected 1 argument, got 0
TypeError: 'int' object is not iterable
TypeError: Cannot specify a default for max() with multiple positional arguments
```

Аргумент `default=` допустим только с единственным позиционным параметром типа "итерируемая последовательность"

---
> Что выведет этот код?
> 
> ```python
> def x(a, *, c):
>     print(a, c)
> 
> x(1)
> ```

`TypeError: x() missing 1 required keyword-only argument: 'c'`

Несмотря на то, что у `c` нет значения по умолчанию, он всё так же находится после `*[args]` и может вызываться только по имени. Причем без дефолтного значения он становится обязательным

---
> Что выведет этот код?
> 
> ```python
> class C:
>     pass
> 
> issubclass(C, C)
> ```

Для любого класса всегда

```python
True
```

---
> Что выведет этот код?
> 
> ```python
> list(filter(None, [0, 1, {}, 2]))
> ```

```python
[1, 2]
```

Функцию фильтрации можно заменить на `None`, тогда проверка элемента на истинность будет идти для каждого элемента по стандартным правилам приведения типов

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (,)
> ```

Ничему, будет выброшено `SyntaxError: invalid syntax`

Пустой кортеж задается просто парой скобок, а не запятой, со скобками или без - `(,)`/`,`

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> for i, num in enumerate(x := list(range(10))):
>     del x[i]
> ```

```python
[1, 3, 5, 7, 9]
```

(?) Разобраться, почему так

---
> Что выведет этот код?
> 
> ```python
> class A():
>     x = 1
> 
> c = A()
> print(c.x)
> del A.x
> print(c.x)
> ```

```shell
1
AttributeError: 'A' object has no attribute 'x'
```

Удаление атрибута класса приведет к "исчезновению" атрибута у всех объектов, в том числе уже созданных

---
> Что выведет этот код?
> 
> ```python
> all([])
> any([])
> ```

```python
True
False
```

Ключевое слово для обеих функций - "любой" (вычисления по короткой цепи). По определению этих функций:

- `all()` - возвращает `False`, если любой элемент последовательности `~ False`, иначе (пустая последовательность) `True`
- `any()` - возвращает `True`, если любой элемент последовательности `~ True`, иначе (пустая последовательность) `False`

---
> Что выведет этот код?
> 
> ```python
> int('1001', 0)
> int('0b1001', 0)
> ```

```python
1001
9
```

Ноль в качестве второго параметра конструктора `int` (основание системы счисления, `radix`) будет пытаться распознать строку по префиксу. Строки без префикса считаются десятичными числами

---
> Что выведет этот код?
> 
> ```python
> int(2.4), int(2.5), int(2.6)
> ```

```python
(2, 2, 2)
```

Конструктор типа `int` не округляет свои параметры - дробные числа, а просто усекает их дробную часть

---
> Что выведет этот код?
> 
> ```python
> dict([(1,2,3)])
> ```

`ValueError: dictionary update sequence element #0 has length 3; 2 is required`

В такой форме (через последовательность item-ов) конструктор принимает только пары (кортежи из двух элементов)

---
> Что выведет этот код?
> 
> ```python
> bytes(0)
> bytes(1)
> ```

```python
b''
b'\x00'
```

Целое число `N` в (обоих) конструкторах байтовых последовательностях повторяют ноль (`\x00`) `N` раз

---
> Что выведет этот код?
> 
> ```python
> bytes(256)
> bytes([256])
> ```

```shell
b'\x00...\x00' # 256 нулей
ValueError: bytes must be in range(0, 256)
```

Списки и целые числа ведут себя по разному в конструкторах байтовых последовательностей

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [1, 2]
> x[10:0] = [3,4]
> ```

```python
[1, 2, 3, 4]
```

Вместо левой границы среза будет взята длина списка. Правый индекс меньше левого, срез пустой. Операция эквивалента добавлению списка в конец, конкатенации

---
> Что будет выведено в консоль, если запустить скрипт `test.py` со следующим кодом?
> 
> ```python
> import sys
> import test
> 
> print(sys.modules['test'], sys.modules['__main__'])
> ```

```shell
<module 'test' from 'test.py'> <module '__main__' from 'test.py'>
<module 'test' from 'test.py'> <module '__main__' from 'test.py'>
```

- при импорте скрипта из самого себя в `sys.modules` появятся два ключа - `test` и `__main__` - две записи в каждой строке
- но и тело скрипта будет выполнено дважды - две строки в выводе

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [1, 2, 3]
> x[1:2] = range(2)
> ```

```python
[1, 0, 1, 3]
```

- RHS в присваивании срезу не обязана быть списком, а может быть любым итерируемым объектом
- размер тоже не обязан совпадать

---
> Что выведет этот код?
> 
> ```python
> x = (1,2); id(x) == id(x[:])
> x = (1,2); id(x) == id(x * 1)
> ```

```python
True
True
```

В отличие от списков, кортежи не создают shallow-клоны через срезы и умножение на единицу, а просто возвращают ссылку на тот же объект

---
> Что выведет этот код?
> 
> ```python
> class C:
>     def x(self):
>         return self.y
> 
> try:
>     getattr(C(), 'x')()
> 
> except AttributeError:
>     print('default')
> ```

```python
'default'
```

Это пример ошибочного, слишком "широкого" применения стратегии EAFP: в блоке `except:` перехватывается не только возможное отсутствие атрибута, но и (случайно) все исключения типа `AttributeError`, выброшенные в самой функции. В нашем случае это обращение к несуществующему атрибуту `self.y`

Нужно оставить в `try:` только получение атрибута, а вызов полученного метода вынести в `else:`

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except ArithmeticError:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
1
```

Несмотря на то, что `ZeroDivisionError` специфичнее (точное совпадение с типом), его базовый класс `ArithmeticError` идет в списке `except:`-ов первым, и будет выполнен именно он

Поэтому правило "располагайте более специфичные обработчики выше более общих" лишь хорошая практика, а не жесткое требование на уровне языка

---
> Что выведет этот код?
> 
> ```python
> class C(ZeroDivisionError):
>     pass
> 
> try:
>     1/0
> except C:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
2
```

Класс `C` более специфичен, чем `ZeroDivisionError`, и выбрасываемое исключение не является его подклассом

---
> Что выведет этот код?
> 
> ```python
> try: 1/0
> except ZeroDivisionError: 1 + ''
> ```

```shell
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

В v3 автоматически запоминается контекст, и выводится информация об обоих ошибках, если одна возникла в процессе обработки другой

---
> Что выведет этот код?
> 
> ```python
> print(print(1), print(2))
> ```

```python
1
2
None None
```

`print()` возвращает `None`

---
> Что выведет этот код?
> 
> ```python
> 1e1
> 1e2
> ```

```python
10.0
100.0
```

`e|E` обозначает степень десятки

---
> Как выполнить тесты (doctest) в комментариях? Приведите 2 варианта

Запустив скрипт с кодом:

```python
import doctest

if __name__ == '__main__':
    doctest.run_docstring_examples(<func>, globals())
```

Или запустив doctest как скрипт и передав ему свой скрипт в качестве параметра:

```shell
$ python3 -m doctest <file>
```

---
> Что выведет этот код?
> 
> ```python
> [[]]*3
> ```

```python
[[], [], []]
```

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [[]]*3
> x.append(1)
> ```

```python
[[], [], [], 1]
```

---
> Что выведет этот код?
> 
> ```python
> -1 - -1
> ```

```python
0
```

---
> Напишите функцию, сравнивающую два дробных числа

```python
def approx_eq(x, y, tolerance=1e-5):
    return abs(x - y) < tolerance
```

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [[]]*3
> x[0].append(1)
> ```

```python
[[1], [1], [1]]
```

`[[]]*3` создает три ссылки на один и тот же список

---
> Каково поведение оператора `//` для разных типов данных?

- если хотя бы один аргумент дробный (`5.0//2`, `-5//2.0`) результат тоже дробный (`2.0`)
- т.е. результат будет иметь тип `int` только если оба аргумента `int` (`5//2 = 2`)
- при этом всегда идет округление вниз: `5.0//2 = 2.0`, `-5//2.0 = -3.0`

---
> Напишите однострочник генерации пустой квадратной матрицы размера `n`

```python
[[None for i in range(n)] for j in range(n)]
```

или

```python
[[0]*n for _ in range(n)]
```

Использовать `[[0]*n]*n` нельзя: внутренний список будет продублирован как shallow-клон

---
> Напишите однострочник, строящий подмножество всех слов длиной не меньше 5 символов, для которых в исходном множестве есть обратное слово

```python
{ w for w in words if len(w) >= 5 and w[::-1] in words }
```

---
> Что выведет этот код?
> 
> ```python
> two = print(2)
> print(two)
> ```

```python
2
None
```

`print()` возвращает `None`

---
> Какая есть альтернативная запись операторов в Python?

Как функций. Их можно импортировать из модуля operator:

```python
from operator import add, mul

2 + 3 * 4 + 5 # = 19
add(add(2, mul(3, 4)) , 5) # = 19
```

---
> Что делает функция `random.uniform()`?

Получает 2 аргумента и возвращает псевдослучайный `float`, лежащий между ними (`a <= N <= b`). Если второй аргумент меньше первого, они прост меняются местами

---
> Как заполнить матрицу значениями вне главной диагонали?

В два цикла, вложенный перебирает до текущего счетчика внешнего:

```python
for i in range(n):
    for j in range(i):
        matrix[i][j] = matrix[j][i] = ...
```

Нужно предварительно сгенерировать пустую матрицу

---
> Что выведет этот код?
> 
> ```python
> i = 4
> def foo(x):
>     def bar():
>         print(i, end='')
> 
>     for i in x:
>         print(i, end='')
>     bar()
> 
> foo([1, 2, 3])
> ```

`1 2 3 3`, последняя цифра не `4`: `i` - локальна для `foo()` и будет последним результатом счетчика цикла

---
> Что выведет этот код?
> 
> ```python
> x = 3
> addr = id(x)
> x += 1
> addr == id(x)
> ```

```python
False
```

Числа неизменяемы, даже составное присваивание не изменит объект, а просто переназначит ссылку (установит ее на временный объект)

---
> Что выведет этот код?
> 
> ```python
> 2 == 2 and 0 == 0
> ```

```python
True
```

Операторы сравнения имеют более высокий приоритет, чем логические связки

---
> Что выведет этот код?
> 
> ```python
> "bc" in "abcde" == True
> ```

```python
False
```

Код эквивалентен

```python
"bc" in "abcde" and "abcde" == True
```

Для этой группы операторов цепочки условий разбиваются на части при помощи связки `and`

---
> Что выведет этот код?
> 
> ```python
> x = [1, 2, 3]
> x[1:1] = [4]
> ```

```python
[1, 4, 2, 3]
```

Это альтернативный способ вставки элементов в список

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][1:1]
> ```

```python
[]
```

При совпадающих индексах срез всегда пустой

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][-2:-1]
> ```

```python
[2]
```

Для приведения сложим отрицательные индексы с длиной. Получим `[1:2]`

---
> Что выведет этот код?
> 
> ```python
> list(range(10))[-5:]
> ```

```python
[5, 6, 7, 8, 9]
```

Все элементы начиная с `(10-5)`-го

---
> Что выведет этот код? Какие есть альтернативные записи?
> 
> ```python
> list(range(10))[10:0:-2]
> ```

```python
[9, 7, 5, 3, 1]
```

Любой из индексов начала/конца можно опустить: `[10:0:-2]` ~ `[10::-2]` ~ `[:0:-2]` ~ `[::-2]`

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (['a'], ['b'])
> x[1] = 'c'
> ```

`TypeError: 'tuple' object does not support item assignment`

Кортежи неизменяемы, доступ по индексу только на чтение, присваивать значения нельзя

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (['a'], ['b'])
> x[1][0] = 'c'
> ```

```python
(['a'], ['c'])
```

Хотя кортежи и неизменяемы, здесь заменяется не элемент кортежа, а первый элемент его изменяемого элемента - списка в позиции `1`

В целом, такая практика - кортежи из элементов изменяемых типов - не рекомендована

---
> Что выведет этот код?
> 
> ```python
> x = [1]
> addr = id(x)
> x[:] = [2]
> addr == id(x)
> ```

```python
True
```

Переприсваивание через полный срез не меняет адрес объекта, а перезаписывает его

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = list(range(6))
> del x[::2]
> ```

```python
[1, 3, 5]
```

Удалены элементы под индексами `0`, `2`, `4` (значение совпадают с индексами)

---
> Что выведет этот код?
> 
> ```python
> for d in {1: 2, 3: 4}:
>     print(d)
> ```

```python
1
3
```

Итерация по словарю всегда идет по его ключам, не по парам или значениям

---
> Что выведет этот код?
> 
> ```python
> test = [1, 2, 3]
> 
> for test[1] in 'xyz':
>     print(test)
> ```

```python
[1, 'x', 3]
[1, 'y', 3]
[1, 'z', 3]
```

В качестве целевой переменной цикла может служить всё что угодно, в том числе элемент списка

---
> Что выведет этот код?
> 
> ```python
> for i in []:
>     pass
> print(i)
> ```

`NameError: name 'i' is not defined`

Целевая переменная цикла инициализируется лишь тогда, когда итерируемая последовательность непуста. Иначе не выполняется ни тело цикла, ни присваивание `i`

---
> Что выведет этот код?
> 
> ```python
> for x in []:
>     print(1)
> else:
>     print(2)
> print(3)
> ```

```python
2
3
```
Коллекция `[]` пустая, цикл не выполнится ни разу. Но выход не по `break`, и `else` будет выполняться

---
> Что выведет этот код?
> 
> ```python
> def f(x, y=[]):
>     y.append(x)
>     return y
> 
> print (f(23))
> print (f(42))
> ```

```python
[23]
[23, 42]
```

Значение именованного параметра вычисляется единожды, в момент объявления функции

---
> Что выведет этот код?
> 
> ```python
> def f(x, y):
>     х = 23
>     y.append(42)
>
> a = 77
> b = [99]
> f(a, b)
> print(a, b)
> ```

```python
77 [99, 42]
```

Числа и прочие неизменяемые объекты передаются в функцию по значению, тогда как изменяемые объекты (напр., списки) - по ссылке

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     y += 1
> f()
> print(y)
> ```

`UnboundLocalError: local variable 'y' referenced before assignment`

Идет попытка записи в глобальную переменную без явного указания директивы `global`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
> 
> f()
> print(x)
> ```

`NameError: name 'x' is not defined`

Присваивание (инициализация `x`) обязательно: `global <var>` не является "объявлением" переменной с пустым значением

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
>     x = 1
> 
> f()
> print(x)
> ```

```python
1
```

Создавать глобальные переменные из функций вполне можно

---
> Что выведет этот код?
> 
> ```python
> def f():
>     x = 1
> 
>     def g():
>         x += 1
> 
>     g()
>     return x
> 
> print(f())
> ```

`UnboundLocalError: local variable 'x' referenced before assignment`

Ситуация аналогична доступу на запись к глобальным переменным: `x += 1` нельзя вызывать, т.к. внутри функции `g()` переменная `x` из внешней функции по умолчанию доступна только на чтение. Нужно либо инициализировать (создать) свою переменную `x` внутри `g()`, либо указать перед составным сложением директиву `nonlocal x`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     def g():
>         nonlocal y
>         y = 2
> 
>     g()
>     return y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

В отличие от `global`, создавать переменные внешних функций из внутренних нельзя

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     def g():
>         nonlocal y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

Директива `nonlocal` просматривает только вложенные функции, не глобальную область видимости. Поэтому глобальный `y` рассматриваться не будет

Кроме того, в отличие от `global` она уже выбрасывает ошибку, если не найдет указанную в директиве переменную

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> print(type(A), type(A()))
> ```

`<class 'type'> <class '__main__.A'>`

---
> Напишите базовую реализацию синглтона

```python
class Singleton:
    _instances = {}

    def __new__(cls, *args, **kwds):
        if cls not in cls._instances:
            cls._instances[cls] = super().__new__(cls)

        return cls._instances[cls]
```

После `.__new__()` будет автоматически вызван `.__init__()`, так что нужно позаботиться еще и том, чтобы инициализация учитывала единственность экземпляра

---
> Что выведет этот код при запуске с одной и с двумя `-O`?
> 
> ```python
> def test():
>     """Doctsring."""
> 
> print(test.__doc__)
> ```

```python
# с одной -O
'Doctsring.'
# с двумя -O строки документации будут удалены
None
```

---
> Что выведет этот код?
> 
> ```python
> x = [1,2]
> addr = id(x)
> x += [2]
> print(id(x) == addr)
> ```

```python
True
```

Составное сложение (конкатенация) списков не изменит адреса объекта
---
> Что выведет этот код?
> 
> ```python
> x = (1,2)
> addr = id(x)
> x += (2,)
> print(id(x) == addr)
> ```

```python
False
```

В отличие от списков кортежи неизменяемы, и даже составное присваивание (конкатенация) не сохранит адрес объекта

---
> Что выведет этот код?
> ```python
> def f(x, msg=None):
>     if msg:
>         print(msg, end=',')
>     return x
> 
> print(f(1) < f(2) < f(3, 'last'))
> print(f(2) < f(1) < f(3, 'last'))
> ```

```shell
last,True
False
```

Цепочки сравнений разворачиваются в выражения с `and`, которые вычисляются по короткой цепи. Во втором случае `2 < 1 == False`, и следующее за ним выражение `... and f(3)` уже не вычисляется

---
> Что выведет этот код?
> 
> ```python
> class A:
>     def test(self):
>         pass
> 
> print(A.test, A().test)
> ```

`<function A.test at 0x7f...> <bound method A.test of <__main__.A object at 0x7f...>>`

Методы экземпляра являются объектами *связанных методов* (bound methods), а атрибуты класса - просто объектами функций

> На уровне класса это будут *несвязанные методы* - `<unbound method A.test>`

---
> Что выведет этот код?
>
> ```python
> class A:
>     def x(self):
>         pass
> 
> def y():
>     pass
> 
> a = A()
> a.y = y
> 
> print(a.x)
> print(a.y)
> ```

```shell
<bound method A.x of <__main__.A object at 0x7f...>>
<function y at 0x7f...>
```

Python не создает связанные методы для функций из словаря экземпляра `C().__dict__`, только для атрибутов класса. И только для атрибутов класса, объект-метод (являющийся дескриптором) вызовет свой `.__get__()` и вернет объект типа `bound method`

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> print(A.__mro__)
> ```

`(<class '__main__.A'>, <class 'object'>)`

Read-only кортеж включает также и сам класс

---
> Что выведет этот код?
> 
> ```python
> class A:
>     @property
>     def x(self): return 1
> 
> class B(A):
>     def x(self): return 2
> 
> print(B().x)
> ```

`<bound method B.x of <__main__.B object at 0x7f...>>`

Декораторы не наследуются

---
> Что выведет этот код?
> 
> ```python
> class A:
>     def x(self): return 1
>     y = property(x)
> 
> class B(A):
>     def x(self): return 2
> 
> print(B().y)
> ```

```python
1
```

Конструктор свойства получает объект метода в момент выполнения тела класса `A`, а не динамически, в процессе выполнения скрипта. Поэтому, единожды "обернув" метод, он всегда будет возвращать значение из класса `A`

Это можно обойти, использовав еще один уровень косвенности. Или через декоратор, повторяя его в каждом дочернем классе

---
> Что выведет этот код?
> 
> ```python
> def fake_get_item(n):
>     return n
> 
> class A:
>     def __getitem__(self, n):
>         return fake_get_item(n)
> 
> class B:
>     pass
> 
> a, b = A(), B()
> b.__getitem__ = fake_get_item
> 
> print(a[3])
> print(b[3])
> ```

```shell
3
TypeError: 'B' object is not subscriptable
```

Специальный методы нельзя связывать на уровне экземпляра, только на уровне класса

---
> Что выведет этот код?
> 
> ```python
> class A(dict, list):
>     pass
> ```

`TypeError: multiple bases have instance lay-out conflict`

Хотя язык позволяет наследование от встроенных типов, оно не безусловное, и иногда невозможно, если типы несовместимые

---
> Что выведет этот код?
> 
> ```python
> class A:
>     x = 1
>     def __getattr__(self, name):
>         print('get attr')
>     def __setattr__(self, name, val):
>         print('set attr')
> 
> A().x = 2
> ```

`set attr`

В отличие от `.__getattr__()` специальный метод установки вызывается всегда, а не только когда атрибута нет

---
> Что выведет этот код?
> 
> ```python
> class A:
>     x = 1
>     def __setattr__(self, name, val):
>         print(getattr(self, name))
> 
> A().x = 2
> ```

```python
1
```

Без вызова

```python
super().__setattr__(name, val)
```

в начале метода в словарь `self.__dict__` ничего записано не будет

После добавления этого вызова `print()` выведет `2`

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> def x(self, y):
>     print(self, y)
> 
> A.x = x
> A().x(1)
> ```

`<__main__.A object at 0x7f...> 1`

Задавать методы вполне можно и вне тела класса, и это будут полноценные *связанные* методы

---
> Что выведет этот код?
> 
> ```python
> x: int
>
> if x:
>     print('inside if')
> ```

`NameError: name 'x' is not defined`

"Объявления" вида `x: int` не создают переменную, без начального присваивания она не существует

---
> Что выведет этот код?
> 
> ```python
> -2**2
> ```

```python
-4
```

Унарный минус в записи `-2` - это оператор, не часть литерала, поэтому на него распространяется приоритет. Оператор же возведения в степень приоритетней унарного минуса

---
> Как записать следующий код через `type()`?
> 
> ```python
> class A(B):
>     pass
> ```

```python
A = type('A', (B,), {})
```

Вызов `type()` с тремя параметрами создает класс "на лету"; родительские классы должны попадать в кортеж - второй аргумент

---
> Что выведет этот код?
> 
> ```python
> class A: pass
> 
> print(A.__class__)
> print(A().__class__.__class__)
> ```

```shell
<class 'type'>
<class 'type'>
```

Дефолтным метаклассом всех классов является `type`

---
> Что выведет этот код?
> 
> ```python
> type.__class__
> ```

```shell
<class 'type'>
```

`type` является собственным метаклассом

Это нельзя реализовать на самом языке, сделано на уровне внутренней реализации

---
> Что выведет этот код?
> 
> ```python
> try: pass
> except NonExistingClass: pass
> ```

Ничего, отработает нормально. Обработчик исключения (блок `except:`) выполняется только в случае, когда выброшено исключение

То есть ошибку (`NameError: name 'NonExistingClass' is not defined`) вызовет только вот такой код:

```python
try: 1/0
except NonExistingClass: pass
```

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except ZeroDivisionError:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
1
```

Обработчики исключений просматриваются в порядке объявления, и выполняется только один - первый

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

Ошибку `SyntaxError: default 'except:' must be last`

---
> Что выведет этот код?
> 
> ```python
> try: pass
> except: pass
> else: print(1)
> finally: print(2)
> ```

```python
1
2
```

`else` будет выполнено т.к. исключения в `try` выброшено не было. `finally` выполняется всегда

---
> Что выведет этот код?
> 
> ```python
> try: pass
> else: print(1)
> finally: print(2)
> ```

`SyntaxError: invalid syntax`

Блок `else` может присутствовать только если есть хотя бы один `except`

---
> Что выведет этот код?
> 
> ```python
> try:
>     try: 1/0
>     except: print(1)
>     finally: print(2)
> except:
>     print(3)
> ```

```python
1
2
```

Внутренний `except` перехватит исключение и дальше оно распространяться не будет. При этом блок `finally` выполнится тоже: он выполняется всегда

---
> Что выведет этот код?
> 
> ```python
> try:
>     try: 1/0
>     except TypeError: print(1)
>     finally: print(2)
> except:
>     print(3)
> ```

```python
2
3
```

Будет выброшено `ZeroDivisionError`, оно не будет перехвачено внутренним `except`, и распространение исключения продолжится. `finally` выполняется всегда, но не подавляет распространение исключения

---
> Что будет, если в REPL-е присвоить значение переменной `_`?

Будет создана локальная переменная, которая скроет встроенную `builtins._`

---
> Как узнать версию пакета?

- через командную строку: `$ python3 -m pip show <package>`
- сразу для нескольких пакетов: : `$ python3 -m pip {list|freeze} | grep <package>`
- через код: : `$ python3 -c 'import <package>; print(<package>.__version__)`

Последний вариант будет иногда падать: не все пакеты/модули имеют атрибут `.__version__` (это лишь рекомендация, задавать в Python-коде такое значение)

---
> Какие (и на каких языках) есть реализации Python?

- *CPython* - на C, самая поддерживаемая (*референсная*)
- *Jython* - на Java, для взаимодействия с кодом на Яве
- *Python for .NET*, *IronPython* - оба для .NET, первая использует CPython, вторая написана на Python
- *PyPy* - полностью на Python, поддерживает stackless и JIT

---
> Для какой реализации Python рассматриваются все вопросы здесь?

Для *CPython*, наиболее распространенной

---
> Какие два самых известных линтера для Python?

PyFlakes (более простой) и PyLint (более тяжелый, но с б*о*льшими возможностями)

---
> Какие есть способы выйти из REPL?

- `quit()`
- `sys.exit()`
- `raise SystemExit[()]`
- `Ctrl + D` (EOF)
- `Ctrl + Z` (SIGTSTP; не сохраняет историю)

Первые три завершают также любой скрипт

---
> Как получить последний результат в REPL?

Переменная "подчеркивание", `_`

---
> Как выглядят и где задаются строки приглашений в REPL?

Их два уровня, первый и второй. Задаются в модуле `sys`:

```python
sys.ps1 == '>>> '
sys.ps2 == '... '
```

---
> Что будет, если запустить интерпретатор с именем папки или zip-файла в качестве аргумента?

Будет искать в папке или zip-архиве файл с именем `__main__.py`, и выполнит его с `__name__ == '__main__'`

---
> Сработает ли команда `$ cat test.py | python3`?

Да, она так же выполнит скрипт, как и

```shell
$ python3 test.py
```

---
> Как вызвать краткую справку по консольной команде `$ python3`?

Три варианта опции: `-?`/`-h`/`--help`

---
> Как узнать версию интерпретатора?

Не стоит путать с маленькой `-v` (verbose): `-V`/`--version`. Удвоение любой из этих опция дает чуть более подробное описание версии

---
> Для чего служит опция командной строки `-c`?

Выполняется следующая за опцией команда:

```shell
$ python3 -c 'print(3)'
```

Текущая директория подставляется в начало `sys.path` (это позволяет импортировать локальные модули)

---
> Что делает опция командной строки `-m`?

Находит в `sys.path` модуль по имени (без расширения `.py`), следующему за опцией, и исполняет его как скрипт - с `__name__ == '__main__'`. Как и для `-c`, текущая директория подставляется в начало `sys.path`

---
> Допустимы ли имена пакетов с cli-опцией `-m`?

Да. В этом случае интерпретатор будет искать (и выполнять как скрипт) модуль `<pkg>.__main__`. Поведение аналогично тому, когда вместо скрипта интерпретатору передается папка или zip-файл

---
> Как получить список всех вкомпилированных (встроенных) в интерпретатор модулей?

`sys.builtin_module_names` возвращает кортеж с именами. Примеры: `sys`, `itertools`, `time`, `zlib`

---
> В каких случаях опция `-m` неприменима?

Для встроенных (`sys.builtin_module_names`) модулей и модулей, написанных на C - выдает ошибку `"No code object available for <module>"`

Для precompiled-модулей эта опция использоваться может

---
> Как передать модулю, выполняемому в режиме скрипта, параметры?

Просто перечислить их после имени модуля, например:

```shell
$ python3 -m doctest test.py # "test.py" - параметр модуля
$ python3 -m venv -h         # "-h" - параметр модуля
```

---
> Есть ли у команды `$ python3` длинные варианты опций?

Только три (`--help`, `--version`, `--check-hash-based-pycs`), для большинства же только короткие

---
> Что делает опция `-s`?

Не добавляет в `sys.path` директорию `~/.local/lib/python3.n/site-packages/` (константа `site.USER_SITE`)

---
> Что делает опция `-S`?

Запрещает авто-импорт модуля `site`. Из-за этого в `sys.path` не попадают все директории `(dist|site)-packages/`, остается только `/usr/lib/python3.n/`

Игнорирует также пользовательский каталог (`~/.local/lib/python3.n/site-packages/`), т.е. неявно подразумевает `-s`

---
> Что делает опция `-E`?

Игнорирует все переменные окружения `PYTHON*`

---
> Что делает опция `-I`?

Запускает интерпретатор в "изолированном" режиме: не учитывает переменные окружения и пользовательский каталог `site-packages` (т.е. неявно включает опции `-sE`, и кроме того не включает в `sys.path` каталог текущий)

---
> Что делает опция `-i`?

Интерпретатор переходит в интерактивный режим после выполнения переданного скрипта / команд из `stdin`. В этом интерактивном сеансе доступны все переменные из выполненного скрипта

---
> Что делает опция `-x`?

Пропускает первую строку в выполняемом скрипте (для игнорирования не-NIX shebang-ов)

---
> Какие значения принимает и что делает переменная `PYTHONINSPECT`?

Переменная-флаг, при любом непустом значении переводит интерпретатор в интерактивный режим после выполнения переданного скрипта. Аналогична опции `-i`

---
> Как запретить запись `.pyc`-файлов?

Установить значение переменной окружения `PYTHONDONTWRITEBYTECODE` в непустую строку, или вызывать интерпретатор с опцией `-B`

Эта опция установит значение `sys.dont_write_bytecode` в `True`

---
> Как удалить отладочный код при исполнении скрипта?

Удалить все ассерты и весь код, зависящий от значения `__debug__`, можно через опцию `-O` или переменную окружения `PYTHONOPTIMIZE` (равную непустой строке, или целому, равному числу повторений опции `-O`)

---
> Как в коде определить, что установлена переменная среды `PYTHONOPTIMIZE` / указана опция `-O[O]`?

Проверив "магическую" переменную `__debug__ = True|False`

В коде таким образом можно убирать целые секции, например, экономить время компиляции, скрывая используемые только в `assert`-ах функции:

```python
if __debug__:
    def my_assert_check():
        ...
```

---
> Как отключить docstrings в коде?

Вызвать интерпретатор с опцией `-OO`

Расширения генерируемых файлов байткода станут `.opt-2.pyc`

---
> Как выводить информацию об импорте/выгрузке всех модулей при выполнении скрипта?

Опция `-v` или переменная окружения `PYTHONVERBOSE` (равная непустой строке, или целому, равному числу повторений опции `-v`)

---
> Сколько раз интерпретатор выводит warning для строчки кода?

По умолчанию - один раз, это соответствует `-Wdefault`/`-Wd`. Можно поменять, например на `-Walways`/`-Wa` или `-Wignore`/`-Wi`

Те же ключи можно присваивать переменной окружения `PYTHONWARNINGS`, например, `PYTHONWARNINGS=module` (once per calling module) или `PYTHONWARNINGS=once` (once per Python process)

---
> Как превратить все warning-и в исключения?

Вызвать интерпретатор с опцией `-Werror`/`-We`, или установить переменную окружения в `PYTHONWARNINGS=error`

---
> Как можно управлять настройками интерпретатора Python?

Через пару десятков переменных окружения `PYTHON*=<some-val>` и через опции (с одним дефисом) `python3 -<opt>`. Часто переменные дублируют опции (и наоборот)

Некоторые переменные, при равенстве непустой строке, соответствуют одной опции, а при равенстве положительному числу - числу повторений этой опции:

```shell
PYTHONVERBOSE="some" ~ py3 -v
PYTHONVERBOSE=3 ~ py3 -vvv
```

---
> Как получить справку модуля по запуску его в режиме скрипта?

Стандартным способом передачи аргументов модулю, передав `-h/--help`:

```shell
$ python3 -m timeit -h
```

---
> Как выполнить Python скрипт из кода?

В модуле `runpy` есть нужная функция. По умолчанию `run_name='<run_path>'`:

```python
import runpy
runpy.run_path('./test.py', run_name='__main__')
```

---
> Как из командной строки изменить путь поиска модулей (`sys.path`)?

Задать переменную окружения, *дополняющую* путь поиска - `PYTHONPATH`:

```shell
PYTHONPATH=/some/dir/ python3 test.py
```

По умолчанию она пуста

---
> За что отвечает и какой формат имеет переменная окружения `PYTHONPATH`?

Помогает добавлять свои пути в `sys.path`, для поиска модулей. Ее формат аналогичен стандартной `PATH` - пути, разделенные `os.pathsep`

---
> В какую позицию списка `sys.path` добавляется значение переменной окружения `PYTHONPATH`?

В индекс `1` - после текущей директории, но перед первой системной:

```python
sys.path == ['', <PYTHONPATH dirs>, '/usr/lib/python37.zip', ...]
```

---
> Чему равен `sys.path[0]`?

Папке, из которой запускается скрипт, или пустой строке, при выполнении команд через `-c '...'` или из `stdin`

Во втором случае поиск модулей/пакетов всё равно будет вестись начиная с текущего каталога

---
> Чему равна `os.pathsep` на разных системах? Где используется?

Двоеточию `:` на *NIX и точке с запятой `;` на Windows. Используется в:

- `PYTHONHOME` (`<prefix>:<exec_prefix>`)
- `PYTHONPATH` (`<path1>:<path2>:...`)
- в системном `PATH`

---
> Как можно выполнить команды Python до показа первого приглашения REPL?

В переменной окружения `PYTHONSTARTUP` указать путь к Python-скрипту. Все импортированные/созданные в нем объекты станут доступны и в сессии REPL

Так же можно, например, поменять формат приглашений `sys.ps1`/`sys.ps2`

---
> Что будет, если в переменной среды `PYTHONSTARTUP` указать несуществующий скрипт, или скрипт, для которого нет прав доступа?

Ничего, система проигнорирует значение, даже предупреждения не выдаст

---
> Какая рекомендуемая *shebang*-строка для скриптов?

```shell
#!/usr/bin/env python3
```

И нужно не забывать делать скрипт исполняемым:

```shell
$ chmod +x script
```

---
> Как можно запускать команды shell-а из Python-скрипта?

Есть модуль `subprocess`, и у него функция `run()`. Например:

```python
import subprocess

subprocess.run(['ls', '-l'])
```

---
> Что будет делать команда `$ python3 -`?

Читать инструкции из `stdin`. Это режим по умолчанию, без дефиса будет то же самое. Если ничего на вход нет, то переход в интерактивный режим (`-i`).

Дефис служит для отделения аргументов командной строки от инструкций из `stdin`. Эти аргументы пишутся в `sys.argv`

---
> В каком случае команда `$ python3` читает инструкции из `stdin`?

Если после нее стоит дефис (placeholder) или отсутствует любая лексема. Если в `stdin` инструкций нет, то переход в интерактивный режим

---
> В каких случаях Python компилирует скрипты и сохраняет байткод?

Компилирует всегда

Пишет:

- на диск - при импорте модулей (и только если не установлена `PYTHONDONTWRITEBYTECODE` и не указана опция `-B`)
- в память - для обычных скриптов

---
> Где хостится исходный код CPython?

На ГитХабе: <https://github.com/python/cpython>. Там же рядом репозиторий с PEPами

---
> Откуда можно установить Python?

- скачать с оф. сайта (<https://www.python.org/downloads/>) исходники и собрать (`./configure; make; sudo make altinstall`)
- те же исходники можно склонировать с ГитХаба - <https://github.com/python/cpython>
- в Ubuntu все пакеты включены в дистрибутив. Есть в APTе, и в SNAPах есть отдельные версии и имплементации (CPython, конечно)

---
> Какие *3 пути* на файловой системе хранят файлы инсталляции?

- `/usr/bin/python3` (--> `./python3.n`) - бинарник интерпретатора
- `/usr/lib/python3.n/` - папка со стандартными модулями
- `/usr/include/python3.n/` - папка с заголовочными `.h`-файлами, нужными для разработки расширений и встраивания интерпретатора

---
> В каких папках хранятся установленные пакеты и модули?

- `/usr/lib/python3.n` - идущие вместе с интерпретатором, стандартная библиотека
- `/usr/lib/python3/dist-packages/` - пакеты, установленные через глобальный менеджер (напр., `apt`)
- `/usr/local/lib/python3.n/dist-packages/` - установленные глобально через `pip`
- `~/.local/lib/python3.n/site-packages/` - установленные локально через `pip` (без `sudo` и/или с опцией `--user`)

---
> Как узнать *базовую* директорию *пользователя* для пакетов и бинарников?

Это константа в модуле `site` - `site.USER_BASE`. Вывести ее можно через командную строку:

```shell
$ python3 -m site --user-base
```

Туда `pip` устанавливает пакеты. Как правило это папка `~/.local/` с тремя подпапками:

- `bin/` (туда идут бинарники, standalone-утилиты)
- `lib/` (сами пакеты)
- `share/`

---
> Являются ли модули `venv` и `pip` частью стандартной библиотеки Python?

`venv` является с v3.3, а `pip` - сторонний проект (<https://pip.pypa.io/en/stable/>), хотя с v3.4 он по умолчанию включается в дистрибутив Python

---
> За что отвечает переменная окружения `PYTHONHOME`?

Она может задавать т.н. *префикс* - базовую директорию для поиска папок с пакетами/модулями: `<prefix>/lib/python3.n/`. В случае, если эта переменная пуста, берется префикс `/usr`. Переменная отвечает именно за каталоги пакетов, не самого интерпретатора

---
> Куда Python сохраняет скомпилированный байткод модулей?

В папку `__pycache__/`. В нее складываются файлы (вида `*.cpython-38[.opt-(1|2)].pyc`) импортированных модулей

---
> Как формируется расширение у файлов со скомпилированным байткодом?

`<implemetation>-<version>.pyc`:

- `__pycache__/__init__.cpython-36.pyc`
- `__pycache__/testplugin.cpython-37.pyc`

---
> Как опции оптимизации влияют на расширение файлов байткода?

Перед `.pyc` добавляется `.opt-(1|2)`, в зависимости от количества указанных `-O`:

```shell
__pycache__/__init__.cpython-38.opt-1.pyc
__pycache__/testplugin.cpython-37.opt-2.pyc
```

Файлы складываются рядом в `__pycache__/`, а не перезаписываются.

До v3.5 схема была другая - `.pyc` заменялся на `.pyo`

---
> Какая утилита рекомендована для установки пакетов и модулей? Как ее запустить?

*PIP*, менеджер пакетов, в поставке идет по умолчанию. Две формы ее запуска для установки модуля:

```shell
$ pip3 install <package>
# предпочтительная форма вызова, авто-выбор версии языка
$ python3 -m pip install <package>
```

---
> Как получить справку по какой-либо команде `pip`?

Аналогично общей справке по модулю, но еще и указав нужную команду. Например:

```shell
$ python3 -m pip install --help
$ python3 -m pip list -h
```

---
> Как `pip`-у указать точную и минимальную версию пакета?

```shell
$ python3 -m pip install SomePackage==1.0.4
$ python3 -m pip install "SomePackage>=1.0.4"
```

Символы `>`/`<` интерпретируются шеллом, поэтому выражение взято в кавычки

---
> Где при вызове `pip` должны располагаться опции команд, а где самого модуля?

Опции команд после самой команды, опции менеджера - после `pip` и перед командой:

```shell
$ python3 -m pip -v freeze --user
```

Здесь `-v` (verbose) относится к `pip`, а `--user` - к `freeze`

---
> Как `pip`-ом обновить модуль?

```shell
$ python3 -m pip install (--upgrade|-U) SomePackage
```

---
> Как установить модуль локально, в домашний каталог пользователя?

Запускать `$ python3 -m pip install` без `sudo` (не хватит прав на запись в общесистемные директории), и/или указывать опцию `--user` (тогда и предупреждения показано не будет)

---
> Как установить модуль для конкретной версии Python?

Запускать интерпретатор именно этой версии для установки:

```shell
$ python3.7 -m pip install
# или
$ python3.3 -m pip install
# и.д.
```

---
> Есть ли модуль `pip3`?

Нет, есть только одноименная утилита в `~/.local/bin/`. Поэтому писать

```shell
$ pip3 install
```

можно, а

```shell
$ python3 -m pip3
```

нельзя

---
> Что такое *PyPI*?

*Python Package Index*, открытый репозиторий для открытых же пакетов: <https://pypi.org>. Используется командой `pip` по умолчанию

---
> Что такое *PyPA*?

*Python Packaging Authority*, рабочая группа, разрабатывающая проекты, связанные с Python-пакетами, такие как `pip`, `wheel`, `pipenv` и другие: <https://www.pypa.io>

---
> Почему научные пакеты лучше устанавливать не через `pip`?

Они часто тянут сложные бинарные зависимости. Лучше использовать предназначенные для этого менеджеры, типа *Conda*

---
> Что делает `pip freeze`?

(Построчно) выводит список всех установленных пакетов в формате `<name>==<version>`

---
> Как создать *файл требований*, состоящий только из локально установленных пакетов пользователя?

Использовать опцию `--user`:

```shell
$ python3 -m pip freeze --user > requirements.txt
```

---
> Как установить все пакеты из *файла требований*?

Использовать опцию `-r`:

```shell
$ python3 -m pip install -r requirements.txt
```

---
> Назовите 4 основных причины использования *файлов требований*

1. *Воспроизводимые установки* (repeatable installations) - копирование одной среды в другую через `pip freeze/install`
1. *Истинное разрешение зависимостей* (true dependency resolution) - в случае, если два пакета имеют в зависимостях один и тот же пакет, но разных версий, `pip` просто установит версию из первой по порядку зависимости. С *r*-файлом это можно обойти, явно указав в нем версию зависимого пакета для установки
1. *Принудительное указание версии*. Похож на пред. пункт - зависимый пакет указывается в файле явно; но служит лишь для того, чтобы не бралась автоматически последняя версия (напр., в ней баг), а подтягивалась указанная
1. *Получение последней версии из VCS*. Если в репозитории пакетов еще нет нужного (хот)фикса, можно указать в *r*-файле получение пакета из VCS: `git+https://...@sometag`

---
> Откуда `pip` может ставить пакеты?

Из PyPI по умолчанию, и из других источников:

```shell
# из VSC - в т.н. editable-режиме
$ pip install -e git+https://git.repo/some_pkg.git#egg=SomeProject
# из произвольного индекса
$ pip install --index-url http://my.package.repo/simple/ SomeProject
# поиск в PyPI + произвольный индекс
$ pip install --extra-index-url http://my.package.repo/simple SomeProject
# из локальной папки или файла
$ pip install [-e] <path>
# из локальных архивов
$ pip install ./downloads/SomeProject-1.0.4.tar.gz
```

---
> Как через `pip` можно установить дополнительные зависимости пакета ("extras")?

Указать их в квадратных скобках после имени:

```shell
$ pip install SomePackage[PDF]
$ python3 -m pip install aiohttp[speedups]
```

---
> Какая утилита рекомендована для управления зависимостями в процессе разработки Python-приложения?

*Pipenv* (объединяет `pip` и `venv`), а если она не подходит, то pip, pip-tools, или *Poetry*

<https://packaging.python.org/guides/tool-recommendations/>

---
> Как в `pip` показать информацию о пакете? А список файлов?

```shell
$ python3 -m pip show <package>
$ python3 -m pip show --files <package>
```

---
> Как в `pip` показать все пакеты, для которых есть более новые версии?

```shell
$ python3 -m pip list --outdated
```

---
> Как в `pip` называется команда удаления пакета?

`uninstall`

---
> Как в `pip` называется команда поиска пакетов?

`search`

---
> Как в `pip` называется команда скачивания пакета?

`download`

---
> Можно ли использовать `pip` программно?

Чисто технически `import pip` выполняться будет, но это крайне не рекомендуется: `pip` не предназначен для такого использования. Вызов же его как подпроцесса вполне допустим и это полностью рабочий вариант:

```python
import subprocess

subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'my_package'])
```

---
> Как сделать автодополнение команд `pip`?

Добавить вывод команды `completion` в профайл юзера:

```shell
$ python3 -m pip completion --bash >> ~/.bashrc
```

или вставить туда же

```shell
eval "$(python3 -m pip completion --bash)"
```

Работает только для standalone-утилиты (`$ pip ...`)

---
> Как `pip`/`venv` и `conda` рассматривают сам интерпретатор Python?

Для `conda` он такой же пакет - его можно обновить/удалить/выбрать версию, тогда как `pip` занимается только лишь модулями/пакетами языка

---
> Для чего нужны виртуальные окружения?

Изоляция:

- создания предсказуемого, повторяемого окружения. Это защитит от появления ошибок при переносе программы на другой сервер
- одновременная разработка на одной машине нескольких проектов с разными версиями зависимостей

---
> Какая стандартная утилита для создания виртуальных сред? Как ее запустить?

*VENV*, в поставке идет по умолчанию. Как и `pip`, это модуль Python:

```shell
# выдает предупреждение, что такая форма вызова deprecated
$ pyvenv <dir>
# больше чем предпочтительна
$ python3 -m venv <dir>
```

---
> Как активировать среду, созданную `venv`?

Импортировать скрипт активации в текущий шелл:

```shell
$ source <dir>/bin/activate
```

После этого перед строкой приглашения появится название среды (напр., `(test) [~]$ `)

---
> Как деактивировать среду, созданную `venv`?

Выполнить в консоли

```shell
$ deactivate
```

Это функция, определенная в скрипте `bin/activate`, не физический скрипт, поэтому дополнительно указывать путь не требуется

---
> Устанавливает ли `venv` отдельную версию Python?

Нет, по умолчанию в папке `<env-dir>/bin` создается лишь ссылка на глобальный бинарник: `./python -> ./python3.n -> /usr/bin/python3.n`

Такое поведение можно изменить опцией `--copies`

---
> Куда в `venv` устанавливаются пакеты?

В (под)папку текущей выбранной среды:

`<env-dir>/lib/python3.n/site-packages/`

`pip` полностью корректно работает с виртуальными средами

---
> Как работает `pip install --user` в виртуальной среде?

Игнорируется, всё - и пакеты и бинарники - ставится внутрь `<env-dir>/` (где есть и `bin/` и `lib/`)

---
> Какие пакеты ставятся по умолчанию при создании виртуальной среды?

`pip` и `setuptools` (+ `pkg_resources`). Установку первого можно отменить через `--without-pip`

---
> Как создать сразу несколько виртуальных сред?

Передать команде несколько путей (имен папок):

```shell
python3 -m venv test1 test2
```

---
> Обязательно ли активировать виртуальную среду?

Нет. Активация добавляет папку `bin/` среды в системную переменную `PATH` (и устанавливает переменную окружения `VIRTUAL_ENV`), но это лишь упрощает печать команд. Если использовать полные пути для бинарника интерпретатора, то тоже будет работать

---
> Что происходит при активации виртуальной среды?

- добавление папки `bin/` среды в `PATH`
- определение команды деактивации
- изменение приглашения шелла
- установка переменной окружения `VIRTUAL_ENV` равной пути к каталогу среды

---
> Как интерпретатор определяет, что работа идет в виртуальной среде?

По наличию файла `pyvenv.cfg` на одном уровне с `bin/python[3[.n]]`, даже пустого

Если такой файл есть, `sys.prefix` устанавливается равным директории, в которой он (конф. файл) лежит

---
> Как добавить в `sys.path` путь к пакетам виртуальной среды?

Путь `lib/python3.n/site-packages` добавится автоматически (последним элементом списка), если он есть. Туда пакеты и устанавливаются

---
> Как ограничить пакеты только теми, что установлены в виртуальной среде?

В файле `pyvenv.cfg` задать `include-system-site-packages = false`. Эта опция пишется в файл конфига по умолчанию при создании виртуальной среды

Обратное действие - дать доступ до системных пакетов. Это можно сделать передав опцию при создании среды:

```shell
$ python3 -m venv --system-site-packages <path>
```

---
> Как задать виртуальной среде кастомное имя для отображения в командной строке?

Передать опцию при создании:

```shell
$ python3 -m venv --prompt <some-prompt> <path>
```

Скрипт `bin/activate` будет сгенерирован с учетом этого

---
> Какие есть ссылки из виртуальной среды на инсталляцию Python, использованную для создания этой среды?

В конфигурационном файле `pyvenv.cfg` обычно задана переменная `home = /usr/bin`

Кроме того, в самом интерпретаторе, несмотря на то что он выполняется из среды, переменная `sys.base_prefix` - всегда системный префикс (обычно `/usr`; в отличие от `sys.prefix == <env-path>`)

---
> Почему устанавливаемые при создании виртуальной среды скрипты будут в ней корректно работать?

У шелл-скриптов типа `pip`/`easy_install`, лежащих в `<env-path>/bin/`, shebang-заголовок генерируется корректно - он указывает на интерпретатор внутри самой среды, не на системный

---
> Можно ли менять поведение/создавать свои генераторы сред на основе `venv`?

Да, в отличие от `pip` модуль позволяет импортировать себя и наследовать свой класс `EnvBuilder`, меняя/дополняя функциональность. Создав такой скрипт, в нем можно вызывать `ExtendedBuilder().create(<options>)`

---
> Какая может быть нативная альтернатива `venv`?

Задание переменной окружения `PYTHONPATH`. Пути поиска пакетов будут подставлены в `sys.path` раньше системных

---
> Как обновить виртуальную среду при появлении новой версии Python?

Через вызов на той же папке с опцией `--upgrade`:

```shell
$ python3 -m venv --upgrade <path>
```
---
> Являются ли *утилиты распространения* `distutils` и `setuptools` пакетами стандартной библиотеки?

`distutils` да, а более мощный `setuptools` - сторонний проект, <https://pypi.org/project/setuptools/>

---
> Как устанавливаются пакеты, использующие `distutils` или `setuptools`?

Автор пакета выбирает, какую из двух утилит использовать, но в любом случае в пакет помещается файл `setup.py`

Для установки вызывается команда `$ python3 setup.py install` (возможно с `sudo`, если это не виртуальная среда), которая и копирует файлы пакета в нужные папки

---
> Что такое *wheel* и *eggs*?

Архивные форматы, включающие структурированные метаданные и код на Python. Используются для распространения модулей/пакетов

Их поддержка осуществляется расширениями `setuptools` и `wheels`

---
> Зачем нужен каталог `site-packages/`?

Чтобы устанавливать пакеты, которых нет глобально в системе

Прав на вмешательство в системную инсталляцию может и не быть, а установка в локальныю директорию позволяет это обойти. Такое же имя - `site-packages/` - имеют локальные папки с пакетами в snap-ах, в виртуальных средах, в проектах с исходным кодом

---
> Как программно получить доступ к переменным окружения?

Через

```python
import os

os.environ
```

---
> Как удалить виртуальное окружение, созданное `venv`?

Просто удалить папку с ним. Это удалит все пакеты

---
> Как связан каталог виртуальной среды с каталогами с исходными кодами проекта?

Никак. Исходники не обязаны располагаться внутри папки с файлами среды и наоборот. Можно иметь одну среду на несколько проектов

---
> Как включить в пакет настройки виртуальной среды, в которой он тестировался?


Распространять с пакетом файл `requirements.txt`, содержащий вывод команды `$ python3 -m pip freeze`

---
> Как лучше называть виртуальные окружения?

Использовать в именах суффиксы, равные версии Python в этом окружении

Например, `mutex_27`, `mutex_35`. Это позволит иметь несколько окружений для одного проекта (`mutex`) и легко различать их

---
> Какие есть хорошие практики по хранению каталога виртуальной среды и каталогов с исходными кодами проекта?

- не хранить их вместе, разделять папки
- под VSC-контролем хранить один только `requirements.txt`, не всё окружение

---
> Что наиболее важно в стилистике кода?

Последовательность ее применения

---
> Каков рекомендованный отступ?

4 пробела. Табы могут использоваться только в коде который уже их использует. И в этом случае только они: Python 3 запрещает смешение пробелов и табов в одном файле

> Допустимо смешивать табы и пробелы в одном файле, но отступы должны совпадать. `Tab = 8 Spaces`. По умолчанию выполняется чисто. Добавление опции `-t` при вызове интерпретатора выведет предупреждение, а `-tt` превратит это предупреждение в ошибку

---
> Как переносить длинные последовательности (напр., аргументов функций или выражений в `if`)?

Заключая в скобки. Это предпочтительней явного соединения строк обратным слешем `\`

---
> Какие отступы должны быть у частей длинной последовательности при переносе (напр., у аргументов функций или выражений в `if`)?

Часть аргументов можно оставлять на первой строке (со скобкой), но тогда отступ следующей строки должен совпадать с первым оставленным аргументом:

```python
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
```

В любом случае, отступ переноса не должен сливаться со следующей инструкцией. Если она сдвинута, то переносу нужно добавить еще уровень:

```python
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
```

Последний вариант в случае `if` дискуссионный, и вместо отступа можно разграничить выражения комментарием или даже оставить отступ на том же уровне

---

> Какой отступ может быть у закрывающей скобки при переносе длинной последовательности?

Допустим как отступ по сдвинутому аргументу:

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
```

так и расположение на одном уровне со всем выражением:

```python
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

---
> Какова максимальная длина строки для кода?

*79* символов. Это улучшает читаемость при отображении файлов бок о бок и в инструментах для code review. Возможно увеличение лимита до 100 символов, но, например, стандартная библиотека консервативна, и не допускает такого

---
> Какова максимальная длина строки для комментариев и docstrings?

*72* символа для длинных слабоструктурированных текстов. Это ограничение более жесткое, чем для длины строк кода

---
> Когда обратный слеш `\` всё же может использоваться для переноса длинных строк?

Для конструкций, не поддерживающих скобки. В основном это оператор запятая `,` в конструкциях `with` и `assert`:

```python
# взять в скобки нельзя: синтаксическая ошибка
with open(), open():
# взять в скобки нельзя: изменение смысла, непустой кортеж всегда True
assert cnd1, cnd2
```

---
> Где располагать бинарный оператор при переносе строк?

В начале строки:

```python
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

---
> Как разбивать и переносить длинные строковые литералы?

Без операторов конкатенации, без обратных слешей, заключая всё в скобки:

```python
x = ('This will build a very long long '
     'long long long long long long string')
```

---
> Как отделяются классы и функции верхнего уровня от остального кода?

Двумя пустыми линиями

---
> Как отделяются друг от друга методы внутри класса?

Одной пустой линией

---
> Когда могут использоваться дополнительные пустые строки?

Для отделения групп связанных функций, и внутри самих функций, для отделения логически связанных секций. В обоих случаях - нечасто

---
> Когда блоки можно не разделять пустыми линиями?

Например, если это группа логически связанных однострочников (напр., dummy implementations)

---
> Когда скрипт должен указывать кодировку в заголовке (encoding declaration)?

Никогда, во всяком случае до тех пор пока код написан в UTF-8 (а это жесткое требование)

> То же самое, только вместо юникода ASCII: файл не должен указывать кодировку, если написан в ASCII

В стандартной библиотеке, начиная с Python v3.0, требования совсем жесткие: всё только в ASCII, английскими словами (исключение только имена авторов в комментариях, да и то рекомендуют транслитерировать)

---
> Можно ли импортировать несколько модулей в одну строку?

Чисто технически да, но не рекомендуется. Стилистически каждый импорт должен быть отдельно:

```python
import os
import sys
```

---
> Можно ли импортировать несколько сущностей из одного модуля в одну строку?

Да, это допустимо:

```python
from subprocess import Popen, PIPE
```

---
> Где в файле должны располагаться импорты?

В начале, после комментариев / docstring-ов уровня модуля, и перед глобальными константами и функциями

---
> Как должны быть сгруппированы импорты?

В группы, разделенные пустой строкой:

1. из стандартной библиотеки
2. third-party
3. локальные

---
> Какая форма импорта предпочтительней?

Абсолютная:

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

Относительные импорты могут использоваться, если расположение модулей в пакете достаточно сложное:
```python
from . import sibling
from .sibling import example
```
Хотя гугл не рекомендует совсем, говорит использовать имя пакета (?)

В стандартной библиотеке поощряется простая структура пакетов, и разрешены только абсолютные импорты

---
> Можно ли использовать `*` при импорте?

Крайне нежелательно. Единственный случай, когда это разрешено, - публикация в пакете внутреннего интерфейса в качестве внешнего

---
> Где в модуле должны объявляться *магические* (*dunder*) константы?

После docstring-ов верхнего уровня и перед любыми импортами

---
> Где в модуле должны объявляться импорты из `__future__`?

После docstring-ов верхнего уровня и перед "магическими" константами и импортами

---
> Какие кавычки использовать, одинарные или двойные?

- PEP8, Google: не важно, нужно только не смешивать их, использовать последовательно
- CKAN: предпочитать одинарные

---
> Когда можно смешивать одинарные и двойные кавычки?

Когда строка текста содержит кавычку, желательно использовать для нее кавычки другого типа: это повышает читабельность

---
> Какой тип тройных кавычек использовать?

- PEP 257: двойные тройные, для совместимости с docstring-ами
- Google: одинарные тройные могут использоваться, если везде в проекте используются (обычные) одинарные. Docstring-и всегда в двойных тройных, независимо от этого

---
> Как отделять элементы от фигурных, квадратных и круглых скобок?

Отделяться пробелом не должны:

```python
# Correct
spam(ham[1], {eggs: 2})
foo = (0,)
# Wrong
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
```

---
> Как использовать пробелы с запятыми?

Ставить после и не ставить до

---
> Как использовать пробелы в срезах?

Не использовать в основном. Исключение - когда в срезе есть выражение:


```python
# Correct
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

---
> Ставится ли пробел перед круглыми или квадратными скобками при обращении к функции или структуре данных?

Нет, не ставится, скобка пишется слитно с текстом:

```python
# Correct
spam(1)
dct['key'] = lst[index]
```

---
> Можно ли выравнивать операторы "равно" в группе присваиваний?

Нет:

```python
# Correct
x = 1
long_variable = 2
# Wrong
x             = 1
long_variable = 2
```

---
> Нужно ли окружать пробелами бинарные операторы?

Да, это всегда обязательно. Исключениями могут быть операторы с разными приоритетами, тогда можно отделять только низкоприоритетные:

```python
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

Отделять нужно и стрелки/двоеточия в аннотациях функций (двоеточия только справа)

---
> Нужно ли отделять пробелом оператор "равно" в именованных параметрах и аргументах по умолчанию?

Нет, вот здесь его отделять не нужно, пишется слитно:

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

Это не относится к аргументам с аннотациями:

```python
def func(a: int = 0) -> int:
```

---
> Как объявлять кортежи из одного элемента?

Всегда использовать скобки:

```python
# Correct
FILES = ('setup.cfg',)
# Wrong
FILES = 'setup.cfg',
```

Запятая обязательна, иначе интерпретатор не отличит кортеж от одиночного значения в скобках

---
> Когда нужны (и не нужны) trailing-запятые?

Нужны только когда расположение кода в несколько линий. Для кода в одну строку их указывать не следует:

```python
# Correct
FILES = [
    'setup.cfg',
    'tox.ini',
]
# Wrong
FILES = ['setup.cfg', 'tox.ini',]
```

---
> Когда комментарий можно начинать с маленькой буквы?

Только когда это идентификатор. Комментарий - это законченное предложение, и оно должно начинаться с большой буквы

---
> Как отделять предложения в многострочном комментарии?

Каждое предложения должно заканчиваться точкой. После каждой точки, кроме последней, ставятся два пробела

---
> Для каких функций и методов нужны docstring-и?

Для всех публичных обязательны. Для закрытых тоже нужны, но там можно ограничиться кратким комментарием

---
> На какой строке должны быть закрывающая кавычка у docstring?

На новой для многострочных:

```python
"""Return a foobang.

Optional plotz says to frobnicate the bizbaz first.
"""
```

Для однострочных должна быть на той же строке

---
> Какие однобуквенные переменные не рекомендуется использовать?

Те, которые можно спутать с цифрами или между собой: `I`, `l`, `O`

---
> Какое соглашение по именам модулей и пакетов?

Все в нижнем регистре. В именах модулей можно использовать подчеркивания (если они улучшают читаемость), в именах пакетов нет

Имена низкоуровневых модулей (напр., написанных на C/C++), идущих в комплекте с Python-модулями, должны начинаться с подчеркивания (напр., `_socket`)

---
> В какой нотации пишутся имена классов?

В *CamelCase*

---
> Как должны именоваться классы исключений?

Как и остальные классы, в CamelCase. Кроме того, к имени класса нужно добавлять суффикс `Error`

---
> Как именуются функции и переменные?

В нижнем регистре, слова разделяются подчеркиваниями

---
> Как предотвратить конфликт с зарезервированным / ключевым словом?

Добавить в конец имени подчеркивание: `class_`. А еще лучше использовать синоним

---
> Каков формат имен констант?

В верхнем регистре, слова разделены подчеркиваниями:

```python
MAX_HOLY_HANDGRENADE_COUNT
```

---
> Что делает ключевое слово `is`?

Проверяет, что два объекта являются одним и тем же объектом, расположены по одному ии тому же адресу. По сути, `is` эквивалентно

```python
id(a) == id(b)
```

Должно использоваться для сравнения с синглетами

---
> Какие есть встроенные синглеты?

В единственном экземпляре существуют `True`, `False`, `None`

---
> Как сравнивать с `None`?

Как и со всеми синглетами - через `is [not]`. Оператор "равно" использоваться не должен. Порядок должен быть `is not`:

```python
# Correct
if foo is not None:
# Wrong
if not foo is None:
```

---
> Стоит ли присваивать лямбды именованным переменным?

Нет. Это затрудняет отладку и не дает никакого преимущества. Лучше использовать функции:

```python
# Correct
def f(x): return 2*x
# Wrong
f = lambda x: 2*x
```

---
> От какого класса следует наследовать классы исключений?

От `Exception`, не от `BaseException` (перехват последних не предполагается)

> Используйте синтаксис `raise ValueError('message')` вместо устаревшего `raise ValueError, 'message'`

---
> Как следует оформлять `except:`?

Всегда указывать в нем класс исключения

Пустой `except:` эквивалентен `except BaseException:`, и будет перехватывать даже `SystemExit` / `KeyboardInterrupt`. Если тип неизвестен, пишите `except Exception:`

---
> Допустимо ли смешивать пустые и непустые `return`-ы в функции?

Нет. Если хоть один из них возвращает значение, то и остальные должны: вместо просто `return` нужно писать `return None`

---
> Как можно получить часть строки из середины? Суффикс/префикс?

Через срез:

```python
'some text'[2:4] == 'me'
```

Для префиксов и суффиксов можно опустить первый/последний индекс соответственно:

```python
'some text'[:4] == 'some'
'some text'[5:] == 'text'
```

---
> Какой способ проверки строки на суффикс/префикс предпочтительней?

Через функции `startswith()` / `endswith()`:

```python
# Correct
if foo.startswith('bar'):
# Wrong
if foo[:3] == 'bar':
```

---
> Как сравнивать классы (типы) экземпляров?

Через `isinstance()`, не `type()`:

```python
# Correct
if isinstance(obj, int):
# Wrong
if type(obj) is type(1):
```

---
> Как правильно проверять, что коллекция (не)пустая?

Через неявное приведение к `bool`, не через длину:

```python
# Correct
if not seq:
if seq:
# Wrong
if len(seq):
if not len(seq):
```

---
> Как правильно проверять булевы значения?

Неявно; сравнение с `True`/`False` использовать не нужно:

```python
# Correct
if greeting:
# Wrong
if greeting == True:
if greeting is True:
```

---
> Можно ли использовать `return`/`break`/`continue` в блоке `finally` у `try`?

Нет, это отменит проходящее через блок `finally` исключение

---
> Какие способы передачи аргументов в сигнатуре функции предпочтительней?

Позиционные (`x, y`) и именованные (`a=3, b=4`) аргументы лучше произвольных (`*args`) и произвольных в словаре (`**kwards`)

---
> Почему один аргумент-список лучше запакованных параметров `(*args)`?

Можно передавать структуры, которые не могут быть распакованы. Например, итераторы

---
> Что говорит принцип YAGNI об именованных параметрах функций?

Что не стоит добавлять их на все случаи жизни, просто "чтобы были"

---
> Как обозначаются закрытые члены классов и модулей?

Их имена начинаются с подчеркивания - `_method`

---
> Какое имя давать неиспользуемой переменной?

Подчеркивание, одно `_` или два `__`. Второе может быть полезно, чтобы не спутать с `gettext()` или последним результатом в REPL

---
> Как проверить, что в словаре есть ключ?

```python
# Correct
'hello' in d # через оператор `in`
d.get('hello', 'some') # через `.get()` с дефолтным аргументом
# Wrong
d.has_key('hello') # но не через `.has_key()`
```

---
> Когда стоит предпочитать генераторы спискам?

Когда сам список физически не нужен, например, передать данные в функцию: `max(_ for ...)` лучше, чем `max([_ for ...])`

---
> Почему запись
> 
> ```python
> [print(x) for x in sequence]
> ```
> плоха?

List comprehension используется не по назначению (создание списков), а для side effect-ов. Лучше переписать на обычный цикл

---
> Когда не стоит удалять элементы из коллекции?

При итерации по этой коллекции. Вместо этого можно, например, итерировать по shallow-клону (`[:]`)

---
> Какой предпочтительный способ получения индекса при итерации по коллекции?

Через `enumerate()`. Это более наглядно, чем считать вручную, и функция оптимизирована

---
> Какой предпочтительный способ открыть файл?

Через менеджеры контекста, `with open()`. Автоматически закрывает файл, даже если внутри блока выброшено исключение

Для объектов, которые не поддерживают `with` явно, можно использовать обертку `with contextlib.closing(...):`

---

> Какой линтер рекомендует Google в своём style guide-е?

*pylint*, с подавлением предупреждений через комментарии (`# pylint: disable=redefined-builtin`) в случае необходимости

---
> Какие типы сущностей лучше импортировать а какие нет?

Импортировать следует только пакеты и модули, не отдельные классы/функции в них. При использовании это наглядно показывает, к какому пространству имен относится сущность

---
> Допустимо ли использовать псевдонимы при импорте?

Да, вполне, для сокращения длинных имен или предотвращения конфликтов

---
> Допустимо ли использовать `assert` для проверки данных из внешних источников?

Нет, он только для проверки внутренней логики

В частности, контроль входных значений и аргументов функций не должен отключаться по `PYTHONOPTIMIZE`/`-O`

---
> Какие рекомендации по использованию глобальных переменных?

Избегать: при импортах идет их присваивание, и это может приводить к непредсказуемому поведению

---
> Допустимы ли вложенные функции/классы?

Да, вполне, например для декораторов. Не стоит только объявлять функцию вложенной лишь для того, чтобы скрыть ее при импорте. Вместо этого лучше добавить подчеркивание к ее имени

---
> Для каких случаев рекомендуется использовать list comprehensions?

Только для простых и однострочных. Нежелательны множественные `for`-ы и условия фильтрации

То же условие простоты касается и лямбд, и псевдо-тернарного оператора

---
> Какого типа объекты можно использовать в качестве значений аргументов по умолчанию?

Только неизменяемые:

```python
# Correct
def foo(a, b=None):
def foo(a, b=()):
# Wrong
def foo(a, b=[]):
def foo(a, b={}):
```

---
> Когда list comprehensions лучше связки `map()`/`filter()`?

Всегда, когда функции - однострочные лямбды. То же касается и `reduce()` - циклы `for` всегда предпочтительней

---
> Можно ли использовать `@staticmethod`?

В гугловом руководстве запрещается, лучше писать функцию уровня модуля. Использование `@classmethod` рекомендуется ограничить именованными конструкторами или методами класса, модифицирующими глобальные переменные

---
> Использовать ли в коде типизацию (type annotations)?

Да, сильно поощряется

---
> С чего должен начинаться файл?

С docstring-а, описывающего назначение и использование этого модуля

---
> В каком наклонении должен быть текст в docstring-ах?

- PEP257: в повелительном (`"""Return the ...`)
- Google: (наоборот) В описательном (`"""Fetches from ...`)

---
> Что должны описывать docstring-и у функций/методов?

Назначение и синтаксис вызова, не реализацию

---
> Что можно указать в строке документации у метода дочернего класса, перекрывающего метод родительского класса?

Слово `override`, если родительский метод не вызывается, и `extend` иначе. Описание не должно дублировать docstring базового класса

---
> Какие секции могут быть у docstring функции/метода?

`Args`, `Returns`, `Raises`

---
> Какие секции могут быть у docstring класса?

`Attributes`, описывающая параметры конструктора. Причем в `__init__()` эти параметры уже не описываются

---
> Какой отступ у inline-комментариев?

По Google style guide - 2 пробела после строки кода и 1 - после символа комментария:

```python
if i & (i-1) == 0:  # True if ...
```

---
> Какой предпочтительный способ собрать строку из частей в цикле?

Не использовать `+`/`+=`: т.к. строки неизменяемы, это приведет к созданию слишком большого числа временных объектов и квадратичной сложности вместо линейной

Лучше добавлять подстроки в список, а после цикла вызвать `''.join([...])`

---
> Как использовать TODO-комментарии?

Только для временного кода, оставляя свой идентификатор (имя, ник, почту) в скобках:

```python
# TODO(kl@gmail.com): Use a "*" here for string repetition.
# TODO(Zeke) Change this to use relations.
```

---
> Можно ли располагать несколько инструкций в одной строке?

Нежелательно, разве что очень короткие `if/while`. Использование точки с запятой `;` также нежелательно

---
> Какое расширение должно быть у Python-файлов?

`.py`

---
> Можно ли использовать дефис/тире в именах файлов и в коде?

Нет, только подчеркивание

---
> Когда можно использовать однобуквенные имена переменных?

Только для счетчиков/итераторов. Можно использовать `e` для имен исключений. В остальных случаях нежелательно

---
> Отделяется ли docstring пустыми строками от окружающего кода?

В функции не отделяется, ни с одной из сторон. В классе нужна пустая строка перед первым методом

---
> Должна ли ставиться точка в конце первой строки в docstring?

Да, должна:

```python
"""Return the pathname of the KOS root directory."""
```

---
> Каков общий формат для многострочных docstrings?

Однострочная summary -> пустая строка -> более подробное описание:

```python
def complex(real=0.0, imag=0.0):
    """Form a complex number.

    Keyword arguments:
    ...
```

Отступ внутри - по первой кавычке

---
> Для чего стоит и не стоит использовать инструкцию `raise`?

Стоит только для ошибок, не выбрасывающих исключения сами по себе, то есть только для тех, что определяются логикой программы

Не стоит выбрасывать для дублирования ошибок интерпретатора

---
> Как объявлять пустые функции и классы?

Используя docstring вместо `pass`

Все пустые классы и функции должны содержать строку документации

---
> Какими свойствами должны обладать блоки `try:`/`except:`?

Должны быть как можно более "узкими": блок `try:` должен охватывать как можно меньше кода, а кортеж классов в `except:` должен быть максимально специфичным

---
> Для чего предназначено тело модуля?

Только для связывания атрибутов. Инструкции `def` задают атрибуты-функции, `class` - классы, а присваивания связывают произвольные атрибуты с объектом модуля

Каких-либо других действий, кроме задания атрибутов, следует избегать

---
> Как следует именовать закрытые атрибуты модуля?

Их имена должны начинаться с подчеркивания:

```python
_secret = 4
```

это не предотвратит их импорт, но подскажет другим программистам (и, возможно, инструментам анализа кода), что атрибут предназначен только для использования внутри модуля

---
> Как переносить длинные строки импортов?

Используя скобки:

```python
from <some-long-name-module> import (
    a as alias1, b as alias2, ...
)
```

---
> Какая форма записи инструкции импорта предпочтительней?

Всегда ясно, какое пространство имен используется:

```python
import <module>
```

Использование `*` вообще не рекомендуется (разве что для публикации внутренних интерфейсов или в интерактивных сеансах), а

```python
from <package> import <module>
```

оправдана лишь для импорта модулей из пакетов

---
> Какие рекомендации по циклическим импортам модулей?

Хотя чисто технически он возможен, такого импорта следует избегать: циклические зависимости хрупкие, и ими трудно управлять

---
> Как скопировать словарь?

Методом `.copy()` или через конструктор:

```python
x = {'a': 1}

y = x.copy()
y - dict(x)
```

Т.к. словарь - изменяемый объект, то копия будет иметь другой адрес (`id(x) != id(y)`)

---
> Чему равны `x` и `y` после выполнения этого кода?
> 
> ```python
> x = {'a': []}
> y = x.copy()
> y['a'].append(1)
> ```

Одинаковы, и оба равны:

```python
{'a': [1]}
{'a': [1]}
```

Копирование словарей - через `.copy()` или через конструктор - дает shallow-клон

---
> Как сравнить версию интерпретатора?

```python
sys.version_info >= (3, 6)
```

---
> Где хранится версия интерпретатора?

В кортеже

```python
sys.version_info
```

```
sys.version_info(major=3, minor=8, micro=2, releaselevel='final', serial=0)
```

---
> Что будет печатать этот код? А если раскомментировать метод `.__iter__()`?
> 
> ```python
> class A:
>     # def __iter__(self):
>     #    return self
> 
>     def __next__(self): return 1
>     def __getitem__(self, index): return 2
> 
> for i in A():
>     print(i)
> ```

С закомментированной будет печатать `2`: наличие у класса метода `.__iter__()` определяет, будет ли синтезироваться обертка через `yield obj[i]` или нет. Если раскомментировать - то будет печататься `1`

То есть наличие метода `.__next__()` не влияет на то, итерируем ли объект. `.__iter__()` OR `.__getitem__()` - если нет обоих, то использовать объект в `for` нельзя

---
> Что выведет это код?
> 
> ```python
> from collections import namedtuple
> Point = namedtuple('Point', 'x, _asdict')
> ```

```
ValueError: Field names cannot start with an underscore: '_asdict'
```

---
> Как посчитать количество совпадений с регулярным выражением в строке?

Два способа:

```python
_, n = re.subn(r'ab', '', 'abababab')  # 4
n = len(re.findall(r'ab', 'abababab')) # 4
```

---
> Как создать бесконечный диапазон значений?

Использовать

```python
itertools.count(start=0, step=1)
```

---
> Как сэмулировать `enumerate()` через `zip()`?

Использовать бесконечный итератор `itertools.count()`:

```python
zip(itertools.count(), [1,3,4,1,2,3])
```

---
> Что происходит при достижении конца функции-генератора (или при явном вызове `return`)?

Выбрасывается исключение `StopIteration`. При этом значение в `return` будет передано как параметр конструктора исключения

---
> Какой тип будет у результата вызова?
> 
> ```python
> def func():
>     if False:
>         yield 1
> 
> type(func()) # ?
> ```

```
<class 'generator'>
```

Функция считается генератором по факту наличия `yield`. Достижим ли он - не имеет значения

---
> Как найти в списке объект, имеющий минимум/максимум по какому-либо атрибуту?

Встроенные функции `min()`/`max()` имеют необязательный параметр `key=`, аналогичный тому что в `.sort()`/`sorted()`

---
> Как `print()` выводит аргументы, не являющиеся строками?

Неявно вызывает на них `str()`

---
> Как в `print()` управлять разделителями и переносами строк?

Через именованные параметры `sep=` и `end=` соответственно
