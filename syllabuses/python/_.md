# Общее `[lang]`

---
> Соединяет ли Python строки такого вида: `... # ... \`?

Нет, обратный слеш находится за комментарием и игнорируется

---
> В каких случаях смежные строки кода объединяются в одну логическую?

Если открыта любая из скобок `(`/`[`/`{` или тройная кавычка

Физические строки, входящие в одну логическую строку, называются *строками продолжения*. Соображения, касающиеся отступов, относятся к первой физической строке каждой логической строки, а не к строкам продолжения

---
> Как указать кодировку файла с исходным кодом?

Нужен комментарий в начале файла - *директива кодировки*, например, `# coding: iso-8859-1`

---
> Какие символы могут содержать файлы с исходным кодом?

Любые символы Unicode в кодировке UTF-8. ASCII-символы (коды 0-127) - их часть

> По умолчанию только ASCII. Кодировку можно сменить через `# coding: utf[-8]` в начале файла. Использовать юникод в v2 можно только в строковых литералах и комментариях

---
> Какие символы разрешается использовать в именах идентификаторов?

Любые символы, интерпретируемые Юникодом как буквы / цифры / символы подчеркивания. Не может начинаться с цифры. Вполне допустимы, например, имена переменных из русских букв:

```python
фф = 3
```

> Только `[a-zA-Z0-9_]`

---
> Имеет ли регистр значение в Python?

Да, язык регистр-чувствительный. Как для идентификаторов, так и для ключевых слов

---
> Допускается ли использование знаков пунктуации в именах идентификаторов?

Нет, ничего вроде `@`/`$`/`!` использовать нельзя

---
> В каком регистре пишутся ключевые слова?

Все в нижнем. Т.к. язык регистр-чувствительный, то изменение регистра любого символа в них приведет к синтаксической ошибке (`SyntaxError: invalid syntax`)

---
> Чем являются `exec` и `print`?

Функциями

> Ключевыми словами. Хотя, если включить в код `from __future__ import print_function`, то станет функцией

---
> Чем являются в языке лексемы `True`, `False`, `None`?

Ключевыми словами. Например, при попытке их использования в качестве переменной будет выброшена ошибка `SyntaxError: can't assign to keyword`

---
> Есть ли в Python объявления (функций, переменных, и т.д.)?

Нет, есть только инструкции

---
> Чем является операция присваивания?

Инструкцией. И поэтому не возвращает значения и не может входить в выражения

---
> Что является признаком конца блока?

Возврат к отступу, равному или меньшему отступу заголовка блока

---
> Как получить тип объекта?

Встроенная функция

```python
type(obj)
```

возвращает класс (напр., `<class 'float'>`)

---
> Как проверить принадлежность объекта классу?

Встроенная функция `isinstance(obj, type)` возвращает `True`, если `type` находится в базовых классах `obj`

---
> Какие есть встроенные числовые типы?

Их три:

- целочисленные `int`
- с плавающей точкой `float`
- комплексные `complex`

> Есть еще `long`

---
> Чем являются все числа в Python?

Неизменяемыми объектами. Поэтому любая операция с ними порождает новый объект (в том числе, составные присваивания)

---
> Какие есть литералы для записи чисел в не-десятичных системах счисления?

Двоичный `0b`, восьмеричный `0o`, шестнадцатеричный `0x`

> Восьмеричный можно писать без `o`, просто ноль

---
> Какое максимальное целое число можно записать литералом?

Любое, верхняя граница не определена

> Граница между `int` и `long` определяется константой `sys.maxint`

---
> Каков формат литерала для чисел с плавающей точкой?

Первый ноль может опускаться (`.1`), может использоваться научная нотация: `e|E` (в любом регистре), за ней необязательный `+/-`, потом цифры показателя степени (`.1E+2 == 10.0`)

---
> Как получить информацию о представлении чисел с плавающей точкой на текущей машине?

Кортеж `sys.float_info`

---
> Какой формат у литерала комплексного числа?

Два числа с плавающей точкой, соединенные символом `+`/`-`. Вторая часть (мнимый литерал) записывается с суффиксом `j`:

```python
4-.1e3j == (4-100j)
```

Сложение/вычитание выполняется в момент компиляции

---
> Можно ли разделять разряды в числовых литералах?

Да, с v3.6 можно использовать подчеркивания:

```python
100_000.000_0001 == 100000.0000001
0x_FF_FF == 65535
0o7_777 == 4095
0b_1010_1010 == 170
```

---
> Чем являются строки в Python?

Неизменяемыми объектами, последовательностями символов Unicode. Любая операция с ними порождает новый объект

> Недекодированные литералы являются байтовыми строками (не Unicode)

---
> Какие кавычки предпочтительней для строк?

Одинарные

---
> Как преобразуется перенос в строках в тройных кавычках?

В символ новой строки `\n`:

```python
"""1
2
3""" === "1\n2\n3"
```

---
> Как избежать переносов строк и отступов внутри тройных кавычек?

Использовать обратный слеш `\`:

```python
"""\
2\
3""" === "23"
```

---
> В чем основная особенность "сырых" строковых литералов?

В них обратный слеш `\` не имеет специального значения - он сам и все следующие за ним символы просто копируются в строку. Такой литерал обозначается буквой `r|R` перед открывающей кавычкой (кавычками)

---
> Какими символами не может заканчиваться литерал "сырой" строки?

Нечетным количеством обратных слешей. В таком случае последняя косая черта будет восприниматься как будто она экранирует закрывающую кавычку

---
> Как можно задать в строке символ Юникода через его числовое значение?

- указав 4 цифры после `\u` (напр., `"\u3421"`)
- указав 8 цифр после `\U`
- указав имя в фигурных скобках после `N` (напр., `"\N{Copyright Sign}"`)

---
> Что произойдет, если просто записать два строковых литерала рядом?

Компилятор соединит их в одну строку. Пробелы между литералами опциональны. Если один из литералов - байтовая строка (`[r]b'...'`), а второй Юникод, то ошибка

> При слиянии байтовой строки (`br`) и строки Юникода результат приводится к Unicode

---
> Чем являются кортежи в Python?

Неизменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов. Любая операция с ними порождает новый объект

Элементом кортежа может быть изменяемый объект (напр., список), но в соответствии с установившейся практикой этого лучше избегать

---
> Сколько элементов в кортеже `(1,2,)`?

Два. Последняя запятая не добавляет пустой элемент, она вообще опциональна. Это же касается и остальных коллекций, вроде списка, множества и словаря

----
> Как записать литерал пустого кортежа?

Парой круглых скобок `()`

---
> Что такое *пара*?

Кортеж из двух элементов, `(a, b)`

---
> Какой тип у (позиционного) аргумента `x` конструктора `tuple/set/list/dict(x)`?

Любой итерируемый (иначе ошибка `TypeError: 'int' object is not iterable`)

---
> Чем являются списки в Python?

Изменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов

---
> На какую другую коллекцию Python больше всего похожи списки?

На кортежи: такой же тип (итерируемый объект) у конструктора `list(x)`, такая же необязательная trailing-запятая `[1,2,]`, такой же доступ к элементам по индексу

---
> Чем являются множества в Python?

Могут быть как изменяемыми (`set`/`{}`), так и неизменяемыми (`frozenset`) объектами, *неупорядоченными* последовательностями уникальных объектов

---
> Какое ограничение накладывается на элементы множеств?

Они должны быть хешируемыми (неизменяемыми) объектами: должны иметь методы `.__hash__()` и `.__eq__()` (для сравнения с другими элементами)

Хешируемые элементы могут быть ключами словарей и элементами множеств. Объекты пользовательских классов хешируемые по дефолту

---
> В каком случае объекты типа `tuple` и `frozenset` являются хешируемыми?

Только когда их элементы хешируемые (неизменяемые)

---
> Как записать литерал пустого множества?

Это сделать нельзя, из-за неразличимости с литералом пустого словаря - `{}`. Нужно писать через конструктор класса - `set()`

---
> Чем являются словари в Python?

Изменяемыми неупорядоченными объектами, отображениями (map) множества ключей на множество объектов. Аналогичны ассоциативным массивам

---
> Какие ограничения накладываются на ключи и значения словарей?

На значения ограничений не накладывается, а ключи должны быть хешируемыми (неизменяемыми) объектами

---
> Какое из значений будет выбрано при наличии повторяющихся ключей в словаре?

Последнее; указанное последним в литерале или последнее добавленное (переписывает существующее). До версии v3.7 это не гарантируется, и выбирается произвольное значение (UB)

---
> Как можно создать словарь через конструктор `dict()`?

Используя именованные параметры или список кортежей:

```python
dict(x=42, у=3.14, z=7) == {'x': 42, 'у': 3.14, 'z': 7}
dict([(1, 'za'), ('br',23)]) == {1: 'za', 'br': 23}
```

----
> Как записать литерал пустого словаря?

Парой фигурных скобок `{}` (получается именно словарь, не множество)

---
> Что будет, если конструктору словаря передать одновременно и итерируемый (позиционный) параметр, и один или несколько именованных?

Отработает нормально, создаст словарь. Именованные аргументы здесь имеют более высокий приоритет, так что они перепишут ключи-дубликаты в позиционном параметре (если есть):

```python
dict([(1, 'za'), ('br',23)], br='ddd') == {1: 'za', 'br': 'ddd'}
```
---
> Как создать словарь из набора ключей и одного (общего для всех) значения?

Воспользоваться методом `dict.fromkeys()`. Первый параметр - любая итерируемая последовательность, второй опционален - значение-заполнитель (если не указано, то `None`):

```python
dict.fromkeys('hello', 2) == {'h': 2, 'e': 2, 'l': 2, 'o': 2}
dict.fromkeys([1, 2, 3]) == {1: None, 2: None, 3: None}
```

---
> Что такое `None`?

Встроенный объект, синглет. Не имеет неспециальных методов и атрибутов. Возвращается функцией, если в ней нет инструкции `return`

---
> Какие есть *вызываемые типы*?

- функции/методы
- генераторы
- все классы (встроенные и пользовательские)
- экземпляры классов, предоставляющие спец. метод `__call__()`

---
> К какому типу относятся `True`/`False`?

Это объекты класса `bool`, который сам является подклассом `int`

---
> Чему равны `True`/`False`?

`1`/`0` соответственно

---
> Каковы правила преобразования объектов к `True`/`False`?

К `False` приводятся:

- `None`
- `0`
- пустая строка и все пустые коллекции: `[]`, `{}`, `()`
- объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно

Всё остальное `~ True`

---
> Как создать и освободить переменную (ссылку)?

Объявлений переменных в Python нет, они создаются в момент инициализации (как правило присваивания). Явное удаление ссылки можно сделать оператором `del`

---
> Что такое *сборка мусора*?

(Автоматическое) удаление объектов, на которые не указывает ни одна ссылка (переменная). Такие свободные объекты могут оставаться в памяти, например, при переприсваивании переменным других значений

---
> Какие идентификаторы можно использовать в качестве имен переменных?

Любые, кроме (~ 30 штук) ключевых слов языка

---
> Чем отличается обращение к *атрибуту* и *элементу* объекта-коллекции?

К атрибуту обращение идет через точку (`x.y`), тогда как к элементу коллекции - через оператор квадратных скобок `[]`. Вызываемые атрибуты класса называются *методами*

---
> Что такое *LHS* и *RHS*?

*Lefthand side* и *righthand side*, левая и правая части присваиваний. Т.к. в Python функции/методы являются объектами первого класса, они могут быть RHS

---
> Можно ли присваивать значение срезу списка?

Да, вся указанная в левой части присваивании часть будет заменена на то, что справа от "равно" (с возможным изменением размера списка). Присваивать можно только итерируемый объект

---
> Что такое *групповое присваивание*?

Присваивание ссылки на объект сразу нескольким переменным. RHS здесь вычисляется ровно один раз

Все переменные после этого ссылаются на один объект, но не на друг друга:

```python
x = y = 3; x = 4; print(x, y) # 4 3
x = y = []; x.append(4); print(x, y) # [4] [4]
```

---
> Что такое *присваивание с распаковкой*?

Форма записи, когда в LHS переменные перечисляются через запятую, а в RHS находится итерируемый объект: `а, Ь, с = х`

Элементов в распаковываемом объекте должно быть *ровно столько* (не больше и не меньше), сколько и переменных в LHS, иначе ошибка

---
> Для чего часто используется присваивание с распаковкой?

Для обмена значений и в циклах:

```python
a, b = b, a
a, b = enumerate(...)
```

---
> Что такое *расширенное присваивание с распаковкой*?

Используется символ звездочка `*`. Он указывает элемент, который станет списком-"остатком" - в который будут записаны все лишние элементы из правой части (RHS):

```python
x, *y, z = [1, 3, 5, 6, 5]
print(x, y, z) # 1 [3, 5, 6] 5
# аналог:
first, *middle, last = х 
first, middle, last = х[О], x[1:-1], х[-1]
```

Правая часть может быть произвольным итерируемым объектом

> Нет такой конструкции. Ее можно только эмулировать через индексы, как в примере выше

---
> Каково минимальное число элементов в правой части расширенного присваивания с распаковкой?

На единицу меньше кол-ва элементов в LHS:

```python
x, *y, z = [1, 5]
print(x, y, z) # 1 [] 5
```

---
> Что такое *составное присваивание*? Сколько всего таких операторов есть?

Семь для арифметических операций: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=` и пять для бинарных битовых: `|=`, `>>=`, `<<=`, `&=`, `^=`. В v3.5 появился еще оператор умножения матриц `@=`

В левой части составного присваивания допускается только одна целевая ссылка; множественные целевые ссылки не поддерживаются

> Оператора `@=` естественно нет

---
> Как физически реализуется составное присваивание?

Через специальные методы объекта (как правило, начинающиеся с `i`). Если такого метода нет, выполняется обычная операция, ее результат пишется во временный объект, после чего этот объект присваивается левой части.

Так, например, для `x += y` сначала проверяется, есть ли у `x` метод `__iadd__()`, и если есть, вызывается `x = x.__iadd__(y)`. Если метода нет, выполняется `x = x + y`

---
> Можно ли вызывать составное присваивание на еще не определенной переменной?

Нет, ссылка к этому моменту должна существовать. Инструкция

```python
<non-existing-var> += 1
```

вызовет ошибку

---
> Что делает инструкция `del`?

Не удаляет объекты физически, а лишь открепляет ссылки на них, разрывает связь между идентификатором (ссылкой) и физическим объектом в памяти

Также в списках ей можно удалять элементы и срезы

---
> Какой формат у инструкции `del`?

После самой инструкции следует имя переменной (идентификатор), одно или несколько, разделенные запятыми. Все переменные должны быть определены, иначе ошибка

---
> Какие методы управляют поведением инструкции `del` на объектах классов?

`.__delattr__()` для атрибутов класса и `.__delitem__()` для удаления элемента коллекции. Каждый из них может запретить удаление, сгенерировав исключение

---
> Может ли выполнение инструкции `del` сопровождаться побочными эффектами? Приведите примеры

Да, может. Например, при удаление по ключу из словаря (`del C[2]`) больше обращаться к удаленному элементу нельзя (чистое удаление, без побочных эффектов), тогда как такое же удаление из списка (`del C[2]`) оставит второй индекс валидным (удаление со сдвигом, который и является побочным эффектом)

---
> Какой приоритет у логических операторов?

`not` самый приоритетный, затем `and`, у `or` самый низкий приоритет

---
> У чего выше приоритет, у логических связок или у операторов сравнения?

У операторов сравнения:

```python
(2 == 2 and 0 == 0) == True
```

---
> Какой минус/плюс приоритетней, унарный или бинарный?

Унарные операторы приоритетней

---
> Где в таблице приоритетов находятся битовые операторы?

Их приоритет ниже арифметических, но выше операторов сравнения

---
> Каков приоритет у операторов `[not] in` / `is [not]`?

Такой же, как у операторов сравнения, и одинаковый между собой

---
> Что такое *цепочки сравнений*?

Особая форма записи условий в Python, позволяющая обходиться без логических связок:

```python
a < b < c
a != b != c
```

Вычисления идут по короткой цепи, третье и последующее выражения могут и не вычисляться

---
> Какие операторы допускают объединение в цепочки?

`[not] in`, `is [not]`, `<`, `<=`, `>`, `>=`, `!=`, `==`

У всех у них одинаковый приоритет

---
> Как раскрываются цепочки сравнений?

Через логическую связку `and`:

```python
a < b < c # a < b and b < c
"bc" in "abcde" == True # "bc" in "abcde" and "abcde" == True
```

По сути, это просто синтаксический сахар

---
> В какой момент вычисление логического выражения останавливается?

Вычисления идут *по короткой цепи*: слева направо и останавливаются, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

---
> Что возвращают логические связки `and`/`or`?

Свои операнды, не булевы значения. Это позволяет использовать их (связки) в более общих, а не только булевых контекстах

---
> Как в Python выглядит тернарный оператор?

```python
<if-true> if <condition> else <if-not-true>
```

---
> Чем являются унарные `-`/`+` в записи обычных чисел, и бинарные `-`/`+` в записи комплексных? Почему это важно?

Являются обычными операторами, не частью литералов чисел. Важно это потому, что на них распространяются приоритеты операторов. Так, например, `-2**2 == -4`, т.к. возведение в степень имеет более высокий приоритет, чем унарный минус

---
> Как в Python идет неявное преобразование числовых типов?

Оно *повышающее* - если операнды различаются, то тип "меньшего" неявно приводится к типу "большего". Самый "маленький" тип `int`, потом `float`, самый большой `complex`

---
> Как можно преобразовать комплексное число в другой числовой тип?

Никак, не существует однозначных ("сужающих") преобразований

---
> Как привести строку к числу?

Вызвать конструктор соответствующего типа с этой строкой:

```python
int('33') == 33
float('33.44') == 33.44
complex('3+.2j') == (3+0.2j)
```

---
> Как распарсить строку в число в не-десятичной системе счисления?

Работает только для целых чисел. Передать основание системы (от 2 до 36) счисления вторым параметром конструктору `int`:

```python
int('10101', 2) == 21
```

---
> Какие ограничения на операнды `/`, `//`, `%`?

Правый их операнд не может быть равен нулю, иначе runtime-ошибка

---
> Какой тип возвращаемого значения у оператора `/`?

Всегда число с плавающей точкой (истинное деление)

> Если оба операнда - целые числа, то округляет вниз (`5/3 == 1`, `-5/3 == -2`). Чтобы поведение было такое же, как в v3, нужно указать опцию командной строки для интерпретатора - `-Qnew`, умножать на `float` - `1.О*а/Ь`, или (что лучше) указать в начале файла `from __future__ import division`. Не помешает также опция `-Qwarn`, которая предупредит о возможных несоответствиях при использовании оператора `/`

---
> Какой тип возвращаемого значения у оператора `//`?

Совпадает с типом самого "широкого" операнда. То есть, если хотя бы один операнд - это число с плавающей точкой, то результат `float`. И только если и делимое и делитель целые, то результат `int`

---
> Как оператор `//` вычисляет значение?

Округляет вниз:

```python
5//3 == 1
-5//3 == -2
```

Тип всегда берется по самому "широкому" операнду:

```python
5//3 == 1
5.0//3 == 1.0
```

---
> Как можно в одно действие получить и целую часть, и остаток от деления?

Использовать встроенную функцию `divmod(a, b)` - она вернет пару `(int, int)` с нужными значениями

---
> Как можно выполнить возведение в степень?

Оператором `a**b` или встроенной функцией `pow(a, b)`

---
> Что будет, если возвести в дробную степень отрицательное число?

Будет возвращено комплексное число:

```python
(-4)**.5 == (1.2246467991473532e-16+2j)
```

> Будет выброшено исключение

---
> За что отвечает третий параметр функции `pow()`

С ним функция начинает возвращать остаток от деления результата возведения в степень на это параметр:

```python
pow(а, Ь, с) == (а**Ь)%с
```

Функция работает немного быстрее последовательности операторов

---
> Можно ли сравнивать комплексные числа?

Только на равенство/неравенство. Иначе выбрасывается исключение

---
> Что возвращают операторы сравнения?

В отличие от логических связок - булевы значения, не свои операнды

---
> Можно ли сравнивать числа с плавающей точкой?

Нет, из-за возможных ошибок представления/округления

---
> Можно ли использовать битовые операторы с целыми числами?

Да. Положительные целые числа концептуально расширяются влево неограниченной строкой битов `0`. Отрицательные числа, для представления которых используется дополнительный код, концептуально расширяются влево неограниченной строкой битов `1`

---
> Как получить длину последовательности, минимальный/максимальный элементы, как вычислить сумму элементов?

Всё - через встроенные (built-in) функции: `len()`, `min()`, `max()`, `sum()` соответственно

Это работает для списков, кортежей, множеств и словарей (списка их ключей)

---
> Как можно конкатенировать и повторить последовательность?

Операторами сложения и умножения соответственно:

```python
[1, 2] + [3, 4] == [1, 2, 3, 4]
[1, 2] * 2 == [1, 2, 1, 2]
```

---
> Что будет при "умножении" последовательности на отрицательное число?

Будет возвращена последовательность того же типа, но нулевой длины:

```python
[1, 2, 3] * -2 == []
```

---
> Как проверить принадлежность элемента коллекции?

Оператором `[not] in`: `х in S`. Эквивалентная запись для `not`: `x not in S` ~ `not (x in S)`

Это работает для всех: для строки, списка, кортежа, множества и словаря

---
> Какой тип значения возвращает оператор `[not] in`?

Логическое:

```python
("bc" in "abcde") == True
(1 in []) == False
```

---
> В чем особенность использования оператора `[not] in` со строками?

Он может проверять вхождения сразу по подстроке, не только по одному символу:

```python
("bc" in "abcde") == True
```

---
> Каков допустимый диапазон отрицательных индексов последовательности длиной `L`?

От `-1` до `-L` включительно:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == 3
x[-3] == 1
```

---
> Как из отрицательного индекса последовательности получить положительный?

Сложить отрицательный с длиной - `L + -n`:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == x[len(x) - 1] == x[2] == 3
x[-3] == x[len(x) - 3] == x[0] == 1
```

---
> Что происходит при попытке доступа на чтение к элементу последовательности по несуществующему индексу? При попытке присвоения?

В обоих случаях выбрасывается исключение

---
> Как можно вставить элемент в список в позицию `n`, не прибегая к методу `.insert()`?

Используя срез `[n:n] = [val]`:

```python
x = [1, 2, 3]
x[1:1] = [4]
x == [1, 4, 2, 3]
```

---
> Каким типом интервала является срез?

Полуоткрытым: первый индекс включается в срез, а второй нет - `[i, j)`

---
> Какую подпоследовательность вернет срез с одинаковыми индексами?

Пустую. Так как `[i:i]` ~ `[i, i)`, т.е. конечный индекс не включается, то и длина среза равна нулю

---
> Какое ограничение на значение шага в срезе?

Не должен быть нулем, иначе `ValueError: slice step cannot be zero`

---
> Чем являются числа в обозначении среза?

Реальными индексами элементов. Например:

```python
[1, 2, 3][1:2] == [2]
[1, 2, 3][1:3] == [2, 3]
```

Индекс `1` указывает на второй элемент, индекс `2` на последний, а `3` - на индекс за последним элементом списка. Вторые индексы среза не включаются в результирующую последовательность

---
> Чему равны пропущенные индекс в срезе?

Левый нулю, а правый длине последовательности:

```python
[:n] ~ [0:n]
[n:] ~ [n:len(seq)]
```

Таким образом, правый дефолтный индекс указывает на элемент за последним элементом последовательности

---
> В каких случаях срез `[i:j]` даст пустую последовательность?

Когда первый индекс больше или равен второму (`i >= j`), или первый индекс больше или равен длине последовательности (`i >= len(seq)`)

---
> Что будет, если второй индекс в срезе больше длины последовательности?

Ничего, корректно отработает. Возьмет длину вместо слишком большого индекса

---
> Как сделать shallow copy последовательности через срез?

Опустить оба индекса: `seq[:]`

---
> Как привести отрицательные индексы в срезе к положительным?

Так же, как приводятся отрицательные индексы при доступе к элементам последовательности - вычесть из длины:

```python
[1, 2, 3][-2:-1] == [1, 2, 3][1:2] == [2]
```

---
> Что задает третий параметр среза?

Шаг. По умолчанию равен `1`

---
> Что происходит, если шаг среза отрицательный?

Элементы выбираются в обратном порядке (справа налево) начиная со второго индекса среза

---
> Какое условие для индексов среза должно выполняться при отрицательном шаге?

Второй индекс должен быть меньше первого, иначе срез будет пустой:

```python
x = list(range(10))
x[8:4:-1] == [8, 7, 6, 5]
x[4:8:-1] == []
```

---
> Какой тип имеет элемент последовательности "строка"?

Тоже строка, только длиной `1`. В Python не предусмотрен специальный тип для одиночных символов

---
> Можно ли вставить в строку элемент(ы) через присваивание срезу?

Нет, нельзя, как и нельзя поменять отдельный символ: строка - это неизменяемый объект. Обе этих инструкции:

```python
"abcde"[1:1] = ["f"]
"abcde"[1] = ["f"]
```

выбросят исключение: `TypeError: 'str' object does not support item assignment`

То же верно и для кортежа, только он уже может хранить изменяемые элементы

---
> Чем являются срезы списков?

Тоже списками

---
> При присваивании значения срезу списка чем должно являться RHS?

Итерируемым объектом произвольной длины

---
> Какие существуют варианты присвоения срезу?

```python
# присвоение непустому срезу перезаписывает элементы
[i:j] = [a, b, ...]
# присвоение непустому срезу пустого списка приводит к удалению элементов
[i:j] = []
# присвоение списка пустому срезу - это вставка элементов
[i:i] = [a, b, ...]
```

В случае перезаписи размер списка может увеличиваться/уменьшаться

---
> В какую позицию идет вставка в список при указании в LHS среза нулевой длины?

Вставляемый список начинается с (единственного совпадающего) индекса из среза в LHS:

```python
x = [1, 2, 3]
x[1:1] = [5, 6]
# начало [5, 6] теперь под индеком 1
x == [1, 5, 6, 2, 3]
```

---
> Что происходит, если размер присваиваемого списка не совпадает с размером среза в LHS?

Размер результирующего списка увеличивается/уменьшается

---
> Что будет, если присвоить новое значение срезу `[:]`?

Список будет полностью перезаписан (по тому же адресу):

```python
x = [1, 2]
addr = id(x)
x[:] = [3, 4]

x == [3, 4]
addr == id(x)
```

---
> Как можно применять оператор `del` к списку? Что при этом происходит с размером списка?

Можно применять как к отдельному индексу, так и к срезу:

```python
x = [1, 2, 3, 4, 5]
del x[1] # [1, 3, 4, 5]
del x[::2] # [3, 5]
```

Размер списка при этом автоматически уменьшается

---
> Какие есть составные операторы для списков?

- `L += L1` аналогична методу `L.extend(L1)`
- умножение на число `n` добавляет в конец `n-1` копию списка:

```python
x = [1,2]
x *= 2
x == [1, 2, 1, 2]
```

---
> Что будет, если умножить кортеж или список на неположительное число?

Получим пустую последовательность:

```python
(1,2) * -2 == ()
```

---
> Как можно очистить список без использования метода `.clear()`?

```python
del x[:]  # оператором `del`
x[:] = [] # присвоением пустого списка полному срезу
x *= 0    # n <= 0
```

---
> Какие есть *немутирующие* методы у списка?

- `.count(a)` - подсчет количества вхождений элемента `a`
- `.index(a)` - возврат индекса первого встретившегося элемента `a`

---
> Что возвращает метод `list.index(a)` если `a` не найден в списке?

Выбрасывает исключение `ValueError: <a> is not in list`

---
> Что возвращает метод `list.count(a)` если `a` не найден в списке?

Ноль `0`, в отличие от `.index()` исключения не выбрасывает

---
> Какие есть аналоги `list.append(a)`?

Через срез или через составное сложение:

```python
L[len(L):] = [a]
L += [a]
```

---
> Какие есть аналоги `list.extend(s)`?

Через срез или через составное сложение:

```python
L[len(L):] = s
L += s
```

---
> Какой есть аналог `list.insert(i, a)` через срез?

Вставка элемента в позицию `i`, сдвиг всех остальных вправо и увеличение длины списка на единицу:

```python
L[i:i] = [x]
```

---
> Что делает метод `list.remove(a)`?

Удаляет из списка первый встретившийся элемент равный `a`, или выбрасывает исключение, если такой элемент не найден

---
> Что делает метод `list.pop(i=-1)`?

Удаляет элемент по индексу и возвращает его значение.Без аргумента возвращает последний элемент (`[-1]`). На пустом списке или недопустимом индексе выбрасывает исключение

---
> Как обратить список?

- метод `.reverse()` (без аргументов)
- через срез: `[::-1]`

---
> Какая сигнатура у метода `list.sort`?

Сортировка in-place, метод ничего не возвращает. Аргументы только именованные:

- `key=None` - функция, применяемая к каждому элементу. Если задана, то сравниваются не `x1 <=> x2`, а `key(x1) <=> key(x2)`
- `reverse=False` - обратный порядок

> Есть еще аргумент `cmp=func`, но он признан устаревшим даже в v2

---
> Что возвращают мутирующие методы классов `list` и `set`?

Все, кроме `.pop()`, возвращают `None`: это in-place операции

---
> Какой алгоритм используется в `list.sort()`?

Устойчивый (равные элементы не меняются местами в процессе) *Timsort*, названный в честь Тима Петерса. Гибрид сортировки вставками и сортировки слиянием

---
> Почему в общем случае `list.sort()` + `list.reverse()` не то же самое, что `list.sort(reverse=True)`?

Алгоритм сортировки в методе `.sort()` *устойчивый*, он не меняет местами равные элементы

---
> В чем сходства и отличия встроенной функции `sorted()` и метода `list.sort()`?

Аргументы одинаковы (`key=None, reverse=False`), но `sorted()` возвращает значение, а `.sort()` выполняет сортировку in-place

---
> Какие есть хелперы для сортировки списков объектов и списков списков?

В модуле `operator` есть функции `attrgetter()` и `itemgetter()`, которые можно использовать в качестве `key=` в `.sort()`/`sorted()`:

```python
sorted(items, key=operator.attrgetter('price'))
items.sort(key=itemgetter(1))
```

---
> Как можно создать shallow copy для коллекции?

- классы `list`, `set`, `frozenset`, `dict` имеют метод `.copy()`. У `tuple` его нет
- класс `list` можно клонировать через срез `[:]` или `* 1` (`tuple` так не клонируется, дает ссылку на тот же объект)

---
> Назовите 7 основных математических операции над множествами и их вызов для `[frozen]set`

```python
a | b | c ~ a.union(b, c)
a & b & c ~ a.intersection(b, c)
a - b - c ~ a.difference(b, c)
a ^ b ~ a.symmetric_difference(b)
a <[=] b ~ a.issubset(b)
a >[=] b ~ a.issuperset(b)
a.isdisjoint(b) ~ a & b == set() # empty
```

---
> Как добавить элемент в множество?

Методом `.add()`. Он не выполняет никаких действий и не выводит никаких ошибок, если такой элемент уже есть

---
> Как удалить элемент из множества?

- `set.discard(a)` не выполняет никаких действий и не выводит никаких ошибок, если элемента нет
- `set.remove(a)` генерирует исключение `KeyError`, если элемента нет

---
> Как можно очистить множество или словарь (удалить все элементы)?

Методом `.clear()`. В отличие от списка, срезы и `*= 0` здесь неприменимы

---
> Что делает метод `set.pop()`?

Возвращает произвольный элемент, удаляя его из множества

---
> Когда может быть полезен метод `set.pop()`?

Когда нужно одновременно обходить множество и удалять его элементы. Обход через `for` не позволяет удалять элементы (инвалидируются итераторы), а

```python
while s:
    e = s.pop()
```

отлично работает. Кроме того, такой вариант сильно экономит память для больших множеств

---
> Применима ли встроенная функция `len()` к словарям?

Да, она возвращает количество пар "ключ-значение" (= количеству ключей и значений)

---
> Что вернут функции `min()`/`max()` для словаря?

Наименьший/наибольший из *ключей*

Вообще, для любой функции, принимающей итератор, при передаче словаря работа будет идти с его ключами

---
> Что попадет в переменную `d` цикла `for d in dict():` (итерация по словарю)?

Ключи словаря, не пары

---
> Что будет при обращении к несуществующему ключу словаря на чтение? На запись? На удаление?

- `x['a']` - при чтении несуществующего ключа будет выброшено исключение `KeyError`
- `x['a'] = 1` - а вот запись - валидная операция
- `del x['a']` - при удалении то же, что и при чтении - ошибка

---
> Какой есть безопасный способ получения значения по ключу в словаре?

Метод `dict.get(<key>[, None])`. Аргумент по умолчанию не обязательный, без него вернет `None`, если ключ не существует

---
> Как у словаря получить все ключи или значения? Как получить список их пар?

Методы `.keys()`/`.values()`, и общий метод `.items()`

> Все эти методы имеют префикс `iter`, и возвращают не итераторы класса `dict_*`, а списки

---
> Назовите 2 отличия `dict.pop()` от `dict.get()`

1. `.pop(<key>)` не только возвращает значение по ключу, но и удаляет его из словаря
2. `.pop(<key>[, a])` также имеет опциональный аргумент, но если он не указан при вызове и ключа нет, будет выброшено `KeyError` (у него нет значения по умолчанию)

---
> Как из словаря получить произвольную пару "ключ-значение"?

Метод `dict.popitem()`

В отличие от `.items()`, этот метод удобно использовать для деструктивного итерирования по словарю

---
> Что делает метод `dict.update()`?

Объединяет объекты по равенству ключей. `D1.update(D2)` перезапишет все значения в `D1` значениями из `D2` при равенстве ключей. Некий аналог `Object.assign()` в JS

---
> Какие типы аргумента может принимать метод `dict.update()`?

Те же, что и конструктор `dict`:

- другой словарь или литерал словаря
- итерируемую последовательность пар
- именованные параметры (`<key>=<val>`), отдельно или в дополнение к позиционному аргументу

---
> Что делает метод `dict.setdefault()`?

У него 2 параметра: `<key>[, None]`:

- если ключа нет, то устанавливает его со значением из второго параметра (или `None`, если он не указан)
- возвращает значение по ключу

---
> Какая есть альтернатива методу `dict.setdefault()`?

Встроенный `dict.get()` (но в нем может не хватить функционала), и более быстрый и удобный класс `collections.defaultdict`

---
> В каком случае порядок ключей в словаре может нарушаться?

С v3.6 порядок ключей из литерала / порядок вставки в словарь сохраняется. Но это сохранение не гарантировано, если к словарю применялся мутирующий in-place метод (напр, `.pop[item]()`)

---
> Чего следует избегать при итерации по словарю?

Вставки/удаления (вообще изменения) ключей

---
> Могут ли `break`/`continue` принимать аргументы?

Нет, прерывают/продолжают только ближайший цикл

---
> Как можно перебрать строку посимвольно?

Строка - это просто последовательность, ее вполне допустимо использовать в цикле:

```python
for letter in 'ciao':
    pass
```

---
> Можно ли в цикле использовать расширенное присваивание с распаковкой?

Да, можно. Ровно один элемент может быть указан со звездочкой, ему будут присвоены все "лишние" элементы распаковываемого элемента:

```python
for a, *b, c in seq:
    pass
```

> Нет такой распаковки, ни в цикле ни вообще

---
> Как перебрать словарь в цикле `for`, получая сразу и ключ и значение?

Использовать метод словаря `.items()`. Он возвращает пары "ключ-значение", и в цикле они распаковываются:

```python
for key, value in d.items():
    pass
```

---
> Что может являться целевой переменной для `for`?

Всё, что поддерживает присваивание, даже, например, элемент списка:

```python
for test[1] in seq:
    pass
```

---
> Какая хорошая практика при итерации по изменяемому объекту?

Не изменять сам этот объект, будь то словарь, список или множество

---
> Можно ли присваивать целевым переменным цикла другие значения в его (цикла) теле?

Да, но перед следующей итерацией они всё равно будут автоматически переприсвоены

---
> В каких случаях целевой переменной цикла вообще не присваивается значение?

В случае пустой последовательности:

```python
for i in []:
    pass
```

---
> Какая область видимости у целевой переменной цикла?

Она доступна и вне цикла, конечно, если итерируемая последовательность не пуста:

```python
for i in [...]:
    pass
# i здесь имеет последнее назначенное в цикле значение
print(i)
```

---
> Напишите код, эквивалентный циклу `for`

Функция `iter()` получает сам итератор, а функция `next()` забирает следующее значение в итерируемой последовательности (или выбрасывает исключение `Stopiteration`, если элементы закончились):

```python
_temporary_iterator = iter(c)
while True:
    try:
        х = next(_temporary_iterator)
    except Stopiteration:
        break
    <instructions>
```

---
> Как сделать объект пользовательского класса итерируемым?

Объявить методы `.__iter__()` и `.__next__()`. Именно их будут искать встроенные функции `iter()`/`next()`, неявно вызываемые при попытке итерации в циклах

---
> Что возвращает функция `range()`?

Легковесный объект, поддерживающий итерацию *по целочисленным диапазонам* (в том числе и по отрицательным)

> Объект списка. Для получения итерируемого объекта нужно использовать функцию `xrange()`

---
> Какие аргументы принимает функция `range()`?

Аналогичны числам в обозначении среза:

- начальный индекс, включается в диапазон
- конечный индекс, не включается в диапазон
- шаг, не должен быть нулем

Как и в срезе, при отрицательном шаге второй индекс должен быть больше первого

---
> Как получить итератор по диапазону или последовательности?

Вызвать builtin-функцию `iter()` на итерируемом объекте:

```python
iter(range(...)) # <range_iterator object at 0x7f...>
iter([...]) # <list_iterator object at 0x7f...>
```

> То же, только диапазон задается другим классом: `iter(xrange(...))`

---
> Как получить список - последовательность целых чисел?

```python
list(range(i, j))
```

---
> Где можно использовать list comprehension (генератор списка)?

Поскольку это не инструкция, его можно использовать везде, где допустимы выражения. Например, в качестве аргумента функции (`f([x for x in ...])`) или как значение в `return`

---
> В чем особенность распаковки значений в списковых включениях?

Кортеж, в который идет распаковка, всегда нужно заключать в скобки, иначе ошибка:

```python
[(key, value) for x in {}.items()]
```

---
> Какой формат может иметь filter-часть в списковом включении?

Может быть стандартным условием или аналогом вложенного цикла:

```python
if <cnd>
for <e> in <seq>
```

Второй вариант можно развернуть как вложенный цикл, в котором вполне можно использовать переменную верхнего уровня:

```python
[х for sublist in <seq> for х in sublist]
# equals to
res = []
for sublist in <seq>:
    for х in sublist:
        res.append(x)
```

---
> Какая область видимости у целевой переменной в генераторе списка (list comprehension)?

Локальная. В отличие от цикла `for`, переменная `x` из `[x for x in ...]` недоступна извне, после генерации

> А здесь доступна, поведение аналогично `for`, поэтому стоит помнить и не перекрывать внешние переменные

---
> Какой синтаксис у генераторов множеств (set comprehension)?

Такой же как и у списков, но вместо квадратных скобок используются фигурные:

```python
{n//2 for n in range(10)} == {0, 1, 2, 3, 4}
```

Порядок элементов здесь не сохраняется, а дубликаты игнорируются

---
> Какой синтаксис у генераторов словарей (dict comprehension)?

Похож на генераторы множеств и списков, обрамляющие скобки - фигурные, а значение в map-части записывается через двоеточие:

```python
{n:n//2 for n in range(5)} == {0: 0, 1: 0, 2: 1, 3: 1, 4: 2}
```

---
> Можно ли использовать `break`/`continue` вне цикла?

Нет, будет выброшена `SyntaxError`

---
> Как меняется поведение `break`/`continue`, если они вызваны внутри `if`?

Не меняется, эти инструкции не реагируют на дополнительную вложенность и всё так же прерывают/продолжают ближайший цикл

---
> Какой частый кейс использования `continue`?

Уменьшение вложенности `if`-ов внутри цикла. Это может быть одной из реализаций принципа из дзен Python-а "плоское лучше чем вложенное"

---
> При каких условиях выполняется `else` после циклов?

Если цикл завершился "естественным" образом: исчерпался итератор в `for` или условие в `while` стало ложным

В случае выхода из цикла по `break` код в `else` не выполнится

---
> Для каких циклов доступен блок `else`?

Для обоих, и для `for` и для `while`

---
> Выполнится ли блок `else:` после цикла `for` с пустой последовательностью?

Да, т.к. выход был по исчерпанию (пустого) итератора, не по `break`:

```python
for x in []:
    pass
else:
    print('Это будет напечатано')
```

---
> Какое есть альтернативное применение инструкции `pass`?

В качестве заглушки в сложной системе условий `if`. В случае, если в некоторых внутренних `if` не нужны никакие действия, но сами эти условия из цепочки убрать трудно, можно записать в них `pass`: Python не допускает пустого тела для составных инструкций

---
> Какие есть альтернативы использованию `pass` в пустых объявлениях функций (`def`) и классов (`class`)?

Строки документации (docstring). Если такая строка есть, добавлять `pass` уже не нужно (хотя ошибкой и не будет)

Некоторые рекомендуют именно docstring-и в качестве заглушек

---
> Назовите 5 ключевых слов языка, относящихся к обработке исключений

```python
try
except
finally
else
raise
```

---
> Какую инструкцию можно использовать вместо `try`/`finally`?

Менеджер контекста `with`

---
> Что вернет функция без инструкции `return`?

`None`. Это не Groovy, результат последнего выражения Python не возвращает

---
> Можно ли передавать функцию как аргумент в другую функцию?

Да, можно. Функции в Python являются объектами первого класса

---
> Можно ли использовать функцию в качестве ключа в словаре?

Да, можно. У ее класса определен метод `.__hash__()`

---
> Что такое *именованные параметры*?

Фактически это аргументы по умолчанию: они обязаны иметь дефолтное значение, иметь синтаксис `<name>=<value>`. Также они обязаны идти после позиционных (обязательных) параметров

---
> В какой момент определяется значение именованного параметра?

Единожды, в момент объявления функции (в момент выполнения инструкции `def`). Это может приводить к неожиданному поведению для изменяемых объектов, например, для списков

---
> Как правильно использовать изменяемые объекты в качестве значений именованных параметров?

Не задавать их в сигнатуре функции, а присваивать каждый раз в теле:

```python
def f(x, y=None):
    if y is None: y = []
    ...
```

----
> В каких случаях всё же может понадобится использование изменяемых объектов в качестве значений именованных параметров?

Например, для *мемоизации* - кеширования результатов затратных операций:

```python
def cached_compute(x, cache={}):
    if х not in cache:
        cache[x] = costly_computat1on(x)
    return cache[x]
```

Хотя даже в этом случае лучше использовать декорирование с помощью функции `functools.lru_cache`

---
> Что означают параметры `*args` и `**kwargs` в сигнатуре функции?

Позволяют передавать любое количество дополнительных параметров:

- `*args` - позиционных; кортеж
- `**kwargs` - именованных; словарь

---
> В каком порядке в сигнатуре функции должны идти `*args` и `**kwargs`?

Сначала кортеж позиционных (`args`), потом словарь именованных (`kwargs`):

```python
def f(..., *args, **kwargs):
    pass
```

---
> Фиксированы ли имена для `*args` и `**kwargs`?

Нет, имена могут быть любыми. Так, например, вместо `**kwargs` часто используют `**kwds`

---
> Сохраняется ли порядок ключей в `**kwargs`?

Да, с v3.6, как и для любых словарей. Ключи идут в том порядке, в котором именованные параметры указаны при вызове

---
> Как задать параметры, которые могут быть указаны *только как именованные*?

Указать их в объявлении функции после `*[args]` (но до `**kwargs`). Такие параметры не обязаны иметь значение по умолчанию:

```python
def f(a, *, Ь, с=56):
def g(x, *а, Ь=23, **k):
```

Последовательность `*args`, либо хотя бы звездочка от нее, присутствовать обязана

---
> Какие у функции есть "магические" (dunder) атрибуты?

- `__name__` - собственно имя функции, указанное при объявлении (после `def`)
- `__defaults__` - кортеж значений по умолчанию для необязательных параметров (`None` если нет необязательных параметров)
- `__doc__` - строка документации (`None` если не указана)
- `__code__` - объект-код функции

---
> Как расшифровывается *docstring*?

*Documentation string*

---
> Для чего могут использоваться docstrings?

- в качестве комментариев для разбирающих код
- для показа при вызове `help()` и генерации документации вообще
- для хранения тестов в формате doctest

---
> Каков рекомендуемый формат docstring?

- первая строка содержит краткое описание функции, начинается с большой буквы и заканчивается точкой. Само имя функции в ней не упоминается
- потом пустая строка-разделитель
- дальше более подробное описание в виде текста, разделенного пустыми строками на несколько абзацев
- оно содержит описание параметров функции, предусловий, возвращаемого значения, побочных эффектов
- в конце могут размещаться примеры использования в формате doctest, и любая другая вспомогательная информация

---
> Можно ли задать пользовательской функции произвольный атрибут?

Да, можно привязать его прямо к имени. Например:

```python
def counter():
    counter.count += 1
    return counter.count

counter.count = 0
```

Вообще, такой подход не рекомендуется, лучше использовать ООП

---
> Что такое *аннотации* в сигнатуре функции (в общем случае)?

Произвольные выражения, которые можно указать после каждого параметра после двоеточия (`a: 'some'`) и для возвращаемого значения - после закрывающей круглой скобки со стрелкой (`) -> 'some'`). При таком объявлении аннотации окажутся в атрибуте-словаре `__annotations__` функции:

```python
def f(a:'foo', b)->'bar':
    pass

f.__annotations__ == {'a': 'foo', 'return': 'bar'}
```

Сам по себе Python никак не использует эти аннотации, а лишь создает атрибут

---
> Зачем нужны аннотации типов?

Сам Python не проверяет типы, и рассматривает аннотации просто как произвольные выражения. Но IDE, статические анализаторы и линтеры могут их использовать, проверяя корректность кода


---
> Какой пакет отвечает за аннотацию типов?

Модуль стандартной библиотеки `typing`. Доступен с v3.5. Для встроенных типов его импортировать не нужно

---
> Как пишутся аннотации типов для переменных и полей класса?

Двоеточие с выражением после имени, но перед значением:

```python
price: int = 5
title: str
...
class Book:
    title: str
    author: str
```

---
> Как указать аннотацию опционального типа?

Импортировать `typing.Optional` и указать тип в квадратных скобках:

```python
from typing import Optional

amount: int
amount = None  # Error

price: Optional[int]
price = None # Ok
```

---
> Как указать в аннотации, что тип переменной - любой?

Импортировать `typing.Any` и указать его:

```python
from typing import Any

unknown_item: Any = 1
```

---
> Как в аннотации указать, что переменная может быть нескольких (разных) типов?

Импортировать `typing.Union` и перечислить типы в квадратных скобках:

```python
from typing import Union

x: Union[int, float]
```

---
> Как в аннотации указать тип коллекции?

Импортировать `typing.<type>` и указать тип элементов коллекции в квадратных скобках:

```python
price_with_title: Tuple[int, str] = (1, "hello")
book_authors: Dict[str, str] = {"Fahrenheit 451": "Bradbury"}
def generate_two() -> Iterable[int]:
```

---
> Как в аннотации указать, что функция не возвращает значение?

```python
def forever() -> NoReturn:
```

`NoReturn` нужно импортировать из `typing`

---
> Можно ли использовать `return` вне функций?

Нет, это синтаксическая ошибка `SyntaxError: 'return' outside function`

---
> Какое есть стилистическое соглашение о `return None`?

Использовать его только если в функции есть другие `return`, возвращающие значение. Таким образом достигается единообразие в инструкциях возврата

Кроме того, функцию не рекомендуется завершать пустой инструкцией `return`

---
> В какой позиции относительно `*args` должны идти аргументы со значениями по умолчанию?

Могут идти как до, так и после. Только в первом случае они просто позиционные с дефолтными значениями, и могут указываться как угодно, а во втором могут быть указаны исключительно как именованные:

```python
def f(a, b, c=23, d=42, *x):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 3 4 (5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()

# но

def f(a, b, *x, c=23, d=42):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 23 42 (3, 4, 5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()
```

---
> Можно ли указывать позиционный аргумент как именованный?

Да, вполне:

```python
def f(x):
    print(x)

f(1) # 1
f(x=1) # 1
```

---
> Как можно передать в функцию словарь именованных аргументов?

Через оператор распаковки:

```python
def f(a, b, **kwards):
    pass

f(**{'a': 1, 'b': 2, ...})
```

---
> Сколько пространств имен в Python?

Три:

- встроенное (автоматически импортируемый модуль `builtins`)
- глобальное (весь скрипт)
- локальное (внутри функций)

Пространства вложены одно в другое, имена текущего скрывают имена окружающего ("вышестоящего"). Иногда также выделяют четвертое пространство - окружающих фунций

---
> Как внутри функции интерпретатор различает локальные и глобальные переменные?

Просматривается *вся* функция:

- все переменные, для которых внутри функции есть обращение и на чтение и на запись, должны быть инициализированы до первого обращения на чтение (иначе выбрасывается исключение `UnboundLocalError: local variable '<var>' referenced before assignment`)
- если обращения только на чтение, то ищется глобальная переменная с таким именем
- если обращения только на запись, то переменная считается локальной

Для любого из этих случаев указание `global <var>` для этой переменной сделает ее глобальной. Для обращений только на чтение/запись это избыточная директива, а вот для смешанного случая она *может* отменить исключение (если одноименная переменная объявлена в глобальной области)

Обращений на чтение всегда больше и они безопасны. Таким образом, Python и не принуждает постоянно писать `global` (а делает неявный поиск если нужно), но и не дает случайно перезаписать глобальную переменную - для этого нужно явно выразить намерение инструкцией `global <var>`

---
> Что такое *LEGB*-правило?

То, как Python разрешает имена в областях видимости. Они (области) просматриваются в порядке:

- *L*ocal (function) - область видимости текущей функции или лямбды
- *E*nclosing (nonlocal) - (только для вложенных функций) область функций, "окружающих" текущую
- *G*lobal (module) - глобальная область видимости, модуля/скрипта
- *B*uilt-in - пространство имен автоматически импортируемого модуля `builtin`

---
> Как просмотреть все имена в глобальном пространстве имен?

`globals()` вернет словарь с именами и значениями, а `dir()` без аргументов - список только имен

---
> Что делает ключевое слово `global`?

Указывает интерпретатору, что внутри функции нужно использовать для записи переменную из глобальной области видимости, а не локальную - т.е. связывает указанное имя с глобальной областью. Использование этой директивы не рекомендуется

В этой директиве могут быть указаны несколько переменных (через запятую):

```python
global <var1>, <var2>, ...
```

---
> Что делает ключевое слово `nonlocal`?

Открывает на запись переменную из внешней функции, из той, внутри которой объявлена текущая функция. Функции перебираются в порядке вложенности. Глобальная область видимости при разрешении имен при этом не просматривается

> Такого ключевого слова нет. Его можно сымитировать, сделав внешнюю переменную изменяемым объектом, и записывая в один из ее элементов (напр., `count[O] += 1`)

---
> Как создать глобальную переменную внутри функции?

Указав ее имя в директиве `global` и присвоив значение:

```python
def f():
    global x
    x = 1

f()
print(x) # 1
```

Присваивание обязательно: `global <var>` не является "объявлением" переменной

---
> Что происходит, если в функции инициализирована переменная, одноименной глобальной?

Она *скрывает* глобальную, все обращения идут к локальной

---
> Что будет, если в `global` указать имя переменной, которой не существует в глобальной области видимости?

Ничего, ошибок не будет, как не будет и создана переменная. Для создания нужно после указания в `global` еще и инициализировать эту переменную. До инициализации переменной не существует, даже проверять ее нельзя

---
> Что такое нелокальные и глобальные переменные?

- *нелокальные* - (также *свободные*) переменные из внешней функции, внутри которой объявлена текущая функция
- *глобальные* - переменные, созданные вне функций, в скрипте

---
> Внутри вложенной функции, чем отличаются и чем схожи нелокальные и глобальные переменные?

Сходства:

- могут скрываться локальными переменными
- неявно доступны на чтение
- требуют явного разрешения на запись через директивы

Различия:

- директивы, разрешающие их запись, разные: `global` и `nonlocal`
- в отличие от `global`, создать нелокальную переменную (переменную внешней функции) через `nonlocal` + присваивание нельзя

---
> Что называется *замыканием*?

Вложенная функция, получающая значения из внешних локальных переменных:

```python
def make_closure(x):
    def g(n):
        return x + n

    return g

closure7 = make_closure(7)
closure11 = make_closure(11)

print(closure7(3), closure11(4)) # 10 15
```

Нелокальные переменные (свободные переменные внешней функции) могут быть как параметрами, так и просто переменными внутри функции. Внутренняя функция "захватывает" их в момент объявления. Немного напоминает каррирование

---
> В каком порядке ищется переменная при указании директивы `nonlocal`?

Изнутри наружу, перебирая вложенные функции, начиная с ближайшей. Если не найдена, то выбрасывается исключение `SyntaxError: no binding for nonlocal '<var>' found`. Глобальная область не просматривается, одноименные переменные в ней не учитываются

---
> В чем сходство ООП и замыканий?

Внешняя функция замыкания, как и объект, хранит некоторые данные, состояние. Таким образом, функция-фабрика позволяет создавать независимые варианты других функций-замыканий

```python
def make_counter():
    _count = 0
    def counter():
        nonlocal _count
        _count += 1
        return _count

    return counter

c1 = make_counter()
c2 = make_counter()

print(c1(), c1(), c1()) # 1 2 3
print(c2(), c2()) # 1 2
```

---
> Что возвращает функция `filter()`?

Генератор

> Список

---
> Что такое *генератор*?

Функция, содержащая одно или несколько ключевых слов `yield`. Такая функция при вызове не выполняется, а лишь возвращает специальный *объект генератора*, обертывающий саму функцию, ее переменные и текущую точку выполнения. По вызову метода `next` с этим возвращенным объектом функция выполняется от текущей точки до следующего `yield`

---
> Какие есть преимущества у генераторов?

- генераторы гибче списков, и могут использоваться везде, где и итерируемые объекты
- генераторы выполняют "ленивые" вычисления, что может вести к сокращению расхода памяти
- могут возвращать неограниченный итератор для использования в циклах, прерываемых по `break`

Генератор в любой момент можно преобразовать в список через `list(g(<args>))`

---
> Когда завершается выполнение генератора?

По достижению конца функции или вызову `return`. Выбрасывается исключение `StopIteration`, которому, в качестве аргумента, передается значение из `return`

> Инструкции `return` в генераторе не могут содержать выражения, допустимы только пустые

---
> Что возвращает пустой `yield`?

То же, что и пустой `return` - `None`

---
> Напишите генератор - аналог `range()` для чисел с плавающей точкой

```python
def frange (start, stop, stride=1.0):
    while start < stop:
        yield start
        start += stride

for i in frange(1.0, 10):
    print(i)
```

---
> Для чего используется инструкция `yield from`?

Синтаксический сахар для возврата очередного значения из итератора:

```python
for x in <iter>:
    yield x
# ~
yiled from <iter>
```

> Такой инструкции нет

---
> Что такое выражения-генераторы?

То же, что списковое включение (list comprehension), только без физического создания списка. Вместо внешних квадратных скобок используются круглые, которые даже не нужны, например, при передаче в функцию:

```python
sum([х*х for х in range (10)]) # список
sum(х*х for х in range (10)) # генератор
```

Они выполняются "лениво", и требуют меньшего объема памяти, хотя и могут выполняться медленнее

---
> Как передать значение генератору?

Вызовом функции `send():`

```python
<gen-obj>.send(<val>)
```

Это значение будет возвращено `yield` при следующем вызове:

```python
<val> = yield <...>
```

---
> Какая по дефолту глубина рекурсии в Python? Как ее можно изменить?

Глубина стека по умолчанию - 1000 (тысяча) вызовов, можно получить через `sys.getrecursionlimit()`. Можно поменять вызовом функции `sys.setrecursionlimit()`

При исчерпании стека выбрасывается исключение `RecursionLimitExceeded`

---
> Как Python работает с хвостовой рекурсией?

Оптимизации хвостовой рекурсии в языке нет

---
> Какой структурой данных можно представить в Python бинарное дерево? Каким типом алгоритма его обходить?

Например, кортежем, где нулевой элемент - значение узла, а первый и второй - такие же кортежи для левого/правого узлов:

```python
(23, (42, (5, None, None), (55, None, None)), (94, None, None))
```

Обойти такое дерево можно рекурсивным алгоритмом ([p.145])

---
> Что такое *класс* в Python?

Это пользовательский тип и одновременно экземпляр объекта. Его атрибуты могут иметь произвольные имена и быть переменными (свойства) или функциями (методы)

Класс можно передать в и возвратить из функции, можно сделать его атрибутом объекта или ключом словаря. Класс в Python является *вызываемым* объектом первого класса

---
> Обязательны ли скобки в объявлении класса после имени?

Нет, не обязательны, что с пустыми скобками что без наследование будет от `object`

Для более лучшего стиля лучше не писать пустые скобки или `(object)`

> Без скобок класс будет считаться классом старого стиля. Поэтому, для указания на то что класс нового типа, можно всегда писать `class <C>(object)`

---
> Как проверить, что один класс наследуется от другого?

Встроенная функция `issubclass(derived, base) == True|False`

---
> Допускаются ли вложенные классы?

Да, вполне. Класс может иметь в качестве атрибута что угодно, в том числе и другой класс

---
> Допустимо ли объявлять статические атрибуты вне тела класса?

Да, вполне:

```python
class A:
    pass

A.x = 'some'
print(A.x) # some
```

Но такой стиль не рекомендуется: ухудшает читаемость. Лучше задавать атрибут в теле

---
> Какие основные атрибуты *класс* создает неявно?

- `__name__` - имя класса (то, что после `class` в объявлении)
- `__bases__` - кортеж базовых классов (по дефолту `(object)`)
- `__doc__` - строка документации (`None` если не задана)

---
> Какие основные атрибуты *экземпляр класса* создает неявно?

- `__class__` - ссылка на объект класса
- `__dict__` - словарь со всеми атрибутами экземпляра

Вызов `x.attr = 'some'` эквивалентен вызову `x.__dict__['attr'] = 'some'`, если конечно установка атрибута не перехватывается методом `.__setattr__()` самого класса, или методом `.__set__()` его атрибута

---
> Можно ли в статических атрибутах класса ссылаться на другие такие же атрибуты?

Да, это допустимо. Например, такой код вполне рабочий:

```python
class A:
    x = 23
    y = x + 23
```

Здесь, в отличие от функций, имена испльзуются напрямую, без уточнений

---
> Доступно ли в методах класса обращение к его свойствам напрямую, без уточнения?

Нет, нужно писать `<C>.<prop>` или `self.<prop>`

---
> Фиксировано ли имя `self` для первого параметра методов класса?

Нет, это просто общеприянтое соглашение. Использоваться может любое имя

---
> Обязана ли docstring быть в тройных кавычках?

Нет, это просто стилистическое соглашение. Python вообще проигнорирует любую отдельностоящую строку в кавычках

---
> Что компилятор делает с членами класса, начинающимися с двух подчеркиваний `__`?

Переименовывает в `_<C>__<name>`:

```python
class A:
    __x = 1

A._A__x == 1
A.__x # ошибка
```

---
> Что компилятор делает с членами класса, начинающимися с одного подчеркивания `_`?

Ничего, они считаются "закрытыми" лишь по соглашению об именах

---
> Что такое *дескриптор*?

Это любой объект, класс которого определяет dunder-метод `.__get__()`. Если определен еще и `.__set__()`, то это *дескриптор данных* (или *перекрывающий дескриптор*)

Дескрипторы важны тогда, когда они являются атрибутами другого класса:

```python
DescriptorClass:
    def __init__(self, value):
        self.value = value
    def __set__(self, *_):
        pass
    def __get__(self, *_):
        return self.value

class C:
    x = DescriptorClass()
```

В этом случае они управляют доступом к атрибутам: вызываются при установке/получении значения атрибута. Например, при установке атрибута `C().x = 'some'` вызывается метод `.__set__()` объекта `C.x`

---
> Каким дескриптором является объект функции?

*Неперекрывающим*: он определяет метод `.__get__()`, но не определяет `.__set__()`

---
> Может ли метод `.__init__()` возвращать значение

Нет, только `None`, иначе будет выброшено исключение `TypeError`

---
> Какой "магический" метод управляет установкой атрибута объекта?

`.__setattr__(self, name, value)` вызывается и при создании нового атрибута, и при (пере)записи значения существующего

Этот метод вызывается только для объектов класса, не для статических атрибутов

---
> Что такое *идиома функции-фабрики*?

Когда нужно выбирать, экземпляр какого класса создать, делать это следует через отдельную функцию. Через модификацию `.__init__()` это не получится: язык запрещает возвращать этому методу что-либо кроме `None`

Обычно реализуется через "магический" метод `.__new__()`

---
> Что делает метод `.__new__()`? Какая у него сигнатура?

`.__new__(С, *args, **kwds)`. Автоматически вызывается при создании экземпляра класса (через `C()`), до вызова `.__init__()`

Этот метод возвращает значение - созданный *неинициализированный* экземпляр. Если он действительно является экземпляром класса - первого аргумента (или любого из его подклассов), то вызывается `.__init__()`

---
> Напишите код - аналог создания экземпляра класса

```python
x = C.__new__(C, 23)
if isinstance(x, C): type(x).__init__(x, 23)
```

---
> Как можно перекрыть метод `.__new__()`?

Стандартным способом, указывать декоратор `@classmethod` не нужно: интерпретатор сам распознает имя метода

Вот для перекрытия вне тела класса уже нужно писать

```python
C.__new__ = classmethod(<method>)
```

Но перекрытия вне тела класса рекомендуется избегать

---
> Нужны ли функции `super()` аргументы?

Не обязательны

> Да, нужно передавать класс

---
> Можно ли в рантайме менять "магические" атрибуты `__class__`/`__bases__` экземпляра класса?

Да, можно, на `__class__` только есть ограничения (`__class__ assignment only supported for heap types or ModuleType subclasses`)

---
> Какие шаги выполняет интерпретатор при разрешении имени *статического атрибута класса* `C`?

1. Если имя `name` - ключ в словаре `C.__dict__`, то берем `v = C.__dict__['name']`
   - если `v` - дескриптор, то вызываем его метод `.__get__()`: `type(v).__get__(v, None, C)`
   - иначе возвращаем сам `v`
2. Иначе перебираем в цикле все родительские классы и выполняем п.1 для них
3. Если ничего не найдено, выбрасываем `AttributeError: type object 'C' has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение

---
> Какие шаги выполняет интерпретатор при разрешении имени *атрибута экземпляра класса* `x`?

1. Ищем в *классе* `C` и его предках одноименный перекрывающий (с методами `.__get__()`/`.__set__()`) дескриптор (т.е. идет поиск статического члена с таким именем). Если найден, вызываем его: `type(v).__get__(v, x, C)`
2. Если такой дескриптор не найден, но имя `name` - ключ в словаре `x.__dict__`, то берем `v = x.__dict__['name']`
3. Если не найдено и в словаре, то делегируем поиск классу, с теми же шагами 1-2 (дескриптор -> словарь)
4. Если ничего не найдено, но у класса есть метод `.__getattr__()`, то вызываем его
5. Иначе выбрасываем `AttributeError: 'C' object has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение
---
> Что такое *связанный метод*?

Объект-функция, атрибут класса, связанный с его (класса) экземпляром: `C().x`

Вызывать такой метод нужно без явного указания аргумента: экземпляр класса будет передан первым параметром автоматически

---
> Можно ли вызвать нестатический метод класса не на экземпляре, а на самом классе?

Можно, но передавать первый параметр (`self`) всё равно придется, вручную:

```python
C.x(C(), ...)
```

Так (явно) лучше не вызывать, но иногда можно, например, для передачи метода как параметра:

```python
list('...').sort(key=str.lower)
```

---
> Что такое *MRO*? Как осуществляется в Python?

*Method resolution order*, порядок разрешения имен при поиске метода/атрибута в классе, текущем и базовых

Классы-потомки всегда просматриваются раньше предков. В Python родительские классы просматриваются слева направо

---
> Как происходит устранение проблемы ромба в MRO?

Родительские классы просматриваются слева направо. Всегда берется крайнее справа вхождение любого класса (?)

Посмотреть последовательность классов можно через read-only атрибут `C.__mro__` (только у класса, не у экземпляра)

---
> Какие атрибуты разрешено перекрывать в дочерних классах?

Любые, как вызываемые атрибуты, так и атрибуты данных:

```python
class A:
    x = 1
    def y(self): pass

class B:
    x = 2
    def y(self): pass
```

---
> Обязательно ли перекрывать методы родительского класса?

Нет, они будут вызываться автоматически

Более того, перекрытие лишь для вызова родительского метода считается плохим стилем

---
> Как можно вызвать метод родительского класса без `super()`?

Явно указав имя родительского класса, вызвав на нем метод как статический, и явно же передав ему `self`:

```python
class A:
    def x(self):
        pass

class B:
    def x(self):
        A.x(self)
```

---
> Какие есть преимущества у функции `super()` по сравнению с явным указанием имени базового класса?

- автоматически решает проблему ромба, формирует "суперобъект", вызов метода на котором не приведет к дублированию вызова в родительских классах
- позволяет меньше писать, аргументы можно не указывать

> Нужно передавать имя *текущего* (не базового) класса и `self`: `super(C, self).method()`

---
> В каких случаях может понадобиться вызов метода родительского класса не через `super()`, а явным указанием имени?

Когда сигнатуры методов в суперклассе и подклассах не совпадают

Но такое несовпадение - это грубое нарушение принципов ООП, в частности полиморфизма

---
> Назовите 3 способа удалить атрибут в дочернем классе

- перекрыть метод и в нем генерировать исключение
- хранить атрибуты не в `.__dict__`, а где-либо еще, и описать логику доступа в `.__getattr__()`
- перекрыть метод `.__getattribute__()`

---
> Назовите 3 группы "магических" методов класса `object`

- методы создания: `__new__`, `__init__`
- работа с атрибутами: `__delattr__`, `__setattr__`, `__getattribute__`
- представление в строковом/числовом виде: `__hash__`, `__repr__`, `__str__`

---
> Можно ли непосредственно создать экземпляр класса `object`?

Да, без проблем:

```python
x = object()
```

Его конструктор не принимает никаких аргументов

---
> Что такое *статический метод* класса?

Это обычная функция, просто сделанная атрибутом класса. На ее сигнатуру не накладывается никаких ограничений, в том числе не нужно передавать `self` первым параметром. Такую функцию можно вызывать не только на классе (`C.x()`), но и на экземпляре (`C().x()`); при этом ошибок о несовпадении числа аргументов не возникает

В принципе, ничто не мешает сделать такую отдельной, но некоторые предпочитают связывать ее с классом

---
> Как задается *статический метод* класса?

Через конструктор встроенного типа `staticmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(): pass
    x = staticmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое (статический) *метод класса*?

Метод, получающий при вызове первым параметром сам класс. Этим он отличается от *статического метода* (простой функции в качестве атрибута), и гораздо удобнее его: перекрывать в подклассах значительно проще

Такой метод можно вызывать как на самом классе, так и на его экземпляре

---
> Как задается (статический) *метод класса*?

Через конструктор встроенного типа `classmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(cls): pass
    x = classmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое *свойство* класса?

Метод, к которому можно обращаться как к read-only атрибуту данных, без скобок. В нем доступен первый параметр `self`:

```python
class A:
    def x(self): return 1
    x = property(x, doc='Some docstring.')

A().x # 1
```

Или (предпочтительно) через декоратор

---
> Какая сигнатура конструктора у встроенного типа `property`?

Обычно указывают только один позиционный параметр, но есть и сеттер/делитер, и строка документации:

```python
property(fget=None, fset=None, fdel=None, doc=None)
```

Функция `fset` вызывается при попытке присваивания свойству, а `fdel` - при вызове на нем оператора `del`. Параметр `doc` устанавливает атрибут `__doc__`

В случае, если `fset`/`fdel` не указаны, свойство ведет себя как read-only атрибут

---
> Как через декоратор указать setter/deleter для свойства?

Указать `@<prop-name>.setter|deleter` у отдельных *одноименных* методов:

```python
class A:
    @property
    def x(self): return 1
    @x.setter
    def x(self, val): pass
    @x.deleter
    def x(self): pass

a = A()
a.x = 2
del a.x
```

---
> Какой есть более удобный аналог геттеров/сеттеров?

*Свойства* - декорированные через `property` методы класса

---
> Наследуется ли декоратор свойства (`@property`) класса?

Нет, его нужно повторять для дочерних классов. Вот здесь `B.x` будет методом, не свойством:

```python
class A:
    @property
    def x(self): return 1

class B(A):
    def x(self): return 2

B().x() # не B().x
```

---
> Что представляет собой и что делает атрибут `__slots__` у класса?

Это кортеж строк-идентификаторов, ограничивающий набор возможных атрибутов *экземпляра* класса. Позволяет немного экономить память, не создавая динамический словарь атрибутов `__dict__`. Определяться может только в теле класса

Использовать его нужно лишь тогда, когда количество экземпляров может быть очень велико (миллионы), иначе экономия может оказаться несущественной, а удобство/читабельность снижены

---
> В чем отличие `__getattr__` от `__getattribute__`?

`__getattribute__` вызывается *до* поиска атрибута в экземпляре (до начала разрешения имен), тогда как `__getattr__` вызывается лишь в случае, если атрибут не найдет (fallback)

Из-за такой логики их оба, в принципе, можно использовать для удаления атрибутов в дочерних классах. Только в случае `__getattr__` атрибуты нужно хранить где-то помимо `__dict__`

---
> Можно ли наследоваться от встроенных типов?

Да, это разрешено. Но совместимость не безусловная, может оказаться, что множественное наследование от двух разных типов невозможно

Так, например, нельзя одновременно наследовать класс от `dict` и `list`

---
> Как сделать экземпляр класса *вызываемым объектом*?

Определить у его класса метод `.__call__()`:

```python
class A():
    def __call__(self, text):
        print(text)

A()('It works') # It works
```

---
> Существуют ли в Python *деструкторы*?

Да, класс может определить метод `.__del__(self)`, который автоматически будет вызван сборщиком мусора

Определению этого метода стоит предпочитать использование `try`/`finally`, а еще лучше `with`

---
> Сколько всего специальных методов сравнения есть у класса?

Шесть:

```python
.__eq|ge|gt|le|lt|ne__()
```

---
> Каков наилучший подход в определении методов сравнения для класса?

Определить только два метода и применить к классу декоратор:

```python
import functools

@functools.total_ordering
class A():
    def __lt__(self, obj): pass
    def __eq__(self, obj): pass
```

---
> Какой негативный эффект может быть от использования метода `.__getattribute__()`?

Снижение производительности. Этот метод будет вызываться каждый раз при обращении к любому атрибуту, для разрешения имен

---
> Какие требования накладываются на специальный метод класса `.__hash__()`?

- он должен возвращать целое число
- такое, что из `x = y` следует эквивалентность двух объектов
- для любого заданного объекта это значение должно быть одним и тем же

---
> Что вернет вызов `hash(x)` на экземпляре, если у его класса не определен метод `.__hash__()`?

Зависит от того, определен ли также метод `.__eq__()`:

- если не определен, то возвращается `id(x)`
- иначе генерируется исключение

---
> В каких случаях объект пользовательского класса будет *хешируемым*?

В случаях, если вызов `hash(x)` на экземпляре не выбрасывает исключения. Класс удовлетворяет этому условию, если:

- он определяет специальный метод `.__hash__()`
- или не определяет ни его, ни метод `.__eq__()` - в этом случае в качестве хеша берется `id(x)`

---
> Где должна происходить инициализация неизменяемых пользовательских объектов?

В методе `.__new__()`, ведь после создания экземпляра изменить его уже нельзя

Во всех остальных случаях всегда следует инициализировать экземпляр в `.__init__()`

---
> Какой специальный метод класса используется для проверки экземпляра в логических выражениях?

Метод `.__bool__()`

> Он называется `.__nonzero__()`

---
> В чем различие методов `.__str__()` и `.__repr__()`?

- `.__repr__()` должен возвращать полное строковое представление, желательно такое, что `eval(repr(x)) == x`
- `.__str__()` должен возвращать компактное, неформальное представление

---
> Какой метод класса будет вызываться при вызове на экземпляре `str(x)` или `print(x)`?

`.__str__()`, а если его нет - `.__repr__()`

---
> В чем отличие вызова `.__getattr__()` от `.__setattr__()`?

`.__setattr__()` вызывается всегда, тогда как `.__getattr__()` - только если атрибут не найден (fallback)

---
> Как можно описать форматирование текстового представления экземпляров класса?

Определив специальный метод:

```python
__format__(self, format_string=''):
```

Если класс унаследован от `object`, то он делегирует вызов методу `.__str__()` и не принимает непустую строку формата

---
> Какие три типа коллекций есть в языке?

*Последовательность*, *отображение* и *множество*. Они взаимоисключающие

---
> Как желательно проектировать классы пользовательских коллекций?

Они должны быть *полиморфны встроенным* коллекциям: определять тот же интерфейс, те же специальные методы, выбрасывать исключения нужного типа, и т.д.

---
> Что такое встроенный класс `slice`? Какая сигнатура у его конструктора?

Экземпляры этого класса используются в качестве индекса-среза. Конструктор принимает три параметра:

```python
slice(start, stop, step=None)
```

---
> Какие требования налагаются на индексы пользовательских последовательностей?

При длине последовательности `L`:

- допустимый интервал индексов: `-L <= i < L`
- для отрицательных индексов (`0 > i >= -L`) должно выполняться `i ~ i + L`
- если индекс имеет недопустимый тип, выбрасывать `TypeError`
- если индекс выходит за допустимый интервал, выбрасывать `IndexError`
- принимать в качестве индекса экземпляр встроенного класса `slice`

---
> Какие специальные методы должен определять класс пользовательской последовательности, чтобы допускать конкатенацию и повторение через операторы?

Методы `.__[r|i]add__()` и `.__[r|i]mul__()`

Методы с префиксом `i` нужны для составных (in-place) операций

---
> Перечислите 11 неспециальных методов класса `list`

- `.append()`, `.insert()`, `.extend()`, `.remove()`, `.pop()` - 5 методов добавления/удаления
- `.count()`, `.index()` - 2 немутирующих метода поиска/подсчета
- `.sort()`, `.reverse()` - 2 мутирующих метода изменения порядка элементов
- `.clear()`, `.copy()` - 2 оставшихся метода, очистка и поверхностное копирование

---
> Какие неспециальные методы нужно определять вручную при создании класса пользовательской последовательности?

При наследовании от абстрактных классов `[Mutable]Sequence` - только `.sort()`

При создании с нуля - `.index()`/`.count()` обязательно, и 7 мутирующих методов (таких же как в `list`) если последовательность изменяемая

---
> В каких случаях коллекция будет хешируемой?

Тогда и только тогда, когда все ее элементы хешируемые

---
> Какую ошибку должен выбрасывать класс пользовательского отображения (словаря) при запросе несуществующего ключа?

В отличие от списка - `KeyError` (не `IndexError`)

---
> Перечислите 10 неспециальных методов класса `dict`

- `.keys()`, `.values()`, `.items()` - 3 способа получения последовательностей для итерирования
- `.get()`, `.setdefault()`, `.pop()`, `.popitem()` - 4 метода получения произвольного элемента
- `.clear()`, `.copy()`, `.update()` - 3 оставшихся метода, очистка, поверхностное копирование и обновление

> Методы первой группы имеют префикс `iter`

---
> Какому специальному методу эквивалентен `dict.keys()`?

Методу `.__iter__()`

Этот подход следует соблюдать и при проектировании классов пользовательских словарей

> Метод отличается на префикс: `dict.iterkeys()`

---
> Перечислите 7 неспециальных методов класса `set` (кроме операций теории множеств)

- `.add()`, `.remove()`, `.discard()` - 3 метода удаления/добавления
- `.pop()` - 1 метод получения произвольного элемента
- `.clear()`, `.copy()`, `.update()` - 3 оставшихся метода, очистка, поверхностное копирование и обновление

Одно из основных действий - проверка принадлежности множеству - делается оператором `[not] in`, а не методом

---
> Какой метод класса `dict` (и с какими аргументами) будет вызван при выполнении инструкции `del x[:3]`?

Будет вызыван

```python
x.__delitem__({'start': None, 'stop': 3, 'step': None})
```

---
> Напишите реализацию метода `.__getitem__()` пользовательской коллекции с поддержкой срезов

Распространенная рекурсивная идиома:

```python
class A:
    def __getitem__(self, index):
        if isinstance(index, slice):
            return self.__class__(
                self[х] for х in range(*index.indices(len(self)))
            )

        if not isinstance(index, numbers.Integral):
            raise TypeError

        if index < 0:
            index += len(self)

        if not (0 <= index < len(self)):
            raise IndexError

        # Теперь индекс является корректным целым числом
        # из диапазона от 0 до range(len(self))
```

---
> Какой специальный метод коллекций обеспечивает поддержку оператора `[not] in`?

Булева операция `y in x` вызывает метод `х.__contains__(у)`

---
> Как интерпретатор выполняет оператор `[not] in` для коллекций, не определяющих метод `.__contains__()`?

Перебором брутфорсом, сложность `O(n)`:

```python
for z in х:
    if y == z: return True

return False
```

---
> Назовите 3 специальных метода работы с элементами коллекций

- `.__getitem__(self, key)` - получение элемента по индексу или ключу (для всех кроме множеств)
- `.__setitem__(self, key, value)` - установка элемента/среза (только для изменяемых)
- `.__delitem__(self, key)` - удаление элемента/среза оператором `del` (только для изменяемых)

---
> Назовите 2 специальных метода для поддержки итерации в коллекциях

- `.__iter__(self)`
- `.__len__(self)`

---
> Какой тип коллекций не должен определять специальный метод `.__getitem__()`?

Множества и подобные: там нельзя получить элемент по ключу или индексу

---
> Какой тип коллекций не должен определять специальные методы `.__setitem__()` и `.__delitem__()`?

Неизменяемые: в них нельзя добавить/изменить/удалить элемент/срез

---
> В каких случаях вызывается специальный метод коллекций `.__len__()`?

- при вызове встроенной функции `len(x)` с экземпляром
- при использовании экземпляра коллекции в булевых выражениях, если не определен метод `.__bool__()`

---
> Что произойдет при вызове встроенной функции `iter(x)` на экземпляре коллекции, у которой не определен метод `.__iter__()`?

Интерпретатор синтезирует специальный объект-обертку над `x`, который последовательно возвращает `x[0], x[1], ...` до тех пор, пока обращение по индексу не выбросит `IndexError` (исчерпание контейнера)

Лучше всё же явно задавать `.__iter__()`, это хорошая практика

---
> Обязан ли объект - пользовательская коллекция, обязательно определять метод `.__len__()`?

Нет, хотя это очень рекомендуется. Разве что в случае очень дорогой операции определения количества элементов можно его не определять

---
> Как сделать класс абстрактным базовым?

Унаследовать его от `abc.ABC` или явно указать ему метакласс `abc.ABCMeta`:

```python
class A(abc.ABC):
class A(metaclass=abc.ABCMeta):
```

> Класса `abc.ABC` нет, так что только второй вариант

---
> Что делает метод `abc.ABCMeta.register()`?

Регистрирует переданный ему класс в качестве виртуального подкласса для вызываемого абстрактного класса:

```python
import abc

class A(abc.ABC): pass
class B: pass

A.register(B)
print(issubclass(B, A), B.__mro__)
```

Этот код выведет `True (<class '__main__.B'>, <class 'object'>)`. То есть виртуальный подкласс определяется функцией `issubclass()`, но методы базового не наследует, и базовый класс в разрешении имен не участвует

---
> Какая есть альтернатива вызову метода `.register()` на базовом абстрактном классе?

Переопределение статического метода `__subclasshook__`:

```python
import abc

class A(abc.ABC):
    def __subclasshook__(C):
        return C == B
class B: pass

print(issubclass(B, A), B.__mro__)
```

Этот код выведет `True (<class '__main__.B'>, <class 'object'>)` - в точности то же, что и вариант с `A.register(B)`

---
> Как объявить метод класса абстрактным? Что это даст?

Оба условия должны быть выполнены:

- класс должен иметь `abc.ABCMeta` в качестве метакласса (напр., наследоваться от `abc.ABC`)
- для метода должен быть указан декоратор `@abc.abstractmethod`

Такой класс нельзя инстантиировать. Код

```python
import abc

class A(abc.ABC):
    @abc.abstractmethod
    def x(self): pass

A()
```

выведет `TypeError: Can't instantiate abstract class A with abstract methods x`

> Есть еще декоратор `@abc.abstractproperty`, который в v3 устарел и эквивалентен там `@abc.abstractmethod`

---
> Может ли абстрактный метод иметь реализацию?

Да, вполне. И его можно вызывать из дочерних классов через `super()`

Наличие метода с декоратором `@abc.abstractmethod` лишь запрещает создавать экземпляры такого класса, и требует перекрыть такой метод в дочернем классе, но не запрещает иметь в этом методе код

---
> В каком модуле хранятся абстрактные базовые классы коллекций?

В `collections.abc`

До v3.4 доступ до этих классов возможен напрямую из `collections`, но это устаревшее поведение и вскоре будет убрано

---
> Назовите пять основных абстрактных базовых классов, определяющих лишь один специальный метод абстрактным

Все из модуля `collections.abc`:

- `Callable` - `.__call__()`
- `Container` - `.__contains__()`
- `Hashable` - `.__hash__()`
- `Iterable` - `.__iter__()`
- `Sized` - `.__len()__`

---
> Перечислите некоторые абстрактные базовые классы коллекций

Все находятся в модуле `collections.abc`. Это, например, `Iterator`, `[Mutable]Sequence|Set|Mapping`, `(Keys|Values|Items)View`

Все они расширяют разные комбинации пяти базовых абстрактных классов одного метода, расширяют друг друга, а также определяют разные комбинации специальных методов (`.__...__()`) в качестве абстрактных и примесных

---
> Какие абстрактные базовые классы определяются в модуле `numbers`?

В порядке наследования: `Number` -> `Complex` -> `Real`-> `Rational` -> `Integral`

`Number` - самый базовый класс, корень иерархии. Его потомки требуют определять всё больше и больше специальных методов для поддержки соответствующих операторов

---
> Как на уровне класса поддерживается перегрузка математических операторов?

При помощи пары десятков специальных методов (указаны только части между `.__...__()`):

- `invert`, `neg`, `pos`, `abs` - для унарных `~`/`-`/`+`/`abs()`
- `add`, `sub`, `mul`, `mod` - для бинарных `+`/`-`/`*`/`%`
- `truediv`, `floordiv` - для двух операторов деления
- `and`, `or`, `xor`, `(l|r)shift` - для битовых операторов
- `complex`, `int`, `float` - для применения конструкторов
- `pow`, `divmod` для встроенных функций
- а также версии с префиксами `r` и `i` для всех бинарных

Вообще, специальные методы работают также и со встроенными функциями, вроде `abs()`, или конструкторами числовых типов, вроде `int()`

---
> Зачем нужны специальные методы с префиксом `r`, вроде `.__radd__()`?

Такой метод будет вызван в случае, если в выражении `x + y` у `x` нет `.__add__()` (или он возвращает `NotImplemented`), но у `y` есть `.__radd__()`

Инверсия по сути

---
> Что такое *декоратор* по сути? Приведите примеры декораторов

Функция *высшего порядка* - она получает функцию как параметр и функцию же возвращает

Встроенные декораторы: `@propery`, `@classmethod`, `@staticmethod`

---
> Какие есть способы записи декораторов для методов класса?

Можно вызывать либо явно, либо через аннотацию:

```python
class A:
    def f(cls): pass
    f = classmethod(f)

    @classmethod
    def g(cls): pass
```

Второй способ предпочтительней

---
> Можно ли декорировать классы целиком?

Да, вполне. Аннотация декоратора `@...` в этом случае пишется над ключевым словом `class ...`

---
> Что может быть именем декоратора `@name`?

В общем случае это вычисляемое выражение, не обязательно имя функции

---
> Можно ли применять декораторы к инструкциям `def` вне тела класса?

Да, можно применять к любым функциям (и классам), в том числе и не-методам:

```python
@showdoc
def x(): pass
```

---
> Какие есть варианты вызова встроенной функции `type()`?

В зависимости от количества параметров она возвращает либо тип аргумента, либо создает класс:

```python
# возвращает тип
type(MyClass()) == MyClass
type('MyClass') == str
# создает класс
type(
    'MyClass',
    (<кортеж родительских классов>),
    {<атрибуты нового класса>},
) == MyClass
```

---
> Что такое *метакласс*?

Классы в Python сами являются объектами. Метаклассс - это класс объекта-класса:

```python
Class = MetaClass()
object = Class()
```

Дефолтным метаклассом является `type` - вызов его конструктора с тремя аргументами порождает классы

---
> Как можно задать метакласс?

Через последний (именованный) параметр в инструкции `class`, после перечисления базовых классов:

```python
class A(B, C, metaclass=M):
    pass
```

---
> Какая сигнатура у специального метода `.__prepare__()` метаклассов?

```python
class Meta:
    def __prepare__(name, *bases, **kwargs):
        return {}
```

Метод получает имя создаваемого класса, кортеж базовых классов, и произвольное число произвольных именованных параметров-атрибутов

Возвращает словарь, содержащий описание пространства имен, в котором выполняется тело класса

---
> Как вызывается специальный метод метакласса `.__prepare__()` при создании класса?

Встретив инструкцию вида

```python
class A(B, C, metaclass=MC, x='some'):
```

интерпретатор выполнит

```python
MC.__prepare__('A', B, C, x='some')
```

где

```python
class MC:
    def __prepare__(name, *bases, **kwargs):
        return {}
```

---
> Какие именованные параметры могут передаваться при объявлении класса после списка базовых классов?

- если метакласс = `type`, то никакие, будет `TypeError`
- если же метакласс кастомный, то произвольные

---
> Для чего могут использоваться исключения?

- для остановки программы при возникновении ошибки
- для индикации особой ситуации; например, встроенная `next()` выбрасывает `StopIteration` при исчерпании итератора

---
> Сколько может быть блоков `except` после `try`? Сколько `else`/`finally`?

`except` может быть несколько

Каждый из `else` и `finally` может быть только один

---
> Какой синтаксис у `except`?

Можно указать тип и объект исключения. Для объекта нужно ключевое слово `as`:

```python
except:
except Exception:
except Exception as e:
```

---
> Можно ли в `except:` указать несколько классов исключений?

Да, можно указать кортеж классов, но он обязательно должен писаться в скобках (иначе `SyntaxError`):

```python
except (Exception, BaseException) as e:
```

---
> Как в блоке `except:` получить объект исключения?

- указав его после класса - `... as e`
- через `sys.exc_info()`

Для второго случая будет возвращен кортеж. Код

```python
import sys

try:
    1/0
except:
    print(sys.exc_info())
```

выведет

```shell
(
    <class 'ZeroDivisionError'>,
    ZeroDivisionError('division by zero'),
    <traceback object at 0x7f...>
)
```

---
> Как желательно располагать обработчики исключений (блоки `except:`)?

Обработчики специфичных исключений всегда должны предшествовать обработчикам более общих

Несоблюдение этого правила приведет к тому, что более специфичные исключения никогда не будут перехвачены

---
> Каких блоков `except:` следует избегать?

"Пустых" без `raise` - тех, у которых не указан тип исключения, и внутри которых исключение не выбрасывается вручную

"Пустые" `except:` могут приводить к неправильному поведению в случае лексически (в коде) или динамически (в стеке вызываемых функций) вложенных блоков `try:`. Например, такие общие обработчики маскируют специфические. Код

```python
try
    try:
        1/0
    except:
        print('common')
except ZeroDivisionError:
    print('specific')
```

выведет `common` вместо `specific`

---
> В каких случаях выполняется блок `else:` у `try`/`except`?

В случае успешного выполнения блока `try` - тогда, когда в нем не было выброшено исключение, и не было вызвано `break`/`continue`/`return`

---
> Что такое *обработчик очистки* для исключений?

Блок `finally:` после `try:`. Он выполняется всегда, независимо от того, было в `try:` исключение (или `break`/`continue`/`return`) или нет

В отличие от `except`, после `finally:` исключение продолжает распространяться

---
> Для чего обычно используется `finally`?

Это надежный способ закрытия файлов, закрытия соединений с базами данных, освобождения ресурсов - любых операций очистки

Но всё же предпочтительнее делать это через менеджеры контекста `with`

---
> Какие инструкции не должны использоваться в `finally:`?

`continue` там запрещено использовать на уровне языка

`break` и `return` в этом блоке разрешены, но их стоит избегать: большинство людей не будут ожидать, что распространение исключения может прерваться в `finally`

---
> Напишите через `try` код эквивалентный `with`

Код

```python
with <expr> as e:
    <instrs>
```

будет эквивалентен (`else` можно заменить на `finally`, но нужен флаг)

```python
e = <expt>.__enter__()
try:
    <instrs>
except:
    if not <expr>.__exit__(*sys.exc_info()):
        raise
else:
    <expr>.__exit__()
```

Объект, возвращаемый выражением `<expr>` и имеющий методы `.__enter__()` и `.__exit__()`, называется менеджером контекста

---
> Что называется *менеджером контекста*?

Объект, возвращаемый выражением `<expr>` в `with`

```python
with <expr> as e:
```

и имеющий методы `.__enter__()` и `.__exit__()`

---
> Какую идиому воплощает инструкция `with`?

*RAII* (Resource Acquisition Is Initialization) - "получение ресурса есть инициализация"

Методы `.__enter__()` и `.__exit__()` захватывают и освобождают ресурсы (некий аналог конструкторов/деструкторов и `try`/`finally`)

---
> Как в менеджере контекста можно подавить распространение исключения?

Возвратить `True` из `.__exit__()` (`raise` внутри `except:` не будет выполнено)

---
> Как создать менеджер контекста через декоратор?

Использовать модуль `contextlib`:

- указать `@contextlib.contextmanager` у генератора
- создать свой класс-потомок `contextlib.AbstractContextManager`

---
> Разрешена ли инструкция `yield` в блоках `try`/`catch`?

Да, разрешена, в отличие от `break`/`continue`/`return`

---
> Какие есть 2 метода генераторов для взаимодействия с исключениями и менеджерами контекста?

Если `g` - объект, возвращенный функцией-генератором:

- `g.throw(exc_val)` - эквивалентен вызову `raise exc_val` в точке последнего `yield`
- `g.close()` ~ `g.throw(GeneratorExit())`

---
> Как получить ссылку на файл стандартного потока ошибок `stderr`?

В модуле `sys` есть все потоки:

```python
import sys

sys.stderr
```

В `stderr` выводятся все неперехваченные исключения

---
> Где у Python находится стандартный системный обработчик неперехваченных исключений?

Это функция `sys.excepthook`, управляющая выводом сообщений об ошибке

Ее можно заменить на свою

---
> В каких случаях сообщения об ошибке не выводятся при завершении программы?

Если было выброшено исключение класса `SystemExit`

В этом случае также происходит выход из интерактивного режима

---
> Где разрешено вызывать `raise` без аргументов?

Только в обработчике исключений (блоке `except:`), или функции, прямо или косвенно им вызываемой. В таком случае происходит выброс того же, существующего, исключения (re-throw)

В этих случаях смысл `raise` без аргументов - "я не могу обработать это исключение, возможно кто-то по стеку выше может"

---
> Что может быть аргументом `raise`?

Объект класса-потомка `BaseException`, конструктору которого можно передать сообщение об ошибке:

```python
raise ValueError('some text')
```

иначе будет выброшено `TypeError: exceptions must derive from BaseException`

---
> Можно ли передать `raise` класс исключения, не экземпляр?

Да, будет выброшено то же исключение, с пустым сообщением об ошибке:

```python
raise ValueError
```

---
> Как объекты исключений получают и хранят свои параметры?

Конструктор потомков `BaseException` получает произвольное количество позиционных аргументов, которые сохраняются в кортеж `.args`:

```python
try:
    raise ValueError(2,3,4,5)

except ValueError as e:
    print(e.args) # (2, 3, 4, 5)
```

---
> Какие 3 класса исключений не наследуются от `Exception`?

Напрямую от `BaseException` наследуются `KeyboardInterrupt`, `GeneratorExit`, `SystemExit`

---
> Какой стандартный способ возбуждения исключений класса `SystemExit`?

Через вызов `sys.exit()`

---
> Какой стандартный способ возбуждения исключений класса `KeyboardInterrupt`?

Нажатие `Ctrl + C` на клавиатуре

---
> Обрисуйте общий вид иерархии классов исключений

```python
BaseException
  Exception
    ...
    OSError
    StopIteration
    SyntaxError
    ValueError
    Warning
  KeyboardInterrupt
  GeneratorExit
  SystemExit
```

---
> Перечислите несколько базовых (псевдо-абстрактных) классов, наследующихся от `Exception`?

- `ArithmeticError` - ошибки арифметических операций
- `OSError` (синоним `EnvironmentError`) - ошибки, обусловленные внешними причинами (ввод-вывод)
- `LookupError` - ошибки, генерируемые контейнером (коллекцией) при получении недопустимого ключа или индекса
- `Warning` - большой класс, много потомков; предупреждения

---
> Перечислите классы исключений - потомков `ArithmeticError`

- `OverflowError` (не может возникать; только для обратной совместимости)
- `FloatingPointError` (не используется)
- `ZeroDivisionError`

> Из-за наличия типа `long` исключения типа `OverflowError` могут возникать при переполнении `int`

---
> Перечислите несколько классов исключений - потомков `OSError`

Например, `FileNotFoundError`, `ConnectionError` (базовый класс для всех ошибок, связанных с соединениями), `InterruptedError` (прерывание по внешнему сигналу)

---
> Перечислите классы исключений - потомков `LookupError`

- `IndexError` - для последовательностей
- `KeyError` - для отображений (словарей)

---
> Какие типы исключений могут быть выброшены при обращении к элементу последовательности по индексу?

- `TypeError` - в качестве индекса передан объект, не являющийся целым числом
- `IndexError` - выход за границы диапазона

У них разные базовые классы. `TypeError` наследуется напрямую от `Exception`, тогда как `IndexError` - через промежуточный базовый класс `LookupError`

---
> Какой класс исключения используется для индикации того, что метод не имеет реализации в данном классе?

`NotImplementedError`. Является подклассом `RuntimeError` (а тот уже наследуется от `Exception`)

---
> Что означает исключение типа `SystemError`?

Внутреннюю ошибку интерпретатора Python, но не настолько серьезную, чтобы аварийно завершаться

Такие ошибки следует отправлять разработчикам

---
> Какого типа исключения выбрасываются при использовании несовместимых типов?

`TypeError`, здесь вам не JavaScript

---
> В каких четырех случаях выбрасывается исключение `ZeroDivisionError`?

Ноль в правой части операторов `/`, `//`, `%` и ноль вторым аргументом функции `divmod(x, y)` (= `(x//y, x%y)`)

---
> Какие есть 2 способа выбросить исключение с traceback-ом другого исключения?

Используя метод `Exception.with_traceback(tb)`:

```python
except SomeException:
    raise OtherException(...).with_traceback(sys.exc_info()[2])
```

В консоли появится текст `During handling of the above exception, another exception occurred:`

Используя конструкцию языка `raise from`:

```python
except SomeException as e:
    raise OtherException(...) from e
```

В консоли появится текст `The above exception was the direct cause of the following exception:`

---
> Как обрабатываются подклассы указанных в `except:` классов исключений?

Для перехвата достаточно, чтобы класс был базовым, не обязательно чтобы совпадал

Обработчик выбирается по порядку, не по специфичности. Следующий код выведет `1`:

```python
try: 1/0
except ArithmeticError: print(1)
except ZeroDivisionError: print(2)
```

---
> Какая хорошая практика объявления пользовательских исключений, похожих на стандартные?

Использовать множественное наследование - наследоваться и от базового класса своих исключений, и от того стандартного, поведение которого нужно повторить:

```python
class MyAttributeError(MyModuleBaseError, AttributeError):
    ...
```

---
> Какие есть две стратегии контроля ошибок?

- *LBYL* (Look Before You Leap) - проверки перед выполнением операции
- *EAFP* (Easier to Ask Forgiveness than Permission) - выполнение кода в блоках `try:`

LBYL громоздкая и не гарантирует покрытие всех кейсов, EAFP на основе механизма исключений (с частым использованием `else:`) предпочтительней

---
> Какие есть хорошая практика обработки ошибок в длительно выполняющихся программах?

- журналировать возникающие ошибки, и потом внимательно изучать логи
- (?) реализовать систему контрольных точек, с возможностью восстановления в некое рабочее состояния
- (?) организовать обработку транзакций

---
> Когда допустимо ослаблять требования к блокам `try`/`except`?

В программах, которые должны сохранять работоспособность даже в самых критических случаях

В таких программах можно делать достаточно "широкие" секции `try:` и указывать более общие классы в `except:`

---
> Где лучше реализовывать журналирование неперехваченных исключений?

Переопределив атрибут `sys.excepthook` своей функцией, и уже в ней перенаправляя сообщения об ошибках (вместо `stderr`), например, в файл. Программа завершится только после завершения функции `sys.excepthook()`

Для форматирования отладочной информации можно использовать, например, модуль `traceback`

---
> Какие системные средства можно использовать для журналирования исключений?

Модуль стандартной библиотеки `logging`

Базовый его функционал - набор функций

```python
logging.(debug|info|warning|error|critical)('foo is %r', foo)
```

пишущих (или не пишущих) в журнал форматированные строки в зависимости от текущего уровня

```python
logging.getLogger().setLevel(logging.ERROR)
```

---
> Какой дефолтный уровень для вывода сообщений у модуля `logging`?

```python
logging.WARNING
```

Т.е. по умолчанию функции (`logging.<>`) `warning()`, `error()` и `critical()` пишут информацию в журнал, а функции `debug()` и `info()` - нет

---
> Как задаются настройки модуля `logging`?

через именованные параметры функции `logging.baseConfig()`

Функция обязана быть вызвана до первой записи в журнал (`debug()`, `info()` etc.), так что стандартная идиома - задавать конфиг логгера сразу после импорта модуля:

```python
import logging

logging.baseConfig(
    format='%(asctime)s %(levelname)8s %(message)s',
    filename='/tmp/logfile.txt',
    filemode='w'
)
```

В примере выше каждое сообщение в файле будет снабжено временной меткой в указанном формате

---
> Куда по умолчанию пишет ошибки модуль `logging`?

В `stderr`

Для перенаправления, например, в файл, нужно в начале программы вызвать

```python
logging.baseConfig(filename='/tmp/logfile.txt', filemode='w')
```

---
> Каков синтаксис инструкции `assert` в общем случае?

```python
assert <condition>[, <expression>]
```

Если условие верно, то ничего не делается. Если же нет, то выбрасывается исключение с выражением после запятой в качестве параметра:

```python
raise AssertionError(<expression>)
```

---
> В каких случаях `assert` не будет выполнен совсем?

Если установлена переменная окружения `PYTHONOPTIMIZE` или у интерпретатора указана одна или несколько опций `-O`

Компилятор в этом случае генерирует на месте `assert` нулевую инструкцию

---
> Какое возможно альтернативное использование инструкции `assert`?

Для документирования программ, вместо комментариев, проверяя любые неочевидные условия (*инварианты* программы)

В отличие от комментария, такая "документация" сама известит, если какое-либо условие не выполняется

---
> Какая область видимости у глобальных переменных в модуле?

Ограничена самим этим модулем, такие переменные не видны в других пакетах/модулях. Глобальные переменные являются атрибутами класса модуля

Таким образом, связь между модулями в Python всегда должна устанавливаться явно

---
> Что такое *модули расширения*?

Модули, написанные на других языках, не на самом Python

Для вызывающей стороны язык реализации модуля не имеет значения, импорт идет как обычно

---
> Что такое *модуль*?

Объект Python с произвольно именованными атрибутами, которые можно связывать и на которые можно ссылаться. Таким образом, модуль является объектом первого класса

Обычно код модуля, носящего имя `name`, хранится в файле `name.py`

---
> Что происходит при выполнении инструкции `import <module>`?

Интерпретатор ищет файл `<module>.py` в `sys.path`, импортирует его, и связывает *переменную* `<module>` с объектом модуля

До начала исполнения тела модуля его объект уже создан, и добавлен в `sys.modules`

---
> Какие есть специальные атрибуты у объекта модуля?

- `__dict__` - хранит все атрибуты (переменные, функции, классы) заданные на верхнем уровне
- `__name__` - имя модуля
- `__file__` - файл с кодом модуля

---
> В каком модуле хранятся встроенные функции?

В `builtins`

> Он называется `__builtin__`

---
> Как подменить встроенную функцию?

Нужно явно импортировать модуль `builtins`, и явно же переназначить нужный его атрибут:

```python
import builtins

_abs = builtins.abs
def my_abs():
    ...
    return _abs()

builtins.abs = my_abs
```

После такой подмены новая функция станет использоваться всеми другими модулями

> Имя модуля другое, и нужно писать `import __builtin__ as builtins`

---
> Как задается и куда сохраняется docstring модуля?

Первая непустая строка, содержащая строковый литерал, считается строкой документации, и пишется в атрибут `__doc__` объекта модуля

---
> Будут ли после импорта доступны атрибуты модуля, начинающиеся с подчеркивания?

Да, будут:

```python
import <module>

<module>._x # ok
```

Подчеркивание в именах здесь - лишь соглашение, для лучшей читаемости кода

---
> Какие есть 2 формы импорта?

```python
import <module>[ as <alias>][, ...]
from <module> import <attribute>[ as <alias>][, ...]
```

Во второй форме вместо конкретного атрибута может стоять `*`

---
> Как раскрывается "звездочка" в инструкции `from <module> import *`?

- если модуль определяет "магический" атрибут `__all__`, то берутся имена из этого списка
- иначе импортируются все атрибуты, чьи имена не начинаются с подчеркивания

---
> Какие ограничения есть на переменные в `<attr> as <alias>` в инструкциях импорта?

Не могут быть выражениями, обязаны быть простыми идентификаторами

---
> Как динамически загрузить модуль, по строке с его именем?

С помощью функции

```python
import importlib

importlib.import_module('<module-name>')
```

Этот код неявно вызовет встроенную функцию `__import__()`. Ее можно вызвать и напрямую, но в современном коде так делать категорически не рекомендуется

---
> Как функция `__import__()` выполняет импорт модуля?

Эта встроенная функция получает строку `M` с именем модуля своим аргументом, и ищет в словаре `sys.modules` ключ `M`. Если не найден, то она создает пустой объект модуля с `.__name__ = M`, инициализирует его, и добавляет в словарь

Таким образом происходит кеширование модуля в `sys.modules[M]`, и при повторном его импорте не происходят ни создание объекта, ни выполнение кода (инициализация)

---
> В какую позицию списка `sys.path` вставляются значения из `PYTHONPATH`?

Под индексом `1`: после текущей директории но перед всеми остальными:

```python
sys.path = ['', *PYTHONPATH.split(os.pathsep), '/usr/lib/python38.zip', ...]
```

---
> Для чего используются файлы с расширением `.pth`?

Файл может содержать список путей (по одному в строке) и операции импорта, которые выполняются перед программой. Если расположить такой файл в папке `PYTHONHOME`, то пути из него будут добавлены в `sys.path`

Пустые строки и строки, начинающиеся с `#`, в таких файлах игнорируются

---
> Кешируется ли при выполнении объект скрипта?

Да, он рассматривается как модуль с именем `__main__`, и так же кешируется в `sys.modules['__main__']`

---
> Можно ли импортировать скрипт из самого себя?

Да, технически это возможно, но делать так очень не рекомендуется

При таком импорте в `sys.modules` появятся два ключа - `<module-name>` и `__main__`, а тело скрипта будет выполнено дважды

---
> Как перезагрузить модуль?

Функцией из `importlib`:

```python
import importlib

importlib.reload('<module-name>')
```

> Встроенной функцией `reload('<module-name>')`

---
> Какие ссылки (идентификаторы) обновляет `importlib.reload('<module-name>')` при вызове?

Только пеерменные, чьи имена совпадают с `<module-name>` в инструкциях

```python
import <module-name>
```

Это еще один аргумент "за" использование `import <name>` вместо `from <name> import ...`

---
> Выполняет ли `importlib.reload()` рекурсивную перезагрузку модулей?

Нет, модули, импортируемые перезагружаемым модулем, не перезагружаются сами

Нужно писать `.reload()` явно для каждого модуля

---
> Разрешен ли циклический импорт модулей?

Чисто технически он возможен, но его следует избегать

Последовательность действий при циклическом импорте:

- выполняется тело модуля `A`, он добавляется в словарь `sys.modules` и словарь его атрибутов начинает заполняться
- в коде модуля `A` встречается инструкция `import B`
- выполняется тело модуля `B`, он добавляется в словарь `sys.modules` и словарь его атрибутов начинает заполняться
- в коде модуля `B` встречается инструкция `import A`
- из кеша - словаря `sys.modules` достается частично инициализированный объект модуля `A`. Его код не выполняется: модуль считается уже импортированным
- (проблемы возможны здесь) продолжается выполнение модуля `B` до конца
- продолжается выполнение модуля `A` до конца

Как видно, в модуле `B` будут доступны лишь те атрибуты `A`, которые связаны до инструкции `import B`. Попытка обращения к другим атрибутам вызовет ошибку

---
> Можно ли изменять вручную записи в `sys.modules`?

Да, технически это возможно, хотя прием редкий. Функция `__import__()` не проверяет тип объекта в словаре, и вернет установленный пользователем

В частности, можно заменить запись (напр., `sys.modules['__main__']`) на объект, чей класс реализует специальные методы типа `.__(g|s)etattr__()`, и управлять атрибутами псевдо-"модуля" динамически

---
> Для чего могут потребоваться пользовательские функции - импортеры модулей?

Например, для импорта из архивов, отличных от ZIP, для импорта из баз данных, для импорта по сети

---
> Как можно установить пользовательские функции - импортеры модулей?

- (не рекомендуется) через подмену функции `builtin.__import__()`
- (?) с использованием `sys.meta_path`
- (?) с использованием мощных возможностей `importlib`
- добавив свой класс в список `sys.path_hooks`

В последнем случае пишется свой класс (совмещающий импортер и загрузчик) с методами `.find|create|exec|load_module()`, и добавляется в хуки:

```python
sys.path_hooks.append(ImporterAndLoader)
sys.path.append(ImporterAndLoader.fake_path)
```

После этого в конструкторе этого класса проверять текущий путь на совпадение с `.fake_path`, и выполнять кастомные действия, если нужно

---
> Что такое *пакет*?

Модуль, объединяющий другие модули

Физически представляет из себя папку или ZIP-архив с файлом `__init__.py` (возможно пустым) в корне

---
> Что является телом пакета?

Содержимое файла `__init__.py`, возможно пустое

Этот файл выполняется при импорте пакета

---
> Какой тип переменных имеют `P`/`M`/`V` в импортах пакетов `import P.M[ as V]`?

- без алиаса `P` связывается с объектом пакета, `M` становится атрибутом `P` и имеет тип объекта модуля
- с алиасом `V` имеет тип модуля

---
> Как разделять общие (глобальные) переменные между модулями одного пакета?

Выносить такие переменные в файл `common.py`

Это позволит писать в модулях `from . import common`, после чего получать доступ через `common.<attr>`

---
> Как внутри пакета импортировать модуль на том же уровне вложенности?

Использовать *относительный* импорт:

```python
from . import <module-name>
```

---
> Перечислите основные специальные атрибуты пакета

- `__file__` - путь к файлу `P/__init__.py` (телу пакета)
- `__package__` - строка, имя пакета
- `__all__` - глобальная переменная, определяемая в теле пакета, перечисляет то, что импортируется под `*`
- `__path__` - список путей, в которых ищутся модули и подпакеты `P`

---
> Можно ли расположить модули и подпакеты пакета в разрозненных каталогах?

Да, можно, но для этого нужно вручную модифицировать атрибут `.__path__`

---
> Что такое *пакеты пространств имен*?

*Непосредственные* подкаталоги директорий из `sys.path`, не содержащие файла `__init__.py`

Импортировать их можно стандартным импортом, и для них создаются объекты в `sys.modules[P]`, только без атрибута `.__file__`

---
> Что такое *абсолютный импорт*?

Стандартный импорт, запись вида

```python
import <package>
import <package>.<module>
from <package> import <module>
```

Поиск при таком синтаксисе производится в каталогах из `sys.path`

> Сначала идет поиск в текущем модуле/пакете. Чтобы этого избежать, нужно указывать
> 
> ```python
> from __future__ import absolute_import
> ```

---
> Что такое *относительный импорт*?

При таком импорте поиск не ведется в `sys.path`, а только в текущем пакете. Синтаксис только через `from`, и нужно указывать точку `.`:

```python
from . import M
```

Можно указать модуль/подпакет на текущем уровне, внутри которого осуществлять поиск:

```python
from .SP import M
```

---
> Как сделать относительный импорт из модуля на несколько уровней выше?

Точек в записи относительного импорта должно быть столько, сколько уровней вверх + 1. Например, импорт из директории на один уровень выше (из родительской):

```python
from .. import M
from ..SP import M
```

---
> Какой объект называется *встроенным*?

Обращение к которому возможно без явной инструкции `import`

Встроенными бывают типы, а также функции из модуля `builtins`

---
> Что называется *байтом* в Python?

Целое число в диапазоне от `0` до `255`

В байтовых последовательностях (`bytes` и `bytearray`) байты как правило записываются в шестнадцатеричном представлении:

```python
b'\xff ...'
```

---
> В чем отличие типов `bytes` и `bytearray`?

- `bytes` - неизменяемая последовательность, гибрид `list` и `str`
- `bytearray` - то же, только последовательность изменяемая

> `bytes` синоним `str`

---
> Какой литерал у типов `bytes` и `bytearray`?

- у `bytes` - строка с префиксом `b`: `b'\x01\x02\x03'`
- у `bytearray` нет своего литерала, нужно вызывать конструктор: `bytearray(b'\x01...')`

---
> Как преобразовать строку в последовательность байтов?

Вызвать на строке метод `.encode()` с опциональной строкой - именем кодека:

```python
'test'.encode() == b'test'
'test'.encode('utf8') == b'test'
```

Преобразование идет в (неизменяемую) последовательность `bytes`. Для преобразования в `bytearray` нужно еще обернуть всё в его конструктор

---
> Как преобразовать список целых чисел в байтовую строку `bytes`? В `bytearray`?

Конструкторы обоих типов принимают списки, так что напрямую:

```python
bytes([1,2]) == b'\x01\x02'
bytearray([1,2]) == bytearray(b'\x01\x02')
```

---
> Какие аргументы принимает конструктор `complex()`?

Их два:

```python
complex(real=0, imag=0)
```

---
> Как конструктор коллекции копирует переданную ему в качестве аргумента (другую) коллекцию?

Делает shallow copy в случае изменяемых последовательностей и возвращает ссылку на ту же коллекцию в случае неизменяемой:

```python
dict(x) ~ x.copy()
list(x) ~ x.copy() ~ x[:]
set(x) ~ x.copy()
str(x) == x
frozenset(x) == x.copy() == x
tuple(x) == x == x[:]
```

---
> Как работает копирование для неизменяемых коллекций?

Возвращается та же коллекция:

```python
x = tuple([1, 2])
x[:] == x == tuple(x)

x = frozenset([1, 2])
x.copy() == x == frozenset(x)
```

Это верно не только для shallow-клонов, но и для `copy.deepcopy`: в памяти не хранится два одинаковых неизменяемых объекта, видимо нет смысла в этом

---
> Что такое тип `memoryview`?

- его конструктор получает аргумент, объект, который должен поддерживать интерфейс `buffer`. Это, например, `bytes` и `bytearray`
- возвращает объект - точное внутренне представление участка памяти, в котором хранится эта байтовая последовательность
- поддерживает атрибут `.itemsize` (размер элемента в байтах, как правило `1`), на нем можно вызвать `len(m)`

---
> В каком качестве можно использовать экземпляр `object` в сравнениях?

Как некий "страж", объект, отличающийся от любого другого:

```python
(C() != object()) == True
```

---
> Какие значения по умолчанию у аргументов конструктора `slice`?

Для всех трех `None`, не числа

---
> Где можно вызывать `super()`?

Только в коде методов класса. В этом случае, через интроспекцию, конструктор суперобъекта сам определит текущий класс и объект, и параметры можно не передавать

---
> Какой специальный атрибут экземпляра `x` возвращает вызов `type()`?

Атрибут `__class__`:

```python
type(x) == x.__class__
```

---
> Как проверять типы в Python?

Через `type(x) is <type>` лучше не проверять: не будут учитываться полиморфные типы. Лучше использовать одну из двух стратегий:

- "утиную" типизацию - в блоках `try:`/`except:` выполнять действия так, как будто переменная имеет нужный тип
- "гусиная" типизация - проверять типы через встроенную функцию `isinstance()`

---
> Что возвращает встроенная функция `abs()` для комплексного числа?

Так называемый *модуль комплексного числа*:

```python
abs(x) == x.imag**2 + x.real**2
```

---
> Как идет процесс вычислений во встроенных функциях `all()`/`any()`?

По короткой цепи, от начала последовательности

Вычисления останавливаются как только:

- для `all()` - найден элемент `~ False`
- для `any()` - найден элемент `~ True`

---
> Как перевести число в строку в разных системах счисления?

Через конструктор `str` или группу встроенных функций:

```python
str(3) == '3'

bin(3) == '0b11'
oct(3) == '0o3'
hex(3) == '0x3'
```

---
> Как проверить, что объект вызываемый?

Лучше не полагаться на проверку специального атрибута `x.__call__()`, а использовать встроенную функцию `callable(x)` (возвращает булево значение)

---
> Как получить символ по его Unicode-коду?

Через встроенную функцию `chr()`. Она возвращает строку единичной длиной:

```python
chr(112) == 'p'
chr(1092) == 'ф'
```

> Работает только для кодов `< 256`, для Юникода нужно использовать `unichr()`

---
> Какое промежуточное действие функции `eval()`/`exec()` выполняют неявно?

Компиляцию строки кода, делают неявный вызов встроенной функции `compile` с нужным третьим аргументом:

```python
compile('<code>', None, 'eval')
compile('<code>', None, 'exec')
```

---
> Как на объекте получить доступ к атрибуту, чье имя задано строкой/переменной?

Через группу встроенных функций:

```python
getattr(obj, 'x', None) ~ obj.x
setattr(obj, 'x', 1) ~ obj.x = 1
delattr(obj, 'x') ~ del obj.x
hasattr(obj, 'x') ~ 'x' in obj
```

Как видно из примера выше, `getattr()` поддерживает также значение по умолчанию, если атрибут не найден

---
> За что отвечает второй параметр встроенной функции `enumerate()`?

Он не усекает сам список, он задает стартовый индекс для нумерации пар:

```python
# len() == 2
list(enumerate([1, 2], 3)) == [(3, 1), (4, 2)]
```

По умолчанию равен нулю:

```python
enumerate(iterable, start=0)
```

---
> Какая сигнатура у функций `eval()`/`exec()`?

- первым аргументом идет или строка, или предварительно скомпилированный объект кода. В случае строки компиляция выполняется неявно, через встроенную `compile()`
- вторым и третьим аргументами идут словари пространств имен, по умолчанию это `globals()` и `locals()` соответственно

> `exec` работает аналогично, но является инструкцией, не функцией

---
> Каков порядок аргументов в функциях `filter()`/`map()`? Что они возвращают?

Сначала идет функция, потом итерируемый объект

Возвращают итератор

> Возвращают список

---
> Что возвращает встроенная функция `globals()`?

Атрибут `.__dict__` вызывающего модуля, словарь "имя-значение" текущего глобального пространства имен в точке вызова

В скрипте этот словарь будет содержать

```python
globals()['__name__'] == '__main__' == __name__
```

---
> Чему равна переменная `__name__` в интерактивном сеансе?

```python
'__main__'
```

---
> Чему равен словарь `locals()` вне функций?

И вне функций он равен текущему пространству имен, то есть совпадает с `globals()`

---
> Как будут сравниваться два экземпляра класса, у которого не определена операция сравнения `.__eq__()`?

По `id()`:

```python
x == y ~ id(x) == id(y)
```

А вот проверка идентичности

```python
x is y
```

эквивалентна сравнению по `id()` всегда

---
> Какая сигнатура у встроенной функции `input()`?

Один параметр - `prompt=''`. Функция всегда возвращает строку

> Эквивалентна `eval(raw_input(prompt))`

---
> Какой тип у второго аргумента `isinstance()`?

Он может быть классом или кортежем классов

В случае кортежа функция вернет `True` если первый аргумент - экземпляр *любого из* классов в кортеже

---
> В чем сходства и различия функций `isinstance()` и `issubclass()`?

- обе они - встроенные функции
- у обеих второй аргумент может быть кортежем, обе возвращают булево значение

- но первая работает на уровне экземпляров, а вторая - классов
- соответственно различаются и сигнатуры в первом аргументе (экземпляр и класс)

---
> Напишите функцию-генератор, которая будет синтезирована при вызове `iter()`, если у класса последовательности нет метода `.__iter__()`

Именно для последовательности, не для других типов коллекций:

```python
def iter_seq(obj):
    i = 0

    while True:
        try:
            yield obj[i]

        except IndexError:
            raise StopIteration

        i += 1
```

Это обертка, которая просто обращается к индексам последовательно до тех пор, пока не выйдет за границу

---
> Как через литерал записать кортеж из одного элемента?

Обязательно указывать запятую, лучше со скобками:

```python
x = (1,)
x = 1,
```

Без запятой в обоих случаях в примере выше будет создан не кортеж, а объект-число

Это, в некотором роде, противоположность литерала пустого кортежа: там запятая не требуется и вызывает ошибку





---

# Примеры кода `[code]`

---
> Что выведет этот код?
> 
> ```python
> ```

```python
```

---
> Что выведет этот код?
> 
> ```python
> def x(a, *, c):
>     print(a, c)
> 
> x(1)
> ```

`TypeError: x() missing 1 required keyword-only argument: 'c'`

Несмотря на то, что у `c` нет значения по умолчанию, он всё так же находится после `*[args]` и может вызываться только по имени. Причем без дефолтного значения он становится обязательным

---
> Что выведет этот код?
> 
> ```python
> class C:
>     pass
> 
> issubclass(C, C)
> ```

Для любого класса всегда

```python
True
```

---
> Что выведет этот код?
> 
> ```python
> list(filter(None, [0, 1, {}, 2]))
> ```

```python
[1, 2]
```

Функцию фильтрации можно заменить на `None`, тогда проверка элемента на истинность будет идти для каждого элемента по стандартным правилам приведения типов

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (,)
> ```

Ничему, будет выброшено `SyntaxError: invalid syntax`

Пустой кортеж задается просто парой скобок, а не запятой, со скобками или без - `(,)`/`,`

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> for i, num in enumerate(x := list(range(10))):
>     del x[i]
> ```

```python
[1, 3, 5, 7, 9]
```

(?) Разобраться, почему так

---
> Что выведет этот код?
> 
> ```python
> class A():
>     x = 1
> 
> c = A()
> print(c.x)
> del A.x
> print(c.x)
> ```

```shell
1
AttributeError: 'A' object has no attribute 'x'
```

Удаление атрибута класса приведет к "исчезновению" атрибута у всех объектов, в том числе уже созданных

---
> Что выведет этот код?
> 
> ```python
> all([])
> any([])
> ```

```python
True
False
```

Ключевое слово для обеих функций - "любой" (вычисления по короткой цепи). По определению этих функций:

- `all()` - возвращает `False`, если любой элемент последовательности `~ False`, иначе (пустая последовательность) `True`
- `any()` - возвращает `True`, если любой элемент последовательности `~ True`, иначе (пустая последовательность) `False`

---
> Что выведет этот код?
> 
> ```python
> int('1001', 0)
> int('0b1001', 0)
> ```

```python
1001
9
```

Ноль в качестве второго параметра конструктора `int` (основание системы счисления, `radix`) будет пытаться распознать строку по префиксу. Строки без префикса считаются десятичными числами

---
> Что выведет этот код?
> 
> ```python
> int(2.4), int(2.5), int(2.6)
> ```

```python
(2, 2, 2)
```

Конструктор типа `int` не округляет свои параметры - дробные числа, а просто усекает их дробную часть

---
> Что выведет этот код?
> 
> ```python
> dict([(1,2,3)])
> ```

```python
ValueError: dictionary update sequence element #0 has length 3; 2 is required
```

В такой форме (через последовательность item-ов) конструктор принимает только пары (кортежи из двух элементов)

---
> Что выведет этот код?
> 
> ```python
> bytes(0)
> bytes(1)
> ```

```python
b''
b'\x00'
```

Целое число `N` в (обоих) конструкторах байтовых последовательностях повторяют ноль (`\x00`) `N` раз

---
> Что выведет этот код?
> 
> ```python
> bytes(256)
> bytes([256])
> ```

```shell
b'\x00...\x00' # 256 нулей
ValueError: bytes must be in range(0, 256)
```

Списки и целые числа ведут себя по разному в конструкторах байтовых последовательностей

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [1, 2]
> x[10:0] = [3,4]
> ```

```python
[1, 2, 3, 4]
```

Вместо левой границы среза будет взята длина списка. Правый индекс меньше левого, срез пустой. Операция эквивалента добавлению списка в конец, конкатенации

---
> Что будет выведено в консоль, если запустить скрипт `test.py` со следующим кодом?
> 
> ```python
> import sys
> import test
> 
> print(sys.modules['test'], sys.modules['__main__'])
> ```

```shell
<module 'test' from 'test.py'> <module '__main__' from 'test.py'>
<module 'test' from 'test.py'> <module '__main__' from 'test.py'>
```

- при импорте скрипта из самого себя в `sys.modules` появятся два ключа - `test` и `__main__` - две записи в каждой строке
- но и тело скрипта будет выполнено дважды - две строки в выводе

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [1, 2, 3]
> x[1:2] = range(2)
> ```

```python
[1, 0, 1, 3]
```

- RHS в присваивании срезу не обязана быть списком, а может быть любым итерируемым объектом
- размер тоже не обязан совпадать

---
> Что выведет этот код?
> 
> ```python
> x = (1,2); id(x) == id(x[:])
> x = (1,2); id(x) == id(x * 1)
> ```

```python
True
True
```

В отличие от списков, кортежи не создают shallow-клоны через срезы и умножение на единицу, а просто возвращают ссылку на тот же объект

---
> Что выведет этот код?
> 
> ```python
> class C:
>     def x(self):
>         return self.y
> 
> try:
>     getattr(C(), 'x')()
> 
> except AttributeError:
>     print('default')
> ```

`default`

Это пример ошибочного, слишком "широкого" применения стратегии EAFP: в блоке `except:` перехватывается не только возможное отсутствие атрибута, но и (случайно) все исключения типа `AttributeError`, выброшенные в самой функции. В нашем случае это обращение к несуществующему атрибуту `self.y`

Нужно оставить в `try:` только получение атрибута, а вызов полученного метода вынести в `else:`

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except ArithmeticError:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
1
```

Несмотря на то, что `ZeroDivisionError` специфичнее (точное совпадение с типом), его базовый класс `ArithmeticError` идет в списке `except:`-ов первым, и будет выполнен именно он

Поэтому правило "располагайте более специфичные обработчики выше более общих" лишь хорошая практика, а не жесткое требование на уровне языка

---
> Что выведет этот код?
> 
> ```python
> class C(ZeroDivisionError):
>     pass
> 
> try:
>     1/0
> except C:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
2
```

Класс `C` более специфичен, чем `ZeroDivisionError`, и выбрасываемое исключение не является его подклассом

---
> Что выведет этот код?
> 
> ```python
> try: 1/0
> except ZeroDivisionError: 1 + ''
> ```

```shell
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

В v3 автоматически запоминается контекст, и выводится информация об обоих ошибках, если одна возникла в процессе обработки другой

---
> Что выведет этот код?
> 
> ```python
> print(print(1), print(2))
> ```

```python
1
2
None None
```

`print()` возвращает `None`

---
> Что выведет этот код?
> 
> ```python
> 1e1
> 1e2
> ```

```python
10.0
100.0
```

`e|E` обозначает степень десятки

---
> Как выполнить тесты (doctest) в комментариях? Приведите 2 варианта

Запустив скрипт с кодом:

```python
import doctest

if __name__ == '__main__':
    doctest.run_docstring_examples(<func>, globals())
```

Или запустив doctest как скрипт и передав ему свой скрипт в качестве параметра:

```shell
$ python3 -m doctest <file>
```

---
> Что выведет этот код?
> 
> ```python
> [[]]*3
> ```

```python
[[], [], []]
```

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [[]]*3
> x.append(1)
> ```

```python
[[], [], [], 1]
```

---
> Что выведет этот код?
> 
> ```python
> -1 - -1
> ```

```python
0
```

---
> Напишите функцию, сравнивающую два дробных числа

```python
def approx_eq(x, y, tolerance=1e-5):
    return abs(x - y) < tolerance
```

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = [[]]*3
> x[0].append(1)
> ```

```python
[[1], [1], [1]]
```

`[[]]*3` создает три ссылки на один и тот же список

---
> Каково поведение оператора `//` для разных типов данных?

- если хотя бы один аргумент дробный (`5.0//2`, `-5//2.0`) результат тоже дробный (`2.0`)
- т.е. результат будет иметь тип `int` только если оба аргумента `int` (`5//2 = 2`)
- при этом всегда идет округление вниз: `5.0//2 = 2.0`, `-5//2.0 = -3.0`

---
> Напишите однострочник генерации пустой квадратной матрицы размера `n`

```python
[[None for i in range(n)] for j in range(n)]
```

или

```python
[[0]*n for _ in range(n)]
```

Использовать `[[0]*n]*n` нельзя: внутренний список будет продублирован как shallow-клон

---
> Напишите однострочник, строящий подмножество всех слов длиной не меньше 5 символов, для которых в исходном множестве есть обратное слово

```python
{ w for w in words if len(w) >= 5 and w[::-1] in words }
```

---
> Что выведет этот код?
> 
> ```python
> two = print(2)
> print(two)
> ```

```python
2
None
```

`print()` возвращает `None`

---
> Какая есть альтернативная запись операторов в Python?

Как функций. Их можно импортировать из модуля operator:

```python
from operator import add, mul

2 + 3 * 4 + 5 # = 19
add(add(2, mul(3, 4)) , 5) # = 19
```

---
> Что делает функция `random.uniform()`?

Получает 2 аргумента и возвращает псевдослучайный `float`, лежащий между ними (`a <= N <= b`). Если второй аргумент меньше первого, они прост меняются местами

---
> Как заполнить матрицу значениями вне главной диагонали?

В два цикла, вложенный перебирает до текущего счетчика внешнего:

```python
for i in range(n):
    for j in range(i):
        matrix[i][j] = matrix[j][i] = ...
```

Нужно предварительно сгенерировать пустую матрицу

---
> Что выведет этот код?
> 
> ```python
> i = 4
> def foo(x):
>     def bar():
>         print(i, end='')
> 
>     for i in x:
>         print(i, end='')
>     bar()
> 
> foo([1, 2, 3])
> ```

`1 2 3 3`, последняя цифра не `4`: `i` - локальна для `foo()` и будет последним результатом счетчика цикла

---
> Что выведет этот код?
> 
> ```python
> x = 3
> addr = id(x)
> x += 1
> addr == id(x)
> ```

```python
False
```

Числа неизменяемы, даже составное присваивание не изменит объект, а просто переназначит ссылку (установит ее на временный объект)

---
> Что выведет этот код?
> 
> ```python
> 2 == 2 and 0 == 0
> ```

```python
True
```

Операторы сравнения имеют более высокий приоритет, чем логические связки

---
> Что выведет этот код?
> 
> ```python
> "bc" in "abcde" == True
> ```

```python
False
```

Код эквивалентен

```python
"bc" in "abcde" and "abcde" == True
```

Для этой группы операторов цепочки условий разбиваются на части при помощи связки `and`

---
> Что выведет этот код?
> 
> ```python
> x = [1, 2, 3]
> x[1:1] = [4]
> ```

```python
[1, 4, 2, 3]
```

Это альтернативный способ вставки элементов в список

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][1:1]
> ```

```python
[]
```

При совпадающих индексах срез всегда пустой

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][-2:-1]
> ```

```python
[2]
```

Для приведения сложим отрицательные индексы с длиной. Получим `[1:2]`

---
> Что выведет этот код?
> 
> ```python
> list(range(10))[-5:]
> ```

```python
[5, 6, 7, 8, 9]
```

Все элементы начиная с `(10-5)`-го

---
> Что выведет этот код? Какие есть альтернативные записи?
> 
> ```python
> list(range(10))[10:0:-2]
> ```

```python
[9, 7, 5, 3, 1]
```

Любой из индексов начала/конца можно опустить: `[10:0:-2]` ~ `[10::-2]` ~ `[:0:-2]` ~ `[::-2]`

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (['a'], ['b'])
> x[1] = 'c'
> ```

`TypeError: 'tuple' object does not support item assignment`

Кортежи неизменяемы, доступ по индексу только на чтение, присваивать значения нельзя

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = (['a'], ['b'])
> x[1][0] = 'c'
> ```

```python
(['a'], ['c'])
```

Хотя кортежи и неизменяемы, здесь заменяется не элемент кортежа, а первый элемент его изменяемого элемента - списка в позиции `1`

В целом, такая практика - кортежи из элементов изменяемых типов - не рекомендована

---
> Что выведет этот код?
> 
> ```python
> x = [1]
> addr = id(x)
> x[:] = [2]
> addr == id(x)
> ```

```python
True
```

Переприсваивание через полный срез не меняет адрес объекта, а перезаписывает его

---
> Чему равен `x` после выполнения этого кода?
> 
> ```python
> x = list(range(6))
> del x[::2]
> ```

```python
[1, 3, 5]
```

Удалены элементы под индексами `0`, `2`, `4` (значение совпадают с индексами)

---
> Что выведет этот код?
> 
> ```python
> for d in {1: 2, 3: 4}:
>     print(d)
> ```

```python
1
3
```

Итерация по словарю всегда идет по его ключам, не по парам или значениям

---
> Что выведет этот код?
> 
> ```python
> test = [1, 2, 3]
> 
> for test[1] in 'xyz':
>     print(test)
> ```

```python
[1, 'x', 3]
[1, 'y', 3]
[1, 'z', 3]
```

В качестве целевой переменной цикла может служить всё что угодно, в том числе элемент списка

---
> Что выведет этот код?
> 
> ```python
> for i in []:
>     pass
> print(i)
> ```

`NameError: name 'i' is not defined`

Целевая переменная цикла инициализируется лишь тогда, когда итерируемая последовательность непуста. Иначе не выполняется ни тело цикла, ни присваивание `i`

---
> Что выведет этот код?
> 
> ```python
> for x in []:
>     print(1)
> else:
>     print(2)
> print(3)
> ```

```python
2
3
```
Коллекция `[]` пустая, цикл не выполнится ни разу. Но выход не по `break`, и `else` будет выполняться

---
> Что выведет этот код?
> 
> ```python
> def f(x, y=[]):
>     y.append(x)
>     return y
> 
> print (f(23))
> print (f(42))
> ```

```python
[23]
[23, 42]
```

Значение именованного параметра вычисляется единожды, в момент объявления функции

---
> Что выведет этот код?
> 
> ```python
> def f(x, y):
>     х = 23
>     y.append(42)
>
> a = 77
> b = [99]
> f(a, b)
> print(a, b)
> ```

```python
77 [99, 42]
```

Числа и прочие неизменяемые объекты передаются в функцию по значению, тогда как изменяемые объекты (напр., списки) - по ссылке

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     y += 1
> f()
> print(y)
> ```

`UnboundLocalError: local variable 'y' referenced before assignment`

Идет попытка записи в глобальную переменную без явного указания директивы `global`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
> 
> f()
> print(x)
> ```

`NameError: name 'x' is not defined`

Присваивание (инициализация `x`) обязательно: `global <var>` не является "объявлением" переменной с пустым значением

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
>     x = 1
> 
> f()
> print(x)
> ```

```python
1
```

Создавать глобальные переменные из функций вполне можно

---
> Что выведет этот код?
> 
> ```python
> def f():
>     x = 1
> 
>     def g():
>         x += 1
> 
>     g()
>     return x
> 
> print(f())
> ```

`UnboundLocalError: local variable 'x' referenced before assignment`

Ситуация аналогична доступу на запись к глобальным переменным: `x += 1` нельзя вызывать, т.к. внутри функции `g()` переменная `x` из внешней функции по умолчанию доступна только на чтение. Нужно либо инициализировать (создать) свою переменную `x` внутри `g()`, либо указать перед составным сложением директиву `nonlocal x`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     def g():
>         nonlocal y
>         y = 2
> 
>     g()
>     return y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

В отличие от `global`, создавать переменные внешних функций из внутренних нельзя

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     def g():
>         nonlocal y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

Директива `nonlocal` просматривает только вложенные функции, не глобальную область видимости. Поэтому глобальный `y` рассматриваться не будет

Кроме того, в отличие от `global` она уже выбрасывает ошибку, если не найдет указанную в директиве переменную

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> print(type(A), type(A()))
> ```

`<class 'type'> <class '__main__.A'>`

---
> Напишите базовую реализацию синглтона

```python
class Singleton:
    _instances = {}

    def __new__(cls, *args, **kwds):
        if cls not in cls._instances:
            cls._instances[cls] = super().__new__(cls)

        return cls._instances[cls]
```

После `.__new__()` будет автоматически вызван `.__init__()`, так что нужно позаботиться еще и том, чтобы инициализация учитывала единственность экземпляра

---
> Что выведет этот код при запуске с одной и с двумя `-O`?
> 
> ```python
> def test():
>     """Doctsring."""
> 
> print(test.__doc__)
> ```

```python
# с одной -O
'Doctsring.'
# с двумя -O строки документации будут удалены
None
```

---
> Что выведет этот код?
> 
> ```python
> x = [1,2]
> addr = id(x)
> x += [2]
> print(id(x) == addr)
> ```

```python
True
```

Составное сложение (конкатенация) списков не изменит адреса объекта
---
> Что выведет этот код?
> 
> ```python
> x = (1,2)
> addr = id(x)
> x += (2,)
> print(id(x) == addr)
> ```

```python
False
```

В отличие от списков кортежи неизменяемы, и даже составное присваивание (конкатенация) не сохранит адрес объекта

---
> Что выведет этот код?
> ```python
> def f(x, msg=None):
>     if msg:
>         print(msg, end=',')
>     return x
> 
> print(f(1) < f(2) < f(3, 'last'))
> print(f(2) < f(1) < f(3, 'last'))
> ```

```shell
last,True
False
```

Цепочки сравнений разворачиваются в выражения с `and`, которые вычисляются по короткой цепи. Во втором случае `2 < 1 == False`, и следующее за ним выражение `... and f(3)` уже не вычисляется

---
> Что выведет этот код?
> 
> ```python
> class A:
>     def test(self):
>         pass
> 
> print(A.test, A().test)
> ```

`<function A.test at 0x7f...> <bound method A.test of <__main__.A object at 0x7f...>>`

Методы экземпляра являются объектами *связанных методов* (bound methods), а атрибуты класса - просто объектами функций

> На уровне класса это будут *несвязанные методы* - `<unbound method A.test>`

---
> Что выведет этот код?
>
> ```python
> class A:
>     def x(self):
>         pass
> 
> def y():
>     pass
> 
> a = A()
> a.y = y
> 
> print(a.x)
> print(a.y)
> ```

```shell
<bound method A.x of <__main__.A object at 0x7f...>>
<function y at 0x7f...>
```

Python не создает связанные методы для функций из словаря экземпляра `C().__dict__`, только для атрибутов класса. И только для атрибутов класса, объект-метод (являющийся дескриптором) вызовет свой `.__get__()` и вернет объект типа `bound method`

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> print(A.__mro__)
> ```

`(<class '__main__.A'>, <class 'object'>)`

Read-only кортеж включает также и сам класс

---
> Что выведет этот код?
> 
> ```python
> class A:
>     @property
>     def x(self): return 1
> 
> class B(A):
>     def x(self): return 2
> 
> print(B().x)
> ```

`<bound method B.x of <__main__.B object at 0x7f...>>`

Декораторы не наследуются

---
> Что выведет этот код?
> 
> ```python
> class A:
>     def x(self): return 1
>     y = property(x)
> 
> class B(A):
>     def x(self): return 2
> 
> print(B().y)
> ```

```python
1
```

Конструктор свойства получает объект метода в момент выполнения тела класса `A`, а не динамически, в процессе выполнения скрипта. Поэтому, единожды "обернув" метод, он всегда будет возвращать значение из класса `A`

Это можно обойти, использовав еще один уровень косвенности. Или через декоратор, повторяя его в каждом дочернем классе

---
> Что выведет этот код?
> 
> ```python
> def fake_get_item(n):
>     return n
> 
> class A:
>     def __getitem__(self, n):
>         return fake_get_item(n)
> 
> class B:
>     pass
> 
> a, b = A(), B()
> b.__getitem__ = fake_get_item
> 
> print(a[3])
> print(b[3])
> ```

```shell
3
TypeError: 'B' object is not subscriptable
```

Специальный методы нельзя связывать на уровне экземпляра, только на уровне класса

---
> Что выведет этот код?
> 
> ```python
> class A(dict, list):
>     pass
> ```

`TypeError: multiple bases have instance lay-out conflict`

Хотя язык позволяет наследование от встроенных типов, оно не безусловное, и иногда невозможно, если типы несовместимые

---
> Что выведет этот код?
> 
> ```python
> class A:
>     x = 1
>     def __getattr__(self, name):
>         print('get attr')
>     def __setattr__(self, name, val):
>         print('set attr')
> 
> A().x = 2
> ```

`set attr`

В отличие от `.__getattr__()` специальный метод установки вызывается всегда, а не только когда атрибута нет

---
> Что выведет этот код?
> 
> ```python
> class A:
>     x = 1
>     def __setattr__(self, name, val):
>         print(getattr(self, name))
> 
> A().x = 2
> ```

```python
1
```

Без вызова

```python
super().__setattr__(name, val)
```

в начале метода в словарь `self.__dict__` ничего записано не будет

После добавления этого вызова `print()` выведет `2`

---
> Что выведет этот код?
> 
> ```python
> class A:
>     pass
> 
> def x(self, y)
>     print(self, y)
> 
> A.x = x
> A().x(1)
> ```

`<__main__.A object at 0x7f...> 1`

Задавать методы вполне можно и вне тела класса, и это будут полноценные *связанные* методы

---
> Что выведет этот код?
> 
> ```python
> x: int
>
> if x:
>     print('inside if')
> ```

`NameError: name 'x' is not defined`

"Объявления" вида `x: int` не создают переменную, без начального присваивания она не существует

---
> Что выведет этот код?
> 
> ```python
> -2**2
> ```

```python
-4
```

Унарный минус в записи `-2` - это оператор, не часть литерала, поэтому на него распространяется приоритет. Оператор же возведения в степень приоритетней унарного минуса

---
> Как записать следующий код через `type()`?
> 
> ```python
> class A(B):
>     pass
> ```

```python
A = type('A', (B,), {})
```

Вызов `type()` с тремя параметрами создает класс "на лету"; родительские классы должны попадать в кортеж - второй аргумент
---
> Что выведет этот код?
> 
> ```python
> class A: pass
> 
> print(A.__class__)
> print(A().__class__.__class__)

```shell
<class 'type'>
<class 'type'>
```

Дефолтным метаклассом всех классов является `type`

---
> Что выведет этот код?
> 
> ```python
> type.__class__
> ```

```shell
<class 'type'>
```

`type` является собственным метаклассом

Это нельзя реализовать на самом языке, сделано на уровне внутренней реализации

---
> Что выведет этот код?
> 
> ```python
> try: pass
> except NonExistingClass: pass
> ```

Ничего, отработает нормально. Обработчик исключения (блок `except:`) выполняется только в случае, когда выброшено исключение

То есть ошибку (`NameError: name 'NonExistingClass' is not defined`) вызовет только вот такой код:

```python
try: 1/0
except NonExistingClass: pass
```

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except ZeroDivisionError:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

```python
1
```

Обработчики исключений просматриваются в порядке объявления, и выполняется только один - первый

---
> Что выведет этот код?
> 
> ```python
> try:
>     1/0
> except:
>     print(1)
> except ZeroDivisionError:
>     print(2)
> ```

Ошибку `SyntaxError: default 'except:' must be last`

---
> Что выведет этот код?
> 
> ```python
> try: pass
> except: pass
> else: print(1)
> finally: print(2)
> ```

```python
1
2
```

`else` будет выполнено т.к. исключения в `try` выброшено не было. `finally` выполняется всегда

---
> Что выведет этот код?
> 
> ```python
> try: pass
> else: print(1)
> finally: print(2)
> ```

`SyntaxError: invalid syntax`

Блок `else` может присутствовать только если есть хотя бы один `except`

---
> Что выведет этот код?
> 
> ```python
> try:
>     try: 1/0
>     except: print(1)
>     finally: print(2)
> except:
>     print(3)
> ```

```python
1
2
```

Внутренний `except` перехватит исключение и дальше оно распространяться не будет. При этом блок `finally` выполнится тоже: он выполняется всегда

---
> Что выведет этот код?
> 
> ```python
> try:
>     try: 1/0
>     except TypeError: print(1)
>     finally: print(2)
> except:
>     print(3)
> ```

```python
2
3
```

Будет выброшено `ZeroDivisionError`, оно не будет перехвачено внутренним `except`, и распространение исключения продолжится. `finally` выполняется всегда, но не подавляет распространение исключения

---

# Среда и командная строка `[env]`

---
> Какие (и на каких языках) есть реализации Python?

- *CPython* - на C, самая поддерживаемая (*референсная*)
- *Jython* - на Java, для взаимодействия с кодом на Яве
- *Python for .NET*, *IronPython* - оба для .NET, первая использует CPython, вторая написана на Python
- *PyPy* - полностью на Python, поддерживает stackless и JIT

---
> Для какой реализации Python рассматриваются все вопросы здесь?

Для *CPython*, наиболее распространенной

---
> Какие два самых известных линтера для Python?

PyFlakes (более простой) и PyLint (более тяжелый, но с б*о*льшими возможностями)

---
> Какие есть способы выйти из REPL?

- `quit()`
- `sys.exit()`
- `raise SystemExit[()]`
- `Ctrl + D` (EOF)
- `Ctrl + Z` (SIGTSTP; не сохраняет историю)

Первые три завершают также любой скрипт

---
> Как получить последний результат в REPL?

Переменная "подчеркивание", `_`

---
> Как выглядят и где задаются строки приглашений в REPL?

Их два уровня, первый и второй. Задаются в модуле `sys`:

```python
sys.ps1 == '>>> '
sys.ps2 == '... '
```

---
> Что будет, если запустить интерпретатор с именем папки или zip-файла в качестве аргумента?

Будет искать в папке или zip-архиве файл с именем `__main__.py`, и выполнит его с `__name__ == '__main__'`

---
> Сработает ли команда `$ cat test.py | python3`?

Да, она так же выполнит скрипт, как и

```shell
$ python3 test.py
```

---
> Как вызвать краткую справку по консольной команде `$ python3`?

Три варианта опции: `-?`/`-h`/`--help`

---
> Как узнать версию интерпретатора?

Не стоит путать с маленькой `-v` (verbose): `-V`/`--version`. Удвоение любой из этих опция дает чуть более подробное описание версии

---
> Для чего служит опция командной строки `-c`?

Выполняется следующая за опцией команда:

```shell
$ python3 -c 'print(3)'
```

Текущая директория подставляется в начало `sys.path` (это позволяет импортировать локальные модули)

---
> Что делает опция командной строки `-m`?

Находит в `sys.path` модуль по имени (без расширения `.py`), следующему за опцией, и исполняет его как скрипт - с `__name__ == '__main__'`. Как и для `-c`, текущая директория подставляется в начало `sys.path`

---
> Допустимы ли имена пакетов с cli-опцией `-m`?

Да. В этом случае интерпретатор будет искать (и выполнять как скрипт) модуль `<pkg>.__main__`. Поведение аналогично тому, когда вместо скрипта интерпретатору передается папка или zip-файл

---
> Как получить список всех вкомпилированных (встроенных) в интерпретатор модулей?

`sys.builtin_module_names` возвращает кортеж с именами. Примеры: `sys`, `itertools`, `time`, `zlib`

---
> В каких случаях опция `-m` неприменима?

Для встроенных (`sys.builtin_module_names`) модулей и модулей, написанных на C - выдает ошибку `"No code object available for <module>"`

Для precompiled-модулей эта опция использоваться может

---
> Как передать модулю, выполняемому в режиме скрипта, параметры?

Просто перечислить их после имени модуля, например:

```shell
$ python3 -m doctest test.py # "test.py" - параметр модуля
$ python3 -m venv -h         # "-h" - параметр модуля
```

---
> Есть ли у команды `$ python3` длинные варианты опций?

Только три (`--help`, `--version`, `--check-hash-based-pycs`), для большинства же только короткие

---
> Что делает опция `-s`?

Не добавляет в `sys.path` директорию `~/.local/lib/python3.n/site-packages/` (константа `site.USER_SITE`)

---
> Что делает опция `-S`?

Запрещает авто-импорт модуля `site`. Из-за этого в `sys.path` не попадают все директории `(dist|site)-packages/`, остается только `/usr/lib/python3.n/`

Игнорирует также пользовательский каталог (`~/.local/lib/python3.n/site-packages/`), т.е. неявно подразумевает `-s`

---
> Что делает опция `-E`?

Игнорирует все переменные окружения `PYTHON*`

---
> Что делает опция `-I`?

Запускает интерпретатор в "изолированном" режиме: не учитывает переменные окружения и пользовательский каталог `site-packages` (т.е. неявно включает опции `-sE`, и кроме того не включает в `sys.path` каталог текущий)

---
> Что делает опция `-i`?

Интерпретатор переходит в интерактивный режим после выполнения переданного скрипта / команд из `stdin`. В этом интерактивном сеансе доступны все переменные из выполненного скрипта

---
> Что делает опция `-x`?

Пропускает первую строку в выполняемом скрипте (для игнорирования не-NIX shebang-ов)

---
> Какие значения принимает и что делает переменная `PYTHONINSPECT`?

Переменная-флаг, при любом непустом значении переводит интерпретатор в интерактивный режим после выполнения переданного скрипта. Аналогична опции `-i`

---
> Как запретить запись `.pyc`-файлов?

Установить значение переменной окружения `PYTHONDONTWRITEBYTECODE` в непустую строку, или вызывать интерпретатор с опцией `-B`

---
> Как удалить отладочный код при исполнении скрипта?

Удалить все ассерты и весь код, зависящий от значения `__debug__`, можно через опцию `-O` или переменную окружения `PYTHONOPTIMIZE` (равную непустой строке, или целому, равному числу повторений опции `-O`)

---
> Как в коде определить, что установлена переменная среды `PYTHONOPTIMIZE` / указана опция `-O[O]`?

Проверив "магическую" переменную `__debug__ = True|False`

В коде таким образом можно убирать целые секции, например, экономить время компиляции, скрывая используемые только в `assert`-ах функции:

```python
if __debug__:
    def my_assert_check():
        ...
```

---
> Как отключить docstrings в коде?

Вызвать интерпретатор с опцией `-OO`

Расширения генерируемых файлов байткода станут `.opt-2.pyc`

---
> Как выводить информацию об импорте/выгрузке всех модулей при выполнении скрипта?

Опция `-v` или переменная окружения `PYTHONVERBOSE` (равная непустой строке, или целому, равному числу повторений опции `-v`)

---
> Сколько раз интерпретатор выводит warning для строчки кода?

По умолчанию - один раз, это соответствует `-Wdefault`/`-Wd`. Можно поменять, например на `-Walways`/`-Wa` или `-Wignore`/`-Wi`

Те же ключи можно присваивать переменной окружения `PYTHONWARNINGS`, например, `PYTHONWARNINGS=module` (once per calling module) или `PYTHONWARNINGS=once` (once per Python process)

---
> Как превратить все warning-и в исключения?

Вызвать интерпретатор с опцией `-Werror`/`-We`, или установить переменную окружения в `PYTHONWARNINGS=error`

---
> Как можно управлять настройками интерпретатора Python?

Через пару десятков переменных окружения `PYTHON*=<some-val>` и через опции (с одним дефисом) `python3 -<opt>`. Часто переменные дублируют опции (и наоборот)

Некоторые переменные, при равенстве непустой строке, соответствуют одной опции, а при равенстве положительному числу - числу повторений этой опции:

```shell
PYTHONVERBOSE="some" ~ py3 -v
PYTHONVERBOSE=3 ~ py3 -vvv
```

---
> Как получить справку модуля по запуску его в режиме скрипта?

Стандартным способом передачи аргументов модулю, передав `-h/--help`:

```shell
$ python3 -m timeit -h
```

---
> Как выполнить Python скрипт из кода?

В модуле `runpy` есть нужная функция. По умолчанию `run_name='<run_path>'`:

```python
import runpy
runpy.run_path('./test.py', run_name='__main__')
```

---
> Как из командной строки изменить путь поиска модулей (`sys.path`)?

Задать переменную окружения, *дополняющую* путь поиска - `PYTHONPATH`:

```shell
PYTHONPATH=/some/dir/ python3 test.py
```

По умолчанию она пуста

---
> За что отвечает и какой формат имеет переменная окружения `PYTHONPATH`?

Помогает добавлять свои пути в `sys.path`, для поиска модулей. Ее формат аналогичен стандартной `PATH` - пути, разделенные `os.pathsep`

---
> В какую позицию списка `sys.path` добавляется значение переменной окружения `PYTHONPATH`?

В индекс `1` - после текущей директории, но перед первой системной:

```python
sys.path == ['', <PYTHONPATH dirs>, '/usr/lib/python37.zip', ...]
```

---
> Чему равен `sys.path[0]`?

Папке, из которой запускается скрипт, или пустой строке, при выполнении команд через `-c '...'` или из `stdin`

Во втором случае поиск модулей/пакетов всё равно будет вестись начиная с текущего каталога

---
> Чему равна `os.pathsep` на разных системах? Где используется?

Двоеточию `:` на *NIX и точке с запятой `;` на Windows. Используется в:

- `PYTHONHOME` (`<prefix>:<exec_prefix>`)
- `PYTHONPATH` (`<path1>:<path2>:...`)
- в системном `PATH`

---
> Как можно выполнить команды Python до показа первого приглашения REPL?

В переменной окружения `PYTHONSTARTUP` указать путь к Python-скрипту. Все импортированные/созданные в нем объекты станут доступны и в сессии REPL

Так же можно, например, поменять формат приглашений `sys.ps1`/`sys.ps2`

---
> Что будет, если в переменной среды `PYTHONSTARTUP` указать несуществующий скрипт, или скрипт, для которого нет прав доступа?

Ничего, система проигнорирует значение, даже предупреждения не выдаст

---
> Какая рекомендуемая *shebang*-строка для скриптов?

```shell
#!/usr/bin/env python3
```

И нужно не забывать делать скрипт исполняемым:

```shell
$ chmod +x script
```

---
> Как можно запускать команды shell-а из Python-скрипта?

Есть модуль `subprocess`, и у него функция `run()`. Например:

```python
import subprocess
subprocess.run(['ls', '-l'])
```

---
> Что будет делать команда `$ python3 -`?

Читать инструкции из `stdin`. Это режим по умолчанию, без дефиса будет то же самое. Если ничего на вход нет, то переход в интерактивный режим (`-i`).

Дефис служит для отделения аргументов командной строки от инструкций из `stdin`. Эти аргументы пишутся в `sys.argv`

---
> В каком случае команда `$ python3` читает инструкции из `stdin`?

Если после нее стоит дефис (placeholder) или отсутствует любая лексема. Если в `stdin` инструкций нет, то переход в интерактивный режим

---
> В каких случаях Python компилирует скрипты и сохраняет байткод?

Компилирует всегда

Пишет:

- на диск - при импорте модулей (и только если не установлена `PYTHONDONTWRITEBYTECODE` и не указана опция `-B`)
- в память - для обычных скриптов

---
> Где хостится исходный код CPython?

На ГитХабе: <https://github.com/python/cpython>. Там же рядом репозиторий с PEPами

---
> Откуда можно установить Python?

- скачать с оф. сайта (<https://www.python.org/downloads/>) исходники и собрать (`./configure; make; sudo make altinstall`)
- те же исходники можно склонировать с ГитХаба - <https://github.com/python/cpython>
- в Ubuntu все пакеты включены в дистрибутив. Есть в APTе, и в SNAPах есть отдельные версии и имплементации (CPython, конечно)

---
> Какие *3 пути* на файловой системе хранят файлы инсталляции?

- `/usr/bin/python3` (--> `./python3.n`) - бинарник интерпретатора
- `/usr/lib/python3.n/` - папка со стандартными модулями
- `/usr/include/python3.n/` - папка с заголовочными `.h`-файлами, нужными для разработки расширений и встраивания интерпретатора

---
> В каких папках хранятся установленные пакеты и модули?

- `/usr/lib/python3.n` - идущие вместе с интерпретатором, стандартная библиотека
- `/usr/lib/python3/dist-packages/` - пакеты, установленные через глобальный менеджер (напр., `apt`)
- `/usr/local/lib/python3.n/dist-packages/` - установленные глобально через `pip`
- `~/.local/lib/python3.n/site-packages/` - установленные локально через `pip` (без `sudo` и/или с опцией `--user`)

---
> Как узнать *базовую* директорию *пользователя* для пакетов и бинарников?

Это константа в модуле `site` - `site.USER_BASE`. Вывести ее можно через командную строку:

```shell
$ python3 -m site --user-base
```

Туда `pip` устанавливает пакеты. Как правило это папка `~/.local/` с тремя подпапками:

- `bin/` (туда идут бинарники, standalone-утилиты)
- `lib/` (сами пакеты)
- `share/`

---
> Являются ли модули `venv` и `pip` частью стандартной библиотеки Python?

`venv` является с v3.3, а `pip` - сторонний проект (<https://pip.pypa.io/en/stable/>), хотя с v3.4 он по умолчанию включается в дистрибутив Python

---
> За что отвечает переменная окружения `PYTHONHOME`?

Она может задавать т.н. *префикс* - базовую директорию для поиска папок с пакетами/модулями: `<prefix>/lib/python3.n/`. В случае, если эта переменная пуста, берется префикс `/usr`. Переменная отвечает именно за каталоги пакетов, не самого интерпретатора

---
> Куда Python сохраняет скомпилированный байткод модулей?

В папку `__pycache__/`. В нее складываются файлы (вида `*.cpython-38[.opt-(1|2)].pyc`) импортированных модулей

---
> Как формируется расширение у файлов со скомпилированным байткодом?

`<implemetation>-<version>.pyc`:

- `__pycache__/__init__.cpython-36.pyc`
- `__pycache__/testplugin.cpython-37.pyc`

---
> Как опции оптимизации влияют на расширение файлов байткода?

Перед `.pyc` добавляется `.opt-(1|2)`, в зависимости от количества указанных `-O`:

```shell
__pycache__/__init__.cpython-38.opt-1.pyc
__pycache__/testplugin.cpython-37.opt-2.pyc
```

Файлы складываются рядом в `__pycache__/`, а не перезаписываются.

До v3.5 схема была другая - `.pyc` заменялся на `.pyo`

---
> Какая утилита рекомендована для установки пакетов и модулей? Как ее запустить?

*PIP*, менеджер пакетов, в поставке идет по умолчанию. Две формы ее запуска для установки модуля:

```shell
$ pip3 install <package>
# предпочтительная форма вызова, авто-выбор версии языка
$ python3 -m pip install <package>
```

---
> Как получить справку по какой-либо команде `pip`?

Аналогично общей справке по модулю, но еще и указав нужную команду. Например:

```shell
$ python3 -m pip install --help
$ python3 -m pip list -h
```

---
> Как `pip`-у указать точную и минимальную версию пакета?

```shell
$ python3 -m pip install SomePackage==1.0.4
$ python3 -m pip install "SomePackage>=1.0.4"
```

Символы `>`/`<` интерпретируются шеллом, поэтому выражение взято в кавычки

---
> Где при вызове `pip` должны располагаться опции команд, а где самого модуля?

Опции команд после самой команды, опции менеджера - после `pip` и перед командой:

```shell
$ python3 -m pip -v freeze --user
```

Здесь `-v` (verbose) относится к `pip`, а `--user` - к `freeze`

---
> Как `pip`-ом обновить модуль?

```shell
$ python3 -m pip install (--upgrade|-U) SomePackage
```

---
> Как установить модуль локально, в домашний каталог пользователя?

Запускать `$ python3 -m pip install` без `sudo` (не хватит прав на запись в общесистемные директории), и/или указывать опцию `--user` (тогда и предупреждения показано не будет)

---
> Как установить модуль для конкретной версии Python?

Запускать интерпретатор именно этой версии для установки:

```shell
$ python3.7 -m pip install
# или
$ python3.3 -m pip install
# и.д.
```

---
> Есть ли модуль `pip3`?

Нет, есть только одноименная утилита в `~/.local/bin/`. Поэтому писать

```shell
$ pip3 install
```

можно, а

```shell
$ python3 -m pip3
```

нельзя

---
> Что такое *PyPI*?

*Python Package Index*, открытый репозиторий для открытых же пакетов: <https://pypi.org>. Используется командой `pip` по умолчанию

---
> Что такое *PyPA*?

*Python Packaging Authority*, рабочая группа, разрабатывающая проекты, связанные с Python-пакетами, такие как `pip`, `wheel`, `pipenv` и другие: <https://www.pypa.io>

---
> Почему научные пакеты лучше устанавливать не через `pip`?

Они часто тянут сложные бинарные зависимости. Лучше использовать предназначенные для этого менеджеры, типа *Conda*

---
> Что делает `pip freeze`?

(Построчно) выводит список всех установленных пакетов в формате `<name>==<version>`

---
> Как создать *файл требований*, состоящий только из локально установленных пакетов пользователя?

Использовать опцию `--user`:

```shell
$ python3 -m pip freeze --user > requirements.txt
```

---
> Как установить все пакеты из *файла требований*?

Использовать опцию `-r`:

```shell
$ python3 -m pip install -r requirements.txt
```

---
> Назовите 4 основных причины использования *файлов требований*

1. *Воспроизводимые установки* (repeatable installations) - копирование одной среды в другую через `pip freeze/install`
1. *Истинное разрешение зависимостей* (true dependency resolution) - в случае, если два пакета имеют в зависимостях один и тот же пакет, но разных версий, `pip` просто установит версию из первой по порядку зависимости. С *r*-файлом это можно обойти, явно указав в нем версию зависимого пакета для установки
1. *Принудительное указание версии*. Похож на пред. пункт - зависимый пакет указывается в файле явно; но служит лишь для того, чтобы не бралась автоматически последняя версия (напр., в ней баг), а подтягивалась указанная
1. *Получение последней версии из VCS*. Если в репозитории пакетов еще нет нужного (хот)фикса, можно указать в *r*-файле получение пакета из VCS: `git+https://...@sometag`

---
> Откуда `pip` может ставить пакеты?

Из PyPI по умолчанию, и из других источников:

```shell
# из VSC - в т.н. editable-режиме
$ pip install -e git+https://git.repo/some_pkg.git#egg=SomeProject
# из произвольного индекса
$ pip install --index-url http://my.package.repo/simple/ SomeProject
# поиск в PyPI + произвольный индекс
$ pip install --extra-index-url http://my.package.repo/simple SomeProject
# из локальной папки или файла
$ pip install [-e] <path>
# из локальных архивов
$ pip install ./downloads/SomeProject-1.0.4.tar.gz
```

---
> Как через `pip` можно установить дополнительные зависимости пакета ("extras")?

Указать их в квадратных скобках после имени:

```shell
$ pip install SomePackage[PDF]
```

---
> Какая утилита рекомендована для управления зависимостями в процессе разработки Python-приложения?

*Pipenv* (объединяет `pip` и `venv`), а если она не подходит, то pip, pip-tools, или *Poetry*

<https://packaging.python.org/guides/tool-recommendations/>

---
> Как в `pip` показать информацию о пакете? А список файлов?

```shell
$ python3 -m pip show <package>
$ python3 -m pip show --files <package>
```

---
> Как в `pip` показать все пакеты, для которых есть более новые версии?

```shell
$ python3 -m pip list --outdated
```

---
> Как в `pip` называется команда удаления пакета?

`uninstall`

---
> Как в `pip` называется команда поиска пакетов?

`search`

---
> Как в `pip` называется команда скачивания пакета?

`download`

---
> Можно ли использовать `pip` программно?

Чисто технически `import pip` выполняться будет, но это крайне не рекомендуется: `pip` не предназначен для такого использования. Вызов же его как подпроцесса вполне допустим и это полностью рабочий вариант:

```python
import subprocess
subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'my_package'])
```

---
> Как сделать автодополнение команд `pip`?

Добавить вывод команды `completion` в профайл юзера:

```shell
$ python3 -m pip completion --bash >> ~/.bashrc
```

или вставить туда же

```shell
eval "$(python3 -m pip completion --bash)"
```

Работает только для standalone-утилиты (`$ pip ...`)

---
> Как `pip`/`venv` и `conda` рассматривают сам интерпретатор Python?

Для `conda` он такой же пакет - его можно обновить/удалить/выбрать версию, тогда как `pip` занимается только лишь модулями/пакетами языка

---
> Для чего нужны виртуальные окружения?

Изоляция:

- создания предсказуемого, повторяемого окружения. Это защитит от появления ошибок при переносе программы на другой сервер
- одновременная разработка на одной машине нескольких проектов с разными версиями зависимостей

---
> Какая стандартная утилита для создания виртуальных сред? Как ее запустить?

*VENV*, в поставке идет по умолчанию. Как и `pip`, это модуль Python:

```shell
# выдает предупреждение, что такая форма вызова deprecated
$ pyvenv <dir>
# больше чем предпочтительна
$ python3 -m venv <dir>
```

---
> Как активировать среду, созданную `venv`?

Импортировать скрипт активации в текущий шелл:

```shell
$ source <dir>/bin/activate
```

После этого перед строкой приглашения появится название среды (напр., `(test) [~]$ `)

---
> Как деактивировать среду, созданную `venv`?

Выполнить в консоли

```shell
$ deactivate
```

Это функция, определенная в скрипте `bin/activate`, не физический скрипт, поэтому дополнительно указывать путь не требуется

---
> Устанавливает ли `venv` отдельную версию Python?

Нет, по умолчанию в папке `<env-dir>/bin` создается лишь ссылка на глобальный бинарник: `./python -> ./python3.n -> /usr/bin/python3.n`

Такое поведение можно изменить опцией `--copies`

---
> Куда в `venv` устанавливаются пакеты?

В (под)папку текущей выбранной среды:

`<env-dir>/lib/python3.n/site-packages/`

`pip` полностью корректно работает с виртуальными средами

---
> Как работает `pip install --user` в виртуальной среде?

Игнорируется, всё - и пакеты и бинарники - ставится внутрь `<env-dir>/` (где есть и `bin/` и `lib/`)

---
> Какие пакеты ставятся по умолчанию при создании виртуальной среды?

`pip` и `setuptools` (+ `pkg_resources`). Установку первого можно отменить через `--without-pip`

---
> Как создать сразу несколько виртуальных сред?

Передать команде несколько путей (имен папок):

```shell
python3 -m venv test1 test2
```

---
> Обязательно ли активировать виртуальную среду?

Нет. Активация добавляет папку `bin/` среды в системную переменную `PATH` (и устанавливает переменную окружения `VIRTUAL_ENV`), но это лишь упрощает печать команд. Если использовать полные пути для бинарника интерпретатора, то тоже будет работать

---
> Что происходит при активации виртуальной среды?

- добавление папки `bin/` среды в `PATH`
- определение команды деактивации
- изменение приглашения шелла
- установка переменной окружения `VIRTUAL_ENV` равной пути к каталогу среды

---
> Как интерпретатор определяет, что работа идет в виртуальной среде?

По наличию файла `pyvenv.cfg` на одном уровне с `bin/python[3[.n]]`, даже пустого

Если такой файл есть, `sys.prefix` устанавливается равным директории, в которой он (конф. файл) лежит

---
> Как добавить в `sys.path` путь к пакетам виртуальной среды?

Путь `lib/python3.n/site-packages` добавится автоматически (последним элементом списка), если он есть. Туда пакеты и устанавливаются

---
> Как ограничить пакеты только теми, что установлены в виртуальной среде?

В файле `pyvenv.cfg` задать `include-system-site-packages = false`. Эта опция пишется в файл конфига по умолчанию при создании виртуальной среды

Обратное действие - дать доступ до системных пакетов. Это можно сделать передав опцию при создании среды:

```shell
$ python3 -m venv --system-site-packages <path>
```

---
> Как задать виртуальной среде кастомное имя для отображения в командной строке?

Передать опцию при создании:

```shell
$ python3 -m venv --prompt <some-prompt> <path>
```

Скрипт `bin/activate` будет сгенерирован с учетом этого

---
> Какие есть ссылки из виртуальной среды на инсталляцию Python, использованную для создания этой среды?

В конфигурационном файле `pyvenv.cfg` обычно задана переменная `home = /usr/bin`

Кроме того, в самом интерпретаторе, несмотря на то что он выполняется из среды, переменная `sys.base_prefix` - всегда системный префикс (обычно `/usr`; в отличие от `sys.prefix == <env-path>`)

---
> Почему устанавливаемые при создании виртуальной среды скрипты будут в ней корректно работать?

У шелл-скриптов типа `pip`/`easy_install`, лежащих в `<env-path>/bin/`, shebang-заголовок генерируется корректно - он указывает на интерпретатор внутри самой среды, не на системный

---
> Можно ли менять поведение/создавать свои генераторы сред на основе `venv`?

Да, в отличие от `pip` модуль позволяет импортировать себя и наследовать свой класс `EnvBuilder`, меняя/дополняя функциональность. Создав такой скрипт, в нем можно вызывать `ExtendedBuilder().create(<options>)`

---
> Какая может быть нативная альтернатива `venv`?

Задание переменной окружения `PYTHONPATH`. Пути поиска пакетов будут подставлены в `sys.path` раньше системных

---
> Как обновить виртуальную среду при появлении новой версии Python?

Через вызов на той же папке с опцией `--upgrade`:

```shell
$ python3 -m venv --upgrade <path>
```
---
> Являются ли *утилиты распространения* `distutils` и `setuptools` пакетами стандартной библиотеки?

`distutils` да, а более мощный `setuptools` - сторонний проект, <https://pypi.org/project/setuptools/>

---
> Как устанавливаются пакеты, использующие `distutils` или `setuptools`?

Автор пакета выбирает, какую из двух утилит использовать, но в любом случае в пакет помещается файл `setup.py`

Для установки вызывается команда `$ python3 setup.py install` (возможно с `sudo`, если это не виртуальная среда), которая и копирует файлы пакета в нужные папки

---
> Что такое *wheel* и *eggs*?

Архивные форматы, включающие структурированные метаданные и код на Python. Используются для распространения модулей/пакетов

Их поддержка осуществляется расширениями `setuptools` и `wheels`

---
> Зачем нужен каталог `site-packages/`?

Чтобы устанавливать пакеты, которых нет глобально в системе

Прав на вмешательство в системную инсталляцию может и не быть, а установка в локальныю директорию позволяет это обойти. Такое же имя - `site-packages/` - имеют локальные папки с пакетами в snap-ах, в виртуальных средах, в проектах с исходным кодом

---
> Как программно получить доступ к переменным окружения?

Через

```python
os.environ
```

---
> Как удалить виртуальное окружение, созданное `venv`?

Просто удалить папку с ним. Это удалит все пакеты

---
> Как связан каталог виртуальной среды с каталогами с исходными кодами проекта?

Никак. Исходники не обязаны располагаться внутри папки с файлами среды и наоборот. Можно иметь одну среду на несколько проектов

---
> Как включить в пакет настройки виртуальной среды, в которой он тестировался?


Распространять с пакетом файл `requirements.txt`, содержащий вывод команды `$ python3 -m pip freeze`

---
> Как лучше называть виртуальные окружения?

Использовать в именах суффиксы, равные версии Python в этом окружении

Например, `mutex_27`, `mutex_35`. Это позволит иметь несколько окружений для одного проекта (`mutex`) и легко различать их

---
> Какие есть хорошие практики по хранению каталога виртуальной среды и каталогов с исходными кодами проекта?

- не хранить их вместе, разделять папки
- под VSC-контролем хранить один только `requirements.txt`, не всё окружение

---

# Стилистика кода `[style]`

---
> Что наиболее важно в стилистике кода?

Последовательность ее применения

---
> Каков рекомендованный отступ?

4 пробела. Табы могут использоваться только в коде который уже их использует. И в этом случае только они: Python 3 запрещает смешение пробелов и табов в одном файле

> Допустимо смешивать табы и пробелы в одном файле, но отступы должны совпадать. `Tab = 8 Spaces`. По умолчанию выполняется чисто. Добавление опции `-t` при вызове интерпретатора выведет предупреждение, а `-tt` превратит это предупреждение в ошибку

---
> Как переносить длинные последовательности (напр., аргументов функций или выражений в `if`)?

Заключая в скобки. Это предпочтительней явного соединения строк обратным слешем `\`

---
> Какие отступы должны быть у частей длинной последовательности при переносе (напр., у аргументов функций или выражений в `if`)?

Часть аргументов можно оставлять на первой строке (со скобкой), но тогда отступ следующей строки должен совпадать с первым оставленным аргументом:

```python
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
```

В любом случае, отступ переноса не должен сливаться со следующей инструкцией. Если она сдвинута, то переносу нужно добавить еще уровень:

```python
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
```

Последний вариант в случае `if` дискуссионный, и вместо отступа можно разграничить выражения комментарием или даже оставить отступ на том же уровне

---

> Какой отступ может быть у закрывающей скобки при переносе длинной последовательности?

Допустим как отступ по сдвинутому аргументу:

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
```

так и расположение на одном уровне со всем выражением:

```python
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

---
> Какова максимальная длина строки для кода?

*79* символов. Это улучшает читаемость при отображении файлов бок о бок и в инструментах для code review. Возможно увеличение лимита до 100 символов, но, например, стандартная библиотека консервативна, и не допускает такого

---
> Какова максимальная длина строки для комментариев и docstrings?

*72* символа для длинных слабоструктурированных текстов. Это ограничение более жесткое, чем для длины строк кода

---
> Когда обратный слеш `\` всё же может использоваться для переноса длинных строк?

Для конструкций, не поддерживающих скобки. В основном это оператор запятая `,` в конструкциях `with` и `assert`:

```python
# взять в скобки нельзя: синтаксическая ошибка
with open(), open():
# взять в скобки нельзя: изменение смысла, непустой кортеж всегда True
assert cnd1, cnd2
```

---
> Где располагать бинарный оператор при переносе строк?

В начале строки:

```python
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

---
> Как разбивать и переносить длинные строковые литералы?

Без операторов конкатенации, без обратных слешей, заключая всё в скобки:

```python
x = ('This will build a very long long '
     'long long long long long long string')
```

---
> Как отделяются классы и функции верхнего уровня от остального кода?

Двумя пустыми линиями

---
> Как отделяются друг от друга методы внутри класса?

Одной пустой линией

---
> Когда могут использоваться дополнительные пустые строки?

Для отделения групп связанных функций, и внутри самих функций, для отделения логически связанных секций. В обоих случаях - нечасто

---
> Когда блоки можно не разделять пустыми линиями?

Например, если это группа логически связанных однострочников (напр., dummy implementations)

---
> Когда скрипт должен указывать кодировку в заголовке (encoding declaration)?

Никогда, во всяком случае до тех пор пока код написан в UTF-8 (а это жесткое требование)

> То же самое, только вместо юникода ASCII: файл не должен указывать кодировку, если написан в ASCII

В стандартной библиотеке, начиная с Python v3.0, требования совсем жесткие: всё только в ASCII, английскими словами (исключение только имена авторов в комментариях, да и то рекомендуют транслитерировать)

---
> Можно ли импортировать несколько модулей в одну строку?

Нет, каждый импорт должен быть отдельно:

```python
import os
import sys
```

---
> Можно ли импортировать несколько сущностей из одного модуля в одну строку?

Да, это допустимо:

```python
from subprocess import Popen, PIPE
```

---
> Где в файле должны располагаться импорты?

В начале, после комментариев / docstring-ов уровня модуля, и перед глобальными константами и функциями

---
> Как должны быть сгруппированы импорты?

В группы, разделенные пустой строкой:

1. из стандартной библиотеки
2. third-party
3. локальные

---
> Какая форма импорта предпочтительней?

Абсолютная:

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

Относительные импорты могут использоваться, если расположение модулей в пакете достаточно сложное:
```python
from . import sibling
from .sibling import example
```
Хотя гугл не рекомендует совсем, говорит использовать имя пакета (?)

В стандартной библиотеке поощряется простая структура пакетов, и разрешены только абсолютные импорты

---
> Можно ли использовать `*` при импорте?

Крайне нежелательно. Единственный случай, когда это разрешено, - публикация в пакете внутреннего интерфейса в качестве внешнего

---
> Где в модуле должны объявляться *магические* (*dunder*) константы?

После docstring-ов верхнего уровня и перед любыми импортами

---
> Где в модуле должны объявляться импорты из `__future__`?

После docstring-ов верхнего уровня и перед "магическими" константами и импортами

---
> Какие кавычки использовать, одинарные или двойные?

- PEP8, Google: не важно, нужно только не смешивать их, использовать последовательно
- CKAN: предпочитать одинарные

---
> Когда можно смешивать одинарные и двойные кавычки?

Когда строка текста содержит кавычку, желательно использовать для нее кавычки другого типа: это повышает читабельность

---
> Какой тип тройных кавычек использовать?

- PEP 257: двойные тройные, для совместимости с docstring-ами
- Google: одинарные тройные могут использоваться, если везде в проекте используются (обычные) одинарные. Docstring-и всегда в двойных тройных, независимо от этого

---
> Как отделять элементы от фигурных, квадратных и круглых скобок?

Отделяться пробелом не должны:

```python
# Correct
spam(ham[1], {eggs: 2})
foo = (0,)
# Wrong
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
```

---
> Как использовать пробелы с запятыми?

Ставить после и не ставить до

---
> Как использовать пробелы в срезах?

Не использовать в основном. Исключение - когда в срезе есть выражение:


```python
# Correct
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

---
> Ставится ли пробел перед круглыми или квадратными скобками при обращении к функции или структуре данных?

Нет, не ставится, скобка пишется слитно с текстом:

```python
# Correct
spam(1)
dct['key'] = lst[index]
```

---
> Можно ли выравнивать операторы "равно" в группе присваиваний?

Нет:

```python
# Correct
x = 1
long_variable = 2
# Wrong
x             = 1
long_variable = 2
```

---
> Нужно ли окружать пробелами бинарные операторы?

Да, это всегда обязательно. Исключениями могут быть операторы с разными приоритетами, тогда можно отделять только низкоприоритетные:

```python
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

Отделять нужно и стрелки/двоеточия в аннотациях функций (двоеточия только справа)

---
> Нужно ли отделять пробелом оператор "равно" в именованных параметрах и аргументах по умолчанию?

Нет, вот здесь его отделять не нужно, пишется слитно:

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

Это не относится к аргументам с аннотациями:

```python
def func(a: int = 0) -> int:
```

---
> Как объявлять кортежи из одного элемента?

Всегда использовать скобки:

```python
# Correct
FILES = ('setup.cfg',)
# Wrong
FILES = 'setup.cfg',
```

Запятая обязательна, иначе интерпретатор не отличит кортеж от одиночного значения в скобках

---
> Когда нужны (и не нужны) trailing-запятые?

Нужны только когда расположение кода в несколько линий. Для кода в одну строку их указывать не следует:

```python
# Correct
FILES = [
    'setup.cfg',
    'tox.ini',
]
# Wrong
FILES = ['setup.cfg', 'tox.ini',]
```

---
> Когда комментарий можно начинать с маленькой буквы?

Только когда это идентификатор. Комментарий - это законченное предложение, и оно должно начинаться с большой буквы

---
> Как отделять предложения в многострочном комментарии?

Каждое предложения должно заканчиваться точкой. После каждой точки, кроме последней, ставятся два пробела

---
> Для каких функций и методов нужны docstring-и?

Для всех публичных обязательны. Для закрытых тоже нужны, но там можно ограничиться кратким комментарием

---
> На какой строке должны быть закрывающая кавычка у docstring?

На новой для многострочных:

```python
"""Return a foobang.

Optional plotz says to frobnicate the bizbaz first.
"""
```

Для однострочных должна быть на той же строке

---
> Какие однобуквенные переменные не рекомендуется использовать?

Те, которые можно спутать с цифрами или между собой: `I`, `l`, `O`

---
> Какое соглашение по именам модулей и пакетов?

Все в нижнем регистре. В именах модулей можно использовать подчеркивания (если они улучшают читаемость), в именах пакетов нет. Имена низкоуровневых модулей (напр., написанных на C/C++), идущих в комплекте с Python-модулями, должны начинаться с подчеркивания (напр., `_socket`)

---
> В какой нотации пишутся имена классов?

В *CamelCase*

---
> Как должны именоваться классы исключений?

Как и остальные классы, в CamelCase. Кроме того, к имени класса нужно добавлять суффикс `Error`

---
> Как именуются функции и переменные?

В нижнем регистре, слова разделяются подчеркиваниями

---
> Как предотвратить конфликт с зарезервированным / ключевым словом?

Добавить в конец имени подчеркивание: `class_`. А еще лучше использовать синоним

---
> Каков формат имен констант?

В верхнем регистре, слова разделены подчеркиваниями:

```python
MAX_HOLY_HANDGRENADE_COUNT
```

---
> Что делает ключевое слово `is`?

Проверяет, что два объекта являются одним и тем же объектом, расположены по одному ии тому же адресу. По сути, `is` эквивалентно

```python
id(a) == id(b)
```

Должно использоваться для сравнения с синглетами

---
> Какие есть встроенные синглеты?

В единственном экземпляре существуют `True`, `False`, `None`

---
> Как сравнивать с `None`?

Как и со всеми синглетами - через `is [not]`. Оператор "равно" использоваться не должен. Порядок должен быть `is not`:

```python
# Correct
if foo is not None:
# Wrong
if not foo is None:
```

---
> Стоит ли присваивать лямбды именованным переменным?

Нет. Это затрудняет отладку и не дает никакого преимущества. Лучше использовать функции:

```python
# Correct
def f(x): return 2*x
# Wrong
f = lambda x: 2*x
```

---
> От какого класса следует наследовать классы исключений?

От `Exception`, не от `BaseException` (перехват последних не предполагается)

> Используйте синтаксис `raise ValueError('message')` вместо устаревшего `raise ValueError, 'message'`

---
> Как следует оформлять `except:`?

Всегда указывать в нем класс исключения

Пустой `except:` эквивалентен `except BaseException:`, и будет перехватывать даже `SystemExit` / `KeyboardInterrupt`. Если тип неизвестен, пишите `except Exception:`

---
> Допустимо ли смешивать пустые и непустые `return`-ы в функции?

Нет. Если хоть один из них возвращает значение, то и остальные должны: вместо просто `return` нужно писать `return None`

---
> Как можно получить часть строки из середины? Суффикс/префикс?

Через срез:

```python
'some text'[2:4] == 'me'
```

Для префиксов и суффиксов можно опустить первый/последний индекс соответственно:

```python
'some text'[:4] == 'some'
'some text'[5:] == 'text'
```

---
> Какой способ проверки строки на суффикс/префикс предпочтительней?

Через функции `startswith()` / `endswith()`:

```python
# Correct
if foo.startswith('bar'):
# Wrong
if foo[:3] == 'bar':
```

---
> Как сравнивать классы (типы) экземпляров?

Через `isinstance()`, не `type()`:

```python
# Correct
if isinstance(obj, int):
# Wrong
if type(obj) is type(1):
```

---
> Как правильно проверять, что коллекция (не)пустая?

Через неявное приведение к `bool`, не через длину:

```python
# Correct
if not seq:
if seq:
# Wrong
if len(seq):
if not len(seq):
```

---
> Как правильно проверять булевы значения?

Неявно; сравнение с `True`/`False` использовать не нужно:

```python
# Correct
if greeting:
# Wrong
if greeting == True:
if greeting is True:
```

---
> Можно ли использовать `return`/`break`/`continue` в блоке `finally` у `try`?

Нет, это отменит проходящее через блок `finally` исключение

---
> Какие способы передачи аргументов в сигнатуре функции предпочтительней?

Позиционные (`x, y`) и именованные (`a=3, b=4`) аргументы лучше произвольных (`*args`) и произвольных в словаре (`**kwards`)

---
> Почему один аргумент-список лучше запакованных параметров `(*args)`?

Можно передавать структуры, которые не могут быть распакованы. Например, итераторы

---
> Что говорит принцип YAGNI об именованных параметрах функций?

Что не стоит добавлять их на все случаи жизни, просто "чтобы были"

---
> Как обозначаются закрытые члены классов и модулей?

Их имена начинаются с подчеркивания - `_method`

---
> Какое имя давать неиспользуемой переменной?

Подчеркивание, одно `_` или два `__`. Второе может быть полезно, чтобы не спутать с `gettext()` или последним результатом в REPL

---
> Как проверять, что в словаре есть ключ?

```python
# Correct
'hello' in d # через оператор `in`
d.get('hello', 'some') # через `.get()` с дефолтным аргументом
# Wrong
d.has_key('hello') # но не через `.has_key()`
```

---
> Когда стоит предпочитать генераторы спискам?

Когда сам список физически не нужен, например, передать данные в функцию: `max(_ for ...)` лучше, чем `max([_ for ...])`

---
> Почему запись
> 
> ```python
> [print(x) for x in sequence]
> ```
> плоха?

List comprehension используется не по назначению (создание списков), а для side effect-ов. Лучше переписать на обычный цикл

---
> Когда не стоит удалять элементы из коллекции?

При итерации по этой коллекции. Вместо этого можно, например, итерировать по shallow-клону (`[:]`)

---
> Какой предпочтительный способ получения индекса при итерации по коллекции?

Через `enumerate()`. Это более наглядно, чем считать вручную, и функция оптимизирована

---
> Какой предпочтительный способ открыть файл?

Через менеджеры контекста, `with open()`. Автоматически закрывает файл, даже если внутри блока выброшено исключение

Для объектов, которые не поддерживают `with` явно, можно использовать обертку `with contextlib.closing(...):`

---

> Какой линтер рекомендует Google в своём style guide-е?

*pylint*, с подавлением предупреждений через комментарии (`# pylint: disable=redefined-builtin`) в случае необходимости

---
> Какие типы сущностей лучше импортировать а какие нет?

Импортировать следует только пакеты и модули, не отдельные классы/функции в них. При использовании это наглядно показывает, к какому пространству имен относится сущность

---
> Допустимо ли использовать псевдонимы при импорте?

Да, вполне, для сокращения длинных имен или предотвращения конфликтов

---
> Допустимо ли использовать `assert` для проверки данных из внешних источников?

Нет, он только для проверки внутренней логики

В частности, контроль входных значений и аргументов функций не должен отключаться по `PYTHONOPTIMIZE`/`-O`

---
> Какие рекомендации по использованию глобальных переменных?

Избегать: при импортах идет их присваивание, и это может приводить к непредсказуемому поведению

---
> Допустимы ли вложенные функции/классы?

Да, вполне, например для декораторов. Не стоит только объявлять функцию вложенной лишь для того, чтобы скрыть ее при импорте. Вместо этого лучше добавить подчеркивание к ее имени

---
> Для каких случаев рекомендуется использовать list comprehensions?

Только для простых и однострочных. Нежелательны множественные `for`-ы и условия фильтрации

То же условие простоты касается и лямбд, и псевдо-тернарного оператора

---
> Какого типа объекты можно использовать в качестве значений аргументов по умолчанию?

Только неизменяемые:

```python
# Correct
def foo(a, b=None):
def foo(a, b=()):
# Wrong
def foo(a, b=[]):
def foo(a, b={}):
```

---
> Когда list comprehensions лучше связки `map()`/`filter()`?

Всегда, когда функции - однострочные лямбды. То же касается и `reduce()` - циклы `for` всегда предпочтительней

---
> Можно ли использовать `@staticmethod`?

В гугловом руководстве запрещается, лучше писать функцию уровня модуля. Использование `@classmethod` рекомендуется ограничить именованными конструкторами или методами класса, модифицирующими глобальные переменные

---
> Использовать ли в коде типизацию (type annotations)?

Да, сильно поощряется

---
> С чего должен начинаться файл?

С docstring-а, описывающего назначение и использование этого модуля

---
> В каком наклонении должен быть текст в docstring-ах?

- PEP257: в повелительном (`"""Return the ...`)
- Google: (наоборот) В описательном (`"""Fetches from ...`)

---
> Что должны описывать docstring-и у функций/методов?

Назначение и синтаксис вызова, не реализацию

---
> Что можно указать в строке документации у метода дочернего класса, перекрывающего метод родительского класса?

Слово `override`, если родительский метод не вызывается, и `extend` иначе. Описание не должно дублировать docstring базового класса

---
> Какие секции могут быть у docstring функции/метода?

`Args`, `Returns`, `Raises`

---
> Какие секции могут быть у docstring класса?

`Attributes`, описывающая параметры конструктора. Причем в `__init__()` эти параметры уже не описываются

---
> Какой отступ у inline-комментариев?

По Google style guide - 2 пробела после строки кода и 1 - после символа комментария:

```python
if i & (i-1) == 0:  # True if ...
```

---
> Какой предпочтительный способ собрать строку из частей в цикле?

Не использовать `+`/`+=`: т.к. строки неизменяемы, это приведет к созданию слишком большого числа временных объектов и квадратичной сложности вместо линейной

Лучше добавлять подстроки в список, а после цикла вызвать `''.join([...])`

---
> Как использовать TODO-комментарии?

Только для временного кода, оставляя свой идентификатор (имя, ник, почту) в скобках:

```python
# TODO(kl@gmail.com): Use a "*" here for string repetition.
# TODO(Zeke) Change this to use relations.
```

---
> Можно ли располагать несколько инструкций в одной строке?

Нежелательно, разве что очень короткие `if/while`. Использование точки с запятой `;` также нежелательно

---
> Какое расширение должно быть у Python-файлов?

`.py`

---
> Можно ли использовать дефис/тире в именах файлов и в коде?

Нет, только подчеркивание

---
> Когда можно использовать однобуквенные имена переменных?

Только для счетчиков/итераторов. Можно использовать `e` для имен исключений. В остальных случаях нежелательно

---
> Отделяется ли docstring пустыми строками от окружающего кода?

В функции не отделяется, ни с одной из сторон. В классе нужна пустая строка перед первым методом

---
> Должна ли ставиться точка в конце первой строки в docstring?

Да, должна:

```python
"""Return the pathname of the KOS root directory."""
```

---
> Каков общий формат для многострочных docstrings?

Однострочная summary -> пустая строка -> более подробное описание:

```python
def complex(real=0.0, imag=0.0):
    """Form a complex number.

    Keyword arguments:
    ...
```

Отступ внутри - по первой кавычке

---
> Для чего стоит и не стоит использовать инструкцию `raise`?

Стоит только для ошибок, не выбрасывающих исключения сами по себе, то есть только для тех, что определяются логикой программы

Не стоит выбрасывать для дублирования ошибок интерпретатора

---
> Как объявлять пустые функции и классы?

Используя docstring вместо `pass`

Все пустые классы и функции должны содержать строку документации

---
> Какими свойствами должны обладать блоки `try:`/`except:`?

Должны быть как можно более "узкими": блок `try:` должен охватывать как можно меньше кода, а кортеж классов в `except:` должен быть максимально специфичным

---
> Для чего предназначено тело модуля?

Только для связывания атрибутов. Инструкции `def` задают атрибуты-функции, `class` - классы, а присваивания связывают произвольные атрибуты с объектом модуля

Каких-либо других действий, кроме задания атрибутов, следует избегать

---
> Как следует именовать закрытые атрибуты модуля?

Их имена должны начинаться с подчеркивания:

```python
_secret = 4
```

это не предотвратит их импорт, но подскажет другим программистам (и, возможно, инструментам анализа кода), что атрибут предназначен только для использования внутри модуля

---
> Как переносить длинные строки импортов?

Используя скобки:

```python
from <some-long-name-module> import (
    a as alias1, b as alias2, ...
)
```

---
> Какая форма записи инструкции импорта предпочтительней?

Всегда ясно, какое пространство имен используется:

```python
import <module>
```

Использование `*` вообще не рекомендуется (разве что для публикации внутренних интерфейсов или в интерактивных сеансах), а

```python
from <package> import <module>
```

оправдана лишь для импорта модулей из пакетов

---
> Какие рекомендации по циклическим импортам модулей?

Хотя чисто технически он возможен, такого импорта следует избегать: циклические зависимости хрупкие, и ими трудно управлять
