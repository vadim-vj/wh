---
> Что выведет этот код?
> 
> ```python
> print(print(1), print(2))
> ```

```python
1
2
None None
```

`print()` возвращает `None`

---
> Что выведет этот код?
> 
> ```python
> 1e1
> 1e2 
> ```

```python
10.0
100.0
```

`e|E` обозначает степень десятки

---
> Как выполнить тесты (doctest) в комментариях? Приведите 2 варианта

Запустив скрипт с кодом:

```python
import doctest

if __name__ == '__main__':
    doctest.run_docstring_examples(<func>, globals())
```

Или запустив doctest как скрипт и передав ему свой скрипт в качестве параметра:

```shell
$ python3 -m doctest <file>
```

---
> Что выведет этот код?
> 
> ```python
> [[]]*3
> ```

```python
[[], [], []]
```

---
> Чему равен `x`?
> 
> ```python
> x = [[]]*3
> x.append(1)
> ```

```python
[[], [], [], 1]
```

---
> Что выведет этот код?
> 
> ```python
> -1 - -1
> ```

```python
0
```

---
> Напишите функцию, сравнивающую два дробных числа

```python
def approx_eq(x, y, tolerance=1e-5):
    return abs(x - y) < tolerance
```

---
> Чему равен `x`?
> 
> ```python
> x = [[]]*3
> x[0].append(1)
> ```

```python
[[1], [1], [1]]
```

`[[]]*3` создает три ссылки на один и тот же список

---
> Каково поведение оператора `//` для разных типов данных?

- если хотя бы один аргумент дробный (`5.0//2`, `-5//2.0`) результат тоже дробный (`2.0`)
- т.е. результат будет иметь тип `int` только если оба аргумента `int` (`5//2 = 2`)
- при этом всегда идет округление вниз: `5.0//2 = 2.0`, `-5//2.0 = -3.0`

---
> Напишите на однострочник генерации пустой квадратной матрицы размера `n`

```python
[[None for i in range(n)] for j in range(n)]
```

или

```python
[[0]*n for _ in range(n)]
```

Использовать `[[0]*n]*n` нельзя: внутренний список будет продублирован как shallow-клон

---
> Напишите однострочник, строящий подмножество всех слов длиной не меньше 5 символов, для которых в исходном множестве есть обратное слово

```python
{ w for w in words if len(w) >= 5 and w[::-1] in words }
```

---
> Что выведет этот код?
> 
> ```python
> two = print(2)
> print(two) 
> ```

```python
2
None
```

`print()` возвращает `None`

---
> Какая есть альтернативная запись операторов в Python?

Как функций. Их можно импортировать из модуля operator:

```python
from operator import add, mul

2 + 3 * 4 + 5 # = 19
add(add(2, mul(3, 4)) , 5) # = 19
```

---
> Что делает функция `random.uniform()`?

Получает 2 аргумента и возвращает псевдослучайный `float`, лежащий между ними (`a <= N <= b`). Если второй аргумент меньше первого, они прост меняются местами

---
> Как заполнить матрицу значениями вне главной диагонали?

В два цикла, вложенный перебирает до текущего счетчика внешнего:

```python
for i in range(n):
    for j in range(i):
        matrix[i][j] = matrix[j][i] = ...
```

Нужно предварительно сгенерировать пустую матрицу

---
> Что выведет этот код?
> 
> ```python
> i = 4
> def foo(x):
>     def bar():
>         print(i, end='')
> 
>     for i in x:
>         print(i, end='')
>     bar()
> 
> foo([1, 2, 3])
> ```

`1 2 3 3`, последняя цифра не `4`: `i` - локальна для `foo()` и будет последним результатом счетчика цикла

---
> Что выведет этот код?
> 
> ```python
> x = 3
> addr = id(x)
> x += 1
> addr == id(x)
> ```

```python
False
```

Числа неизменяемы, даже составное присваивание не изменит объект, а просто переназначит ссылку (установит ее на временный объект)

---
> Что выведет этот код?
> 
> ```python
> 2 == 2 and 0 == 0
> ```

```python
True
```

Операторы сравнения имеют более высокий приоритет, чем логические связки

---
> Что выведет этот код?
> 
> ```python
> "bc" in "abcde" == True
> ```

```python
False
```

Код эквивалентен

```python
"bc" in "abcde" and "abcde" == True
```

Для этой группы операторов цепочки условий разбиваются на части при помощи связки `and`

---
> Что выведет этот код?
> 
> ```python
> x = [1, 2, 3]
> x[1:1] = [4]
> ```

```python
[1, 4, 2, 3]
```

Это альтернативный способ вставки элементов в список

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][1:1]
> ```

```python
[]
```

При совпадающих индексах срез всегда пустой

---
> Что выведет этот код?
> 
> ```python
> [1, 2, 3][-2:-1]
> ```

```python
[2]
```

Для приведения сложим отрицательные индексы с длиной. Получим `[1:2]`

---
> Что выведет этот код?
> 
> ```python
> list(range(10))[-5:]
> ```

```python
[5, 6, 7, 8, 9]
```

Все элементы начиная с `(10-5)`-го

---
> Что выведет этот код? Какие есть альтернативные записи?
> 
> ```python
> list(range(10))[10:0:-2]
> ```

```python
[9, 7, 5, 3, 1]
```

Любой из индексов начала/конца можно опустить: `[10:0:-2]` ~ `[10::-2]` ~ `[:0:-2]` ~ `[::-2]`

---
> Чему равен `x`?
> 
> ```python
> x = (['a'], ['b'])
> x[1] = 'c'
> ```

`TypeError: 'tuple' object does not support item assignment`

Кортежи неизменяемы, доступ по индексу только на чтение, присваивать значения нельзя

---
> Чему равен `x`?
> 
> ```python
> x = (['a'], ['b'])
> x[1][0] = 'c'
> ```

```python
(['a'], ['c'])
```

Хотя кортежи и неизменяемы, здесь заменяется не элемент кортежа, а первый элемент его изменяемого элемента - списка в позиции `1`

В целом, такая практика - кортежи из элементов изменяемых типов - не рекомендована

---
> Что выведет этот код?
> 
> ```python
> x = [1]
> addr = id(x)
> x[:] = [2]
> addr == id(x) 
> ```

```python
True
```

Переприсваивание через полный срез не меняет адрес объекта, а перезаписывает его

---
> Чему равен `x`?
> 
> ```python
> x = list(range(6))
> del x[::2]
> ```

```python
[1, 3, 5]
```

Удалены элементы под индексами `0`, `2`, `4` (значение совпадают с индексами)

---
> Что выведет этот код?
> 
> ```python
> for d in {1: 2, 3: 4}:
>     print(d)
> ```

```python
1
3
```

Итерация по словарю всегда идет по его ключам, не по парам или значениям

---
> Что выведет этот код?
> 
> ```python
> test = [1, 2, 3]
> 
> for test[1] in 'xyz':
>     print(test)
> ```

```python
[1, 'x', 3]
[1, 'y', 3]
[1, 'z', 3]
```

В качестве целевой переменной цикла может служить всё что угодно, в том числе элемент списка

---
> Что выведет этот код?
> 
> ```python
> for i in []:
>     pass
> print(i)
> ```

`NameError: name 'i' is not defined`

Целевая переменная цикла инициализируется лишь тогда, когда итерируемая последовательность непуста. Иначе не выполняется ни тело цикла, ни присваивание `i`

---
> Что выведет этот код?
> 
> ```python
> for x in []:
>     print(1)
> else:
>     print(2)
> print(3)
> ```

```python
2
3
```
Коллекция `[]` пустая, цикл не выполнится ни разу. Но выход не по `break`, и `else` будет выполняться

---
> Что выведет этот код?
> 
> ```python
> def f(x, y=[]):
>     y.append(x)
>     return y
> 
> print (f(23))
> print (f(42))
> ```

```python
[23]
[23, 42]
```

Значение именованного параметра вычисляется единожды, в момент объявления функции

---
> Что выведет этот код?
> 
> ```python
> def f(x, y):
>     х = 23
>     y.append(42)
>
> a = 77
> b = [99]
> f(a, b)
> print(a, b)
> ```

```python
77 [99, 42]
```

Числа и прочие неизменяемые объекты передаются в функцию по значению, тогда как изменяемые объекты (напр., списки) - по ссылке

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     y += 1
> f()
> print(y)
> ```

`UnboundLocalError: local variable 'y' referenced before assignment`

Идет попытка записи в глобальную переменную без явного указания директивы `global`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
> 
> f()
> print(x)
> ```

`NameError: name 'x' is not defined`

Присваивание (инициализация `x`) обязательно: `global <var>` не объявлением "является" переменной с пустым значением

---
> Что выведет этот код?
> 
> ```python
> def f():
>     global x
>     x = 1
> 
> f()
> print(x)
> ```

```python
1
```

Создавать глобальные переменные из функций вполне можно

---
> Что выведет этот код?
> 
> ```python
> def f():
>     x = 1
> 
>     def g():
>         x += 1
> 
>     g()
>     return x
> 
> print(f())
> ```

`UnboundLocalError: local variable 'x' referenced before assignment`

Ситуация аналогична доступу на запись к глобальным переменным: `x += 1` нельзя вызывать, т.к. внутри функции `g()` переменная `x` из внешней функции по умолчанию доступна только на запись. Нужно либо инициализировать (создать) свою переменную `x` внутри `g()`, либо указать перед составным сложением директиву `nonlocal x`

---
> Что выведет этот код?
> 
> ```python
> def f():
>     def g():
>         nonlocal y
>         y = 2
> 
>     g()
>     return y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

В отличие от `global`, создавать переменные внешних функций из внутренних нельзя

---
> Что выведет этот код?
> 
> ```python
> y = 0
> def f():
>     def g():
>         nonlocal y
>         y = 2
> 
>     g()
>     return y
> 
> print(f())
> ```

`SyntaxError: no binding for nonlocal 'y' found`

Директива `nonlocal` просматривает только вложенные функции, не глобальную область видимости. Поэтому глобальный `y` рассматриваться не будет
