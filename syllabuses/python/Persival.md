### Персиваль Г., Python. Разработка на основе тестирования
<https://dmkpress.com/catalog/computer/programming/python/978-5-97060-594-3/>

---

Просто заметки, не конспект. Смотрим, в основном, только юнит-тестирование (а большая часть книги посвящена написанию web-приложения на Django и функциональным тестам).

#### I. Основы TDD и Django
- структура проектов Джанго тоже имеет вложенную одноименную папку (напр., `superlists/superlists`) с `__init__.py` внутри
- термины *user story* - описание требований на естественном языке, и *failure* - ожидаемая неполадка, *не*срабатывание `assert`-а в тесте
- функциональные тесты проверяют приложение снаружи, с точки зрения пользователя (более высокий уровень), модульные - изнутри, с точки зрения программиста (более низкий уровень)
- порядок разработки: функциональные тесты --> (повторять пока не заработает: юнит-тесты --> минимальный код) --> рефакторинг --> возврат на первый шаг и повтор всей цепочки
- юнит-тесты создает стандартно - `class HomePageTest(unittest.TestCase):`, методы `def test_root_url_re...(self):`. Вызов: `if __name__ == '__main__': \n\t unittest.main(warnings='ignore')`
- `assert`-ы: `.assertEqual(2 arg)`, `.assertTrue(1 arg)`, `.assertIn(subsrt, str)` (для коллекций работает? да), `.assertContains()` (то же, что и пред., но для объектов `HttpResponse` со статусом 200), `.assertRedirects()` (то же, что и пред., но для статуса 302), `.assertAlmostEqual(1,2,delta)`
- `def setUp(self):`, `def tearDown(self):`, (внутри метода) `self.fail('Закончить тест!')`
- использует несколько `assert`-ов на метод. Хотя в следующей главе уже пишет что-то против такого подхода. Вынос кода во вспомогательные методы предотвращает "распухание" тестов
- говорит что вот это - `self.assertTrue(any(row.text == '...' for row in rows))` - генераторное выражение, похоже на list comprehension. И стандартная функция Python `any()`
- правило *не тестировать константы* - не стоит писать что-то вроде `wibble = 3; ...; assert wibble == 3`. Модульные тесты должны заниматься проверкой логики, потока управления и конфигурации
- идея *регрессии* - возникновения ошибок в работающих частях кода, возникновение новых ошибок при фиксах. Тесты помогают избегать этого
- f-строки (`f"...{var}..."`; с подстановками), здесь используются для задания сообщений об ошибках
- тесты, проверяющие работу БД (здесь через ORM-а Django) можно назвать скорее интегрированными, чем модульными: они тестируют внешнюю систему
- описание *миграций* ORM - модификации БД через Python-код. Уже запушенные миграции удалять не стоит, это чревато ошибками
- *блокнот с рабочим списком неотложных дел* - место для фиксации рабочих моментов, которые происходят с нами во время программирования, чтобы можно было закончить то, что мы делаем, и вернуться к ним позже
- можно выполнять тесты на отдельной версии БД, создавая/очищая ее в `setUp()`/`tearDown()`. Для функциональных тестов у Django вообще есть класс `LiveServerTestCase`, создающий тестовую среду (а для юнит-тестов?)
- тесты не должны влиять друг на друга. Нужно очищать состояние (напр., БД) между тестами
- концепция инкрементной разработки (малыми шажками) и выпуска MVP. Между состояниями (работающего) кода нужно перемещаться постепенно
- выше упоминался принцип DRY (Do not Repeat Yourself). Здесь говорится о принципе YAGNI - You Ain't Gonna Need It! (вам это никогда не понадобится): не писать код сверх необходимого, тот, что *возможно* пригодится
- REST (Representational State Transfer) - система урлов вида `/lists/<list identifier>/<action>`
- называет `##` метакомментариями - они описывают почему именно так реализован тест, и должны отличаться от текстов пользовательских историй

#### II. Непременные условия веб-разработки
- глава о Bootstrap-е, JS, шаблонах и (по большей части) о деплое
- написанные ранее тесты позволяют отловить ошибки, возникающие при деплое
- *декоратор пропуска* - аннотация `@unittest.skip[("<some-text>")]` у метода класса-потомка `unittest.TestCase` пропускает тест, причем без текста в скобках пишет `ok` (а с ним - `skipped <some-text>`. Небезопасны, нужно помнить где их оставили. `git diff` разве что поможет
- разбивает тесты на несколько классов, базовый наследует от `FunctionalTest`, а остальные от базового
- советует и выносит тесты в отдельную папку `tests` с файлом `__init__.py`, делает их пакетом. По файлу тестов (`test_<name>.py`) на каждый файл тестируемого кода (`<name>.py`), хотя бы с заглушкой для класса/методов
- `assert` с менеджером контекста: `with self.assertRaises(ValidationError): \n\t item.save()` проверяет, что `item.save()` выбрасывает исключение `ValidationError`. Некий аналог `try: \n\t item.save(); self.fail() \n except ValidationError: \n\t pass`
- пример принципа YAGNI: выносить методы в базовый класс только если они нужны в других потомках, и держать в том же классе иначе
- *фикстуры* (fixtures, оснастки) - тестовые данные/инструкции, приводящие среду тестирования в известное состояние. Напр., фиксированная таблица данных пользователей, или `$(...).hide()` в примере в книге (для проверки что элемент не отображается)

#### III. Основы TDD и Django
- *spiking* (импульсное исследование) - быстрое, исследовательское, программирование, набросок прототипа, чтобы посмотреть что оно работает. Может проводиться без тестов. Как правило, выполняется во временной ветке git
- *de-spiking* - перенос результатов пред. пункта в прод
- тесты могут стать формой документирования кода: они вы-ражают ваши технические требования к отдельному классу или функции. Поэтому важно давать им осмысленные имена
- терминология: <https://github.com/testdouble/contributing-tests/wiki/Test-Double>. Mock, stub, spy, fake и т.д.
- проводить mock-тестирование через monkey patch: объявляет метод-заглушку в классе теста, и перед `assert`-ами присваивает методу реального объекта ссылку на нее (использование динамического характера Python и правил назначения `self`)
- объекты класса `from unittest.mock import Mock` откликаются на обращение к любому атрибуту/методу
- аннотация `@unittest.mock.patch('some.object.method')` автоматически делает monkey patch-и. (???) Как-то передает аргумент тесту - mock-объект. И откладывает объект в конец, чтобы не влиять на другие тесты
- может патчить не метод, а целый класс
- имитации (mock) могут сильно связывать реализации, потому что не вызываются многие нативные методы. Поэтому говорят, что лучше тестировать поведение, а не детали реализации
- имитации могут не только использоваться для подмены внешних зависимостей, но также как-то помогают избежать дублирования кода
- объекты класса `Mock` поддерживают свойства `call_args`, `return_value` (?)
- не рекомендует )из-за сложности) использовать Django-вские фикстуры в JSON, лучше работать через ORM
- пример определения собственного декоратора - функции, получающей одну функцию и возвращающей другую. Пример использования переменного числа аргументов - `*args, **kwargs`
- "снаружи внутрь" - нисходящее проектирование ("сверху вниз") предпочтительней, и точнее отражает методологию TDD. Для имитации еще не написанных нижних уровней (или, напр., моделей) можно использовать класс `Mock`
- хороший подход - создание ORM-оберток, напр., `Book.all_available_books()` == `Book.objects.filter(in_print=True, pub_date__lte=datetime.today())`. Это делает код  четче и намного слабее сопряженным
- для тестирования ORM-моделей не сохраняйте их, просто конструируйте в памяти и используйте в тестах - это быстрее
- декоратор `@staticmethod` - возможность вызова на классе: `C.f()`. На экземпляре тоже можно, но свойства экземпляра недоступны, только свойства класса
- опыт написания хороших изолированных модульных тестов помогает вычленять более оптимальную структуру программного кода, заставляя нас идентифицировать зависимости и побуждая следовать раздельной архитектуре
- [p.518] много ссылок на интересные материалы по TDD и методологии построения систем, архитектуру

#### Приложения
A. PythonAnywhere
B. Классы View в Django
C. Деплой через Ansible
D. Тестирование миграций
E. BDD (Behaviour-Driven Development)
   - функциональные (приемочные) тесты описываются на человекочитаемом предметно-ориентированном языке (DSL)
   - есть несколько инструментов для этого (Gherkin/Behave)
F. Создание REST API: JSON, Ajax, JS
G. Django-Rest-Framework (DRF)
H. Шпаргалка
I. Что делать дальше
J. Примеры исходного кода
