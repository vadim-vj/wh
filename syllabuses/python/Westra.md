Исходный код примеров: <https://github.com/PacktPublishing/Modular-Programming-with-Python>

#### Введение в модульное программирование
- *модуль* Python - это просто файл с исходным кодом (функциями): `<name>.py ---> import <name> + <name>.<functions>()`, где `<functions>` - функции, объявленные в модуле
- *пакет* Python группирует модули. Это директория с `.py`-файлам и файлом `__init__.py`, называемым *package initialization file*. Имя пакета == имя директории, обращение к модулям внутри пакета через точку: `import animals.cow; animals.cow.speak()`. Пакеты могут быть вложенными
- начиная с Python3.3 наличие файла `__init__.py` не обязательно, но пока такие пакеты (называемые *namespace packages*) еще мало распространены
- пример веб-приложения: пакетами являются фронтенд (разбит на модули authentication, results, reports, и api) и бэкенд (разбит на модули database, reportgenerator, и emailer)
- долго описывает преимущества модульного программирования, спагетти-код, программу как процесс добавления новых фич, рефакторинг
- питоновский баззворд - *batteries included* - говорит о том, что язык идет с большим количеством встроенных модулей на все случаи жизни - стандартной библиотекой. Она является хорошим примером модульного программирования. Путь к файлам: `/usr/lib/python3.7/`
- пример написания простого модуля - кеширования:
  * один файл `cache.py`, с несколькими функциями
  * и глобальным словарем, который инициализируется как `def init(): \n\t global _cache \n\t _cache = {}`. Называет такую переменную *module-level global variable*
  * символ подчеркивания в начале имени говорит о том, что такая переменная внутренняя для модуля, и вне его использоваться не будет
  * так же, начиная с подчеркивания, называются и служебные функции модуля. Экспортируемые уже имеют обычные имена (`get()`/`set()`/`contains()`/`size()`)
  * пример использования: `import cache; cache.init(); cache.contains(key)`

#### Пишем первую модульную программу
- программа - мониторинг склада (inventory control)
- состоит из трех модулей (`.py`-файлов): data storage, user interface, report generator и главного файла `main.py`
- БД для продуктов - файл `items.json`
- модуль `datastorage.py` импортируют два других модуля и главная программа
- в главной программе весь код вынесен в функцию `main()` и вызывается как `if __name__ == "__main__": \n\t main()`. В ней же вызываются `init()`-ы модулей
- модули имеют функции `init()` (и другие) и служебные функции, начинающиеся с подчеркивания. Функции с именами без подчеркиваний образуют *публичный интерфейс* модулей
- по PEP0008 имена модулей и пакетов все в нижнем регистре. В именах не пакетов нежелательны подчеркивания. <https://www.python.org/dev/peps/pep-0008/#package-and-module-names>
- в начале создания модулей, при программировании "сверху-вниз", вместо тела функций указывается заглушка `pass`. Вообще широко пользуется `pass`-ом в процессе разработки
- так же, как и в пред. разделе, нигде глобально не объявляет переменные. Только `global _items \n\t return _items` в (любых) функциях, которые эти глобальные переменные используют. Инициализируются они в `init()`
- называет использованный в разделе подход (простое деление на модули) системой "разделяй-и-властвуй" ("divide-and-conquer")

#### Использование модулей и пакетов
- импорт модулей внутри вложенных пакетов происходит так же, через my: `точку from_my.package_sub_package import my_module`
- вложенные пакеты образуют древовидную структуру и обычно отражают логику деления программы на составные части, ее организацию. Напр., `program.gui.widgets.menus` или  `program.logic.data.customers`
- весь код верхнего уровня в `.py`-файле при импорте модуля выполняется. Т.е. можно просто поместить весь код инициализации вне функций (но это не рекомендуется, см. ниже)
- модуль импортируется единожды. Если два (других) модуля импортируют один и тот же модуль, то при втором импорте код уже не выполняется, а просто возвращается ссылка на уже инициализированный модуль
- одной из хороших практик Python считается *explicit is better than implicit* (явное лучше неявного), поэтому предпочтительнее выносить код инициализации модулей в отдельную функцию (`init()`). Кроме того, это позволяет явно управлять порядком импорта, и не допускать возможных конфликтов
- файлы пакетов `__init__.py` могут содержать произвольный код, и он будет выполняться при импорте пакета (а при импорте модуля из пакета?). Но, обычно писать отдельный код внутри `__init__.py` считается плохой практикой. Если на уровне пакета нужны какие-то глобальные свойства/методы их определяют в модулях, а в `__init__.py` добавляют импорт, напр., `from test_package.test_module import say_hello`
- такие импорты в `__init__.py` из пред. пункта кроме того говорят пользователю, какие классы и функции им следуют использовать. Если функция не импортирована на уровень пакета, вероятно на то есть причина. Кроме того, такие импорты в `__init__.py` служат чем-то вроде индекса, раскрывая структуру пакета
- два вида импорта: `import <module>[as <alias>]; <module>.<something>` и `from <module> import <something>[as <alias>]; <something>`. И `<module>` и `<something>` могут быть списками (через запятую), но нужно помнить о переносе на новую строку: либо заключать эти списки в скобки, либо использовать обратный слеш
- два пространства имен: `globals()` (все глобальные сущности) и `locals()` (сущности внутри текущей функции). Второе в книге не рассматривается
- импорты добавляют сущности типа "модуль" в глобальное пространство имен. Или переменные/функции/классы, для второго типа импорта
- псевдонимы при импорте (`as`) служат или для сокращения длинных имен, или для различения одноименных сущностей в разных модулях. Не следует злоупотреблять псевдонимами: они могут ухудшать читаемость кода и требуют всё время помнить, что под каким именем было импортировано
- `from math import *` импортирует всё, что не начинается с подчеркивания (это можно обойти через переменную `__all__`). В случае пакета будет импортировано всё из `__init__.py`
- *относительные импорты* (relative imports):
  * `from . import <another-module>` импортирует модуль (в пакете) на том же уровне вложенности, в той же директории. `.` - псевдоним текущего пакета
  * для вложенного пакета нужно указывать его имя после точки: `from .<sub-package> import <another-module>`
  * для импорта с уровня выше: `from .. import <another-module>`
  * три/четыре/etc точки нужно указать, чтобы импортировать модули с всё более высоких родительских уровней: `from ...dialogs.errors import errDialog`
  * относительные импорты сокращают запись и позволяют не думать, куда будет инсталлирован пакет (?? типа как будет называться корень?)
  * при этом они всё же нарушают принцип *explicit is better than implicit*, а также могут вызывать проблемы при использовании из командной строки, поэтому ими не следует злоупотреблять (а то и вообще не использовать)
- переменная `__all__` задается в модуле (напр., `__all__ = ["A", "B"]`) или `__init__.py`-файле пакета (напр., `__all__ = ["module_1", "module_2", "sub_package"]` ~ `import module1; import module2; import sub_package`), и определяет, что будет импортировано при `import *` (или при импорте по имени тоже?). Хотя использовать ее и не обязательно, она так же может выступать в качестве "индекса": подсказывать пользователю, что предназначено для импорта
- ошибка `ImportError: cannot import name <something>` возникает при наличии циклических зависимостей - когда один модуль импортирует что-то из другого, а другой и первого. Смена порядка импорта не поможет, нужно создавать третий модуль, и выносить общие зависимости в него. Есть и другие способы избежать циклических зависимостей (напр., вынос импорта в функцию), но, в общем случае, само наличие такой проблемы говорит о плохом дизайне программы, который лучше изменить
- запуск модулей из командной строки:
  * можно создать т.н. *chameleon module* - ведущий себя как модуль при импорте и как программа из командной строки. Для этого, под `if __name__ == "__main__":` парсятся аргументы запуска (напр., `$ python funkycase.py "The quick brown fox"`, через `sys.argv` или модуль `argparse`) и вызываются методы
  * при наличии в таком модуле-хамелеоне относительных импортов, при запуске из командной строки он упадет с ошибкой `attempted relative import of non-package`
  * последнее можно обойти, запустив модуль как `$ python -m my_module.py`, но это работает только если нет аргументов командной строки (имя модуля здесь - параметр опции `-m`). Иначе нужно удалять относительные импорты. Есть обходные пути, но в книге они не упоминаются и не рекомендуются

#### Использование модулей в реальных программах
- рассматривается пакет построения диаграмм (charter)
- ООП не используется, просто `import charter; chart = charter.new_chart(); charter.set_title(chart, "...")`. Вызов идет из файла (главной программы) `test_charter.py`, находящегося на одном уровне с папкой пакета `charter`
- стандартная структура: `__init__.py` + три модуля (chart, generator, constants), и вложенный пакет renderers (в котором еще вложены пакеты pdf и png), отделяющий механизмы рисования диаграмм от их данных
- для того, чтобы можно было вызывать функции сразу на имени пакета (`charter.new_chart()` вместо `charter.chart.new_chart()`), в `__init__.py` имена вытаскиваются в глобальное пространство: `from .chart import *; from .generator import *`
- `__init__.py` остальных (вложенных) пакетов, но все они содержат строки документации - описания в тройных двойных кавычках в самом верху файла
- для генерации картинок используется библиотека Pillow (новая версия Python Imaging Library (PIL)), для PDF - библиотека ReportLab
- примеры импортов в модуле верхнего уровня (generator): `from .renderers import (title, x_axis, y_axis, \n bar_series, line_series)` и `from .constants import *`
- импортирование констант из нижележащих (`renderers/*.py`) модулей: `from ..constants import *`
- приводит пример - новое требование, отрисовывать диаграммы в векторном формате (PDF), т.к. png-картинки пикселизуются при печати на высококачественных лазерных принтерах. Изменение требований выявляет проблемы архитектуры, делает необходимой дальнейшую модуляризацию - выделения существующего функционала из renderers в виде пакета png и добавление рядом пакета pdf
- таким образом, новые требования оказываются даже полезными, т.к. улучшают архитектуру, делая ее более модульной, а сами модули более продуманными
- в выделенных пакетах png/pdf импорты констант становятся `from ...constants import *`
- модуль в renderers теперь использует словарь с ключами `png`/`pdf`, которые сами содержать словари с указателями на функции. И динамически выбирает нужную, заменяя таким словарем множество `if`-ов
- вместо такого словаря можно было бы использовать импорт модуля по имени (? через переменную?) - системная библиотека `importlib` такое позволяет
- в общем, все импорты из пакетов идут через относительный синтаксис, точки + имя: на том же уровне - `from .pdf import title as title_pdf`, при импорте общих констант - `from ...constants import *`

#### Паттерны и концепции
- подход *разделяй и властвуй* (divide and conquer) разделяет исходную проблему на более мелкие части, которые проще решить. Он может внести ясность в мчсли разработчика, помочь спроектировать более простой и логичный код, или даже решить проблему, решения которой для целого не видно. Применялся, например, в предыдущей главе, для отделения пакета renderer (отрисовки от данных) и пакетов png/pdf для форматов диаграмм
- *абстракция* (abstraction) - абсолютно базовый подход во всём программировании. Скрывает сложность, отделяет то, что нужно сделать, от того, как это нужно сделать. Функция и модуль (группа функций) - хорошие примеры абстракции, они скрывают сложность, позволяют абстрагироваться от деталей реализации
- *инкапсуляция* (encapsulation) - сокрытие деталей реализации и предоставление внешних методов для работы с данными. Хотя обычно реализуется с использованием ООП, пример из пред. главы тоже ей удовлетворяет - `chart = charter.new_chart(); charter.set_title(chart, "...")`: детали реализации `chart` скрыты, функции можно рассматривать как сеттеры. Сокрытие реализации позволяет менять ее в любой момент, не меняя основную программу, а геттеры/сеттеры позволяют добавлять доп. функционал в операции получения/установки данных (напр., записи в БД) и контроль ошибок
- *обертки* (wrappers) - функции, вызывающие другие функции. Упрощают интерфейс или существующий (неудобный или сложный) API. Пример с оберткой над NumPy. Обертка всегда тонкая (thin): хоть она и может иметь некоторый свой код (напр., приводить параметры), основную работу делает вызываемая в ней функция
- *расширяемые модули* (extensible modules):
  * *динамические импорты* (dynamic imports) - `import importlib; importlib.import_module(<module-name>).<method>()`. Имя переменной поддерживает все формы записи (с точками), также можно использовать в записи (внутри кавычек) переменную `__package__` - пакет, в котором содержится текущий модуль. Ошибка в случае неудачи - `ImportError`
  * *плагины* (plugins) - те же динамические импорты используются в plugin loader-е - системе, просматривающей некую (выделенную) директорию, и загружающей все находящиеся там пакеты/модули
  * *хуки* (hooks) - в своем коде делаются врезки, вызовы всех (возможно) зарегистрированных хуков-функций. Рекомендуется использовать возвращаемое значение хуков, напр., для определения, делать некоторые действия или нет (это дает хукам больше возможностей возможностей влиять на программу), а также давать возможность регистрировать сразу несколько хуков для каждой точки вызова

#### Создание повторно используемых модулей
- что дает модулю/пакету возможность использовать его повторно:
  * возможность работать самостоятельно. Все зависимые модули должны быть включены в пакет
  * использование относительных импортов
  * явное указание внешних зависимостей, в README и (возможно) в системах управления пакетами, типа `setuptools` или `pip`
- что делает модуль хорошим для переиспользования:
  * решение им какой-либо общей задачи, а не специфической. Например, вместо перевода дюймов в сантиметры - конвертация английских единиц в метрические, или парсинг файлов с произвольным разделителем полей
  * следование стандартам, в частности PEP0008: <https://www.python.org/dev/peps/pep-0008/>
  * понятная документация. Хороший пример - документация стандартной библиотеки (<https://docs.python.org/3/library/>), подробные описания с примерами. Основные способы добавления: `README[.txt]` (установка, использование, лицензия, несколько примеров) и `docstings` (для модулей, классов, функций и т.д., описания и примеры в тройных двойных кавычках). Оба способа добавления документации желательно ввести в привычку
- примеры таких модулей:
  * Python Package Index (<https://pypi.python.org/pypi>)
  * `requests` (<http://docs.python-requests.org/en/master/>), HTTP-запросы. Пишет, что этот удобней модуля `urllib2` из стандартной библиотеки
  * `python-dateutil` (<https://github.com/dateutil/dateutil>), даты и время. Расширяет возможности модуля `datetime` из стандартной библиотеки
  * `lxml` (<http://lxml.de>), парсинг XML/HTML. Лучше модуля `ElementTree` из стандартной библиотеки
- примеры из модуля для преобразования единиц измерения продуктов, локализация. Используется ООП, и методы `def __init__(self, ...):` и `def __str__(self):` (аналог `.toString()`, для непосредственного использования объекта в `print()`)
- в примере выше, внутри пакета создается отдельный модуль interface, и уже его сущности импортируются в `__init__.py` (`from .interface import *`), т.к. большинство программистов не ожидают встретить код внутри `__init__.py`. Так создается публичный интерфейс пакета
- упоминает Sphinx (<http://www.sphinx-doc.org>) для создания документации по `docstring`-ам

#### Продвинутые техники
- опциональный импорт: `try: ... \n except ImportError: ...`. В блоке `try` идет попытка импортировать модуль и установка флага (`import numpy; has_numpy = True`), а в блоке `except` - сброс этого же флага (`has_numpy = False`). Дальше в программе флаг можно использовать для проверок и выстраивать поведение, в зависимости от того, есть модуль или нет
- локальные импорты - внутри функции. Импорт вообще вытаскивает имена в текущую область видимости. В данном случае в `locals()`. Вообще, они снижают читаемость программы: с ходу не ясны зависимости, их нужно искать в коде. Но могут быть полезны:
  * если импортируемые модули большие или с медленной инициализацией, а функция внутри которой идет импорт вызывается не всегда
  * для избегания циклических зависимостей
- `sys.path` (места, где ищутся модули для импорта) = это массив, и он хранит каталоги в порядке: текущего выполняемого скрипта, переменной окружения `PYTHONPATH`, директории `site-packages` (используемой, напр., пакетными менеджерами; часто - глобально установленные модули). Порядок важен, т.к. поиск останавливается при первом совпадении. Примеры модификации: `sys.path.append("<path>")`, `sys.path.insert(1, "<path>")` (не `0`, не перекрываем текущий каталог). Не стоит менять `sys.path` где-либо кроме главной программы, иначе пользователи могут столкнуться с трудноотлавливаемыми багами при импорте ваших модулей
