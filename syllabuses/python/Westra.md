### Westra E., Modular Programming with Python
<https://www.packtpub.com/application-development/modular-programming-python>

---

Исходный код примеров: <https://github.com/PacktPublishing/Modular-Programming-with-Python>

#### Введение в модульное программирование
- *модуль* Python - это просто файл с исходным кодом (функциями): `<name>.py ---> import <name> + <name>.<functions>()`, где `<functions>` - функции, объявленные в модуле
- *пакет* Python группирует модули. Это директория с `.py`-файлам и файлом `__init__.py`, называемым *package initialization file*. Имя пакета == имя директории, обращение к модулям внутри пакета через точку: `import animals.cow; animals.cow.speak()`. Пакеты могут быть вложенными
- начиная с Python3.3 наличие файла `__init__.py` не обязательно, но пока такие пакеты (называемые *namespace packages*) еще мало распространены
- пример веб-приложения: пакетами являются фронтенд (разбит на модули authentication, results, reports, и api) и бэкенд (разбит на модули database, reportgenerator, и emailer)
- долго описывает преимущества модульного программирования, спагетти-код, программу как процесс добавления новых фич, рефакторинг
- питоновский баззворд - *batteries included* - говорит о том, что язык идет с большим количеством встроенных модулей на все случаи жизни - стандартной библиотекой. Она является хорошим примером модульного программирования. Путь к файлам: `/usr/lib/python3.7/`
- пример написания простого модуля - кеширования:
  * один файл `cache.py`, с несколькими функциями
  * и глобальным словарем, который инициализируется как `def init(): \n\t global _cache \n\t _cache = {}`. Называет такую переменную *module-level global variable*
  * символ подчеркивания в начале имени говорит о том, что такая переменная внутренняя для модуля, и вне его использоваться не будет
  * так же, начиная с подчеркивания, называются и служебные функции модуля. Экспортируемые уже имеют обычные имена (`get()`/`set()`/`contains()`/`size()`)
  * пример использования: `import cache; cache.init(); cache.contains(key)`

#### Пишем первую модульную программу
- программа - мониторинг склада (inventory control)
- состоит из трех модулей (`.py`-файлов): data storage, user interface, report generator и главного файла `main.py`
- БД для продуктов - файл `items.json`
- модуль `datastorage.py` импортируют два других модуля и главная программа
- в главной программе весь код вынесен в функцию `main()` и вызывается как `if __name__ == "__main__": \n\t main()`. В ней же вызываются `init()`-ы модулей
- модули имеют функции `init()` (и другие) и служебные функции, начинающиеся с подчеркивания. Функции с именами без подчеркиваний образуют *публичный интерфейс* модулей
- по PEP0008 имена модулей и пакетов все в нижнем регистре. В именах не пакетов нежелательны подчеркивания. <https://www.python.org/dev/peps/pep-0008/#package-and-module-names>
- в начале создания модулей, при программировании "сверху-вниз", вместо тела функций указывается заглушка `pass`. Вообще широко пользуется `pass`-ом в процессе разработки
- так же, как и в пред. разделе, нигде глобально не объявляет переменные. Только `global _items \n\t return _items` в (любых) функциях, которые эти глобальные переменные используют. Инициализируются они в `init()`
- называет использованный в разделе подход (простое деление на модули) системой "разделяй-и-властвуй" ("divide-and-conquer")

#### Использование модулей и пакетов
- импорт модулей внутри вложенных пакетов происходит так же, через точку: `from my_package.sub_package import my_module`
- вложенные пакеты образуют древовидную структуру и обычно отражают логику деления программы на составные части, ее организацию. Напр., `program.gui.widgets.menus` или  `program.logic.data.customers`
- весь код верхнего уровня в `.py`-файле при импорте модуля выполняется. Т.е. можно просто поместить весь код инициализации вне функций (но это не рекомендуется, см. ниже)
- модуль импортируется единожды. Если два (других) модуля импортируют один и тот же модуль, то при втором импорте код уже не выполняется, а просто возвращается ссылка на уже инициализированный модуль
- одной из хороших практик Python считается *explicit is better than implicit* (явное лучше неявного), поэтому предпочтительнее выносить код инициализации модулей в отдельную функцию (`init()`). Кроме того, это позволяет явно управлять порядком импорта, и не допускать возможных конфликтов
- файлы пакетов `__init__.py` могут содержать произвольный код, и он будет выполняться при импорте пакета (а при импорте модуля из пакета?). Но, обычно писать отдельный код внутри `__init__.py` считается плохой практикой. Если на уровне пакета нужны какие-то глобальные свойства/методы их определяют в модулях, а в `__init__.py` добавляют импорт, напр., `from test_package.test_module import say_hello`
- такие импорты в `__init__.py` из пред. пункта кроме того говорят пользователям, какие классы и функции им следуют использовать. Если функция не импортирована на уровень пакета, вероятно на то есть причина. Кроме того, такие импорты в `__init__.py` служат чем-то вроде индекса, раскрывая структуру пакета
- два вида импорта: `import <module>[as <alias>]; <module>.<something>` и `from <module> import <something>[as <alias>]; <something>`. И `<module>` и `<something>` могут быть списками (через запятую), но нужно помнить о переносе на новую строку: либо заключать эти списки в скобки, либо использовать обратный слеш
- два пространства имен: `globals()` (все глобальные сущности) и `locals()` (сущности внутри текущей функции). Второе в книге не рассматривается
- импорты добавляют сущности типа "модуль" в глобальное пространство имен. Или переменные/функции/классы, для второго типа импорта
- псевдонимы при импорте (`as`) служат или для сокращения длинных имен, или для различения одноименных сущностей в разных модулях. Не следует злоупотреблять псевдонимами: они могут ухудшать читаемость кода и требуют всё время помнить, что под каким именем было импортировано
- `from math import *` импортирует всё, что не начинается с подчеркивания (это можно обойти через переменную `__all__`). В случае пакета будет импортировано всё из `__init__.py`
- *относительные импорты* (relative imports):
  * `from . import <another-module>` импортирует модуль (в пакете) на том же уровне вложенности, в той же директории. `.` - псевдоним текущего пакета
  * для вложенного пакета нужно указывать его имя после точки: `from .<sub-package> import <another-module>`
  * для импорта с уровня выше: `from .. import <another-module>`
  * три/четыре/etc точки нужно указать, чтобы импортировать модули с всё более высоких родительских уровней: `from ...dialogs.errors import errDialog`
  * относительные импорты сокращают запись и позволяют не думать, куда будет инсталлирован пакет (?? типа как будет называться корень?)
  * при этом они всё же нарушают принцип *explicit is better than implicit*, а также могут вызывать проблемы при использовании из командной строки, поэтому ими не следует злоупотреблять (а то и вообще не использовать)
- переменная `__all__` задается в модуле (напр., `__all__ = ["A", "B"]`) или `__init__.py`-файле пакета (напр., `__all__ = ["module_1", "module_2", "sub_package"]` ~ `import module1; import module2; import sub_package`), и определяет, что будет импортировано при `import *` (или при импорте по имени тоже?). Хотя использовать ее и не обязательно, она так же может выступать в качестве "индекса": подсказывать пользователю, что предназначено для импорта
- ошибка `ImportError: cannot import name <something>` возникает при наличии циклических зависимостей - когда один модуль импортирует что-то из другого, а другой и первого. Смена порядка импорта не поможет, нужно создавать третий модуль, и выносить общие зависимости в него. Есть и другие способы избежать циклических зависимостей (напр., вынос импорта в функцию), но, в общем случае, само наличие такой проблемы говорит о плохом дизайне программы, который лучше изменить
- запуск модулей из командной строки:
  * можно создать т.н. *chameleon module* - ведущий себя как модуль при импорте и как программа из командной строки. Для этого, под `if __name__ == "__main__":` парсятся аргументы запуска (напр., `$ python funkycase.py "The quick brown fox"`, через `sys.argv` или модуль `argparse`) и вызываются методы
  * при наличии в таком модуле-хамелеоне относительных импортов, при запуске из командной строки он упадет с ошибкой `attempted relative import of non-package`
  * последнее можно обойти, запустив модуль как `$ python -m my_module.py`, но это работает только если нет аргументов командной строки (имя модуля здесь - параметр опции `-m`). Иначе нужно удалять относительные импорты. Есть обходные пути, но в книге они не упоминаются и не рекомендуются

#### Использование модулей в реальных программах
- рассматривается пакет построения диаграмм (charter)
- ООП не используется, просто `import charter; chart = charter.new_chart(); charter.set_title(chart, "...")`. Вызов идет из файла (главной программы) `test_charter.py`, находящегося на одном уровне с папкой пакета `charter`
- стандартная структура: `__init__.py` + три модуля (chart, generator, constants), и вложенный пакет renderers (в котором еще вложены пакеты pdf и png), отделяющий механизмы рисования диаграмм от их данных
- для того, чтобы можно было вызывать функции сразу на имени пакета (`charter.new_chart()` вместо `charter.chart.new_chart()`), в `__init__.py` имена вытаскиваются в глобальное пространство: `from .chart import *; from .generator import *`
- `__init__.py` остальных (вложенных) пакетов пусты, но все они содержат строки документации - описания в тройных двойных кавычках в самом верху файла
- для генерации картинок используется библиотека Pillow (новая версия Python Imaging Library (PIL)), для PDF - библиотека ReportLab
- примеры импортов в модуле верхнего уровня (generator): `from .renderers import (title, x_axis, y_axis, \n bar_series, line_series)` и `from .constants import *`
- импортирование констант из нижележащих (`renderers/*.py`) модулей: `from ..constants import *`
- приводит пример - новое требование, отрисовывать диаграммы в векторном формате (PDF), т.к. png-картинки пикселизуются при печати на высококачественных лазерных принтерах. Изменение требований выявляет проблемы архитектуры, делает необходимой дальнейшую модуляризацию - выделения существующего функционала из renderers в виде пакета png и добавление рядом пакета pdf
- таким образом, новые требования оказываются даже полезными, т.к. улучшают архитектуру, делая ее более модульной, а сами модули более продуманными
- в выделенных пакетах png/pdf импорты констант становятся `from ...constants import *`
- модуль в renderers теперь использует словарь с ключами `png`/`pdf`, которые сами содержать словари с указателями на функции. И динамически выбирает нужную, заменяя таким словарем множество `if`-ов
- вместо такого словаря можно было бы использовать импорт модуля по имени (? через переменную?) - системная библиотека `importlib` такое позволяет
- в общем, все импорты из пакетов идут через относительный синтаксис, точки + имя: на том же уровне - `from .pdf import title as title_pdf`, при импорте общих констант - `from ...constants import *`

#### Паттерны и концепции
- подход *разделяй и властвуй* (divide and conquer) разделяет исходную проблему на более мелкие части, которые проще решить. Он может внести ясность в мысли разработчика, помочь спроектировать более простой и логичный код, или даже решить проблему, решения которой для целого не видно. Применялся, например, в предыдущей главе, для отделения пакета renderer (отрисовки от данных) и пакетов png/pdf для форматов диаграмм
- *абстракция* (abstraction) - абсолютно базовый подход во всём программировании. Скрывает сложность, отделяет то, что нужно сделать, от того, как это нужно сделать. Функция и модуль (группа функций) - хорошие примеры абстракции, они скрывают сложность, позволяют абстрагироваться от деталей реализации
- *инкапсуляция* (encapsulation) - сокрытие деталей реализации и предоставление внешних методов для работы с данными. Хотя обычно реализуется с использованием ООП, пример из пред. главы тоже ей удовлетворяет - `chart = charter.new_chart(); charter.set_title(chart, "...")`: детали реализации `chart` скрыты, функции можно рассматривать как сеттеры. Сокрытие реализации позволяет менять ее в любой момент, не меняя основную программу, а геттеры/сеттеры позволяют добавлять доп. функционал в операции получения/установки данных (напр., записи в БД) и контроль ошибок
- *обертки* (wrappers) - функции, вызывающие другие функции. Упрощают интерфейс или существующий (неудобный или сложный) API. Пример с оберткой над NumPy. Обертка всегда тонкая (thin): хоть она и может иметь некоторый свой код (напр., приводить параметры), основную работу делает вызываемая в ней функция
- *расширяемые модули* (extensible modules):
  * *динамические импорты* (dynamic imports) - `import importlib; importlib.import_module(<module-name>).<method>()`. Имя переменной поддерживает все формы записи (с точками), также можно использовать в записи (внутри кавычек) переменную `__package__` - пакет, в котором содержится текущий модуль. Ошибка в случае неудачи - `ImportError`
  * *плагины* (plugins) - те же динамические импорты используются в plugin loader-е - системе, просматривающей некую (выделенную) директорию, и загружающей все находящиеся там пакеты/модули
  * *хуки* (hooks) - в своем коде делаются врезки, вызовы всех (возможно) зарегистрированных хуков-функций. Рекомендуется использовать возвращаемое значение хуков, напр., для определения, делать некоторые действия или нет (это дает хукам больше возможностей возможностей влиять на программу), а также давать возможность регистрировать сразу несколько хуков для каждой точки вызова

#### Создание повторно используемых модулей
- что дает модулю/пакету возможность использовать его повторно:
  * возможность работать самостоятельно. Все зависимые модули должны быть включены в пакет
  * использование относительных импортов
  * явное указание внешних зависимостей, в README и (возможно) в системах управления пакетами, типа `setuptools` или `pip`
- что делает модуль хорошим для переиспользования:
  * решение им какой-либо общей задачи, а не специфической. Например, вместо перевода дюймов в сантиметры - конвертация английских единиц в метрические, или парсинг файлов с произвольным разделителем полей
  * следование стандартам, в частности PEP0008: <https://www.python.org/dev/peps/pep-0008/>
  * понятная документация. Хороший пример - документация стандартной библиотеки (<https://docs.python.org/3/library/>), подробные описания с примерами. Основные способы добавления: `README[.txt]` (установка, использование, лицензия, несколько примеров) и `docstings` (для модулей, классов, функций и т.д., описания и примеры в тройных двойных кавычках). Оба способа добавления документации желательно ввести в привычку
- примеры таких модулей:
  * Python Package Index (<https://pypi.python.org/pypi>)
  * `requests` (<http://docs.python-requests.org/en/master/>), HTTP-запросы. Пишет, что этот удобней модуля `urllib2` из стандартной библиотеки
  * `python-dateutil` (<https://github.com/dateutil/dateutil>), даты и время. Расширяет возможности модуля `datetime` из стандартной библиотеки
  * `lxml` (<http://lxml.de>), парсинг XML/HTML. Лучше модуля `ElementTree` из стандартной библиотеки
- примеры из модуля для преобразования единиц измерения продуктов, локализация. Используется ООП, и методы `def __init__(self, ...):` и `def __str__(self):` (аналог `.toString()`, для непосредственного использования объекта в `print()`)
- в примере выше, внутри пакета создается отдельный модуль interface, и уже его сущности импортируются в `__init__.py` (`from .interface import *`), т.к. большинство программистов не ожидают встретить код внутри `__init__.py`. Так создается публичный интерфейс пакета
- упоминает Sphinx (<http://www.sphinx-doc.org>) для создания документации по `docstring`-ам

#### Продвинутые техники
- опциональный импорт: `try: ... \n except ImportError: ...`. В блоке `try` идет попытка импортировать модуль и установка флага (`import numpy; has_numpy = True`), а в блоке `except` - сброс этого же флага (`has_numpy = False`). Дальше в программе флаг можно использовать для проверок и выстраивать поведение, в зависимости от того, есть модуль или нет
- локальные импорты - внутри функции. Импорт вообще вытаскивает имена в текущую область видимости. В данном случае в `locals()`. Вообще, они снижают читаемость программы: с ходу не ясны зависимости, их нужно искать в коде. Но могут быть полезны:
  * если импортируемые модули большие или с медленной инициализацией, а функция внутри которой идет импорт вызывается не всегда
  * для избегания циклических зависимостей
- `sys.path` (места, где ищутся модули для импорта) = это массив, и он хранит каталоги в порядке: текущего выполняемого скрипта, переменной окружения `PYTHONPATH`, директории `site-packages` (используемой, напр., пакетными менеджерами; часто - глобально установленные модули). Порядок важен, т.к. поиск останавливается при первом совпадении. Примеры модификации: `sys.path.append("<path>")`, `sys.path.insert(1, "<path>")` (не `0`, не перекрываем текущий каталог). Не стоит менять `sys.path` где-либо кроме главной программы, иначе пользователи могут столкнуться с трудноотлавливаемыми багами при импорте ваших модулей
- создание одноименных с существующими модулей или пакетов приводит к *сокрытию имен* (name masking) и вызывает ошибки. В том числе, если имя запускаемого скрипта совпадает с именем импортируемого (`puthon3 ./re.py ---> import re`; поиск сначала идет в текущем каталоге)
- код модулей выполняется единожды, при первом импорте, все следующие используют уже инициализированный модуль. Это позволяет корректно работать с глобальными переменными внутри модуля. Добавление текущего пути в `sys.path` (внутри скрипта) приводит к тому, что модуль может импортироваться дважды (так и не понял почему). Так что модификаций `sys.path` следует избегать
- импорт одноименного с исполняемым скриптом модуля внутри самого этого скрипта (даже неявно, через цепочку вызовов функций) приведет к выполнению кода дважды. Этого нужно избегать
- вообще, для избегания конфликтов имен можно использовать в именах исполняемых скриптов префиксы, например, `test_`
- предлагает тестировать модули, импортируя их через REPL. Называет это *rapid application development (RAD)*, хотя сам же признает, что после каждого изменения в модуле нужно импортировать его заново (`>>> import <name>`), и что изменения в зависимых модулях не подтягиваются автоматически
- подход к созданию глобальных переменных внутри пакета: создать отдельный модуль (`globals.py`) с одними только переменными, и импортировать его - `from . import globals`. Можно читать/изменять: `globals.language = "EN"`
- конфигурирование. Если для приложений подходит использование файлов-конфигов (и их парсинг с использованием, напр., модулей стандартной библиотеки `configparser`, `shlex`, и `json`), то для модулей такое не подходит: непонятно где хранить конфиги. Вместо этого, параметризуют функцию `init()` у модуля, аргументами простых типов или словарем
- если используются файлы данных (картинки, базы zip-кодов, и т.д.; всё, что не код), рекомендуется включать их в пакет (делая его самодостаточным). Для чтения/подключения этих файлов нужен относительный путь, который можно получить через `cur_dir = os.path.abspath(os.path.dirname(__file__))`

#### Тестирование и развертывание
- *ad-hoc testing* - свободное (интуитивное) тестирование. Просто вручную проверяются некоторые кейсы, напр., в REPL-е. В противоположность ему *юнит тестирование* (unit tests) - когда тесты пишутся как код, и могут быть запущены когда угодно. Есть еще *integration tests*, проверяющие работы различных частей системы вместе, и *GUI tests* - проверяющие интерфейс
- `assert` (напр., `assert math.floor(2.6197) == 2`) - простейший вид юнит-тестов. Выбрасывает `AssertionError` если его аргумент не равен `True`
- более сложные можно писать с использованием стандартного модуля `unittest`. Создать скрипт, импортировать в него `unittest` и тестируемый модуль. Внутри объявляем класс-потомок `unittest.TestCase` (напр., `class TestQuantities(unittest.TestCase):`) и `if __name__ == "__main__": \n\t unittest.main()`. Функция `.main()` ищет всех потомков класса `unittest.TestCase` в текущем файле, и выполняет его методы, сначала `setUp()`, потом все, начинающиеся с `test`. В этих методах проводится собственно тестирование, напр., вызовы `self.assertXXX(...)`
- вроде поддерживаются сьюты тестов, но не описано как
- дополнительный вывод при выполнении юнит-тестов - `unittest.main(verbosity=N)` или `python <test-script>.py -v`
- пример пакета для расчета покрытия тестами: `coverage` (<https://pypi.python.org/pypi/coverage>)
- *test-driven development* - написание юнит-тестов до кода. Они выступают в роли некой "спецификации"
- *mocking* (модуль `unittest.mock`) - создание заглушек для тестирования внешнего, или сложного/затратного по ресурсам функционала
- расположение файла с тестами - в той же директории, что и файла модуля. Название - напр., `tests.py`. Если модулей в папке несколько, то либо один скрипт тестов на все, либо для каждого отдельный, с именами `test_<...>.py`. Для пакетов не следует помещать тесты внутрь директории пакета: будут проблемы с импортом самого тестируемого пакета, должны лежать на одном уровне. Запуск для обоих типов: `python test.py`
- хороший пакет должен удовлетворять требованиям из более ранней главы ("Создание повторно используемых модулей"), иметь документацию и тесты, быть выложенным в открытый доступ (на ГитХаб или в Python Package Index (PyPI)). Можно сделать в блоге пост, описывающий функциональность, и приложить ссылки
- описывает Git и GitHub на десяти страницах
- PyPI - <https://pypi.python.org/pypi>. Бесплатная регистрация. Перед заливкой и к пакету нужно добавить файлы `LICENSE.txt` (как правило, одну из существующих) и `setup.py`. В последнем добавляется код, с использованием стандартного пакета: `from distutils.core import setup; setup(...)` - добавляются ссылки на репу, email и прочее. Когда файлы готовы, выполнить из терминала `$ python setup.py register; python setup.py sdist upload`. Теги Гита автоматически сопоставляются с версиями в PyPI, в его веб-интерфейсе появляются ссылки на тарболы ГитХаба
- установка в папку `site-packages`: `$ sudo pip install <username>_test_package`, где `<username>` - имя пользователя GitHub (?). И прочие команды, типа `$ pip list`. Можно создавать сразу списки пакетов в `.txt`-файлах (`$ pip freeze > requirements.txt`), и разом устанавливать все: `$ pip install -r requirements.txt`. Такие списки зависимостей обычно распространяются вместе с исходным кодом программы. Поддерживаются также виртуальные среды (как?), такие же как в Conda

#### Модульное программирование как основа хорошей разработки
- для загрузки в PyPI подходит формат reStructuredText (документация, `README.rst`)
- идет пример разработки пакета `counter`. Структура директорий: `counter/counter`, внутри второй `__init__.py`, с кодом `from .interface import *`. Файл `interface.py` там же, внутри второго `counter`-а, с сигнатурами функций и их телами с `pass`
- у всех функций есть docstring-и, в тройных двойных кавычках. Их структура: первая строка краткого описания + пустая строка + более подробное описание.
- тот же паттерн с использованием глобальных переменных, начинающихся с подчеркивания, без предварительного объявления
- после создания - ad-hoc-тестирование, добавление юнит-тестов в `tests.py` в *верхней* папке `counter` (в коде `tests.py` - `import counter`), их запуск (`$ python tests.py`)
- бизнес-требования неизбежно меняются, делая необходимым переписывать код. Приводится пример изменений `counter`-а, перехода с отдельных чисел на диапазоны. Меняется документация (docstring-и), это важно. Пишет, что модульность делает изменения минимальными, а написанные ранее юнит-тесты помогают отлавливать ошибки и убеждаться, что код работает правильно
