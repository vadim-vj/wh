- введение, как установить, про интерпретируемость
- формат приглашений REPL определяется в модуле `sys`: `import sys; sys.ps1; sys.ps2`, выход из REPL - `quit()`
- описание редактора IDLE
- shebang-line для скриптов Python: `#!/usr/bin/env python3`
- `print()` выводит свои аргументы (указанные через запятую) в одну строку, аргументом `input()` служит строка приглашения ввода
- `input()` всегда возвращает строку, нужно приводить явно (напр., `int(result)`) чтобы использовать как число
- в Python всё - объекты, переменные - ссылки на них, при присваиваниях изменяется счетчик ссылок объекта (можно узнать через `sys.getrefcount(<var>)`)
- повторное использование переменной не экономит память. И хоть язык и позволяет (пере)присваивать переменной значение другого типа, делать этого не следует, чтобы не снижать читаемость кода
- имена переменных не должны совпадать с ключевыми словами языка (напр., `break = 'foo'`), будет выброшена синтаксическая ошибка
- `help()` переводит REPL в режим показа помощи, можно искать по ключевым словам в разделах справки
- рекомендует имена переменных в нижнем регистре через подчеркивание (вероятно это из PEP). И не должны совпадать со встроенными функциями (могут, но не стоит: встроенная станет недоступной)
- PEP8 = "Python Enhancement Proposal" ("Предложение по улучшению Python"): [PEP 8 — Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)
- модуль `__builtins__` импортируется по умолчанию. Вывод всех: `dir(__builtins__)`
- по поводу переопределения встроенных. Стоит помнить, что в билтинах есть распространенные имена `dict`, `id`, `list`, `min`, `max`, `open`, `range`, `str`, `sum` и `type`
- `id()` выводит "адрес", оператор `is` сравнивает переменные по `id()`, `type()` возвращает строку с названием типа. Приведение типов через конструкторы классов (напр., `str(<var>)`)
- в Python применяется утиная типизация, т.е., напр., для сложения нужно лишь чтобы объект реализовывал метод `__add__`, а принадлежность к какому-либо типу неважна. То же и про перебор в циклах
- изменяемые объекты: словари и списки, неизменяемые: строки, кортежи и числа. Изменяемые объекты не могут использоваться как ключи в словарях, и могут создавать проблемы при использовании в качестве аргументов по умолчанию
- типы чисел: `int` - целое, `float` - с плавающей точкой
- два типа деления (`//` - в меньшую сторону), `%` - остаток (как-то хитро ведет себя с отрицательными числами), `**` - возведение в степень
- есть спец. модуль математических операторов: `import operator; operator.add(2, 4) # same as 2 + 4`. Пишет, что может пригодиться с лямбдами и генераторами (зачем?)
- строки, кавычки: `'`, `"`, `'''`, `"""`. Raw-строки: `r'...'` (кавычки могут быть любыми (так ли?)) - в них обратный слеш не имеет спец. значения; используются в регулярных выражениях
- кавычки внутри кавычек другого типа не нужно экранировать. Этим удобны тройные для документации - в них можно свободно использовать любые кавычки
- метод `.format()` у строк заполняет пустые позиционные плейсхолдеры: `'I:{} R:{} S:{}'.format(1, 2.5, 'foo')`. Но в фигурных скобках могут быть и цифры - номера позиционных параметров. Если в фигурных скобках имена, то параметрами `.format()` должны быть именованные аргументы или словари. И вообще там целый язык форматирования (см. `>>>help(); >FORMATTING` или <https://pyformat.info>)
- в v3.6 появились т.н. f-строки: ` f'My name is {name}'`/`f'My name is {name.capitalize()}'` - строки с префиксом `f`, допускающие подстановки кода
- методы можно вызывать на литералах (`'...'.capitalize()`), как и получать список всех методов через литерал (`dir('...')`). Через литералы можно получать и справку (`help('some string'.upper)`). Для чисел литералы нужно заключать в круглые скобки (чтобы интерпертатор не путал их с дробными числами)
- методы, начинающиеся с двух подчеркиваний (`__`), называются  специальными, волшебными или дандер-методами (dunder methods). Используются, например, с операторами. В хелпе тема `>>>help(); >SPECIALMETHODS`
- `import pdb; pdb.set_trace()` вызовет в этой точке прогаммы отладчик, запустит его приглашение командной строки. Хотя сам пишет, что отладочный вывод (вставка `print`-ов) часто проще и эффективнее
- сигнатуры методов всегда можно подсмотреть в хелпе (напр., `help(xl.endswith)`)
- некоторые методы строк: `.endswith()`, `.find()`(поиск подстрок), `.format()`, `.join()` (принимает список, обратный порядок по сравнению с JS), `.lower()`, `.startswith()`, `.strip()`, `.upper()`. Тема в хелпе: `>>>help(); >STRINGMETHODS`
- комменатрии только `#`, многострочные в виде строк в тройных кавычках не рекомендуются
- bool-литералы: `True`/`False`, спец. значение `None`. В условиях приведение к bool-у выполняется неявно, явно выполнять не рекомендуется, плохой стиль. Пустые строки, нулевые числа и пустые коллекции = `False`, непустые строки (даже `'0'`/`'False'`) = `True`
- порядок проверки на `True`: метод `.__bool__()` --> метод `.__len__() > 0` --> `True`
- тип `None` - `NoneType`. Сам объект `None` - синглет, всегда существует только один его экземпляр. Для сравнения с синглетами можно использовать `a is [not] b` вместо `==`, `is` сравнивает по `id()`
- методы `.__gt__()`, `.__lt__()`, `.__ge__()`, `.__le__()`, `.__eq__()` и `.__ne__()` соотносятся с `>`, `<`, `>=`, `<=`, `==` и `!=` соответственно. Но если для класса указать спец. декоратор (`@functools.total_ordering \n class Abs(object):`), то можно определять только `.__le__()` и `.__eq__()`, остальные будут сгенерированы автоматически
- логические связки - словами: `and`, `or`, `not`
- Питон поддерживает *диапазонную проверку*: `if 90 < score <=100:`
- круглые скобки в условиях `if` не обязательны, но могут присутствовать. Без них, для переноса условия на новую строку, нужен обратный слеш
- стандартная проверка принадлежности элемента коллекции/диапазону - оператор `in`
- блоки условия: `if`/`elif`/`else`
- блок кода отделяется двоеточием + отступами. PEP8 рекомендует 4 пробела. Смешение табов и пробелов в одном файле может привести к `TabError`
- списки можно создавать как через литерал `[]`, так и через конструктор `list()`. Только он все равно требует литерал, если передать ему строку, он составит список из отдельных букв
- методы `[].append(el)`/`[].insert(N, el)`/`.remove(el)` возвращают `None`, изменяют список по месту. Аналогом `.remove()` служит оператор `del`
- списки в Python реализуются как массивы указателей, для быстрого доступа по индексу. Из-за этого вставка и удаления в конец идут быстро (O(1)), а вставка/удаление в середине - медленно (O(N)). Для частой модификации начала списка лучше использовать `collections.deque`
- метод `.sort()` также меняет список in-place и возвращает `None`, а вот глобальная функция `sorted()` возвращает результат. Сортировка гетерогенного списка выдаст ошибку, нужно явно указывать правило сравнения. В обе функции, через параметр `key`, можно передать функцию, класс или метод, определющие правила сравнения (`things.sort(key=str)`)
- `range([<start>, ]<end>[, <step>]])` создает легковесный диапазон, `list(range())` "материализует" его в список. Без `<start>` диапазон начинается с нуля. Диапазон не включает последний элемент (полуоткрытый интервал; длина равна разности начального и конечного, сращивание двух последовательностей происходит без перекрытия)
- литерал кортежа `()`, конструктор `tuple()`. Гетерогенны. Литерал кортежа из одного элемента (без запятой у скобок будет стандартная функция): `(1,)` == `1,` (скобки можно опустить). Кортежи упорядочены и неизменяемы. Могут служить ключами в словарях, использоваться для возвращения значений из функций. Требует меньше памяти, чем списки
- литерал множества `{}`, конструктор `set()`. Поиск принадлежности множеству очень быстрый, из-за использования хеш-функций. Поэтому может хранить только хешируемые значения, которые всегда дают одинаковый хеш. Изменяемые объекты (списки и словари) этому условию не удовлетворяют
- для хранения пользовательских классов в множествах они должны определять методы `.__hash__()` и `.__eq__()`. Проверка принадлежности элемента множеству - оператор `in` и метод пользовательских классов `.__contains__()` (но реализовывать его не обязательно). На множествах поддерживаются операторы объединения (`|`), пересечения (`&`), вычитания (`-`) и исключающего или (`^`). Оператор `in` работает на множествах гораздо быстрее, чем на списках или кортежах, но множества не сохраняют порядок элементов
- перебор коллекций: `for <el> in []:`, перебор индексов: плохой вариант - `for <index> in range(len([])):`, хороший - `for index, value in enumerate(animals):`. `enumerate()` возвращает кортеж, в цикле идет *распаковка* кортежа. Получение индекса по элементу - `[].index(el)`
- `break`/`continue` стандартные, `else` (если не было выхода по `break`) часто используется для обработки отсутствия элементов. Пользовательские классы, для возможжности итерации по ним в стандартных конструкциях циклов, должны определять метод `.__iter__()`.
- удалять элементы из списка при итерации по нему же - плохая идея. Либо в два прохода (сначала найти элементы для удаления), либо итерировать по клону (`for name in names[:]:`)
- литерал словаря `{'<key>': <value>}`, конструктор `dict()`. С версии 3.6 ключи сортируются по порядку вставки. Обращение к элементу - квадратные скобки (`a['<key>']`), к несуществующему - исключение. Или использовать `.get('<key>'[, <default-value>])`, оно просто возвращает `None`
- наличие ключа - оператор `in`, для пользовательских классов - метод `.__contains__()`
- метод словаря `.setdefault('<key>', <val>)` устанавливает значение по ключу, если ключа нет. И возвращает текущее, если есть. В примере из книги используется для подсчета кол-ва вхождений в (другом) списке, в виде словаря ключ-<число-вхождений>. Но есть и `import collections; count = collections.Counter([...])`, который строит такой же словарь частот
- есть класс `from collections import defaultdict; <var> = defaultdict(<factory>)` (где, напр., `<factory> == list`), вставляющий значение по умолчанию для этой фабрики каждый раз, когда при обращении (напр., через квадратные скобки) отсутствует ключ
- удаление из словаря - оператор `del`. Удалять при переборе словаря нельзя, ошибка `RuntimeError: dictionary changed size during iteration`
- `for <key> in {...}:` перебирает ключи, `for <value> in {...}.values():` - значения, а `for <key>, <value> in {...}.items():` - оба одновременно (`list(data.items())` возвращает список кортежей, так же как `Object.entries()` в JS)
- сортировка словаря по ключам - `sorted(data.keys()[, reverse=True])`. Разнотипные ключи допустимы, хотя это и плохая практика
- функции определяюют новую область видимости, области уровня блока вроде нет. Порядок замещения имен в областях: локальная -> глобальная -> встроенная. Функции `locals()` и `globals()` возвращают словари, со всеми определенными в соответсвующей области именами в качестве ключей
- параметры по умолчанию в функциях стандартно, последними, через равно. Изменяемые типы в качестве параметров по умолчанию (напр., `a=[]`) создаются один раз, в момент генерации функции, и будут меняться каждый раз при вызове (напр., `a.append(<el>)`), так что лучше их избегать (или сделать `a=None`, а уже в функции проверять и присваивать пустой список)
- запись `if` в одну строку: `default = default if default is not None else []` (имитация тернарного оператора)
- имена функций (по PEP8) должны следовать тем же соглашениям, что и имена переменных: нижний регистр, подчеркивания, не должны начинаться с цифр и не должны совпадать с ключевыми словами и именами встроенных функций
- цитата: `"...Правильный подход [к отрицательному индексированию] — интерпретировать a[-X] как a[len(a)-X]"`
- поддержка индексирования пользовательскими классами: `.__getitem__()`
- в срезах нулевой индекс идет по умолчанию, его лучше опускать: `[0:4]` == `[:4]`. Если опущен правый индекс, то срез распространяется до конца списка
- третий параметр срезов - приращение (`[::3]`) - имеет аналог и в диапазонах: `range(0, 7, 3)`. Обращение строки: `'emerih'[::-1] == 'hireme'`
- открыть файл - встроенная функция `open()` с кучей параметров (лучше юзать именованные). Для литералов с обратными слешами (пути в Windows) можно использовать r-строки (`r"C:\test"`). Дефолтный режим - чтение как текстового файла (`r`), можно еще открывать как бинарный (`rb`/`wb`)
- стандартные имена переменных в зависимости от режима: `fin|fout|fp = open(...)` (`fin` (file input), `fout` (file output), `fp` (file pointer - для ввода-вывода))
- `.readline()` читает одну строку, `.readlines()` вычитывает все в список, `.read()` весь контент разом. `.close()` закрывает файл. Для чтения бинарных файлов можно указывать кол-во байт в `.read(8)`
- т.к. `.readlines()` читает всё разом, в циклах лучше ее не использовать, а итерировать по самому объекту: `for line in open(...):`. Метод `.__iter__()` будет читать  строки последовательно
- для записи есть методы `fout.write('...')` и `fout.writelines([...])`. Метод `.flush()` физически производит запись, он вызывается и в `.close()`
- `with open(...) as fout:` работает совместно с *менеджерами контекста* (?) и закрывает файл автоматом по выходу из блока
- строки в Питоне по умолчанию в Юникоде, его символы можно записывать через `'x\u00b2'` или `N{SUPERSCRIPT TWO}`. Раздел хелпа: ``>>>help(); >UNICODE``
- перекодирование строк - метод `'...'.encode('ascii')`, опционально параметр `errors='ignore'` подавляет ошибку `UnicodeEncodeError` (невозможно перекодировать, символ(ы) не поддерживаются), и `errors='replace` - замена неизвестных символов вопросительными знаками. Переводит в что-то типа `b'x\xc2\xb2'`. Обратно - метод `'...'.decode('utf-8')`, параметр подавления ошибок тот же
- текущая кодирока по умолчанию: `import locale; locale.getpreferredencoding(False)`, у меня UTF-8. В ней же читаются и файлы, но в `open()` можно и явно передавать `encoding='cp949'`. Словечко *модзибакэ* - искажение символов, видимо аналог нашего "кракозябры"
- у любого объекта (то есть всего) в Питоне есть поле `.__class__`
- константы могут определяться в классах (`max_occupants = 4`, это статическая переменная???), строка в тройных кавычках после `class ...:` - его документация, методы в декларации первым параметром имеют `self`. Имена классов по PEP8 - в "верблюжьем" регистре (`SnowLeopard`). Конструктор - `__init__`
- имена членов класса уже могут совпадать с именами встроенных функций, перекрывать не будут. Классы создаются в `__main__.Chair`
- создание экземпляра класса - без `new`: `chair = Chair(21)`. Фактическое состояние экземпляра (объекта) хранится в его поле `__dict__` (`chair.__dict__ == {'count': 3, 'id': 21}`). Приватных методов нет, только по соглашению об именах начинаются с (одного) подчеркивания
- базовые классы - в круглых скобках после имени (`class StallChair(CorrectChair):`), хранятся кортежем в свойстве `.__bases__`, `super()` без аргументов - вызов родительских методов, корректно разрешает множественное наследование (как?)
- стили проверок "LBYL (Look Before You Leap)" - сначала проверка, потом действие, и "EAFP (Easier to Ask for Forgiveness than Permission)" - действие в блоке `try/except`. LBYL тоже не гарантирует успеха, напр., в случае гонки в многопоточном коде изменения могут произойти после проверки до действия. Блок перехвата в Python называется `except`, не catch: `try: ... except ZeroDivisionError as e: ...`
- блоков `except` может быть несколько, просто идут на новых строках: `except ZeroDivisionError as e: ... except Exception as e:`, общий тип последним. Можно указать кортеж типов: `except (TypeError, ValueError):`
- секция `finally` в `try/except` выполняется всегда, `else` должна идти перед `finally`, и выполняется только если исключений не было
- ручной выброс - `raise <ExcClass>("text")`, `raise` в блоке `except` можно вызывать без аргумента (re-throw). Можно на лету изменить тип исключения (`from`): `raise ArithmeticError() from ex`, `... from None` - подавление исходного исключения (оба случая типа для сохранения/обнуления стека вызовов?)
- несколько десятков классов исключений, можно от них наследоваться и задавать свои классы
- два типа импорта: `import <module>` `from <module> import <func>`. Можно перечислять функции в круглых скобках: `from math import (sin, cos)`, иначе нужен обратный слеш для переноса на новую строку. Алиасы через `as` можно назначать как функциям, так и модулю. Массовое импортирование `from math import *` загромождает глобальное пространство имен и не рекомендовано
- импорт вложенных библиотек: `import xml.etree.ElementTree; elem = xml.etree.ElementTree.XML(...)`. Группировать импорты по PEP8 нужно в порядке: 1. из стандартной библиотеки, 2. из стороннего кода, 3. из локальных пакетов. Группы этих импортов отделять пустыми строками, а внутри группы располагать по алфавиту. Импорты можно и отложить до точки использования, не обязательно их располагать в начале скрипта
- модуль - файл с расширением `.py`, пакет - каталог, содержащий файл `__init__.py`, может содержать произвольное кол-во модулей и/или субпакетов. По PEP8 имена обоих должны быть короткими и записываться в нижнем регистре. В именах пакетов недопустимы подчеркивания
- импортировать пакеты можно так же, директивой `import`. И модули и пакеты для импорта должны находится в переменной среды `PYTHONPATH` или переменной языка `sys.path` (список путей). Изменять обе переменные не рекомендуется (это может сбить с толку других разработчиков), разве что для использования еще не установленных библиотек. Нормальньй же путь - установить библиотеку, тогда она автоматом попадет в пути. Посмотреть, где физически расположен файл импортированной библиотеки, можно через ее аттрибут `__file__`: `import json; json.__file__` (работает только для библиотек, реализованных на Python (с `sys`, например, не сработает))
- модуль `argparse` из стандартной библиотеки используется для раззбора аргументов командной строки
- `if __name__ == '__main__'` - используется ли модуль как сценарий
- в строку документации (напр., модуля) можно включить примеры в формате REPL. Строки должны начинаться с `>>>`. Тогда можно использовать библиотеку `doctest` для их выполнения. В книге дан пример теста скрипта самого себя: `args.run_tests: \n\t import doctest; doctest.testmod()` - если скрипту передан параметр `--run-tests`, он тестирует примеры из своей документации
- порядок объявлений в модуле: shebang, строка документации, сгруппированные импорты, глобальные переменные, реализация (вынесенная в функцию `main()`), тестирование, (в самом конце) `if __name__ == '__main__': \n\t sys.exit(main(sys.argv[1:]) or 0)`. Глобальные переменные ограничить, разве что для эмуляции констант (такие, по PEP8, писать все в верхнем регистре) и метаданных модуля. По PEP396 это: `__author__`, `__date__`, `__contact__`, `__version__`
- в приложении Б разные полезные ссылки [p.267]
