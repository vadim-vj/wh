# ООП и SOLID, `[oop-solid]`

- <https://github.com/heykarimoff/solid.python>
- <https://blog.byndyu.ru/2009/10/solid.html>

- паттерн "Фасад", когда применяется
- паттерн "Выделение частного класса данных"
- паттерн "Proxy"
- Data Access Object (DAO)
- God object
- GRASP
- Separation of Concerns
- Chain of responsibility

---
> Что такое *SOLID*?

Акроним, означающий 5 основных принципов ООП и проектирования:

- *принцип единственной ответственности* (SRP, single responsibility principle)
- *принцип открытости/закрытости* (OCP, open–closed principle)
- *принцип подстановки Лисков* (LSP, Liskov substitution principle)
- *принцип разделения интерфейса* (ISP, interface segregation principle)
- *принцип инверсии зависимостей* (DIP, dependency inversion principle)

---
> Что означает *S* в SOLID?

*Принцип единственной ответственности*, SRP (single responsibility principle) - каждый класс должен иметь одну ответственность. Как писал Мартин, "классы должны иметь одну и только одну причину для изменений".

---
> Приведите примеры нарушения SRP

- класс отчета, имеющий как методы составления отчета (`.get{Header|Data|Footer}()`), так и методы его отображения (`.to{Print|HTML|XML}()`)
- класс модели, который имеет как геттеры/сеттеры, так и методы работы с базой данных

Вообще, чаще всего приводят примеры смешения бизнес-логики и работы с БД.

---
> Какой принцип ООП, как считается, нарушает паттерн ActiveRecord?

SRP, принцип единственной ответственности. Класс ActiveRecord содержит как логику работы с данными (геттеры/сеттеры), так и работу с БД (чтение/запись).

Вообще, нарушение этим паттерном SR-принципа считается спорным: как сам по себе объект, реализующий ActiveRecord, не содержащий никакой бизнес логики, а предоставляющий таблицу из базы данных, имеет лишь одну причину для изменения (изменение таблицы).

---
> Как можно разрешить нарушения SRP в классе?

Например, используя паттерн "Фасад":

```python
class Animal:
    def __init__(self, name: str):
        self.name = name
        self.db = AnimalDB()

    def get_name(self):
        return self.name

    def get(self, id):
        return self.db.get_animal(id)

    def save(self):
        self.db.save(animal=self)
```

Все методы сохранены, но логика работы с БД теперь в другом классе, а текущий служит лишь фасадом для вызовов методов этого другого.

---
> Что означает *O* в SOLID?

*Принцип открытости/закрытости*, OCP (open–closed principle) - программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Фактически, призывает к расширению классов только через наследование.

---
> Приведите примеры нарушения OCP

Это всегда оставление деталей реализации в коде. Например, группы `if`-ов/`case`-ов:

```python
def animal_sound(animal):
    if animal.name == 'lion':
        print('roar')
    elif animal.name == 'mouse':
       print('squeak')
```

Расширит такую функцию, не вмешиваясь в код, нельзя. Или

```cpp
public function doSomeWork() {
  return (new Server())->run();
}
```

Заменить сервер, не изменяя код клиента, здесь нельзя.

---
> Как можно разрешить нарушения OCP?

Вынесение деталей реализации в отдельные параметры/методы. Например, в параметры конструктора. Или отдельные методы, которые можно перекрыть в дочернем классе, изменив, таким образом, поведение.

```python
class Lion(Animal):
    def make_sound(self):
        return 'roar'

def animal_sound(animal):
    print(animal.make_sound())
```

---
> Что означает *L* в SOLID?

*Принцип подстановки Лисков*, LSP (Liskov substitution principle) - функции, которые используют базовый тип, должны иметь возможность использовать его подтипы, не зная об этом. По сути, на место объекта базового класса должно быть всегда можно подставить объект производного.

---
> Приведите примеры нарушения LSP

Это использование специфических методов (с проверкой или без) производных классов в контексте, где предполагается объект базового типа:

```python
def animal_leg_count(animal: Animal):
    if isinstance(animal, Lion):
        print(lion_leg_count(animal))
    elif isinstance(animal, Mouse):
        print(mouse_leg_count(animal))
    elif isinstance(animal, Pigeon):
        print(pigeon_leg_count(animal))
```

Более тонкие моменты - когда наследуемый класс так переопределяет поведение базового, что это приведет к ошибке бизнес-логики в вызывающей функции:

```python
def animal_leg_count(animal: Animal):
    assert animal.leg_count == 4
```

То есть при наследовании нужно учитывать, где используется интерфейс класса, и не сломает ли переопределение это использование.

---
> Как связаны OCP и LSP?

Это, в основном, касается примера с "лапшей" `if`-ов, проверяющих тип:

```cpp
public void Save(AbstractEntity entity) {
  if (entity is AccountEntity) {
    // специфические действия для AccountEntity
  }
  if (entity is RoleEntity) {
    // специфические действия для RoleEntity
  }
}
```

Добавление нового типа требует вмешательства в код класса - это нарушение OCP. В то же время, метод оперирует специфическими для дочерних классов методами, что является нарушением LSP.

---
> Что означает *I* в SOLID?

*Принцип разделения интерфейса*, ISP (interface segregation principle) - клиенты не должны зависеть от методов, которые они не используют. Слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические.

---
> Приведите примеры нарушения ISP

Основное - это абстрактные методы в базовом классе, которые требуют переопределения в дочерних. Если интерфейс базового класса слишком "широкий", то дочерние классы будут вынуждены переопределять ненужные им методы:

```python
class IBaseShape:
    def draw_square(self):
        raise NotImplementedError

    def draw_rectangle(self):
        raise NotImplementedError

    def draw_circle(self):
        raise NotImplementedError
```

В Python-е принцип актуален только при использовании `@abc.abstractmethod`, то есть только тогда, когда класс *обязан* определить тело абстрактного метода.

---
> Что означает *D* в SOLID?

*Принцип инверсии зависимостей*, DIP, (dependency inversion principle):

- модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракции
- абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

---
> Приведите примеры нарушения DIP

Зависимость класса/модуля от конкретного класса более низкого уровня:

```python
# модуль нижнего уровня
class XMLHttpService:
    pass

# модуль верхнего уровня
class Http:
    def __init__(self, xml_http_service: XMLHttpService):
        ...
```

Жесткая зависимость от конкретного (низкоуровнего) класса не позволяет заменить его на другой / протестировать с заглушкой.

---
> Как можно разрешить нарушения DIP в классе?

Ввести дополнительный уровень косвенности - абстракцию, от которой будут зависеть модули и верхнего, и нижнего уровней. Промежуточное звено - базовый класс:

```python
# новая абстракция
class Connection:
    pass

# модуль нижнего уровня
class XMLHttpService(Connection):
    pass

# модуль верхнего уровня
class Http:
    def __init__(self, http_connection: Connection):
        ...
```

Теперь от этой новой абстракции можно наследовать любые классы, и свободно использовать их в модуле верхнего уровня (по LSP).

---

# Задачи, `[problems]`

---
> Напишите функцию, возвращающую все простые числа до `n`

Важно вести проверку до квадратного корня включительно (`int(i ** .5) + 1`) - напр., `25` делится на свой корень `5`, и если перебор до него не дойдет, число будет признано простым:

```python
def get_primes(n):
    for i in range(3, n + 1, 2):
        for j in range(3, int(i ** .5) + 1, 2):
            if not i % j:
                break
        else:
            yield i

assert list(get_primes(20)) == [3, 5, 7, 11, 13, 17, 19]
```

В обоих циклах, для улучшения производительности, перебор ведется только по нечетным числам - с шагом `2`. Т.к. все числа внешнего цикла нечетные, проверять их делимость на `2` не нужно.

---
> Напишите функцию, проверяющую, является ли число простым

Тот же перебор делителей до квадратного корня включительно:

```python
def is_prime(n):
    for i in range(2, int(n ** .5) + 1):
        if not n % i:
            return False

    return True
```

---
> Напишите генератор первых `n` чисел Фибоначчи

```python
def get_fibonachi(n):
    a = b = 1

    for _ in range(n):
        yield a
        a, b = b, a + b

assert list(get_fibonachi(7)) == [1, 1, 2, 3, 5, 8, 13]
```

Для бесконечного генератора достаточно заменить цикл `for` на `while True:`.

---
> Сгенерируйте матрицу для задачи коммивояжера

Матрица симметрична - `m[i][j] == m[j][i]`: расстояние между городами не зависит от порядка в паре. Значения на главной диагонали равны нулю: один и тот же город.

```python
import random

n = 3
matrix = [[0.0]*n for _ in range(n)]

for i in range(n):
    for j in range(i):
        matrix[i][j] = matrix[j][i] = random.uniform(1, 30)
```

---
> Как вернуть 10 последних строк из текстового файла?

Используя двустороннюю очередь фиксированной длины:

```python
import collections

with open('/home/localhost/Downloads/data.txt') as f:
    collections.deque(f, 10)
```

Здесь итератор можно не перебирать вручную, а сразу отдать его конструктору очереди.

---
> Напишите функции для чисел и операций такие, чтобы выполнялось
> 
> ```python
> assert one(add(five())) == 6
> assert five(add(one())) == 6
> ```

Через каррирование:

```python
def num(val, f=None):
    return f(val) if f else val

def one(f=None):
    return num(1, f)

def five(f=None):
    return num(5, f)

def add(val):
    return lambda x: x + val
```

---
> Напишите жадный алгоритм решения задачи о банкомате с лимитами

При кратных номиналах купюр:

```python
class ATM:
    def __init__(self, banknotes):
        self.banknotes = banknotes

    def get(self, amount):
        result = {}

        for nom, avail in self.banknotes.items():
            fit = min(amount // nom, avail)

            if fit > 0:
                result[nom] = fit
                amount -= fit * nom

                if amount == 0:
                    break
        else:
            raise Exception("Can't handle amount")

        return result

atm = ATM({1000: 10, 500: 20, 100: 100})
assert atm.get(1800) == {1000: 1, 500: 1, 100: 3}
assert atm.get(1300) == {1000: 1, 100: 3}
```

---
> Как обратить строку, не используя "марсианский смайлик"?

Оптимизация хвостовой рекурсии:

```python
def reverse(txt):
    txt = list(txt)

    for i in range(len(txt) // 2):
        neg = len(txt) - 1 - i
        txt[i], txt[neg] = txt[neg], txt[i]

    return ''.join(txt)

assert reverse('Some text') == 'txet emoS'
```

Можно и без деления, а брать два индекса - `start = 0`/`stop = len(txt) - 1`, после чего последовательно их приближать:

```python
start, stop = start + 1, stop - 1
```

---
> Напишите алгоритм поиска *индексов* двух минимумов в списке

Помимо сортировки и поиска-удаления-поиска-вставки, можно их найти перебором:

```python
min1 = min2 = (0, float('inf'))
for i, val in enumerate(lst):
    if val < min1[1]:
        min2 = min1
        min1 = (i, val)

    elif val < min2[1]:
        min2 = (i, val)
```

Здесь важны:

- `elif`. Если вместо него будет просто `if`, то будут найдены два совпадающих элемента
- `float('inf')`. Если вместо него будет первый элемент-минимум, то будут получены два совпадающих индекса (`0`)

Чтобы различались не только позиции но и значения, нужно добавить условие:

```python
elif min1[1] < val < min2[1]:
```

---
> Дана последовательность чисел и некоторое число. Нужно переместить все числа в последовательности, совпадающие с этим числом, в конец, не изменяя порядок остальных элементов

```python
seq = [1, 0, 2, 1, 1, 0, 0, 0, 3]
last_neq = 0
val = 0

for i, v in enumerate(seq):
    if v != val:
        seq[i], seq[last_neq] = seq[last_neq], seq[i]
        last_neq += 1

assert seq == [1, 2, 1, 1, 3, 0, 0, 0, 0]
```

Здесь рассмотрен частный случай - нули, `val = 0`

После перемещения можно, например, удалить срез `seq[last_neq:]` - частный случай, задача об удалении всех элементов по значению

---
> Дан односвязный список
> 
> ```python
> class ListNode:
>     def __init__(self, val=0, next=None):
>         self.val = val
>         self.next = next
> ```
> 
> и некоторое число. Нужно удалить из списка все узлы, чье значение совпадает с этим числом

Удаление из односвязного списка трудоемко, т.к. нужно замыкать предыдущий узел на следующий. Для единообразной работы с первым узлом переприсваиваем головной dummy-узел переменной `head`. Указатель `prev` либо замыкает элементы через один (при совпадении текущего значения), либо просто движется вперед. Проверки идут всегда для одного узла вперед (`prev.next`). Возвращаем `head.next`:

```python
head = ListNode(1, ListNode(2, ListNode(1)))
val = 1

head = prev = ListNode(None, head)

while prev.next:
    if prev.next.val == val:
        prev.next = prev.next.next
    else:
        prev = prev.next

assert head.next.val == 2
```

---
> Дан массив целых чисел и отдельное число. Найти индексы двух элементов, чья сумма равна этому числу

Решение с линейной сложностью и доп. памятью `O(n)`. В словарь пишутся сами значения - они будут "недостающей до суммы частью":

```python
nums = [...]
val = 5

rev_map = {}
for i, v in enumerate(nums):
    diff = val - v

    if diff in rev_map:
        answer = rev_map[diff], i
        break
    else:
        rev_map[v] = i
```

---
> Дано знаковое целое число, нужно обратить порядок его цифр

По условию задачи требуется контроль переполнения:

```python
limit = 2 ** 31
x = int(('-' if x < 0 else '') + str(abs(x))[::-1])

x = x if -limit <= x < limit else 0
```

---
> Проверить, что целое число является палиндромом

```python
assert str(x) == str(x)[::-1]
```

---
> Дан массив строк. Найти их наибольший префикс

Вспомогательная функция-генератор нужна для вычисления наибольшей общей подстроки. Вычисления идут за линейное время:

```python
arr = ['cir', 'car']  # ['flower', 'flow', 'flight']
prefix = arr[0]

def prefix_gen(str1, str2):
    for a, b in zip(str1, str2):
        if a != b: break
        yield a

for string in arr:
    prefix = prefix_gen(prefix, string)

assert ''.join(prefix) == 'c'
#assert ''.join(prefix) == 'fl'
```

---
> Дана строка, состоящая из трех видов скобок. Проверить ее корректность - что число открывающих скобок равно числу закрывающих

Через стек и вспомогательный словарь символов:

```python
stack = []
brackets = {
    '(': ')',
    '[': ']',
    '{': '}',
}

for char in s:
    if char in brackets:
        stack.append(char)

    elif not stack or char != brackets[stack.pop()]:
        answer = False
        break
else:
    answer = not stack
```

Важное краевое условие - `not stack or` в `elif`. Без него, при большем количестве закрывающих скобок, будет выбрасываться ошибка `IndexError: pop from empty list`

---
> Даны два упорядоченных списка (массива). Вернуть результат их слияния - тоже упорядоченный список (массив)

```python
result = []

while nums1 or nums2:
    if nums1 and nums2:
        lst = nums1 if nums1[0] < nums2[0] else nums2
    else:
        lst = nums1 if nums1 else nums2

    result.append(lst.pop(0))
```

---
> Даны два упорядоченных односвязных списка. Вернуть результат их слияния - тоже упорядоченный список

Стандартно для списков - сохраняем dummy-узлы для головы и временного указателя. Алгоритм аналогичен слиянию упорядоченных массивов, но т.к. тут идет переприсваивание переменных, воспользоваться временной ссылкой мы не можем:

```python
head = result = ListNode()

while l1 or l2:
    if l1 and l2:
        if l1.val > l2.val:
            result.next = l2
            l2 = l2.next
        else:
            result.next = l1
            l1 = l1.next

    elif l1:
        result.next = l1
        l1 = l1.next

    else:
        result.next = l2
        l2 = l2.next

    result = result.next
```

---
> Дан сортированный массив чисел. Удалить дубликаты in-place

Удаление целиком срезами. Обработка справа налево: так индексы не "прыгают", и удаление сдвигает меньшие части вектора:

```python
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]

start = len(nums) - 1
end = start - 1

while end >= -1:
    if end <= -1 or nums[start] != nums[end]:
        if start - end > 1:
            del nums[end+2:start+1]

        start = end

    end -= 1

assert nums == [0, 1, 2, 3, 4]
```

Важным условием является равенство с `-1`: оно дает возможность обрабатывать последовательности дубликатов, соприкасающихся с краем

---
> FizzBuzz

```python
def fizzBuzz(self, n: int) -> List[str]:
    for i in range(1, n + 1):
        if i % 15 == 0:
            yield 'FizzBuzz'

        elif i % 3 == 0:
            yield 'Fizz'

        elif i % 5 == 0:
            yield 'Buzz'

        else:
            yield str(i)
```

---
> Дано целое число. Если на текущем шаге число четное, то делить его на 2, иначе вычитать единицу. За сколько шагов число будет сведено до нуля?

```python
num = 100

if num > 3:
    cnt = 0

    while num > 0:
        if num % 2 == 0:
            num /= 2
        else:
            num -= 1
        cnt += 1
else:
    cnt = num

assert cnt == 9
```

---
> Дан массив путей между городами, где наличие элемента `paths[i] = [cityAi, cityBi]` означает, что есть прямой путь между городами. Найдите город, *из* которого не исходит ни одного маршрута
> 
> ```python
> paths = [['London', 'New York'], ['New York', 'Lima'], ['Lima', 'Sao Paulo']]
> ```

Строим словарь "исходящий город"-"множество входящих". Выбираем город с пустым множеством:

```python
paths = [['London', 'New York'], ['New York', 'Lima'], ['Lima', 'Sao Paulo']]

cache = {}
for path in paths:
    for city in path:
        cache[city] = set()

    cache[path[0]].add(path[1])

dest = None
for top, to in cache.items():
    if not to:
        dest = top
        break

assert dest == 'Sao Paulo'
```

---
> Дана строка символов. Найти максимальной длины подстроку, состоящую из одного символа

Код аналогичен удалению дубликатов из массива:

```python
s = 'heed'

start = 0
end = start + 1
max_ = 0

while end <= len(s):
    if end == len(s) or s[start] != s[end]:
        if end - start > max_:
            max_ = end - start

        start = end

    end += 1

assert max_ == 2
```

---
> Дан массив чисел. Найти два *разных* индекса элементов таких, что их произведение максимально

Задача сводится к поиску двух максимумов:

```python
nums = [10, 2, 5, 2]

max1 = max2 = -float('inf')
for i, v in enumerate(nums):
    if v > max1:
        max2 = max1
        max1 = v
    elif v > max2:
        max2 = v

assert max1 * max2 == 50
```

Всё так же важны `elif` и `-float('inf')`.

---
> Напишите сортировку пузырьком

```python
nums = [10, 2, 5, 2]

for i in range(len(nums) - 1):
    for j in range(len(nums) - 1 - i):
        if nums[j] > nums[j+1]:
            nums[j], nums[j+1] = nums[j+1], nums[j]


assert nums == [2, 2, 5, 10]
```

Нерекурсивный алгоритм с квадратичной сложностью (два вложенных цикла).

---
> Напишите сортировку вставками

```python
for i in range(1, len(nums)):
    curr = nums[i]
    j = i

    while j > 0 and nums[j - 1] > curr:
        nums[j] = nums[j - 1]
        j -= 1

    nums[j] = curr
```

Нерекурсивный алгоритм с квадратичной сложностью (два вложенных цикла).

---
> Напишите сортировку слиянием

Здесь `merge()` - функция слияния двух сортированных списков:

```python
def sort(arr):
    if len(arr) == 1:
        return arr

    pivot = len(arr) // 2

    return merge(
        sort(arr[:pivot]),
        sort(arr[pivot:]),
    )
```

Рекурсивный алгоритм с логлинейной сложностью (слияние имеет линейную сложность, рекурсия делит массив данных на каждом шаге пополам - логарифм).

---
> Напишите быструю (хоаровскую) сортировку

```python
def sort(arr):
    if len(arr) <= 1:
        return arr

    parts = ([], [], [])
    pivot = arr[len(arr) // 2]

    for v in arr:
        if v < pivot:
            id = 0
        elif v > pivot:
            id = 2
        else:
            id = 1

        parts[id].append(v)

    return sort(parts[0]) + parts[1] + sort(parts[2])
```

Рекурсивный алгоритм с логлинейной сложностью (перебор списка на каждом шаге - линейное время + рекурсивное деление данных дает логарифм)

---
> Напишите *рекурсивную* функцию вычисления факториала

```python
def factorial(n):
    return 1 if n == 0 else n * factorial(n - 1)
```

---
> Напишите *нерекурсивную* функцию вычисления факториала

```python
def factorial(n):
    result = 1

    for i in range(1, n + 1):
        result *= i

    return result
```

---
> Приведите рекурсивный алгоритм отрисовки английской линейки

```python
def print_line(length, num=None):
    line = '-' * length
    if num is not None:
        line += ' ' + str(num)
    print(line)

def print_interval(length):
    if length > 0:
        print_interval(length - 1)
        print_line(length)
        print_interval(length - 1)

def print_ruler(count, length=4):
    print_line(length, 0)

    for num in range(1, count + 1):
        print_interval(length - 1)
        print_line(length, num)

print_ruler(3, 4)
```

---
> Напишите *рекурсивный* алгоритм бинарного поиска (возвращающий индекс)

Здесь `end` - это индекс последнего элемента, не элемента после последнего. Так нагляднее:

```python
def binary_search(arr, val, start=0, end=None):
    if end is None:
        end = len(arr) - 1

    if start > end:
        return None

    pivot = (end + start) // 2
    if arr[pivot] == val:
        return pivot

    if val > arr[pivot]:
        return binary_search(arr, val, pivot + 1, end)
    else:
        return binary_search(arr, val, start, pivot - 1)
```

`(end + start) // 2` - это результат преобразования выражения `start + (end - start) // 2`. В двух последних `return`-ах берутся точки (физические индексы) на единицу больше/меньше `pivot`, т.к. сам элемент под индексом `pivot` проверяется ранее на равенство.

---
> Напишите *нерекурсивный* алгоритм бинарного поиска (возвращающий индекс)

```python
def binary_search(arr, val, start=0, end=None):
    if end is None:
        end = len(arr) - 1

    while start <= end:
        pivot = (end + start) // 2

        if arr[pivot] == val:
            return pivot

        if val > arr[pivot]:
            start = pivot + 1
        else:
            end = pivot - 1

    return None
```

Это элиминация хвостовой рекурсии.

---
> За какое время выполняется бинарный поиск?

За логарифмическое, там только деление пополам на каждом шаге.

---
> Напишите функцию, рекурсивно подсчитывающую размер файлов и каталогов

`print()` здесь выводит trace - информацию по каждому файлу/каталогу:

```python
import os

def disk_usage(path):
    total = os.path.getsize(path)

    if os.path.isdir(path):
        for filename in os.listdir(path):
            total += disk_usage(os.path.join(path, filename))

    print (f'{total:<10}', path)

    return total
```

`getsize()` можно обрамить в `try`/`except`: так он не будет падать, например, на битых символических ссылках.

---
> Какая сложность у функции вычисления факториала?

У обеих версий - рекурсивной и через цикл - сложность `O(n)`.

---
> Какая сложность у обхода дерева (tree traversal)?

Линейная, `O(n)` - количество рекурсивных вызовов равно числу узлов. Такую сложность имеет, например, алгоритм подсчета занимаемого файлами и каталогами пространства на файловой системе.

---
> Напишите экспоненциальный рекурсивный алгоритм вычисления `n`-ного числа Фибоначи

```python
def bad_fibonacci(n):
    return n if n <= 1 else bad_fibonacci(n-1) + bad_fibonacci(n-2)
```

Каждый рекурсивный вызов порождает еще два, что дает экспоненциальную итоговую сложность `O(2^n)`.

---
> Напишите линейный рекурсивный алгоритм вычисления `n`-ного числа Фибоначи

Вычисления с пред. шага кешируются:

```python
def good_fibonacci(n):
    if n <= 1:
        return (n, 0)
    else:
        (a, b) = good_fibonacci(n - 1)
        return (a + b, a)
```

Сложность `O(n)`.

---
> Что называется *линейной рекурсией*?

Такая, при которой каждый вызов порождает только один рекурсивный вызов.

Термин не имеет отношения к вычислительной сложности. Так, например, и бинарный поиск и вычисление факториала - это линейная рекурсия, но первый имеет сложность `O(logN)`, а второй `O(N)`.

---
> Напишите функцию рекурсивного суммирования последовательности с одним рекурсивным вызовом. Какая у нее сложность?

```python
def sum_rec(nums):
    return 0 if len(nums) == 0 else sum_rec(nums[:-1]) + nums[-1]
```

Сложность линейная, `O(n)` - это линейная рекурсия, порождающая по одному вызову на каждом шаге.

---
> Напишите функцию рекурсивного суммирования последовательности с двумя рекурсивными вызовом. Какая у нее сложность?

Здесь, вместо сложения с последним элементом, идет деление пополам:

```python
def sum_rec(nums):
    if len(nums) == 0:
        return 0

    if len(nums) == 1:
        return nums[0]

    pivot = len(nums) // 2
    return sum_rec(nums[:pivot]) + sum_rec(nums[pivot:])
```

Несмотря на деление пополам, временная сложность всё так же `O(n)`, хотя пространственная и уменьшается до `O(logN)` (?).

---
> Напишите функцию рекурсивного обращения последовательности. Какая у нее сложность?

Здесь `start` и `end` - физические индексы:

```python
def reverse(nums, start=0, end=None):
    if end is None: end = len(nums) - 1

    if start < end:
        nums[start], nums[end] = nums[end], nums[start]
        reverse(nums, start + 1, end - 1)
```

Сложность линейная, `O(n)` - это линейная рекурсия.

---
> Напишите рекурсивный алгоритм проверки, что строка является палиндромом

```python
def is_palindrome(string):
    if len(string) <= 1:
        return True

    if string[0] != string[-1]:
        return False

    return is_palindrome(string[1:-1])
```

---
> Напишите рекурсивный алгоритм вычисления степени за линейное время

Простейший случай, похож на факториал:

```python
def power(n, m):
    if m <= 0:
        return 1

    return n * power(n, m-1)
```

Каждый вызов порождает только один рекурсивный вызов - рекурсия линейная.

---
> Напишите рекурсивный алгоритм вычисления степени за логарифмическое время

Метод базируется на идее, что можно один раз рекурсивно высчитать степень от `n/2`, после чего умножить на себя. Это сократит кол-во рекурсивных вызовов.

Кроме того, требуется проверять число на четность, т.к. `2^13 = 2 * 2^6 * 2^6`, но `2^12 = 2 * 2^6 * 2^6`:

```python
def power(n, m):
    if m <= 0:
        return 1

    result = power(n, m // 2)
    result *= result

    if m % 2:
        result *= n

    return result
```

Несмотря на то, что это линейная рекурсия (на каждом шаге порождается ровно один вызов), сложность алгоритма `O(logN)`.

---
> Является ли рекурсия в вычислении факториала хвостовой?

Нет, не является. После рекурсивного вызова выполняется еще и умножение, так что он не последний:

```python
n * factorial(n - 1)
```

А вот в алгоритме бинарного поиска рекурсия хвостовая.

---
> Что такое *структуры данных* (DS)?

Это способ представления и организации данных в памяти компьютера. Структура данных используются для представления ADT.

---
> Что такое *абстрактные типы данных* (ADTs)?

Это математическая модель типа с набором операций, определенных в рамках этой модели.

ADT лишь описывает, какие операции допустимы для данного типа. То, как они выполняются на низком уровне, описывается уже в DS.

---
> Какие есть два основных типа структур данных?

- *последовательные* - данные хранятся в памяти непрерывно. Это (динамические) массивы и частично хеш-таблицы
- *основанные на указателях* - данные хранятся в памяти произвольно. Это связанные списки, и графы/деревья

---
> Перечислите основные структуры данных

- *массив*
- *динамический массив* (вектор)
- *(дву)связные списки*
- *графы*, *деревья*, основанные на деревьях *кучи*
- *хеш-таблица*

---
> Перечислите основные ADT

- *строка*, *кортеж* (списки фиксированной длины)
- (сортированный) *список*
- *стек*
- (двусторонняя) *очередь*, *очередь с приоритетом*
- *множество*
- *словарь* (*отображение*)

---
> Какая сложность у операций доступа в последовательных DS?

Константная, `O(1)`. Доступ к RAM осуществляется по адресу, это единичная операция.

---
> Как Python хранит массивы объектов?

Как массивы ссылок. Сами объекты хранятся разрозненно в куче, а (непрерывный) массив состоит из 64-битных ссылок (указателей) на эти объекты.

Поверхностное копирование, таким образом, создает копии непрерывных в памяти массивов ссылок, не затрагивая сами объекты. Для копирования и самих объектов вместе со ссылками на них нужно использовать `copy.deepcopy()`.

---
> Приведите код DS *массив*

На базовом уровне это массив из `ctypes`:

```python
(capacity * ctypes.py_object)()
```

Можно обернуть в класс, храня при этом размер:

```python
import ctypes

class Array:
    def __init__(self, length):
        self._length = length
        self._array = (self._length * ctypes.py_object)()

    def __len__(self):
        return self._length

    def __getitem__(self, index):
        return self._array[index]

    def __setitem__(self, index, value):
        self._array[index] = value
```

---
> Как удалить элемент из DS "массив"?

Никак, массив имеет фиксированный размер, задаваемый при создании, и меняться в рантайме (в том числе, через удаление элементов), он не может.

---
> Какая сложность у операций работы с DS "массив"?

Константная для доступа (и на чтение, и на запись) элемента: `O(1)`.

Операции вставки/удаления для этой структуры недоступны.

---
> Какие три основные поля содержит класс DS "динамический массив"?

- сам низкоуровневый массив, `._array: ctype.py_objects[]`
- текущая емкость массива: `._capacity: int`
- актуальная длина массива: `._length: int`

---
> Приведите код DS *динамический массив* (вектор), только сигнатуры методов. В чем основные отличия от массива фиксированной длины?

- три метода - `.__len__()`, `.__getitem__()` и `.__setitem__()` - совпадают с таковыми у статического массива
- метод `.__init__()` же уже не получает параметр-длину, она первоначально задается нулевой
- добавляются методы `.insert()`, `.append()`, и `.__delitem__()` - вставка в середину, в конец, и удаление элемента
- два новых служебных метода нужны для изменения размеров массива

```python
import ctypes

class DynamicArray:
    def __init__(self):

    def __len__(self):
    def __getitem__(self, index):
    def __setitem__(self, index, value):

    def insert(self, index, value):
    def append(self, value):
    def __delitem__(self, index):

    def _resize(self):
    def _make_array(self, capacity):
```

В принципе, можно создать класс через композицию - сделать внутреннее свойство `self._array` типа `Array`, и переадресовывать запросы этому классу.

---
> Приведите код метод `.__init__()` для DS "динамический массив"

Начальная длина задается нулевой, а емкость какой-либо произвольной, напр., `1`:

```python
def __init__(self):
    self._length = 0
    self._capacity = 1
    self._array = self._make_array(self._capacity)
```

Стоит обратить внимание, что в отличие от статического массива длина не передается в параметрах, конструктор вообще не получает аргументов:

```python
a = DynamicArray()
```

---
> Чем отличается код метода `.__getitem__()` для DS статический и динамический массивы?

В динамическом массиве, из-за сдвигов при удалении элементов (да и вообще), за границей `self._length` могут остаться неактуальные значения. Поэтому нужно дополнительно проверять выход за границы:

```python
class DynamicArray:
    def __getitem__(self, index):
        if not 0 <= index < self._length:
            raise IndexError

        return self._array[index]
```

---
> Приведите код метод `._make_array(self, capacity)` для DS "динамический массив"

Это просто генерация `ctypes`-массива фиксированной длины:

```python
def _make_array(self, capacity):
    return (capacity * ctypes.py_object)()
```

Происходит при каждом изменении размера вектора, когда она необходима при вставке/добавлении/удалении элемента. Также массив генерируется при создании объекта. Таким образом, у метода две точки вызова: из `._resize()` и из `.__init__()`.

---
> Приведите код метод `._resize()` для DS "динамический массив"

Генерация массива новой (большей) длины + копирование в него элементов + переприсваивание с заданием новой емкости:

```python
def _resize(self):
    if self._length < self._capacity:
        return

    self._capacity *= 2
    tmp = self._make_array(capacity)

    for index in range(self._length):
        tmp[index] = self[index]

    self._array = tmp
    self._capacity = capacity
```

Ресайз условный: если еще есть место в массиве, то ничего не делать. Здесь же происходит и выбор стратегии аллоцирования. Вызов (безусловный) происходит в методах `.insert()`/`.append()`.

---
> Приведите код метод `.append()` для DS "динамический массив"

Это просто вставка элемента в позицию за последним элементом:

```python
def append(self, value):
    self.insert(self._length, value)
```

Сдвига элементов при этом, разумеется, не происходит: диапазон `range(index, self._length - 1)` в `.insert()` пустой.

---
> Приведите код метод `.insert()` для DS "динамический массив"

(Возможное) изменение размера массива, сдвиг всех элементов, начиная с текущего, на одну позицию вправо, увеличение длины + присваивание:

```python
def insert(self, index, value):
    self._resize()

    for i in range(self._length, index, -1):
        self[i] = self[i - 1]

    self._length += 1
    self[index] = value
```

Необходимость изменения емкости массива (как и само это изменение) происходит в `._resize()`. Два важных момента:

- сдвиг, в отличие от `.__delitem__()`, идет вправо, с отрицательным шагом (иначе будут перетираться элементы)
- изменение длины идет до присваивания, на случай возможных проверок индекса в `.__setitem__()`

---
> Приведите код метод `.__delitem__()` для DS "динамический массив"

Сдвиг влево + уменьшение длины:

```python
def __delitem__(self, index):
    for i in range(index, self._length - 1):
        self[i] = self[i + 1]

    self._length -= 1
```

---
> От чего зависить амортизированная сложность вставки элемента в конец динамического массива?

От аллокатора, от того, какую стратегию увеличения размера вектора он использует:

- для арифметической прогрессии - увеличения всегда на константу - сложность будет квадратичная, `O(n^2)`
- для геометрической прогрессии - увеличения всегда в `N` раз (напр., вдвое) - константная, `O((n + 1 + 1 + ...)/(n + 1)) ~ O(2n/n) = O(1)`

В последнем случае имеется в виду, что вставка `n` элементов требует `n + 1` операций (знаменатель). Суммарная их сложность - `O(n)` на однократное увеличение длины + `n` операций сложности `O(1)` на вставку `n` элементов. Итого, амортизированная (средняя) сложность равна отношению и константна.

---
> Как отличить хвостовой узел связного списка (`tail`)?

Его указатель на следующий элемент равен `None`

---
> Как отличить головной узел связного списка (`head`)?

Никак, на него нужно хранить отдельный указатель

---
> Сколько указателей на узлы связного списка нужно хранить отдельно?

Достаточно одного - `head`: достичь конечного узла можно и последовательным перебором. Но обычно, для удобства, хранят и `tail`.

---
> Как можно организовать класс - связанный список?

Можно сделать два отдельных класса - `Node` и `List`. Второй может хранить, например, ссылки на `head`/`tail`, а также количество узлов в списке `.size`.

---
> Напишите класс - *узел связанного списка* (`Node`)

Т.к. узлов может быть очень много, для экономии памяти используется `.__slots__`:

```python
class Node:
    __slots__ = 'val', 'next'

    def __init__(self, val, next):
        self.val = val
        self.next = next
```

---
> Напишите класс - *связанный список* (`List`)

Он хранит два указателя - `head`/`tail`, и размер. Методы для вставки узла в произвольную позицию и в начало:

```python
class List:
    def __init__(self):
        self.head = self.tail = None
        self.size = 0

    def __len__(self):
        return self.size

    def insert(self, node: Node, after: Node):
        next = after.next
        after.next = node
        node.next = next

        self.size += 1

    def insert_at_head(self, node: Node):
        self.insert(node, self.head)
```

---
> Как можно через кортеж представить DS "связанный список"

Храня значение узла в первом элементе кортежа, а следующий узел - во втором:

```python
(3, (5, (7, None)))
```

С похожим синтаксисом список будет задаваться и через конструкторы класса, если конечно в сигнатуре конструктора идет пара `<val>, <next>`:

```python
Node(3, Node(5, Node(7)))
```

---
> Как можно через кортеж представить DS "бинарное дерево"

Храня значение узла в первом элементе кортежа, а левый/правый узел - во втором и третьем элементах соответственно:

```python
(3, (5, None, None), (7, None, None))
```

С похожим синтаксисом дерево будет задаваться и через конструкторы класса, если конечно в сигнатуре конструктора идет тройка `<val>, <left>, <right>`:

```python
Node(3, Node(5), Node(7))
```

---
> В чем отличие класса - узла двусвязного списка от обычного?

Добавляется указатель на предыдущий узел:

```python
class Node:
    __slots__ = 'val', 'next', 'prev'

    def __init__(self, val, next, prev):
        self.val = val
        self.next = next
        self.prev = prev
```

---
> Напишите метод вставки узла для двусвязного списка

По сравнению с односвязным списком добавятся две строки - замыкания `prev`-указателей:

```python
def insert(self, node: Node, after: Node):
    next = after.next

    after.next = node
    node.next = next

    next.prev = node
    node.prev = after

    self.size += 1
```

---
> Назовите три основных *последовательных* типа в Python

Это *строка*, *кортеж* и *список*. Первые два неизменяемы. Все они поддерживают доступ по индексу `[]`.

Это абстрактные типы, ADTs, и каждый основан на массиве.

---
> Почему ADT "кортеж" более эффективен по памяти, чем "список"?

Они построены на базе разных структур данных, на статическом и динамическом массивах соответственно. Статический массив не требует избыточной емкости, не хранит доп. поля и не выполняет лишние (для неизменяемого типа) операции.

---
> Какая у списка сложность доступа по индексу и вставки?

Список реализован на основе DS "динамический массив" ("вектор"), поэтому имеет константное время произвольного доступа, константное же время вставки в конец, и линейное - для вставки в начало/середину (`O(n - k + 1)`, если быть точным).

---
> Какая сложность у операций сравнения и поиска в строке/кортеже/списке?

Линейная, `O(n)` - производятся перебором по последовательности

Это касается всех операций:

- немутирующих методов `.count()` - `O(n)`, `.index()` - `O(k)`
- проверки принадлежности `x in [...]` - `O(k)`
- любого из операторов сравнения: `x <= y`, `x == y` и т.д. - `O(k)`
- получения срезов `x[i:j]` - `O(i-j)`, сложения `x + y` - `O(n1+n2)`, и умножения `c * x` - `O(c*n)`

Таким образом, `.index()` может быть быстрее `.count()`: он прекращает работу, как только элемент найден. Но в худшем случае их производительность одинакова

---
> Какая сложность у сортировки списка?

Логлинейная, `O(n*log(n))`

---
> Какая сложность у мутирующих операций на списке?

Константная `O(1)` для:

- присвоения `x[i] = val`
- вставки в конец `x.append(val)`
- получение элемента с конца `x.pop()`

Линейная для:

- вставки в начало/середину `x.insert()` - `O(n - k + 1)`
- удаления по индексу из начала/середины `x.pop(k)` - `O(n - k)`
- обращения `x.reverse()` - `O(n)`, расширения `x.extend(y)` - `O(n2)`

---
> Какая сложность у операции удаления из списка по значению?

Всегда линейная, `x.remove(val)` - `O(n)`. `O(k)` на поиск элемента + `O(n - k)` на сдвиг оставшихся элементов.

---
> Какую сложность имеют большинство методов строк?

Линейную, `O(n)`. Это вполне очевидно:

- методы вроде `.capitalize()`, `.strip()` и т.д. возвращают новую строку. Линейное время на копирование
- методы вроде `.islower()` тестируют всю строку. Линейное время (`O(n-k)`) на проход

---
> Какая сложность у наивной имплементации поиска подстроки в строке?

Квадратичная, `O(n*m)`: для каждого индекса строки длиной `n` нужно делать проверку подстроки длиной `m`. Такое выполняется для методов `.__contains__()`, `.find()`/`.index()`, `.count()`, `.replace()`, `.split()`

Однако существует алгоритм поиска за линейное время (?).

---
> Какую временную сложность имеет этот код?
> 
> ```python
> letters = ''
> for c in some_string:
>     letters += c
> ```

Т.к. строки неизменяемы, на каждом шаге происходит создание новой строки, длиной `1`, `2`, ..., `n`. Сумма ряда натуральных чисел дает квадратичную сложность, `O(n^2)`.

Поэтому собирать строку нужно через временный массив, это дает линейную сложность `O(n)`:

```python
temp = []
for c in some_string:
    temp.append(c)
letters = ''.join(temp)
# or
''.join(c in some_string if <cnd>)
```

---
> Как представить ADT "матрица"?

Как список списков:

```python
[
  [22, 18, 709, 5, 33],
  [45, 32, 830, 120, 750],
  [4, 880, 45, 66, 61],
]
```

Создавать такие списки через двойное умножение нельзя, нужно через комбинацию умножение + списковое включение:

```python
[[0]*m for _ in range(n)] == [[0, 0, 0], [0, 0, 0]]
```

---
> Какая сложность у операции получения длины списка?

Константная, `O(1)`: список не вычисляет ее, он ее хранит

---
> Почему операция доступа по индексу в строках/кортежах/списках в Python-е имеет константную сложность?

В основе всех этих абстрактных типов лежит DS "массив", у которого произвольный доступ идет за `O(1)`.

У `collections.deque`, основанной на DS "двусвязный список массивов", произвольный доступ (`[i]`) до элементов в середине может давать сложность `O(n)`.

---
> Что такое ADT *стек*?

Коллекция с двумя основными операциями, вставки и получения элемента - `.push(e)`/`.pop()`, которые работают по принципу LIFO (Last In First Out). Примеры: стопка тарелок в кафетерии, история браузера и кнопка "Назад", история команд текстового редактора и кнопка "Undo".

---
> Как может быть реализован ADT "стек"?

Как на основе (динамического) массива, так и на основе связного списка. В первом случае используется стандартный класс `list`, завернутый в класс (паттерн "Адаптер").

---
> Приведите код реализации ADT "стек" через массив

Простая обертка, "адаптер":

```python
class Stack:
    def __init__(self): self._data = []
    def __len__(self): return len(self._data)

    def is_empty(self): return len(self) == 0
    def top(self): return self._data[-1]

    def push(self, val): self._data.append(val)
    def pop(self): self._data.pop()
```

Можно определить свой класс исключения - `EmptyError`, проверять длину массива в `.is_empty()`/`.top()` и выбрасывать его (исключение) в случае необходимости (т.к. нативное исключение у `list` - это `IndexError`, а стек не поддерживает доступ по индексу).

---
> Какая сложность у операций в стеке?

У всех - вставки, получения элемента, получения длины, проверки на пустоту - константная, `O(1)`.

У `.push()`/`.pop()` имеется в виду амортизированная сложность, т.к. используется DS "динамический массив".

---
> Для чего может быть использован стек?

Для обращения последовательностей. Для проверки парных элементов (скобок, тегов).

---
> Напишите код вывода содержимого файла в обратном порядке

Решение "в лоб" - через стек:

```python
import os
stack = []

with open(os.path.join(os.path.dirname(__file__), 'test.py')) as fin:
    for line in fin:
        stack.append(line.rstrip('\n'))

while stack:
    print(stack.pop())
```

---
> Дан HTML-код. Проверьте, что все открывающие теги в нем корректно закрыты

Задача похожа на проверку парности скобок, решается так же - через стек:

```python
stack = []
start = html.find('<')

while start != -1:
    end = html.find('>', start + 1)

    if end == -1:
        res = False
        break

    tag = html[start+1:end]

    if not tag.startswith('/'):
        stack.append(tag)

    elif not stack or tag[1:] != stack.pop():
        res = False
        break

    start = html.find('<', end + 1)
else:
    res = not stack
```

---
> Что такое ADT *очередь*?

Коллекция с двумя основными операциями, вставки и получения элемента - `.enqueue(e)`/`.dequeue()`, которые работают по принципу FIFO (First In First Out). Примеры: очередь (ожидающих) людей, очередь обработки пользовательских запросов (в техподдержку), очереди запросов к серверам/сетевым устройствам.

---
> До каких собственных элементов имеет доступ односторонняя очередь?

Вставка только в конец. Получение только из начала.

---
> Какой метод очереди соответствует методу `.pop()` стека?

Метод `.first()`. Оба они получают (но не удаляют) первый элемент - из начала очереди или с вершины стека. Оба выбрасывают `EmptyError`, если коллекция пуста.

---
> Какие есть общие методы у очереди и стека?

`.is_empty()` и `.__len__()`, проверка на пустоту и получение длины.

---
> Какой начальный размер у стека и у очереди?

Нулевой, изначально они пустые.

---
> Почему реализация очереди через массив неэффективна?

Каждая операция `.dequeue()` (~ `.pop(0)`) потребует сдвига всех элементов влево, что очень затратно.

Вообще, существуют реализации очереди через массив, с константным временем для всех операций, но они требуют некоторых алгоритмических ухищрений.

---
> Какие основные методы реализует ADT *двусторонняя очередь*?

Добавление и получение элементов с обоих концов:

```python
.add_{first|last}()
.remove_{first|last}()
```

Помимо метода `.first()` также добавляется метод `.last()`.
