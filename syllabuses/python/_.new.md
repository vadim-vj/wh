# ООП и SOLID, `[oop-solid]`

- <https://github.com/heykarimoff/solid.python>
- <https://blog.byndyu.ru/2009/10/solid.html>

- паттерн "Фасад", когда применяется
- паттерн "Выделение частного класса данных"
- паттерн "Proxy"
- Data Access Object (DAO)
- God object
- GRASP
- Separation of Concerns
- Chain of responsibility

---
> Что такое *SOLID*?

Акроним, означающий 5 основных принципов ООП и проектирования:

- *принцип единственной ответственности* (SRP, single responsibility principle)
- *принцип открытости/закрытости* (OCP, open–closed principle)
- *принцип подстановки Лисков* (LSP, Liskov substitution principle)
- *принцип разделения интерфейса* (ISP, interface segregation principle)
- *принцип инверсии зависимостей* (DIP, dependency inversion principle)

---
> Что означает *S* в SOLID?

*Принцип единственной ответственности*, SRP (single responsibility principle) - каждый класс должен иметь одну ответственность. Как писал Мартин, "классы должны иметь одну и только одну причину для изменений".

---
> Приведите примеры нарушения SRP

- класс отчета, имеющий как методы составления отчета (`.get{Header|Data|Footer}()`), так и методы его отображения (`.to{Print|HTML|XML}()`)
- класс модели, который имеет как геттеры/сеттеры, так и методы работы с базой данных

Вообще, чаще всего приводят примеры смешения бизнес-логики и работы с БД.

---
> Какой принцип ООП, как считается, нарушает паттерн ActiveRecord?

SRP, принцип единственной ответственности. Класс ActiveRecord содержит как логику работы с данными (геттеры/сеттеры), так и работу с БД (чтение/запись).

Вообще, нарушение этим паттерном SR-принципа считается спорным: как сам по себе объект, реализующий ActiveRecord, не содержащий никакой бизнес логики, а предоставляющий таблицу из базы данных, имеет лишь одну причину для изменения (изменение таблицы).

---
> Как можно разрешить нарушения SRP в классе?

Например, используя паттерн "Фасад":

```python
class Animal:
    def __init__(self, name: str):
        self.name = name
        self.db = AnimalDB()

    def get_name(self):
        return self.name

    def get(self, id):
        return self.db.get_animal(id)

    def save(self):
        self.db.save(animal=self)
```

Все методы сохранены, но логика работы с БД теперь в другом классе, а текущий служит лишь фасадом для вызовов методов этого другого.

---
> Что означает *O* в SOLID?

*Принцип открытости/закрытости*, OCP (open–closed principle) - программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Фактически, призывает к расширению классов только через наследование.

---
> Приведите примеры нарушения OCP

Это всегда оставление деталей реализации в коде. Например, группы `if`-ов/`case`-ов:

```python
def animal_sound(animal):
    if animal.name == 'lion':
        print('roar')
    elif animal.name == 'mouse':
       print('squeak')
```

Расширит такую функцию, не вмешиваясь в код, нельзя. Или

```cpp
public function doSomeWork() {
  return (new Server())->run();
}
```

Заменить сервер, не изменяя код клиента, здесь нельзя.

---
> Как можно разрешить нарушения OCP?

Вынесение деталей реализации в отдельные параметры/методы. Например, в параметры конструктора. Или отдельные методы, которые можно перекрыть в дочернем классе, изменив, таким образом, поведение.

```python
class Lion(Animal):
    def make_sound(self):
        return 'roar'

def animal_sound(animal):
    print(animal.make_sound())
```

---
> Что означает *L* в SOLID?

*Принцип подстановки Лисков*, LSP (Liskov substitution principle) - функции, которые используют базовый тип, должны иметь возможность использовать его подтипы, не зная об этом. По сути, на место объекта базового класса должно быть всегда можно подставить объект производного.

---
> Приведите примеры нарушения LSP

Это использование специфических методов (с проверкой или без) производных классов в контексте, где предполагается объект базового типа:

```python
def animal_leg_count(animal: Animal):
    if isinstance(animal, Lion):
        print(lion_leg_count(animal))
    elif isinstance(animal, Mouse):
        print(mouse_leg_count(animal))
    elif isinstance(animal, Pigeon):
        print(pigeon_leg_count(animal))
```

Более тонкие моменты - когда наследуемый класс так переопределяет поведение базового, что это приведет к ошибке бизнес-логики в вызывающей функции:

```python
def animal_leg_count(animal: Animal):
    assert animal.leg_count == 4
```

То есть при наследовании нужно учитывать, где используется интерфейс класса, и не сломает ли переопределение это использование.

---
> Как связаны OCP и LSP?

Это, в основном, касается примера с "лапшей" `if`-ов, проверяющих тип:

```cpp
public void Save(AbstractEntity entity) {
  if (entity is AccountEntity) {
    // специфические действия для AccountEntity
  }
  if (entity is RoleEntity) {
    // специфические действия для RoleEntity
  }
}
```

Добавление нового типа требует вмешательства в код класса - это нарушение OCP. В то же время, метод оперирует специфическими для дочерних классов методами, что является нарушением LSP.

---
> Что означает *I* в SOLID?

*Принцип разделения интерфейса*, ISP (interface segregation principle) - клиенты не должны зависеть от методов, которые они не используют. Слишком "толстые" интерфейсы необходимо разделять на более маленькие и специфические.

---
> Приведите примеры нарушения ISP

Основное - это абстрактные методы в базовом классе, которые требуют переопределения в дочерних. Если интерфейс базового класса слишком "широкий", то дочерние классы будут вынуждены переопределять ненужные им методы:

```python
class IBaseShape:
    def draw_square(self):
        raise NotImplementedError

    def draw_rectangle(self):
        raise NotImplementedError

    def draw_circle(self):
        raise NotImplementedError
```

В Python-е принцип актуален только при использовании `@abc.abstractmethod`, то есть только тогда, когда класс *обязан* определить тело абстрактного метода.

---
> Что означает *D* в SOLID?

*Принцип инверсии зависимостей*, DIP, (dependency inversion principle):

- модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракции
- абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

---
> Приведите примеры нарушения DIP

Зависимость класса/модуля от конкретного класса более низкого уровня:

```python
# модуль нижнего уровня
class XMLHttpService:
    pass

# модуль верхнего уровня
class Http:
    def __init__(self, xml_http_service: XMLHttpService):
        ...
```

Жесткая зависимость от конкретного (низкоуровнего) класса не позволяет заменить его на другой / протестировать с заглушкой.

---
> Как можно разрешить нарушения DIP в классе?

Ввести дополнительный уровень косвенности - абстракцию, от которой будут зависеть модули и верхнего, и нижнего уровней. Промежуточное звено - базовый класс:

```python
# новая абстракция
class Connection:
    pass

# модуль нижнего уровня
class XMLHttpService(Connection):
    pass

# модуль верхнего уровня
class Http:
    def __init__(self, http_connection: Connection):
        ...
```

Теперь от этой новой абстракции можно наследовать любые классы, и свободно использовать их в модуле верхнего уровня (по LSP).

---

# Структуры данных и алгоритмы, `[ds-algs]`

---
> Напишите функцию, возвращающую все простые числа до `n`

Важно вести проверку до квадратного корня включительно (`int(i ** .5) + 1`) - напр., `25` делится на свой корень `5`, и если перебор до него не дойдет, число будет признано простым:

```python
def get_primes(n):
    for i in range(3, n + 1, 2):
        for j in range(3, int(i ** .5) + 1, 2):
            if not i % j:
                break
        else:
            yield i

assert list(get_primes(20)) == [3, 5, 7, 11, 13, 17, 19]
```

В обоих циклах, для улучшения производительности, перебор ведется только по нечетным числам - с шагом `2`. Т.к. все числа внешнего цикла нечетные, проверять их делимость на `2` не нужно.

---
> Напишите функцию, проверяющую, является ли число простым

Тот же перебор делителей до квадратного корня включительно:

```python
def is_prime(n):
    for i in range(2, int(n ** .5) + 1):
        if not n % i:
            return False

    return True
```

---
> Напишите генератор первых `n` чисел Фибоначчи

```python
def get_fibonachi(n):
    a = b = 1

    for _ in range(n):
        yield a
        a, b = b, a + b

assert list(get_fibonachi(7)) == [1, 1, 2, 3, 5, 8, 13]
```

Для бесконечного генератора достаточно заменить цикл `for` на `while True:`.

---
> Сгенерируйте матрицу для задачи коммивояжера

Матрица симметрична - `m[i][j] == m[j][i]`: расстояние между городами не зависит от порядка в паре. Значения на главной диагонали равны нулю: один и тот же город.

```python
import random

n = 3
matrix = [[0.0]*n for _ in range(n)]

for i in range(n):
    for j in range(i):
        matrix[i][j] = matrix[j][i] = random.uniform(1, 30)
```

---

# Задачи, `[problems]`

---
> Как вернуть 10 последних строк из текстового файла?

Используя двустороннюю очередь фиксированной длины:

```python
import collections

with open('/home/localhost/Downloads/data.txt') as f:
    collections.deque(f, 10)
```

Здесь итератор можно не перебирать вручную, а сразу отдать его конструктору очереди.

---
> Напишите функции для чисел и операций такие, чтобы выполнялось
> 
> ```python
> assert one(add(five())) == 6
> assert five(add(one())) == 6
> ```

Через каррирование:

```python
def num(val, f=None):
    return f(val) if f else val

def one(f=None):
    return num(1, f)

def five(f=None):
    return num(5, f)

def add(val):
    return lambda x: x + val
```

---
> Напишите жадный алгоритм решения задачи о банкомате с лимитами

При кратных номиналах купюр:

```python
class ATM:
    def __init__(self, banknotes):
        self.banknotes = banknotes

    def get(self, amount):
        result = {}

        for nom, avail in self.banknotes.items():
            fit = min(amount // nom, avail)

            if fit > 0:
                result[nom] = fit
                amount -= fit * nom

                if amount == 0:
                    break
        else:
            raise Exception("Can't handle amount")

        return result

atm = ATM({1000: 10, 500: 20, 100: 100})
assert atm.get(1800) == {1000: 1, 500: 1, 100: 3}
assert atm.get(1300) == {1000: 1, 100: 3}
```

---
> Как обратить строку, не используя "марсианский смайлик"?

```python
def reverse(txt):
    txt = list(txt)

    for i in range(len(txt) // 2):
        neg = len(txt) - 1 - i
        txt[i], txt[neg] = txt[neg], txt[i]

    return ''.join(txt)

assert reverse('Some text') == 'txet emoS'
```

---
> Напишите алгоритм поиска *индексов* двух минимумов в списке

Помимо сортировки и поиска-удаления-поиска-вставки, можно их найти перебором:

```python
min1 = min2 = (0, float('inf'))
for i, val in enumerate(lst):
    if val < min1[1]:
        min2 = min1
        min1 = (i, val)

    elif val < min2[1]:
        min2 = (i, val)
```

Здесь важен `elif`. Если вместо него будет просто `if`, то будут найдены два совпадающих элемента

Чтобы различались не только позиции но и значения, нужно добавить условие:

```python
elif min1[1] < val < min2[1]:
```
