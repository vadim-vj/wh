1. Распаковка фиксированной длины

  - длина и кол-во переменных должны совпадать, иначе `ValueError`
  - неиспользуемые переменные: `_` или `ign`
  - распаковывать можно любую итерируемую последовательность
  - распаковывать можно и вложенные структуры: `name, shares, price, (year, mon, day) = ['ACME', 50, 91.1, (2012, 12, 21)]`

2. Распаковка произвольной длины

  - `first, *middle, last` - достаточно, чтобы длина последовательности справа была равна двум
  - переменная со звездочкой всегда будет списком, проверять тип не нужно
  - деление списков: `*leading, tail` или `head, *trailing`
  - удобно делить строки: `uname, *fields, homedir, sh = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'.split(':')`
  - можно делить сложные структуры: ` name, *_, (*_, year) =  ('ACME', 50, 123.45, (12, 18, 2012))`
  - функция рекурсивного суммирования: `head, *tail = items; return head + sum(tail) if tail else head`

3. Оставляем `N` последних элементов

  - задача хранения ограниченной истории - `collections.deque(maxlen=Infinity)`
  - пример генератора, который и возвращает строку/историю, и пишет ее: `yield line, previous_lines; previous_lines.append(line)`
  - 4 метода `collections.deque`: `.append[Left]()`, `.pop[Left]()` выполняются за `O(1)`, тогда как вставка или удаление элемента в начале списка имеет сложность `O(N)`

4. Поиск `N` максимальных и минимальных элементов

  - модуль `heapq`, методы `.nlargest(N, seq, key=)`/`.nsmallest(N, seq, key=)`
  - обе эти функцци неявно преобразуют последовательность в кучу (`heap = heapq.heapify(seq)`), и `heap[0]` всегда будет минимальным элементом
  - метод `heapq.heappop(heap)` последовательно возвращает (и удаляет) минимальный элемент из кучи
  - эти методы подходят, когда макс./мин. элементов нужно немного. Иначе лучше через срез: `sorted(items)[:N]`/`sorted(items)[-N:]`
  - если нужен один макс./мин. элемент, то лучше использовать функции `max()`/`min()`

5. Реализация очереди с приоритетом

  - через класс, с использованием модуля `heapq`

6. Мультисловарь

  - реализация через `collections.defaultdict` с конструктором `list` или `set`
  - это приводит к созданию (пустых) элементов даже при обращении на чтение, так что альтернативный вариант - использовать обычный словарь с `.setdefault()`
  - можно и вообще вручную, но добавляется проверка `if key not in d: d[key] = []`

7. Упорядоченный словарь, `OrderedDict`
