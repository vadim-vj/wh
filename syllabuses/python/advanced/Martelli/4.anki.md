---
> Что такое *класс* в Python?

Это пользовательский тип и одновременно экземпляр объекта. Его атрибуты могут иметь произвольные имена и быть переменными (свойства) или функциями (методы)

Класс можно передать в и возвратить из функции, можно сделать его атрибутом объекта или ключом словаря. Класс в Python является *вызываемым* объектом первого класса

---
> Обязательны ли скобки в объявлении класса после имени?

Нет, не обязательны, что с пустыми скобками что без наследование будет от `object`

Для более лучшего стиля лучше не писать пустые скобки или `(object)`

> Без скобок класс будет считаться классом старого стиля. Поэтому, для указания на то что класс нового типа, можно всегда писать `class <C>(object)`

---
> Как проверить, что один класс наследуется от другого?

Встроенная функция `issubclass(derived, base) == True|False`

---
> Допускаются ли вложенные классы?

Да, вполне. Класс может иметь в качестве атрибута что угодно, в том числе и другой класс

---
> Допустимо ли объявлять статические атрибуты вне тела класса?

Да, вполне:

```python
class A:
    pass

A.x = 'some'
print(A.x) # some
```

Но такой стиль не рекомендуется: ухудшает читаемость. Лучше задавать атрибут в теле

---
> Какие основные атрибуты *класс* создает неявно?

- `__name__` - имя класса (то, что после `class` в объявлении)
- `__bases__` - кортеж базовых классов (по дефолту `(object)`)
- `__doc__` - строка документации (`None` если не задана)

---
> Какие основные атрибуты *экземпляр класса* создает неявно?

- `__class__` - ссылка на объект класса
- `__dict__` - словарь со всеми атрибутами экземпляра

Вызов `x.attr = 'some'` эквивалентен вызову `x.__dict__['attr'] = 'some'`, если конечно установка атрибута не перехватывается методом `.__setattr__()` самого класса, или методом `.__set__()` его атрибута

---
> Можно ли в статических атрибутах класса ссылаться на другие такие же атрибуты?

Да, это допустимо. Например, такой код вполне рабочий:

```python
class A:
    x = 23
    y = x + 23
```

Здесь, в отличие от функций, имена испльзуются напрямую, без уточнений

---
> Доступно ли в методах класса обращение к его свойствам напрямую, без уточнения?

Нет, нужно писать `<C>.<prop>` или `self.<prop>`

---
> Фиксировано ли имя `self` для первого параметра методов класса?

Нет, это просто общеприянтое соглашение. Использоваться может любое имя

---
> Обязана ли docstring быть в тройных кавычках?

Нет, это просто стилистическое соглашение. Python вообще проигнорирует любую отдельностоящую строку в кавычках

---
> Что компилятор делает с членами класса, начинающимися с двух подчеркиваний `__`?

Переименовывает в `_<C>__<name>`:

```python
class A:
    __x = 1

A._A__x == 1
A.__x # ошибка
```

---
> Что компилятор делает с членами класса, начинающимися с одного подчеркивания `_`?

Ничего, они считаются "закрытыми" лишь по соглашению об именах

---
> Что такое *дескриптор*?

Это любой объект, класс которого определяет dunder-метод `.__get__()`. Если определен еще и `.__set__()`, то это *дескриптор данных* (или *перекрывающий дескриптор*)

Дескрипторы важны тогда, когда они являются атрибутами другого класса:

```python
DescriptorClass:
    def __init__(self, value):
        self.value = value
    def __set__(self, *_):
        pass
    def __get__(self, *_):
        return self.value

class A:
    x = DescriptorClass()
```

В этом случае они управляют доступом к атрибутам: вызываются при установке/получении значения атрибута. Например, при установке атрибута `C().x = 'some'` вызывается метод `.__set__()` объекта `C.x`

---
> Каким дескриптором является объект функции?

*Неперекрывающим*: он определяет метод `.__get__()`, но не определяет `.__set__()`

---
> Может ли метод `.__init__()` возвращать значение

Нет, только `None`, иначе будет выброшено исключение `TypeError`

---
> Какой "магический" метод управляет установкой атрибута объекта?

`.__setattr__(self, name, value)` вызывается и при создании нового атрибута, и при (пере)записи значения существующего

Этот метод вызывается только для объектов класса, не для статических атрибутов

---
> Что такое *идиома функции-фабрики*?

Когда нужно выбирать, экземпляр какого класса создать, делать это следует через отдельную функцию. Через модификацию `.__init__()` это не получится: язык запрещает возвращать этому методу что-либо кроме `None`

Обычно реализуется через "магический" метод `.__new__()`

---
> Что делает метод `.__new__()`? Какая у него сигнатура?

`.__new__(С, *args, **kwds)`. Автоматически вызывается при создании экземпляра класса (через `C()`), до вызова `.__init__()`

Этот метод возвращает значение - созданный *неинициализированный* экземпляр. Если он действительно является экземпляром класса - первого аргумента (или любого из его подклассов), то вызывается `.__init__()`

---
> Напишите код - аналог создания экземпляра класса

```python
x = C.__new__(C, 23)
if isinstance(x, C): type(x).__init__(x, 23)
```

---
> Как можно перекрыть метод `.__new__()`?

Стандартным способом, указывать декоратор `@classmethod` не нужно: интерпретатор сам распознает имя метода

Вот для перекрытия вне тела класса уже нужно писать

```python
C.__new__ = classmethod(<method>)
```

Но перекрытия вне тела класса рекомендуется избегать

---
> Нужны ли функции `super()` аргументы?

Не обязательны

> Да, нужно передавать класс

---
> Можно ли в рантайме менять "магические" атрибуты `__class__`/`__bases__` экземпляра класса?

Да, можно, на `__class__` только есть ограничения (`__class__ assignment only supported for heap types or ModuleType subclasses`)

---
> Какие шаги выполняет интерпретатор при разрешении имена *статического атрибута класса* `C`?

1. Если имя `name` - ключ в словаре `C.__dict__`, то берем `v = C.__dict__['name']`
   - если `v` - дескриптор, то вызываем его метод `.__get__()`: `type(v).__get__(v, None, C)`
   - иначе возвращаем сам `v`
2. Иначе перебираем в цикле все родительские классы и выполняем п.1 для них
3. Если ничего не найдено, выбрасываем `AttributeError: type object 'C' has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение

---
> Какие шаги выполняет интерпретатор при разрешении имена *атрибута экземпляра класса* `x`?

1. Ищем в *классе* `C` и его предках одноименный перекрывающий (с методами `.__get__()`/`.__set__()`) дескриптор (т.е. идет поиск статического члена с таким именем). Если найден, вызываем его: `type(v).__get__(v, x, C)`
2. Если такой дескриптор не найден, но имя `name` - ключ в словаре `x.__dict__`, то берем `v = x.__dict__['name']`
3. Если не найдено и в словаре, то делегируем поиск классу, с теми же шагами 1-2 (дескриптор -> словарь)
4. Если ничего не найдено, но у класса есть метод `.__getattr__()`, то вызываем его
5. Иначе выбрасываем `AttributeError: 'C' object has no attribute 'name'`

Эти шаги относятся только к поиску при обращении на чтение
---
> Что такое *связанный метод*?

Объект-функция, атрибут класса, связанный с его (класса) экземпляром: `C().x`

Вызывать такой метод нужно без явного указания аргумента: экземпляр класса будет передан первым параметорм автоматически

---
> Можно ли вызвать нестатический метод класса не на экземпляре, а на самом классе?

Можно, но передавать первый параметр (`self`) всё равно придется передавать, вручную:

```python
C.x(C(), ...)
```

Явно так лучше не вызывать, но иногда можно, например, для передачи метода как параметра:

```python
list('...').sort(key=str.lower)
```

---
> Можно ли объявлять методы класса вне его (класса) тела?

Да, это допустимо, но объектов - связанных методов из них создано не будет, и вызывать их без явной передачи первого аргумента (`self`) будет нельзя

---
> Что такое *MRO*? Как осуществляется в Python?

*Method resolution order*, порядок разрешения имен при поиске метода/атрибута в классе, текущем и базовых

Классы-потомки всегда просматриваются раньше предков. В Python родительские классы просматриваются слева направо

---
> Как происходит устранение проблемы ромба в MRO?

Родительские классы просматриваются слева направо. Всегда берется крайнее справа вхождение любого класса

Посмотреть последовательность классов можно через read-only атрибут `C.__mro__` (только у класса, не у экземпляра)

---
> Какие атрибуты разрешено перекрывать в дочерних классах?

Любые, как вызываемые атрибуты, так и атрибуты данных:

```python
class A:
    x = 1
    def y(self): pass

class B:
    x = 2
    def y(self): pass
```

---
> Обязательно ли перекрывать методы родительского класса?

Нет, они будут вызываться автоматически

Более того, перекрытие лишь для вызова родительского метода считается плохим стилем

---
> Как можно вызвать метод родительского класса без `super()`?

Явно указав имя родительского класса, вызвав на нем метод как статический, и явно же передав ему `self`:

```python
class A:
    def x(self):
        pass

class B:
    def x(self):
        A.x(self)
```

---
> Какие есть преимущества у функции `super()` по сравнению с явным указанием имени базового класса?

- автоматически решает проблему ромба, формирует "суперобъект", вызов метода на ктором не приведет к дублированию вызова в родительских классах
- позволяет меньше писать, аргументы можно не указывать

> Нужно передавать имя *текущего* (не базового) класса и `self`: `super(C, self).<method>()`

---
> В каких случаях может понадобиться вызов метода родительского класса не через `super()`, а явным указанием имени?

Когда сигнатуры методов в суперклассе и подклассах не совпадают

Но такое несовпадение - это грубое нарушение принципов ООП, в частности полиморфизма

---
> Назовите 3 способа удалить атрибут в дочернем классе

- перекрыть метод и в нем генерировать исключение
- хранить атрибуты не в `.__dict__`, а где-либо еще, и описать логику доступа в `.__getattr__()`
- перекрыть метод `.__getattribute__()`

---
> Назовите 3 группы "магических" методов класса `object`

- методы создания: `__new__`, `__init__`
- работа с атрибутами: `__delattr__`, `__setattr__`, `__getattribute__`
- представление в строковом/числовом виде: `__hash__`, `__repr__`, `__str__`

---
> Можно ли непосредственно создать экземпляр класса `object`?

Да, без проблем:

```python
x = object()
```

Его конструктор не принимает никаких аргументов

---
> Что такое *статический метод* класса?

Это обычная функция, просто сделанная атрибутом класса. На ее сигнатуру не накладывается никаких ограничений, в том числе не нужно передавать `self` первым параметром. Такую функцию можно вызывать не только на классе (`C.x()`), но и на экземпляре (`C().x()`); при этом ошибок о несовпадении числа аргументов не возникает

В принципе, ничто не мешает сделать такую отдельной, но некоторые предпочитают связать ее с классом

---
> Как задается *статический метод* класса?

Через конструктор встроенного типа `staticmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(): pass
    x = staticmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое (статический) *метод класса*?

Метод, получающий при вызове первым параметром сам класс. Этим он отличается от *статического метода* (простой функции в качестве атрибута), и гораздо удобнее его: перекрывать в подклассах значительно проще

Такой метод vожно вызывать как на самом классе, так и на его экземпляре

---
> Как задается (статический) *метод класса*?

Через конструктор встроенного типа `classmethod`, (желательно) сохраняя то же имя:

```python
class A:
    def x(): pass
    x = classmethod(x)
```

Или (предпочтительно) через декоратор

---
> Что такое *свойство* класса?

Метод, к которому можно обращаться как к read-only атрибуту данных, без скобок. В нем доступен первый параметр `self`:

```python
class A:
    def x(self): return 1
    x = property(x, doc='Some docstring.')

A().x
```

Или (предпочтительно) через декоратор

---
> Какая сигнатура конструктора у встроенного типа `property`?

Обычно указывают только одни - позиционный параметр:

```python
property(fget=None, fset=None, fdel=None, doc=None)
```

Функция `fset` вызывается при попфтке присваивания свойству, а `fdel` - при вызове на нем опреатора `del`. Параметр `doc` устанавливает атрибут `__doc__`

В случае, если `fset`/`fdel` не указаны, свойство ведет себя как read-only атрибут

---
> Как через декоратор указать setter/deleter для свойства?

Указать `@<prop-name>.setter|deleter` у отдельных *одноименных* методов:

```python
class A:
    @property
    def x(self): return 1
    @x.setter
    def x(self, val): pass
    @x.deleter
    def x(self): pass

a = A()
a.x = 2
del a.x
```

---
> Какой есть более удобный аналог геттеров/сеттеров?

*Свойства* - декорированные через `property` методы класса

---
> Наследуется ли декоратор свойства (`@property`) класса?

Нет, его нужно повторять для дочерних классов. Вот здесь `B.x` будет методом, не свойством:

```python
class A:
    @property
    def x(self): return 1

class B(A):
    def x(self): return 2

B().x() # не B().x
```

---
> Что представляет собой и что делает атрибут `__slots__` у класса?

Это кортеж строк-идентификаторов, ограничивающий набор возможных атрибутов *экземпляра* класса. Позволяет немного экономить память, не создавая динамический ловарь атрибутов `__dict__`. Определяться может только в теле класса

Использовать его нужно лишь тогда, когда количество экземпляров может быть очень велико (миллионы), иначе экономия может оказаться несущественной, а удобство/читабельность снижены

---
> В чем отличие `__getattr__` от `__getattribute__`?

`__getattribute__` вызывается *до* поиска атрибута в экземпляре (до начала разрешения имен), тогда как `__getattr__` вызывается лишь в случае, если атрибут не найдет (fallback)

Из-за такой логики их оба, в принципе, можно использовать для удаления атрибутов в дочерних классах. Только в случае `__getattr__` атрибуты нужно хранить где-то помимо `__dict__`

---
> Можно ли наследоваться от встроенных типов?

Да, это разрешено. Но совместимость не безусловная, может оказаться, что множественное наследование от двух разных типов невозможно

Так, например, нельзя одновременно наследовать класс от `dict` и `list`
