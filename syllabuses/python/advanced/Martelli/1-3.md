### Мартелли А. и др., Python. Справочник. Полное описание языка
<http://www.williamspublishing.com/Books/978-5-6040723-8-7.html>

---
> Соединяет ли Python строки такого вида: `... # ... \`?

Нет, обратный слеш находится за комментарием и игнорируется

---
> В каких случаях смежные строки кода объединяются в одну логическую?

Если открыта любая из скобок `(`/`[`/`{` или тройная кавычка

Физические строки, входящие в одну логическую строку, называются *строками продолжения*. Соображения, касающиеся отступов, относятся к первой физической строке каждой логической строки, а не к строкам продолжения

---
> Как указать кодировку файла с исходным кодом?

Нужен комментарий в начале файла - *директива кодировки*, например, `# coding: iso-8859-1`

---
> Какие символы могут содержать файлы с исходным кодом?

Любые символы Unicode в кодировке UTF-8. ASCII-символы (коды 0-127) - их часть

> По умолчанию только ASCII. Кодировку можно сменить через `# coding: utf[-8]` в начале файла. Использовать юникод в v2 можно только в строковых литералах и комментариях

---
> Какие символы разрешается использовать в именах идентификаторов?

Любые символы, интерпретируемые Юникодом как буквы / цифры / символы подчеркивания. Не может начинаться с цифры. Вполне допустимы, например, имена переменных из русских букв:

```python
фф = 3
```

> Только `[a-zA-Z0-9_]`

---
> Имеет ли регистр значение в Python?

Да, язык регистр-чувствительный. Как для идентификаторов, так и для ключевых слов

---
> Допускается ли использование знаков пунктуации в именах идентификаторов?

Нет, ничего вроде `@`/`$`/`!` использовать нельзя

---
> В каком регистре пишутся ключевые слова?

Все в нижнем. Т.к. язык регистр-чувствительный, то изменение регистра любого символа в них приведет к синтаксической ошибке (`SyntaxError: invalid syntax`)

---
> Чем являются `exec` и `print`?

Функциями

> Ключевыми словами. Хотя, если включить в код `from __future__ import print_function`, то станет функцией

---
> Чем являются в языке лексемы `True`, `False`, `None`?

Ключевыми словами. Например, при попытке их использования в качестве переменной будет выброшена ошибка `SyntaxError: can't assign to keyword`

---
> Есть ли в Python объявления (функций, переменных, и т.д.)?

Нет, есть только инструкции

---
> Чем является операция присваивания?

Инструкцией. И поэтому не возвращает значения и не может входить в выражения

---
> Что является признаком конца блока?

Возврат к отступу, равному или меньшему отступу заголовка блока

---
> Как получить тип объекта?

Встроенная функция `type(obj)` возвращает класс (напр., `<class 'float'>`)

---
> Как проверить принадлежность объекта типу (классу)?

Встроенная функция `isinstance(obj, type)` возвращает `True`, если `type` находится в базовых классах `obj`

---
> Какие есть встроенные числовые типы?

Из три: целочисленные `int`, с плавающей точкой `float` и комплексные `complex`

> Есть еще `long`

---
> Чем являются все числа в Python?

Неизменяемыми объектами. Поэтому любая операция с ними порождает новый объект (в том числе, составные присваивания)

---
> Какие есть литералы для записи чисел в не-десятичных системах счисления?

Двоичный `0b`, восьмеричный `0o`, шестнадцатеричный `0x`

> Восьмеричный можно писать без `o`, просто ноль

---
> Какое максимальное целое число можно записать литералом?

Любое, верхняя граница не определена

> Граница между `int` и `long` определяется константой `sys.maxint`

---
> Каков формат литерала для чисел с плавающей точкой?

Первый ноль может опускаться (`.1`), может использоваться научная нотация: `e|E` (в любом регистре), за ней необязательный `+/-`, потом цифры показателя степени (`.1E+2 == 10.0`)

---
> Как получить информацию о представлении чисел с плавающей точкой на текущей машине?

Кортеж `sys.float_info`

---
> Какой формат у литерала комплексного числа?

Два числа с плавающей точкой, соединенные символом `+`/`-`. Вторая часть (мнимый литерал) записывается с суффиксом `j`:

```python
4-.1e3j == (4-100j)
```

Сложение/вычитание выполняется в момент компиляции

---
> Можно ли разделять разряды в числовых литералах?

Да, с v3.6 можно использовать подчеркивания:

```python
100_000.000_0001 == 100000.0000001
0x_FF_FF == 65535
0o7_777 == 4095
0b_1010_1010 == 170
```

---
> Чем являются строки в Python?

Неизменяемыми объектами, последовательностями символов Unicode. Любая операция с ними порождает новый объект

> Недекодированные литералы являются байтовыми строками (не Unicode)

---
> Какие кавычки предпочтительней для строк?

Одинарные

---
> Как преобразуется перенос в строках в тройных кавычках?

В символ новой строки `\n`:

```python
"""1
2
3""" === "1\n2\n3"
```

---
> Как избежать переносов строк и отступов внутри тройных кавычек?

Использовать обратный слеш `\`:

```python
"""\
2\
3""" === "23"
```

---
> В чем основная особенность "сырых" строковых литералов?

В них обратный слеш `\` не имеет специального значения - он сам и все следующие за ним символы просто копируются в строку. Такой литерал обозначается буквой `r|R` перед открывающей кавычкой (кавычками)

---
> Какими символами не может заканчиваться литерал "сырой" строки?

Нечетным количеством обратных слешей. В таком случае последняя косая черта будет восприниматься как будто она экранирует закрывающую кавычку

---
> Как можно задать в строке символ Юникода через его числовое значение?

- указав 4 цифры после `\u` (напр., `"\u3421"`)
- указав 8 цифр после `\U`
- указав имя в фигурных скобках после `N` (напр., `"\N{Copyright Sign}"`)

---
> Что произойдет, если просто записать два строковых литерала рядом?

Компилятор просто соединит их в одну строку. Пробелы между литералами опциональны. Если один из литералов - байтовая строка (`[r]b'...'`), а второй Юникод, то ошибка

> При слиянии байтовой строки (`br`) и строки Юникода результат приводится к Unicode

---
> Чем являются кортежи в Python?

Неизменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов. Любая операция с ними порождает новый объект

Элементом кортежа может быть изменяемый объект (напр., список), но в соответствии с установившейся практикой этого лучше избегать

---
> Сколько элементов в кортеже `(1,2,)`?

Два. Последняя запятая не добавляет пустой элемент, она вообще опциональна. Это же касается и остальных коллекций, вроде списка, множества и словаря

----
> Как записать литерал пустого кортежа?

Парой круглых скобок `()`

---
> Что такое *пара*?

Кортеж из двух элементов, `(a, b)`

---
> Какой тип у (позиционного) аргумента `x` конструктора `tuple/set/list/dict(x)`?

Любой итерируемый (иначе ошибка `TypeError: 'int' object is not iterable`)

---
> Чем являются списки в Python?

Изменяемыми объектами, *упорядоченными* последовательностями произвольных (неуникальных) объектов

---
> На какую другую коллекцию Python больше всего похожи списки?

На кортежи: такой же тип (итерируемый объект) у конструктора `list(x)`, такая же необязательная trailing-запятая `[1,2,]`, такой же доступ к элементам по индексу

---
> Чем являются множества в Python?

Могут быть как изменяемыми (`set`/`{}`), так и неизменяемыми (`frozenset`) объектами, *неупорядоченными* последовательностями уникальных объектов

---
> Какое ограничение накладывается на элементы множеств?

Они должны быть хешируемыми (неизменяемыми) объектами (см. функцию `hash()`)

---
> Как записать литерал пустого множества?

Это сделать нельзя, из-за неразличимости с литералом пустого словаря - `{}`. Нужно писать через конструктор класса - `set()`

---
> Чем являются словари в Python?

Изменяемыми неупорядоченными объектами, отображениями (map) множества ключей на множество объектов. Аналогичны ассоциативным массивам

---
> Какие ограничения накладываются на ключи и значения словарей?

На значения ограничений не накладывается, а ключи должны быть хешируемыми (неизменяемыми) объектами

---
> Какое из значений будет выбрано при наличии повторяющихся ключей в словаре?

Последнее; указанное последним в литерале или последнее добавленное (переписывает существующее). До версии v3.7 это не гарантируется, и выбирается произвольное значение (UB)

---
> Как можно создать словарь через конструктор `dict()`?

Используя именованные параметры или список кортежей:

```python
dict(x=42, у=3.14, z=7) == {'x': 42, 'у': 3.14, 'z': 7}
dict([(1, 'za'), ('br',23)]) == {1: 'za', 'br': 23}
```

----
> Как записать литерал пустого словаря?

Парой круглых скобок `{}` (получается именно словарь, не множество)

---
> Что будет, если конструктору словаря передать одновременно и итерируемый (позиционный) параметр, и один или несколько именованных?

Отработает нормально, создаст словарь. Именованные аргументы здесь имеют более высокий приоритет, так что они перепишут ключи-дубликаты в позиционном параметре (если есть):

```python
dict([(1, 'za'), ('br',23)], br='ddd') == {1: 'za', 'br': 'ddd'}
```
---
> Как создаст словарь из набора ключей и одного (общего для всех) значения?

Воспользоваться методом `dict.fromkeys()`. Первый параметр - любая итерируемая последовательность, второй опционален - значение-заполнитель (если не указано, то `None`):

```python
dict.fromkeys('hello', 2) == {'h': 2, 'e': 2, 'l': 2, 'o': 2}
dict.fromkeys([1, 2, 3]) == {1: None, 2: None, 3: None}
```

---
> Что такое `None`?

Встроенный объект, синглет. Не имеет методов и атрибутов. Возвращается функцией, если в ней нет инструкции `return`

---
> Какие есть *вызываемые типы*?

Функции/методы и генераторы, все классы (встроенные и пользовательские) а также экземпляры классов, предоставляющие спец. метод `__call__()`

---
> К какому типу относятся `True`/`False`?

Это объекты класса `bool`, который сам является подклассом `int`

---
> Чему равны `True`/`False`?

`1`/`0` соответственно

---
> Каковы правила преобразования объектов к `True`/`False`?

К `False` приводятся:

- `None`
- `0`
- пустая строка и все пустые коллекции: `[]`, `{}`, `()`
- объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно

Всё остальное `~ True`

---
> Как создать и освободить переменную (ссылку)?

Объявлений переменных в Python нет, они создаются в момент инициализации (как правило присваивания). Явное удаление ссылки можно сделать оператором `del`

---
> Что такое *сборка мусора*?

(Автоматическое) удаление объектов, на которые не указывает ни одна ссылка (переменная). Такие свободные объекты могут оставаться в памяти, например, при переприсваивании переменным других значений

---
> Какие идентификаторы можно использовать в качестве имен переменных?

Любые, кроме (~ 30 штук) ключевых слов языка

---
> Чем отличается обращение к *атрибуту* и *элементу* объекта?

К атрибуту обращение идет через точку (`x.y`), тогда как к элементу коллекции - через оператор квадратных скобок `[]`. Вызываемые атрибуты класса называются *методами*

---
> Что такое *LHS* и *RHS*?

*Lefthand side* и *righthand side*, левая и правая части присваиваний. Т.к. в Python функции/методы являются объектами первого класса, они могут быть RHS

---
> Можно ли присваивать значение срезу списка?

Да, вся указанная в левой части присваивании часть будет заменена на то, что справа от "равно" (с возможным изменением размера списка). Присваивать можно только итерируемый объект

---
> Что такое *групповое присваивание*?

Присваивание ссылки на объект сразу нескольким переменным. RHS здесь вычисляется ровно один раз

Все переменные после этого ссылаются на один объект, но не на друг друга:

```python
x = y = 3; x = 4; print(x, y) # 4 3
x = y = []; x.append(4); print(x, y) # [4] [4]
```

---
> Что такое *присваивание с распаковкой*?

Форма записи, когда в LHS переменные перечисляются через запятую, а в RHS находится итерируемый объект: `а, Ь, с = х`. Элементов в распаковываемом объекте должно быть *ровно столько* (не больше и не меньше), сколько и переменных в LHS, иначе ошибка

---
> Для чего часто используется присваивание с распаковкой?

Для обмена значений и в циклах:

```python
a, b = b, a
a, b = enumerate(...)
```

---
> Что такое *расширенное присваивание с распаковкой*?

Используется символ звездочка `*`. Он указывает элемент, который станет списком-"остатком" - в который будут записаны все лишние элементы из правой части (RHS):

```python
x, *y, z = [1, 3, 5, 6, 5]
print(x, y, z) # 1 [3, 5, 6] 5
# аналог:
first, *middle, last = х 
first, middle, last = х[О], x[1:-1], х[-1]
```

Правая часть может быть произвольным итерируемым объектом

> Нет такой конструкции. Ее можно только эмулировать через индексы, как в примере выше

---
> Каково минимальное число элементов в правой части расширенного присваивания с распаковкой?

На единицу меньше кол-ва элементов в LHS:

```python
x, *y, z = [1, 5]
print(x, y, z) # 1 [] 5
```

---
> Что такое *составное присваивание*? Сколько всего таких операторов есть?

Семь для арифметических операций: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=` и пять для бинарных битовых: `|=`, `>>=`, `<<=`, `&=`, `^=`. В v3.5 появился еще оператор умножения матриц `@=`

В левой части составного присваивания допускается только одна целевая ссылка; множественные целевые ссылки не поддерживаются

> Оператора `@=` естественно нет

---
> Как физически реализуется составное присваивание?

Через специальные методы объекта (как правило, начинающиеся с `i`). Если такого метода нет, выполняется обычная операция, ее результат пишется во временный объект, после чего этот объект присваивается левой части.

Так, например, для `x += y` сначала проверяется, есть ли у `x` метод `__iadd__()`, и если есть, вызывается `x = x.__iadd__(y)`. Если метода нет, выполняется `x = x + y`

---
> Можно ли вызывать составное присваивание на еще не определенной переменной?

Нет, ссылка к этому моменту должна существовать. Инструкция

```python
<non-existing-var> += 1
```

вызовет ошибку

---
> Может ли операция присваивания изменять объект в LHS?

Только если это присваивание *составное* (и при этом определен соответствующий `i`-метод). Обычное присваивание лишь связывает переменную в левой части с новым объектом

---
> Что делает инструкция `del`?

Не удаляет объекты физически, а лишь открепляет ссылки на них, разрывает связь между идентификатором (ссылкой) и физическим объектом в памяти

---
> Какой формат у инструкции `del`?

После самой инструкции следует имя переменной (идентификатор), один или несколько, разделенных запятыми. Все переменные должны быть определены, иначе ошибка

---
> Какие методы управляют поведением инструкции `del` на объектах классов?

`.__delattr__()` для атрибутов класса и `.__delitem__()` для удаления элемента коллекции. Каждый из них может запретить удаление, сгенерировав исключение

---
> Может ли выполнение инструкции `del` сопровождаться побочными эффектами? Приведите примеры

Да, может. Например, при удаление по ключу из словаря (`del C[2]`) больше обращаться к удаленному элементу нельзя (чистое удаление, без побочных эффектов), тогда как такое же удаление из списка (`del C[2]`) оставит второй индекс валидным (удаление со сдвигом, который и является побочным эффектом)

---
> Какой приоритет у логических операторов?

`not` самый приоритетный, затем `and`, у `or` самый низкий приоритет

---
> У чего выше приоритет, у логических связок или у операторов сравнения?

У операторов сравнения:

```python
(2 == 2 and 0 == 0) == True
```

---
> Какой минус/плюс приоритетней, унарный или бинарный?

Унарные операторы приоритетней

---
> Где в таблице приоритетов находятся битовые операторы?

Их приоритет ниже арифметических, но выше операторов сравнения

---
> Каков приоритет у операторов `[not] it` / `is [not]`?

Такой же, как у операторов сравнения

---
> Что такое *цепочки сравнений*?

Особая форма записи условий в Python, позволяющая обходиться без логических связок:

```python
a < b < c
a != b != c
```

В цепочках сравнений каждое выражение вычисляется по крайней мере один раз

---
> Какие операторы допускают объединение в цепочки сравнений?

`[not] in`, `is [not]`, `<`, `<=`, `>`, `>=`, `!=`, `==`. У всех у них одинаковый приоритет

---
> Как раскрываются цепочки сравнений?

Через логическую связку `and`:

```python
a < b < c # a < b and b < c
"bc" in "abcde" == True # "bc" in "abcde" and "abcde" == True
```

По сути, это просто синтаксический сахар

---
> В какой момент вычисление логического выражения останавливается?

Вычисления идут *по короткой цепи*: слева направо и останавливаются, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

---
> Что возвращают логические связки `and`/`or`?

Свои операнды, не булевы значения. Это позволяет использовать их (связки) в более общих, а не только булевых контекстах

---
> Как в Python выглядит тернарный оператор?

```python
<if-true> if <condition> else <if-not-true>
```

---
> Чем являются унарные `-`/`+` в записи обычных чисел, и бинарные `-`/`+` в записи комплексных? Почему это важно?

Являются обычными операторами, не частью литералов чисел. Важно это потому, что на них распространяются приоритеты операторов. Так, например, `-2**2 == -4`, т.к. возведение в степень имеет более высокий приоритет, чем унарный минус

---
> Как в Python идет неявное преобразование числовых типов?

Оно *повышающее* - если операнды различаются, то тип "меньшего" неявно приводится к типу "большего". Самый "маленький" тип `int`, потом `float`, самый большой `complex`

---
> Как можно преобразовать комплексное число в другой числовой тип?

Никак, не существует однозначных ("сужающих") преобразований

---
> Как привести строку к числу?

Вызвать конструктор соответствующего типа с этой строкой:

```python
int('33') == 33
float('33.44') == 33.44
complex('3+.2j') == (3+0.2j)
```

---
> Как распарсить строку в число в не-десятичной системе счисления?

Работает только для целых чисел. Передать основание системы (от 2 до 36) счисления вторым параметром конструктору `int`:

```python
int('10101', 2) == 21
```

---
> Какие ограничения на операнды `/`, `//`, `%`?

Правый их операнд не может быть равен нулю, иначе runtime-ошибка

---
> Какой тип возвращаемого значения у оператора `/`?

Всегда число с плавающей точкой (истинное деление)

> Если оба операнда - целые числа, то округляет вниз (`5/3 == 1`, `-5/3 == -2`). Чтобы поведение было такое же, как в v3, нужно указать опцию командной строки для интерпретатора - `-Qnew`, умножать на `float` - `1.О*а/Ь`, или (что лучше) указать в начале файла `from __future__ import division`. Не помешает также опция `-Qwarn`, которая предупредит о возможных несоответствиях при использовании оператора `/`

---
> Какой тип возвращаемого значения у оператора `//`?

Совпадает с типом самого "широкого" операнда. То есть, если хотя бы один операнд - это число с плавающей точкой, то результат `float`. И только если и делимое и делитель целые, то результат `int`

---
> Как оператор `//` вычисляет значение?

Округляет вниз:

```python
5/3 == 1
-5/3 == -2
```

---
> Как можно в одно действие получить и целую часть, и остаток от деления?

Использовать встроенную функцию `divmod(a, b)` - она вернет пару `(int, int)` с нужными значениями

---
> Как можно выполнить возведение в степень?

Оператором `a**b` или встроенной функцией `pow(a, b)`

---
> Что будет, если возвести в дробную степень отрицательное число?

Будет возвращено комплексное число:

```python
(-4)**.5 == (1.2246467991473532e-16+2j)
```

> Будет выброшено исключение

---
> За что отвечает третий параметр функции `pow()`

С ним функция начинает возвращать остаток от деления результата возведения в степень на это параметр:

```python
pow(а, Ь, с) == (а**Ь)%с
```

Функция работает немного быстрее последовательности операторов

---
> Можно ли сравнивать комплексные числа?

Только на равенство/неравенство. Иначе выбрасывается исключение

---
> Что возвращают операторы сравнения?

В отличие от логических связок - булевы значения, не свои операнды

---
> Можно ли сравнивать числа с плавающей точкой?

Нет, из-за возможных ошибок представления/округления

---
> Можно ли использовать битовые операторы с целыми числами?

Да. Положительные целые числа концептуально расширяются влево неограниченной строкой битов `0`. Отрицательные числа, для представления которых используется дополнительный код, концептуально расширяются влево неограниченной строкой битов `1`

---
> Как получить длину последовательности, минимальный/максимальный элементы, как вычислить сумму элементов?

Всё - через встроенные (built-in) функции: `len()`, `min()`, `max()`, `sum()` соответственно

Это работает для списков, кортежей и множеств

---
> Как можно конкатенировать и повторить последовательность?

Операторами сложения и умножения соответственно:

```python
[1, 2] + [3, 4] == [1, 2, 3, 4]
[1, 2] * 2 == [1, 2, 1, 2]
```

---
> Что будет при "умножении" последовательности на отрицательное число?

Будет возвращена последовательность того же типа, но нулевой длины:

```python
[1, 2, 3] * -2 == []
```

---
> Как проверить принадлежность элемента коллекции?

Оператором `[not] in`: `х in S`. Эквивалентная запись для `not`: `x not in S` ~ `not (x in S)`

Это работает для всех: для строки, списка, кортежа, множества и словаря

---
> Какой тип значения возвращает оператор `[not] in`?

Логическое:

```python
("bc" in "abcde") == True
(1 in []) == False
```

---
> В чем особенность использования оператора `[not] in` со строками?

Он может проверять вхождения сразу по подстроке, не только по одному символу:

```python
("bc" in "abcde") == True
```

---
> Каков допустимый диапазон отрицательных индексов последовательности длиной `L`?

От `-1` до `L` включительно:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == 3
x[-3] == 1
```

---
> Как из отрицательного индекса последовательности получить положительный?

Сложить отрицательный с длиной - `L + -n`:

```python
x = [1, 2, 3]
len(x) == 3

x[-1] == x[len(x) - 1] == x[2] == 3
x[-3] == x[len(x) - 3] == x[0] == 1
```

---
> Что происходит при попытке доступа на чтение к элементу последовательности по несуществующему индексу? При попытке присвоения?

В обоих случаях выбрасывается исключение

---
> Как можно вставить элемент в список в позицию `n`, не прибегая к методу `.insert()`?

Используя срез `[n:n] = [val]`:

```python
x = [1, 2, 3]
x[1:1] = [4]
x == [1, 4, 2, 3]
```

---
> Каким типом интервала является срез?

Полуоткрытым: первый индекс включается в срез, а второй нет - `[i, j)`

---
> Какую подпоследовательность вернет срез с одинаковыми индексами?

Пустую. Так как `[i:i]` ~ `[i, i)`, т.е. конечный индекс не включается, то и длина среза равна нулю

---
> Какое ограничение на значение шага в срезе?

Не должен быть нулем, иначе `ValueError: slice step cannot be zero`

---
> Чем являются числа в обозначении среза?

Реальными индексами элементов. Например:

```python
[1, 2, 3][1:2] == [2]
[1, 2, 3][1:3] == [2, 3]
```

Индекс `1` указывает на второй элемент, индекс `2` на последний, а `3` - на индекс за последним элементом списка. Вторые индексы среза не включаются в результирующую последовательность

---
> Чему равны пропущенные индекс в срезе?

Левый нулю, а правый длине последовательности:

```python
[:n] ~ [0:n]
[n:] ~ [n:len(seq)]
```

Таким образом, правый дефолтный индекс указывает на элемент за последним элементом последовательности

---
> В каких случаях срез `[i:j]` даст пустую последовательность?

Когда первый индекс больше или равен второму (`i >= j`), или первый индекс больше или равен длине последовательности (`i >= len(seq)`)

---
> Что будет, если второй индекс в срезе больше длины последовательности?

Ничего, корректно отработает. Возьмет длину вместо слишком большого индекса

---
> Как сделать shallow copy последовательности через срез?

Опустить оба индекса: `seq[:]`

---
> Как привести отрицательные индексы в срезе к положительным?

Так же, как приводятся отрицательные индексы при доступе к элементам последовательности - вычесть из длины:

```python
[1, 2, 3][-2:-1] == [1, 2, 3][1:2] == [2]
```

---
> Что задает третий параметр среза?

Шаг. По умолчанию равен `1`

---
> Что происходит, если шаг среза отрицательный?

Элементы выбираются в обратном порядке (справа налево) начиная со второго индекса среза

---
> Какое условие для индексов среза должно выполняться при отрицательном шаге?

Второй индекс должен быть меньше первого, иначе срез будет пустой:

```python
x = list(range(10))
x[8:4:-1] == [8, 7, 6, 5]
x[4:8:-1] == []
```

---
> Какой тип имеет элемент последовательности "строка"?

Тоже строка, только длиной `1`. В Python не предусмотрен специальный тип для одиночных символов

---
> Можно ли вставить в строку элемент(ы) через присваивание срезу?

Нет, нельзя, как и нельзя поменять отдельный символ: строка - это неизменяемый объект. Обе этих инструкции:

```python
"abcde"[1:1] = ["f"]
"abcde"[1] = ["f"]
```

выбросят исключение: `TypeError: 'str' object does not support item assignment`

То же верно и для кортежа, только он уже может хранить изменяемые элементы

---
> Чем являются срезы списков?

Тоже списками

---
> При присваивании значения срезу списка чем должно являться RHS?

Итерируемым объектом произвольной длины

---
> Какие существуют варианты присвоения срезу?

```python
[i:j] = [a, b, ...] # присвоение непустому срезу перезаписывает элементы
[i:j] = []          # присвоение непустому срезу пустого списка приводит к удалению элементов
[i:i] = [a, b, ...] # присвоение списка пустому срезу - это *вставка* элементов
```

В случае перезаписи размер списка может увеличиваться/уменьшаться

---
> В какую позицию идет вставка в список при указании в LHS пустого среза?

Вставляемый список начинается с индекса из среза в LHS:

```python
x = [1, 2, 3]
x[1:1] = [5, 6]
x == [1, 5, 6, 2, 3] # начало [5, 6] теперь под индеком 1
```

---
> Что происходит, если размер присваиваемого списка не совпадает с размером среза в LHS?

Размер результирующего списка увеличивается/уменьшается

---
> Что будет, если присвоить новое значение срезу `[:]`?

Список будет полностью перезаписан (по тому же адресу)

---
> Как можно применять оператор `del` к списку? Что при этом происходит с размером списка?

Можно применять как к отдельному индексу, так и к срезу:

```python
x = [1, 2, 3, 4, 5]
del x[1] # [1, 3, 4, 5]
del x[::2] # [3, 5]
```

Размер списка при этом автоматически уменьшается

---
> Какие есть in-place операции для списков?

- `L += L1` аналогична методу `L.extend(L1)`
- умножение на число `n` добавляет в конец `n-1` копию списка:  

```python
x = [1,2]
x *= 2
x == [1, 2, 1, 2]
```

---
> Что будет, если умножить кортеж или список на неположительное число?

Получим пустую последовательность:

```python
(1,2) * -2 == ()
```

---
> Как можно очистить список без использования метода `.clear()`?

```python
del x[:]  # оператором `del`
x[:] = [] # присвоением пустого списка полному срезу
x *= 0    # n <= 0
```

---
> Какие есть *немутирующие* методы у списка?

- `.count(a)` - подсчет количества вхождений элемента `a`
- `.index(a)` - возврат индекса первого встретившегося элемента `a`

---
> Что возвращает метод `list.index(a)` если `a` не найден в списке?

Выбрасывает исключение `ValueError: <a> is not in list`

---
> Какие есть аналоги `list.append(a)`?

Идет вставка в конец списка, или более простой вариант без среза:

```python
L[len(L):] = [a]
L += [a]
```

---
> Какие есть аналоги `list.extend(s)`?

Конкатенация списков, или более простой вариант без среза:

```python
L[len(L):] = s
L += s
```

---
> Какой есть аналог `list.insert(i, a)` через срез?

Вставка элемента в позицию `i`, сдвиг всех остальных вправо и увеличение длины списка на единицу:

```python
L[i:i] = [x]
```

---
> Что делает метод `list.remove(a)`?

Удаляет из списка первый встретившийся элемент равный `a`, или выбрасывает исключение, если такой элемент не найден

---
> Что делает метод `list.pop(i=-1)`?

Удаляет элемент по индексу и возвращает его значение.Без аргумента возвращает последний элемент (`[-1]`). На пустом списке или недопустимом индексе выбрасывает исключение

---
> Как обратить список?

- метод `.reverse()` (без аргументов)
- через срез: `[::-1]`

---
> Какая сигнатура у метода `list.sort`?

Сортировка in-place, метод ничего не возвращает. Аргументы только именованные:

- `key=None` - функция, применяемая к каждому элементу. Если задана, то сравниваются не `x1 <=> x2`, а `key(x1) <=> key(x2)`
- `reverse=False` - обратный порядок

> Есть еще аргумент `cmp=func`, но он признан устаревшим даже в v2

---
> Что возвращают мутирующие методы классов `list` и `set`?

Все, кроме `.pop()`, возвращают `None`: это in-place операции

---
> Какой алгоритм используется в `list.sort()`?

Устойчивый (равные элементы не меняются местами в процессе) *Timsort*, названный в честь Тима Петерса. Гибрид сортировки вставками и сортировки слиянием

---
> Почему в общем случае `list.sort()` + `list.reverse()` не то же самое, что `list.sort(reverse=True)`?

Алгоритм сортировки в методе `.sort()` *устойчивый*, он не меняет местами равные элементы

---
> В чем сходства и отличия встроенной функции `sorted()` и метода `list.sort()`?

Аргументы одинаковы (`key=None, reverse=False`), но `sorted()` возвращает значение, а `.sort()` выполняет сортировку in-place

---
> Какие есть хелперы для сортировки списков объектов и списков списков?

В модуле `operator` есть функции `attrgetter()` и `itemgetter()`, которые можно использовать в качестве `key=` в `.sort()`/`sorted()`:

```python
sorted(items, key=operator.attrgetter('price'))
[[...], [...], ...].sort(key=itemgetter(1))
```

---
> Как можно создать shallow copy для коллекции?

- классы `list`, `set`, `frozenset`, `dict` имеют метод `.copy()`. У `tuple` его нет
- классы `tuple` и `list` можно клонировать через срезы `[:]`

---
> Назовите 7 основных математических операции над множествами и их вызов для `[frozen]set`

```python
a | b | c ~ a.union(b, c)
a & b & c ~ a.intersection(b, c)
a - b - c ~ a.difference(b, c)
a ^ b ~ a.symmetric_difference(b)
a <[=] b ~ a.issubset(b)
a >[=] b ~ a.issuperset(b)
a.isdisjoint(b) ~ a & b == set() # empty
```

---
> Как добавить элемент в множество?

Методом `.add()`. Он не выполняет никаких действий и не выводит никаких ошибок, если такой элемент уже есть

---
> Как удалить элемент из множества?

- `set.discard(a)` не выполняет никаких действий и не выводит никаких ошибок, если элемента нет
- `set.remove(a)` генерирует исключение `KeyError`, если элемента нет

---
> Как можно очистить множество или словарь (удалить все элементы)?

Методом `.clear()`. В отличие от списка, срезы и `*= 0` здесь неприменимы

---
> Что делает метод `set.pop()`?

Возвращает произвольный элемент, удаляя его из множества

---
> Когда может быть полезен метод `set.pop()`?

Когда нужно одновременно обходить множество и удалять его элементы. Обход через `for` не позволяет удалять элементы (инвалидируются итераторы), а

```python
while S:
    e = s.pop()
```

отлично работает. Кроме того, такой вариант сильно экономит память для больших множеств

---
> Применима ли встроенная функция `len()` к словарям?

Да, она возвращает количество пар "ключ-значение" (= количеству ключей и значений)

---
> Что вернут функции `min()`/`max()` для словаря?

Наименьший/наибольший из *ключей*

Вообще, для любой функции, принимающей итератор, при передаче словаря работа будет идти с его ключами

---
> Что попадет в переменную `d` цикла `for d in dict():` (итерация по словарю)?

Ключи словаря, не пары

---
> Что будет при обращении к несуществующему ключу словаря на чтение? На запись? На удаление?

- при чтении несуществующего ключа будет выброшено исключение `KeyError`: `x['a']`
- а вот запись - валидная операция: `x['a'] = 1`
- при удалении то же, что и при чтении - ошибка: `del x['a']`

---
> Какой есть безопасный способ получения значения по ключу в словаре?

Метод `dict.get(<key>[, None])`. Аргумент по умолчанию не обязательный, без него вернет `None`, если ключ не существует

---
> Как у словаря получить все ключи или значения? Как получить список их пар?

Методы `.keys()`/`.values()`, и общий метод `.items()`

> Все эти методы имеют префикс `iter`, и возвращают не итераторы класса `dict_*`, а списки

---
> Назовите 2 отличия `dict.pop()` от `dict.get()`

1. `.pop(<key>)` не только возвращает значение по ключу, но и удаляет его из словаря
2. `.pop(<key>[, a])` также имеет опциональный аргумент, но если он не указан при вызове, будет выброшено `KeyError`

---
> Как из словаря получить произвольную пару "ключ-значение"?

Метод `dict.popitem()`. В отличие от `.items()`, этот метод удобно использовать для деструктивного итерирования по словарю

---
> Что делает метод `dict.update()`?

Объединяет объекты по равенству ключей. `D1.update(D2)` перезапишет все значения в `D1` значениями из `D2` при равенстве ключей. Некий аналог `Object.assign()` в JS

---
> Какие типы аргумента может принимать метод `dict.update()`?

Те же, что и конструктор `dict`:

- другой словарь или литерал словаря
- итерируемую последовательность пар
- именованные параметры (`<key>=<val>`), отдельно или в дополнение к позиционному аргументу

---
> Что делает метод `dict.setdefault()`?

У него 2 параметра: `<key>[, None]`:

- если ключа нет, то устанавливает его со значением из второго параметра (или `None`, если он не указан)
- возвращает значение по ключу

---
> Какая есть альтернатива методу `dict.setdefault()`?

Встроенный `dict.get()` (но в нем может не хватить функционала), и более быстрый и удобный класс `collections.defaultdict`

---
> В каком случае порядок ключей в словаре может нарушаться?

С v3.6 порядок ключей из литерала / порядок вставки в словарь сохраняется. Но это сохранение не гарантировано, если к словарю применялся мутирующий in-place метод (напр, `.pop[item]()`)

---
> Чего следует избегать при итерации по словарю?

Вставки/удаления (вообще изменения) ключей

---
> Могут ли `break`/`continue` принимать аргументы?

Нет, прерывают/продолжают только ближайший цикл

---
> Как можно перебрать строку посимвольно?

Строка - это просто последовательность, ее вполне допустимо использовать в цикле: `for letter in 'ciao':`

---
> Можно ли в цикле использовать расширенное присваивание с распаковкой?

Да, можно. Ровно один элемент может быть указан со звездочкой, ему будут присвоены все "лишние" элементы распаковываемого элемента:

```python
for a, *b, c in seq:
    pass
```

> Нет такой распаковки, ни в цикле ни вообще

---
> Как перебрать словарь в цикле `for`, получая сразу и ключ и значение?

Использовать метод словаря `.items()`. Он возвращает пары "ключ-значение", и в цикле они распаковываются:

```python
for key, value in d.items():
    pass
```

---
> Что может являться целевой переменной для `for`?

Всё, что поддерживает присваивание, даже, например, элемент списка:

```python
for test[1] in seq:
    pass
```

---
> Какая хорошая практика при итерации по изменяемому объекту?

Не изменять сам этот объект, будь то словарь, список или множество

---
> Можно ли присваивать целевым переменным цикла другие значения в его (цикла) теле?

Да, но перед следующей итерацией они всё равно будут автоматически переприсвоены

---
> В каких случаях целевой переменной цикла вообще не присваивается значение?

В случае пустой последовательности:

```python
for i in []:
    pass
```

---
> Какая область видимости у целевой переменной цикла?

Она доступна и вне цикла, конечно, если итерируемая последовательность не пуста:

```python
for i in [...]:
    pass
print(i) # i здесь имеет последнее назначенное в цикле значение
```

---
> Напишите код, эквивалентный циклу `for`

Функция `iter()` получает сам итератор, а функция `next()` забирает следующее значение в итерируемой последовательности (или выбрасывает исключение `Stopiteration`, если элементы закончились):

```python
_temporary_iterator = iter(c)
while True:
    try: х = next(_temporary_iterator)
    except Stopiteration: break
    <instructions>
```

---
> Как сделать объект пользовательского класса итерируемым?

Объявить методы `.__iter__()` и `.__next__()`. Именно их будут искать встроенные функции `iter()`/`next()`, неявно вызываемые при попытке итерации в циклах

---
> Что возвращает функция `range()`?

Легковесный объект, поддерживающий итерацию *по целочисленным диапазонам* (в том числе и по отрицательным)

> Объект списка. Для получения итерируемого объекта нужно использовать функцию `xrange()`

---
> Какие аргументы принимает функция `range()`?

Аналогичны числам в обозначении среза:

- начальный индекс, включается в диапазон
- конечный индекс, не включается в диапазон
- шаг, не должен быть нулем

Как и в срезе, при отрицательном шаге второй индекс должен быть больше первого

---
> Как получить итератор по диапазону или последовательности?

Вызвать builtin-функцию `iter()` на итерируемом объекте:

```python
iter(range(...)) # <range_iterator object at 0x7f2d4d111d80>
iter([...]) # <list_iterator object at 0x7f2d4cf313d0>
```

> То же, только диапазон задается другим классом: `iter(xrange(...))`

---
> Как получить список - последовательность целых чисел?

```python
list(range(i, j))
```

---
> Где можно использовать list comprehension (генератор списка)?

Поскольку это не инструкция, его можно использовать везде, где допустимы выражения. Например, в качестве аргумента функции (`f([x for x in ...])`) или как значение в `return`

---
> В чем особенность распаковки значений в списковых включениях?

Кортеж, в который идет распаковка, всегда нужно заключать в скобки, иначе ошибка:

```python
[(key, value) for x in {}.items()]
```

---
> Какой формат может иметь filter-часть в списковом включении?

Может быть стандартным условием или аналогом вложенного цикла:

```python
if <cnd>
for <e> in <seq>
```

Второй вариант можно развернуть как вложенный цикл, в котором вполне можно использовать переменную верхнего уровня:

```python
[х for sublist in <seq> for х in sublist]
# equals to
res = []
for sublist in <seq>:
    for х in sublist:
        res.append(x)
```

---
> Какая область видимости у целевой переменной в генераторе списка (list comprehension)?

Локальная. В отличие от цикла `for`, переменная `x` из `[x for x in ...]` недоступна извне, после генерации

> А здесь доступна, поведение аналогично `for`, поэтому стоит помнить и не перекрывать внешние переменные

---
> Какой синтаксис у генераторов множеств (set comprehension)?

Такой же как и у списков, но вместо квадратных скобок используются фигурные:

```python
{n//2 for n in range(10)} == {0, 1, 2, 3, 4}
```

Порядок элементов здесь не сохраняется, а дубликаты игнорируются

---
> Какой синтаксис у генераторов словарей (dict comprehension)?

Похож на генераторы множеств и списков, обрамляющие скобки - фигурные, а значение в map-части записывается через двоеточие:

```python
{n:n//2 for n in range(5)} == {0: 0, 1: 0, 2: 1, 3: 1, 4: 2}
```

---
> Можно ли использовать `break`/`continue` вне цикла?

Нет, будет выброшена `SyntaxError`

---
> Как меняется поведение `break`/`continue`, если они вызваны внутри `if`?

Не меняется, эти инструкции не реагируют на дополнительную вложенность и всё так же прерывают/продолжают ближайший цикл

---
> Какой частый кейс использования `continue`?

Уменьшение вложенности `if`-ов внутри цикла. Это может быть одной из реализаций принципа из дзен Python-а "плоское лучше чем вложенное"

---
> При каких условиях выполняется `else` после циклов?

Если цикл завершился "естественным" образом: исчерпался итератор в `for` или условие в `while` стало ложным

В случае выхода из цикла по `break` код в `else` не выполнится

---
> Для каких циклов доступен блок `else`?

Для обоих, и для `for` и для `while`

---
> Выполнится ли блок `else:` после цикла `for` с пустой последовательностью?

Да, т.к. выход был по исчерпанию (пустого) итератора, не по `break`:

```python
for x in []:
    pass
else:
    print('Это будет напечатано')
```

---
> Какое есть альтернативное применение инструкции `pass`?

В качестве заглушки в сложной системе условий `if`. В случае, если в некоторых внутренних `if` не нужны никакие действия, но сами эти условия из цепочки убрать трудно, можно записать в них `pass`: Python не допускает пустого тела для составных инструкций

---
> Какие есть альтернативы использованию `pass` в пустых объявлениях функций (`def`) и классов (`class`)?

Строки документации (docstring). Если такая строка есть, добавлять `pass` уже не нужно (хотя ошибкой и не будет). Автор рекомендует именно docstring-и в качестве заглушек

---
> Назовите 5 ключевых слов языка, относящихся к обработке исключений

```python
try
except
finally
else
raise
```

---
> Какую инструкцию можно использовать вместо `try`/`finally`?

Менеджер контекста `with`

---
> Что вернет функция без инструкции `return`?

`None`. Это не Groovy, результат последнего выражения Python не возвращает

---
> Можно ли передавать функцию как аргумент в другую функцию?

Да, можно. Функции в Python являются объектами первого класса

---
> Можно ли использовать функцию в качестве ключа в словаре?

Да, можно. У ее класса определен метод `.__hash__()`

---
> Что такое *именованные параметры*?

Фактически это аргументы по умолчанию: они обязаны иметь дефолтное значение, иметь синтаксис `<name>=<value>`. Также они обязаны идти после позиционных (обязательных) параметров

---
> В какой момент определяется значение именованного параметра?

Единожды, в момент объявления функции (в момент выполнения инструкции `def`). Это может приводить к неожиданному поведению для изменяемых объектов, например, для списков

---
> Как правильно использовать изменяемые объекты в качестве значений именованных параметров?

Не задавать их в сигнатуре функции, а присваивать каждый раз в теле:

```python
def f(x, y=None):
    if y is None: y = []
    ...
```

----
> В каких случаях всё же может понадобится использование изменяемых объектов в качестве значений именованных параметров?

Например, для *мемоизации* - кеширования результатов затратных операций:

```python
def cached_compute(x, cache={}):
    if х not in cache:
        cache[x] = costly_computat1on(x)
    return cache[x]
```

Хотя даже в этом случае лучше использовать декорирование с помощью функции `functools.lru_cache`

---
> Что означают параметры `*args` и `**kwargs` в сигнатуре функции?

Позволяют передавать любое количество дополнительных параметров:

- `*args` - позиционных; кортеж
- `**kwargs` - именованных; словарь

---
> В каком порядке в сигнатуре функции должны идти `*args` и `**kwargs`?

Сначала кортеж позиционных (`args`), потом словарь именованных (`kwargs`):

```python
f(..., *args, **kwargs):
    pass
```

---
> Фиксированы ли имена для `*args` и `**kwargs`?

Нет, имена могут быть любыми. Так, например, вместо `**kwargs` часто используют `**kwds`

---
> Сохраняется ли порядок ключей в `**kwargs`?

Да, с v3.6, как и для любых словарей. Ключи идут в том порядке, в котором именованные параметры указаны при вызове

---
> Как задать параметры, которые могут быть указаны *только как именованные*?

Указать их в объявлении функции после `*[args]` (но до `**kwargs`). Такие параметры не обязаны иметь значение по умолчанию:

```python
def f(a, *, Ь, с=56):
def g(x, *а, Ь=23, **k):
```

Последовательность `*args`, либо хотя бы звездочка от нее, присутствовать обязана

---
> Какие у функции есть "магические" (dunder) атрибуты?

- `__name__` - собственно имя функции, указанное при объявлении (после `def`)
- `__defaults__` - кортеж значений по умолчанию для необязательных параметров (`None` если нет необязательных параметров)
- `__doc__` - строка документации (`None` если не указана)

---
> Как расшифровывается *docstring*?

*Documentation string*

---
> Для чего могут использоваться docstrings?

- в качестве комментариев для разбирающих код
- для показа при вызове `help()` и генерации документации вообще
- для хранения тестов в формате doctest

---
> Каков рекомендуемый формат docstring?

- первая строка содержит краткое описание функции, начинается с большой буквы и заканчивается точкой. Само имя функции в ней не упоминается
- потом пустая строка-разделитель
- дальше более подробное описание в виде текста, разделенного пустыми строками на несколько абзацев
- оно содержит описание параметров функции, предусловий, возвращаемого значения, побочных эффектов
- в конце могут размещаться примеры использования в формате doctest, и любая другая вспомогательная информация

---
> Можно ли задать пользовательской функции произвольный атрибут?

Да, можно привязать его прямо к имени. Например:

```python
def counter():
    counter.count += 1
    return counter.count

counter.count = 0
```

Вообще, такой подход не рекомендуется, лучше использовать ООП

---
> Что такое *аннотации* в сигнатуре функции (в общем случае)?

Произвольные выражения, которые можно указать после каждого параметра после двоеточия (`a: 'some'`) и для возвращаемого значения - после закрывающей круглой скобки со стрелкой (`) -> 'some'`). При таком объявлении аннотации окажутся в атрибуте-словаре `__annotations__` функции:

```python
def f(a:'foo', b)->'bar':
    pass

f.__annotations__ == {'a': 'foo', 'return': 'bar'}
```

Сам по себе Python никак не использует эти аннотации, а лишь создает атрибут

---
> Зачем нужны аннотации типов?

Сам Python не проверяет типы, и рассматривает аннотации просто как произвольные выражения. Но IDE, статические анализаторы и линтеры могут их использовать, проверяя корректность кода


---
> Какой пакет отвечает за аннотацию типов?

Модуль стандартной библиотеки `typing`. Доступен с v3.5. Для встроенных типов его импортировать не нужно

---
> Как пишутся аннотации типов для переменный и полей класса?

Двоеточие с выражением после имени, но перед значением:

```python
price: int = 5
title: str
...
class Book:
    title: str
    author: str
```

---
> Как указать аннотацию опционального типа?

Импортировать `typing.Optional` и указать тип в квадратных скобках:

```python
from typing import Optional

amount: int
amount = None  # Error

price: Optional[int]
price = None # Ok
```

---
> Как указать в аннотации произвольный тип?

Импортировать `typing.Any` и указать его:

```python
from typing import Any

unknown_item: Any = 1
```

---
> Как в аннотации указать, что переменная может быть нескольких (разных) типов?

Импортировать `typing.Union` и перечислить типы в квадратных скобках:

```python
from typing import Union

x: Union[int, float]
```

---
> Как в аннотации указать тип коллекции?

Импортировать `typing.<type>` и указать тип элементов коллекции в квадратных скобках:

```python
price_with_title: Tuple[int, str] = (1, "hello")
book_authors: Dict[str, str] = {"Fahrenheit 451": "Bradbury"}
def generate_two() -> Iterable[int]:
```

---
> Как в аннотации указать, что функция не возвращает значение?

```python
def forever() -> NoReturn:
```

`NoReturn` нужно импортировать из `typing`

---
> Можно ли использовать `return` вне функций?

Нет, это синтаксическая ошибка `SyntaxError: 'return' outside function`

---
> Какое есть стилистическое соглашение о `return None`?

Использовать его только если в функции есть другие `return`, возвращающие значение. Таким образом достигается единообразие в инструкциях возврата

Кроме того, функцию не рекомендуется завершать пустой инструкцией `return`

---
> В какой позиции относительно `*args` должны идти аргументы со значениями по умолчанию?

Могут идти как до, так и после. Только в первом случае они просто позиционные с дефолтными значениями, и могут указываться как угодно, а во втором могут быть указаны исключительно как именованные:

```python
def f(a, b, c=23, d=42, *x):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 3 4 (5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()

# но

def f(a, b, *x, c=23, d=42):
    print(a, b, c, d, x)

f(1, 2, 3, 4, 5, 6) # 1 2 23 42 (3, 4, 5, 6)
f(1, 2, d=3, c=4) # 1 2 4 3 ()
```

---
> Можно ли указывать позиционный аргумент как именованный?

Да, вполне:

```python
def f(x):
    print(x)

f(1) # 1
f(x=1) # 1
```

---
> Как можно передать в функцию словарь именованных аргументов?

Через оператор распаковки:

```python
f(**{'a': 1, 'b': 2, ...})
```

---
> Сколько пространств имен в Python?

Три: локальное (внутри функций), глобальное (весь скрипт) и встроенное (built-in, автоматические импортируемые функции и классы)

---
> Как внутри функции интерпретатор различает локальные и глобальные переменные?

Сначала в любом случае ищется локальная переменная. Если она не найдена - то в зависимости от типа обращения:

- если обращение на чтение, то ищется глобальная переменная с таким именем
- если обращение на запись, то выбрасывается исключение `UnboundLocalError: local variable '<var>' referenced before assignment`

Обращений на чтение всегда больше и они безопасны. Таким образом, Python и не принуждает постоянно писать `global` (а делает неявный поиск если нужно), но и не дает случайно перезаписать глобальную переменную - для этого нужно явно выразить намерение инструкцией `global <var>`

---
> Что делает ключевое слово `global`?

Указывает интерпретатору, что внутри функции нужно использовать для записи переменную из глобальной области видимости, а не локальную - т.е. связывает указанное имя с глобальной областью. Использование этой директивы не рекомендуется

В этой директиве могут быть указаны несколько переменных (через запятую):

```python
global <var1>, <var2>, ...
```

---
> Что делает ключевое слово `nonlocal`?

Открывает на запись переменную из внешней функции, из той, внутри которой объявлена текущая функция. Функции перебираются в порядке вложенности. Глобальная область видимости при разрешении имен при этом не просматривается

> Такого ключевого слова нет. Его можно сымитировать, сделав внешнюю переменную изменяемым объектом, и записывая в один из ее элементов (напр., `count[O] += 1`)

---
> Как создать глобальную переменную внутри функции?

Указав ее имя в директиве `global` и присвоив значение:

```python
def f():
    global x
    x = 1

f()
print(x) # 1
```

Присваивание обязательно: `global <var>` не является "объявлением" переменной

---
> Что происходит, если в функции инициализирована одноименной глобальной переменная?

Она *скрывает* глобальную, все обращения идут к локальной

---
> Что будет, если в `global` указать имя переменной, которой не существует в глобальной области видимости?

Ничего, ошибок не будет, как не будет и создана переменная. Для создания нужно после указания в `global` еще и инициализировать эту переменную. До инициализации переменной не существует, даже проверять ее нельзя

---
> Что такое нелокальные и глобальные переменные?

- *нелокальные* - (также *свободные*) переменные из внешней функции, внутри которой объявлена текущая функция
- *глобальные* - переменные, созданные вне функций, в скрипте

---
> Внутри вложенной функции, чем отличаются и чем схожи нелокальные и глобальные переменные?

Сходства:

- могут скрываться локальными переменными
- неявно доступны на чтение
- требуют явного разрешения на запись через директивы

Различия:

- директивы, разрешающие их запись, разные: `global` и `nonlocal`
- в отличие от `global`, создать нелокальную переменную (переменную внешней функции) через `nonlocal` + присваивание нельзя

---
> Что называется *замыканием*?

Вложенная функция, получающая значения из внешних локальных переменных:

```python
def make_closure(x):
    def g(n):
        return x + n

    return g

closure7 = make_closure(7)
closure11 = make_closure(11)

print(closure7(3), closure11(4)) # 10 15
```

Нелокальные переменные (свободные переменные внешней функции) могут быть как параметрами, так и просто переменными внутри функции. Внутренняя функция "захватывает" их в момент объявления. Немного напоминает каррирование

---
> В каком порядке ищется переменная при указании директивы `nonlocal`?

Изнутри наружу, перебирая вложенные функции, начиная с ближайшей. Если не найдена, то выбрасывается исключение `SyntaxError: no binding for nonlocal '<var>' found`. Глобальная область не просматривается, одноименные переменные в ней не учитываются

---
> В чем сходство ООП и замыканий?

Внешняя функция замыкания, как и объект, хранит некоторые данные, состояние. Таким образом, функция-фабрика позволяет создавать независимые варианты других функций-замыканий

```python
def make_counter():
    _count = 0
    def counter():
        nonlocal _count
        _count += 1
        return _count

    return counter

c1 = make_counter()
c2 = make_counter()

print(c1(), c1(), c1()) # 1 2 3
print(c2(), c2()) # 1 2
```

---
> Что возвращает функция `filter()`?

Генератор

> Список

---
> Что такое *генератор*?

Функция, содержащая одно или несколько ключевых слов `yield`. Такая функция при вызове не выполняется, а лишь возвращает специальный *объект генератора*, обертывающий саму функцию, ее переменные и текущую точку выполнения. По вызову метода `next` с этим возвращенным объектом функция выполняется от текущей точки до следующего `yield`

---
> Какие есть преимущества у генераторов?

- генераторы гибче списков, и могут использоваться везде, где и итерируемые объекты
- генераторы выполняют "ленивые" вычисления, что может вести к сокращению расхода памяти
- могут возвращать неограниченный итератор для использования в циклах, прерываемых по `break`

Генератор в любой момент можно преобразовать в список через `list(g(<args>))`

---
> Когда завершается выполнение генератора?

По достижению конца функции или вызову `return`. Выбрасывается исключение `StopIteration`, которому, в качестве аргумента, передается значение из `return`

> Инструкции `return` в генераторе не могут содержать выражения, допустимы только пустые

---
> Что возвращает пустой `yield`?

То же, что и пустой `return` - `None`

---
> Напишите генератор - аналог `range()` для чисел с плавающей точкой

```python
def frange (start, stop, stride=1.0):
    while start < stop:
        yield start
        start += stride

for i in frange(1.0, 10):
    print(i)
```

---
> Для чего используется инструкция `yield from`?

Синтаксический сахар для возврата очередного значения из итератора:

```python
for x in <iter>:
    yield x
# ~
yiled from <iter>
```

> Такой инструкции нет

---
> Что такое выражения-генераторы?

То же, что списковое включение (list comprehension), только без физического создания списка. Вместо внешних квадратных скобок используются круглые, которые даже не нужны, например, при передаче в функцию:

```python
sum([х*х for х in range (10)]) # список
sum(х*х for х in range (10)) # генератор
```

Они выполняются "лениво", и требуют меньшего объема памяти, хотя и могут выполняться медленнее

---
> Как передать значение генератору?

Вызовом функции `send():`

```python
<gen-obj>.send(<val>)
```

Это значение будет возвращено `yield` при следующем вызове:

```python
<val> = yield <...>
```

---
> Какая по дефолту глубина рекурсии в Python? Как ее можно изменить?

Глубина стека по умолчанию - 1000 (тысяча) вызовов, можно получить через `sys.getrecursionlimit()`. Можно поменять вызовом функции `sys.setrecursionlimit()`

При исчерпании стека выбрасывается исключение `RecursionLimitExceeded`

---
> Как Python работает с хвостовой рекурсией?

Оптимизации хвостовой рекурсии в языке нет

---
> Какой структурой данных можно представить в Python бинарное дерево? Каким типом алгоритма его обходить?

Например, кортежем, где нулевой элемент - значение узла, а первый и второй - такие же кортежи для левого/правого узлов:

```python
(23, (42, (5, None, None), (55, None, None)), (94, None, None))
```

Обойти такое дерево можно рекурсивным алгоритмом ([p.145])
