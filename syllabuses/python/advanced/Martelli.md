# Генераторы, `[generators]`

---
> Что такое *функция-генератор*?

Функция, содержащая одно или несколько ключевых слов `yield`. При ее вызове не происходит выполнения тела функции, а возвращается т.н. *объект-генератор*, обертывающий тело функции, ее локальные переменные и текущую точку выполнения.

---
> Что такое *объект-генератор*?

Возвращенный функцией-генератором объект, реагирующий на вызов `next()`, возвращающий при этом:

- результат очередного вызова `yield`
- или выбрасывающий `StopIteration`, если выполнение функции завершено или вызван `return`

Метод `next()` каждый раз возобновляет выполнение генератора с точки последнего `yield`.

---
> Какую идиому реализуют генераторы?

Неявное создание итераторов/списков. Так, вместо

```python
def f():
    result = []
    for i in some_list:
        result.append(<expr-with-i>)

    return result
```

можно написать более простую функцию, которая при этом использует "ленивые" вычисления, и не занимает память под целый список `result`:

```python
def f():
    for i in some_list:
        yield <expr-with-i>

```

---
> Какой наиболее типичный случай использования генераторов?

В самом типичном случае использования итераторов - в циклах `for`. Там неявно происходит вызов `next()`.

---
> Чем по сути является `yield`?

Не инструкцией, а выражением: ему можно передать значение, которое потом можно присвоить другой переменной.

---
> Как передать значение `yield`?

Через вызов метода `.send()` на объекте-генераторе:

```python
def gen():
    ...
    x = yield y

g = gen()
g.send(<new-x-value>)
```

---
> Чему будет равно значение `yield` после вызова `.next()` на объекте-генераторе?

```python
None
```

---
> Напишите генератор, получающий на вход число `N`, и выдающий последовательность натуральных чисел до `N` сначала в возрастающем порядке, а потом в убывающем (`3` -> `1 2 3 2 1`)

Через 2 цикла:

```python
def updown(n):
    for i in range(1, n):
        yield i
    for i in range(n, 0, -1):
        yield i
```

---
> Напишите генератор - упрощенную версию `range()` для чисел с плавающей точкой

Для упрощения параметры `start`/`stop` обязательные, и первый меньше второго:

```python
def frange(start, stop, step=1.0):
    while start < stop:
        yield start
        start += step
```

---
> В чем отличие перебора итераторов/генераторов от перебора списков?

Он может быть *неограниченным*, выдавать бесконечный поток результатов, тогда как длина списка всегда конечна.

---
> Как привести итератор/генератор к списку?

Передать его в конструктор:

```python
list(gen(<args>))
```

---
> Как можно упростить этот код?
> 
> ```python
> for i in some_list:
>     yield i
> ```

Использовать конструкцию `yield from`:

```python
yield from some_list
```

---
> Что такое *выражения-генераторы* (generator comprehension)?

Особый синтаксис записи простых генераторов, схожий со списковыми включениями (list comprehension), только записывается в круглых скобках:

```python
x = (x**2 for x in range(3))
list(x) == [0, 1, 4]
```

Для передачи таких выражений в функции дополнительных круглых скобок не требуется:

```python
sum(x*x for x in range(10))
```

---
> В чем схожесть генераторов и сопрограмм (корутин)?

В возможности обратной связи между вызывающим кодом и генератором. Т.к. `yield` является выражением, а не инструкцией, ему можно отправить значение:

```python
# отправка None
next(g) # ~ g.send(None)
# отправка val
g.send(val)
```

---

# Рекурсия, `[recursion]`

---
> 
