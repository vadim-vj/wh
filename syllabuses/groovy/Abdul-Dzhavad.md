### Башар А.-Дж., Groovy and Grails. Практические советы
<https://dmkpress.com/catalog/computer/programming/java/978-5-94074-618-8/>

---

#### Отличия от Java и просто плюсы языка:
- краток, позволяет быстро написать короткий скрипт, не заворачивая всё в классы
- все типы являются объектами (напр., `int` = `java.lang.Integer`). Это полезно, т.к. элементами коллекций в Java могут быть только объекты
- перегрузка операторов для пользовательских типов (так ли?)
- поддержка коллекций на уровне языка
- замыкания, билдеры, диапазоны, метапрограммирование в Java или отсутствуют, или неудобны
- тестовые инструкции `assert`
- компилируется в байткод Java, программы могут состоять и из Groovy, и из Java-кода одновременно
- точка с запятой, круглые скобки, перехват исключений и `return` необязательны
- файл читается в две строки, за счет встроенного (через GDK) объекта `File`, итерации по строкам через `eachLine`, и вывода через `println`
- код может быть оформлен как в виде скриптов, так и в виде классов

#### Пакет программы:
- `groovysh` - REPL
- `groovyConsole` - графическая консоль
- `groovyc [*.groovy]` - компилятор, создает файлы `*.class`, которые можно выполнить командой `java`
- `groovy` - компиляция + запуск, файлы не создаются, сразу в память

#### Более подробное сравнение Java и Groovy
- деление когда два операнда целочисленные, результат: Groovy - с плавающей точкой, Java - целочисленный
- оператор `==`: в Java идентичность, в Groovy эквивалентность (?)
- Груви по умолчанию импортирует некоторые пакеты, типа `Java|Groovy.lang|util`
- точка с запятой в Груви обязательна только если два выражения на одной строке, иначе можно (и нужно) ее опустить
- круглые скобки (напр., в `println`) необязательны. Но автор рекомендует их всё же добавлять
- необязательно определять тип возвращаемого значения у функций, с ключевым словом `def` компилятор выведет его сам
- `return` необязателен, возвращается последний стейтмент
- GroovyBeans: геттеры/сеттеры в формате `def get<Name>() { ... }`, позволяют обращаться к полям через `obj.name`
- модификатор доступа до членов класса по дефолту: Java - `default` (доступ только из пакета где класс определен), Groovy - `public` (доступны где угодно)
- Груви автоматически обертывает исключения в `RunTimeException`, нет необходимости в `try/catch` (?)
- утверждения (`assert`) более широко используются (вместо комментариев) и более мощные, чем в Java: поддерживают любой тип (пустые коллекции и строки, null-ссылки и числа равные нулю ~ `false`)
- утверждения в Груви не могут быть отключены, выполняются всегда. Можно выбрасывать исключения - `assert <...>, "Exception text"`
- замыкания: `{[arg1, arg2, ..., argN -> ] <statements>}`. Анонимные функции, могут быть переданы, присвоены и выполнены
- поддержка коллекций на уровне языка
- списки `[a1, a2, ...]`:
  * элемент может быть любого типа
  * в отличие от Java-массивов, имеют нефиксированную длину
  * хотя в груви можно использовать и массивы (`new Object[4]`)
  * приведение списка к массиву: `[].toArray()`
  * размер списка: `a.size`
  * доступ до элементов: `a[2]`/`a[-1]`/`a.get[At](0)`
  * добавление элемента: `a += [el1, el2, ...]`/`a << el`/`a.add(el)`
  * изменение элемента: `a.putAt(1, el)`/`a.set(2, el)`
  * удаление: `a -= <index>`/`a.minus([...])` (второй - удаление подсписка)
  * обход: `a.each{ println "$it"}`/`a.eachWithIndex{it, index -> println item : "$it", index : "$index"}`
- карты `['<key>': 'value']` (аналог объектов в JS):
  * ключи могут быть любого типа
  * ~~ключи задаются в кавычках (`def a = ['city': ...]`)~~ нет, можно и без кавычек, но обращаться (только на чтение?) к ним можно без кавычек (`a.city`)
  * ключи уникальны: `assert ['name':'Bashar','name':'Abdul'] == ['name':'Abdul']`
  * обращение к элементу: `a.city`/`a['city']`/`a.get[At]('city')`
  * добавление: `a += ['<key>': '<value>']`/`a['<key>'] = '<value>'`
  * обход такой же, как для списков: `map.each{ it -> println it.key + ":" + it.value}map.eachWithIndex{ it, index -> println "item $index - " + it.key + ":" + it.value}`
- диапазоны `<start>..<end>` (две точки)
  * могут иметь разные типы, напр., `def range = 'a'..'c'`
  * исключение последнего элемента: `1..<8`
  * обход: `(1..5).each{println it}`
  * секционирование (создание списка): `assert [*1..4] == [1,2,3,4]; assert [1,*2..4] == [1,2,3,4]` (может стоять в любой позиции)
- метапрограммирование - расширение классов, переадресация обращений к методам через метакласс класса. Груви так расширяет стандартные классы из `java.lang|util`. Рассматривается ниже
- строки GString (`groovy.lang.GString`) поддерживают внутри себя плейсхолдеры (`“Hello, my name is ${name}”`)
- регулярные выражения, их операторы: шаблона - `~template`, поиска - `=~`, соответствия - `==~`
- GDK расширяет около 60 стандартных классов JDK. Содержит методы для списков (`[].any()`/`[].every()`/`[].collect()`/etc.), для чисел (`def x = 10`, `x.abs()`/`x.downto()`/`x.compareTo()`/etc.), для файлов (`def f = new File('...')`, `f.exists()`/`f.text`/`f.renameTo()`/`f.append()`/etc.) и другие
- строки в Груви:
  * тройные кавычки дают поддержку многострочных литералов
  * обычные Java-строки с поддержкой некоторых доп. методов (`''.size()`/`''.substring()`/`''.replace()`/etc). Одинарные и тройные одинарные кавычки
  * Groovy-строки с плейсхолдерами (они вычисляются в момент выполнения программы). Двойные и тройные двойные кавычки
- регулярные выражения удобно определять как строку в прямых слешах (`/.../`), т.к. внутри такой строки не нужно экранировать обратные слеши
- динамическая типизация - через `def`:
  * можно переприсваивать переменной разные типы: `def var = 1; var = '...'`
  * Groovy - типобезопасный язык, вот это - `def var = 15; assert var == "15"` - вызовет исключение
  * то есть всегда нужно явно приводить типы - `Integer.parseInt("15")`
  * статическая типизация тоже допустима (`int var = 1`), но переприсвоить переменной значение другого типа уже нельзя
  * Груви всё же может иногда сам делать неявные преобразования типов, напр., дробные числа в целые
  * проверка типа - через оператор `in` и поле `.class`: `int var = 1; assert var.class in Integer`
  * еще через `instanceof`: `other instanceof RomanNumber`
  * говорит что выбор между статической и динамической типизацией не простой, но тут же рекомендует использовать динамическую
- перегрузка операторов:
  * все операторы преобразуются в вызовы методов (напр., `1 + 1` ~ `1.plus(1)`)
  * оператор `==` в Груви отличается от Явы и преобразуется в `a.equals(b)` (и `a != b` ~ `!a.equals(b)`)
  * перед применением оператора `==` Groovy делает приведение типов (так, `assert 5 == 5.0` вернет `true`, а `assert 5.equals(5.0)` - ошибку)
  * перегрузка оператора делается просто переопределением метода в классе
  * все операторы сравнения в Groovy null-безопасные, т.е. `null`-значения обрабатываются штатно, и `NullPointerException` не выбрасывается (?)

#### Интеграция Groovy и Java
- компиляция в байткод (в *.class файлы)
- в Java-коде можно вызвать GroovyShell: `new GroovyShell(new Binding()).evaluate('<code>')` (eval такой)
- тот же eval на уровне файлов скриптов: `new GroovyScriptEngine('<dir>').run('<file>', new Binding())`
- классы же лучше загружать через `new GroovyClassLoader().parseClass(new File(...)).newInstance().invokeMethod('<method>')`
- "Java Specification Request (JSR) 223: Scripting for the Java Platform" дает интеграцию с разными скриптовыми языками: `new ScriptEngineManager().getEngineByName("groovy").eval('<code>')`

#### Типы данных
- делятся на:
  * простые: строки, регулярные выражения и числа
  * коллекции: списки, карты и диапазоны
- строки:
  * как и в Java - неизменяемы
  * обычные (`java.lang.String`) и GString (`groovy.lang.GString`), Groovy автоматически приведет типы, если они используются совместно
  * строка считается GString, если она заключена в [тройные] двойные кавычки и содержит знак доллара: `"$firstWord ${secondWord.reverse()}"`
  * подстановки высчитываются динамически, в рантайме, не при компиляции
  * может быть объявлена через `new String('...')` или даже как `def s = ['h','e','l','l','o'] as char[]`
  * класс `Object` содержит метод `.toString()`
  * строки содержат много разных методов: поиск, замена, обращение, токенизация и т.д. Методы вызываются как `'...'.<method>()`
  * на строках работают операторы: `'...' + '...'` - конкатенация, `'...' - '...'` - удаление подстроки, `'...' * N` - повторение строки N раз, `'...' > '...'` - (и другие) сравнение строк
  * для поиска min/max и прочего, строку нужно перегонять в список (`'...'.toList()`) и уже на нем искать
  * классы `StringBuffers` и `StringBuilders` являются изменяемыми и позволяют изменять строки (?)
- регулярные выражения:
  * слеш-синтаксис `/.../` всё так же определяет строку, просто так удобней не экранировать обратные слеши
  * используются классы `Pattern` и `Matcher` (`import java.util.regex.*`)
  * оператор шаблона (тильда) компилирует строку в шаблон: `p =  ~/\b[a-zA- Z]\b/` ~ `Pattern p =  Pattern.compile(“\\b[a-zA- Z]+\\b”)`
  * оператор поиска (равно-тильда) сразу и компилирует правый операнд в шаблон, и сопоставляет с левым операндом: `("Groovy" =~ /G.*/).matches()` ~ `Pattern.compile("G.*").matcher("Groovy").matches()`
  * объект класса `Matcher` по сути - двумерный массив. Кол-во строк = кол-ву найденных совпадений (напр., `matcher[3]`), каждое совпадение внутри разделено на группы по круглым скобкам в регекспе (напр., `matcher[3][2]`)
  * оператор соответствия (двойное равно-тильда) возвращает булево значение, найдено ли хоть что-то: `assert "Groovy" ==~ /G.*/`
  * регекспы можно использовать в методах `.replace()` класса `String`. В этих методах также можно указывать (анонимную) функцию, применяемую к каждой найденной группе
  * метод `.grep(<regexp>)` позволяет фильтровать коллекции
- числа:
  * целые числа являются экземплярами классов `Integer`, `Long` (`l`) или `BigInteger` (`g`), компилятор сам выводит класс по литералу, или можно указать суффикс (см. ранее в скобках)
  * для дробных чисел есть экспоненциальная запись: `5.0e+2`, `5.0e-2`, `-1.0E3`, `-4E-6`
  * дробные принадлежат классам `Float` (`f`), `Double` (`d`) и `BigDecimal`
  * деление в Груви дробное, для целочисленного нужно привести к `int` (`(int)(1 / 2)`) или использовать `intdiv` (`1.intdiv(2)`)
  * долго и нудно про то, какой тип имеет результат операций с разными дробными типами
  * т.к. в Груви всё является объектом, вызов методов напрямую на числах вполне допустим. + определяются несколько полезных методов, типа `3.abs()` и побитовых операций
  * через методы целых чисел можно организовывать циклы с вызовом замыкания на каждой итерации: `5.downto(0) {...}`, `0.upto(5){...}`, `10.times{...}`, `2.step(10, 2){...}`
  * (вводится в контексте сложения чисел) оператор безопасного доступа `?.` позволяет обращаться к методам класса без проверки объекта: `a = null; assert a?.plus(3) == null`. `NullPointerException` при этом не выбрасывается
- списки:
  * по умолчанию являются экземплярами класса `java.util.ArrayList`
  * может содержать объекты разных типов, в том числе другие списки
  * доступ до элементов - через оператор индекса (квадратные скобки `[]`), методы `.get()` и `.getAt()`
  * добавление элемента - через операторы `+`/`+=`, `<<` или методов `.plus()` или `.add()`
  * метод `.flatten()` *выравнивает* списки - элементы-списки разворачиваются, их элементы становятся частью родительского списка. Можно это делать сразу во время добавления элемента: `a.add([7,8]).flatten()` ~ `a.addAll([7,8])`
  * удаление элемента - через операторы `-`/`-=`, методы `.minus()` или `.remove()` (последний работает по индексу или по самому элементу)
  * итерация по списку - `.each[WithIndex]{...}`, `.collect{...}` - аналог `.map()` в JS
  * методы `find`, `findAll`, `every` и `any` - поиск элемента(ов) по условию, `.sum()`/`.min()`/`.max()`, `.join()`, `.reverse()`, `.sort()` - тут понятно
  * (вводится в контексте поиска минимального элемента) оператор `switch` может работать с любым типом данных
- карты (аналог объектов в JS):
  * по умолчанию являются экземплярами класса `java.util.LinkedHashMap`
  - пустая карта: `[:]`
  * т.к. использование точки в картах зарезервировано для получения значения по ключу, использовать геттеры GroovyBeans можно только напрямую - `map.getClass()`, не ~~`map.class`~~
  * доступ до элементов - через операторы точка (`a.name`), индекса (квадратные скобки `a.['name']`), методы `.get()` и `.getAt()`
  * если ключ не существует, возвращается `null`; второй параметр `.get()` - значение по умолчанию
  * добавление - через квадратные скобки (`map["title"] = '...'`), методы `.put[At]()`, удаление - через `map.remove('<key>')`, изменение - через `map.<key> = ...`
  * переменная как ключ - через круглые скобки: `[(language):(description)]`. Почему тут значение так же используется?
  * итерация по карте - `.each[WithIndex]{...}`, `it` внутри замыкания - карта с ключами `key`/`value`
  * получение ключей/значений - методы `.keySet()`/`.values()`
  * разные методы - `.contains(Key|Value)()`, `.collect()` (аналог `.map()` в JS), `.findAll()`
- диапазоны:
  * задаются через две точки `'a'..'b'`, можно исключать последний элемент - `1..<10`
  * объявление диапазона внутри списка даст новый элемент-список (секционирование, slicing) - `assert [1..3] == [[1,2,3]]`, а оператор `*` произведет выравнивание (flattenning) - `assert [*1..3] == [1,2,3]`
  * диапазон как индекс списка вернет соответствующий подсписок: `a = [1,2,3,4,5]; assert a[0..2] == [1,2,3]`
  * метод `.toList()`, как и для карт, создает список из другого типа коллекции (зд. из диапазона) - `('a'..'z').toList()`
  * итерирование по диапазону такое же: `.each[WithIndex]{...}`
- Groovy Truth: непустые коллекции, ненулевые числа, непустые строки, macther-ы с найденным совпадением

#### Управляющие структуры:
- есть стандартный `if` и тернарный оператор `?:`
- `switch`:
  * в отличие от Java принимает в условии (`switch (<cnd>) {...}`) не только `int`, но вообще любые типы
  * в `case <cnd>` может принимать любой объект, имеющий метод `.isCase()`. GDK добавляет реализацию этого метода для многих классов: `Class` - является ли экзмепляром, `Collection`/`Range` - содержится ли в, `Pattern`/`String` - совпадает ли с паттерном/строкой
  * стандартный `break` и возможность прохода по нескольким условиям
- циклы:
  * стандартный `while` со всем, что преобразуется в Groovy Truth
  * стандартный `for` со счетчиком: `for (int i = 0; i < 10; i++)`
  * Java-вариант: `for (Integer i : list)` (???)
  * `for` для перебора коллекций: `for (var in iterable) {body}`
  * для многих классов вмесо циклов можно использовать их (классов) методы, такие как: `.each()`, `.eachWithIndex()` и `.collect()`

#### Объектно-ориентированный Groovy
- любой код Груви, находящийся вне класса, называется *скриптом*
- компилятор преобразует скрипты Груви в Java-классы `groovy.lang.Script`
- если файл содержит только один класс, при компиляции будет создан один файл `<class-name>.class`. Имя исходного Groovy-файла при этом не обязано совпадать с именем класса, объявленного в нем (в отличие от Java)
- если классов несколько, то и файлов `.class` будет создано несколько. Опять же, имя файла не обязано совпадать ни с одним из них
- если содержит только скриптовый код, то компилятор сохранит имя файла, будет `<file-name>.groovy ---> <file-name>.class`
- если файл смешивает скриптовый код и классы, то имя файла не должно совпадать ни с одним из имен классов, компилятор выдаст ошибку: два одноименных `.class`-файла получаются
- рекомендации автора:
  * один главный класс + несколько вспомогательных (классов, использующихся только здесь) на файл
  * не смешивать скриптовый код и классы
  * и вообще, меньше скриптового кода
- пакеты:
  * рекомендуется их использовать
  * объявляются вверху файла с классом, `package myclasses`. Компилятор при этом создаст файл `<class-name>.class` внутри каталога `myclasses`
  * можно использовать и в скриптах, так же поместит их в подкаталоги
  * компилятор ищет файлы начиная с каталога `classpath`, и перекомпилирует только если файлы были изменены с последней компиляции
- синонимия типов:
  * ключевое слово `as` при импорте
  * помогает избежать конфликта имен и при этом не использовать полные имена классов. Напр., `import java.sql.Date as SQLDate`
  * можно импортировать класс из библиотеки под другим именем, и унаследовать от него класс с исходным именем - подменить реализацию: `import library.HelloWorld as HelloWorldEnglish; class HelloWorld extends HelloWorldEnglish {...}`
- наследование: ключевое слово `extends`, множественного наследования нет
- интерфейсы так же как и в Java, через `interafce`/`implements`
- в Groovy можно приводить карты к типу класса/интерфейса через `[...] as SomeClass`. Так же, через `as`, можно приводить замыкания к классам/интерфейсам с единственным методом: `{...} as SingleMethodInterface`
- методы интерфейсов, которые не вызываются, можно не реализовывать. И вообще, можно передавать карты как объекты (как в JS) - Груви язык динамический
- что-то про *мультиметоды*, и что Груви динамически разрешает типы объектов, но понять это невозможно
- *категории* - классы со статическими методами, расширяющие (напр., `final`-) другие классы, встраивают в них доп. методы. `use (<CategoryClass>) {...}` делает эти новые методы доступными на первом аргументе нового метода
- переменные-свойства класса должны быть объявлены в самом начале, можно несколько в строке (через запятую)
- в скрипте (вне класса) можно не указывать ни тип переменной, ни `def`: `x = 1`
- обращаться к свойству класса можно как через точку (`obj.count = 1`), так и через квадратные скобки (`obj['count'] = 1`)
- методы классов по умолчанию все `public`. Они могут опускать `return`, использовать `def` вместо типа возвращаемого значения, а тип параметров вообще не указывать
- поддерживаются аргументы методов по умолчанию (`test(x = 1)`)
- варианты для параметров методов:
  * список - явная передача и обработка: `.test([1,2,3])` / `test(List list) { list.each{...} }`
  * массив для опциональных - неявная передача и явная обработка: `test(1,2,3,1,1,1)` / `test(arg1, Object[] optionals) { optionals.toList() ... }`
  * карта - явная передача (но можно без квадратных скобок) и обработка: `.test(a: 1, b: 2)` / `test(Map args) { args.each{} }`
- конструкторы:
  * если не определен, компилятор создаст конструктор без аргументов
  * конструкторы можно вызывать как стандартно, с позиционными параметрами (`def employee = new Employee('Bashar','AbdulJawad')`), так и приводя списки через `as` (`def employee = ['Bashar','Abdul Jawad'] as Employee`) или без `as`, но указывая явно тип переменной (`Employee employee = ['Bashar','AbdulJawad']`)
  * можно вызывать автогенерированные конструкторы с именованными параметрами. Они просто установят поля класса - именованные параметры должны совпадать с их именами: `new Employee(firstName: 'Bashar', lastName: 'AbdulJawad')`
- GroovtBeans - геттеры/сеттеры генерируются автоматически. Оператор `.@` позволяет обращаться к полю в обход их (`employee.@name`)
- GPath позволяет обращаться к методам в иерархии объектов, возможно сразу ко многим:
  * получение методов, пример: `"".class.methods.name.sort()` выведет сортированный список
  * оператор размытия `.*` вернет список возвращаемых значений от каждого метода на объекте в списке: `[...]*.totalEarnings() == [10, 20, ...]`
  * или получения списка всех значений свойства на массиве объектов - `[...].<property>.each{...}` (?)
- класс `Expando` позволяет набирать свойства и методы объекта в рантайме: `def author = new Expando(); author.books = ['Book 1']; author.writeBook = { -> return author.books ...}`
- метакласс:
  * доступ через класс или объект: `(<Class>|<obj>).metaClass`
  * хранит все свойства и методы (`.metaClass.(methods|properties)`) и методы, внедренные GDK (`.metaClass.metaMethods`)
  * проверка, есть ли такой метод или свойство: `obj.metaClass.respondsTo(obj, "<method-name>")` / `obj.metaClass.hasProperty(obj, "<property-name>")`
- перехват обращений к методам и свойствам. Прямо в классе опеределить методы с именами:
  * `(get|set)Property(name[, value])`
  * `invokeMethod(name, args)`
  * `methodMissing(name, args)` - будет вызвано для несуществующих методов
- добавлять свойства/методы к классу можно на лету, напр.: `String.metaClass.capitalize = {...}`. Это называется `ExpandoMetaClass` (это тип свойства `.metaClass` у классов???)

#### Замыкания
- тип - `groovy.lang.Closure`
- в Груви много методов (типа `.each*()`) принимающих замыкания
- аргументы могут быть как типизированными, так и нет
- пустое замыкание: `{->}`
- и все же `->` можно опустить, если нужен только один аргумент. Он неявный и называется `it`: `{ println it }`
- вызов - через круглые скобки, или методы `<clojure>.call()`/`<clojure>.doCall()`. Т.к. круглые скобки в Груви необязательны, их можно опустить
- т.к. `return` в Groovy необязателен, то просто вернется результат последнего выражения. Тип возвращаемого значения у замыкания указывать нельзя
- оператор `.&` позволяет использовать метод класса как замыкание. Вызывается на объекте
- в замыкании доступны все переменные из окружающей области видимости:
  * при объявлении в скрипте - все скриптовые переменные
  * при объявлении как свойство класса - все члены класса
  * при опеределении внутри метода класса - все члены класса + параметры методы
  * последний случай позволяет возвращать из метода замыкание, имеющее доступ до всех членов класса
- внутри замыкания:
  * `this` - класс, где замыкание определено
  * `owner` - внешний (по отношению к замыканию) объект
  * `delegate` - обычно то же самое что `owner`, но может отличаться внутри скрипта, класса `ExpandoMetaClass` или билдеров
- замыкание можно записать в несколько строк, открывающая и закрывающая фигурные скобки будут на разных строках, между ними код
- метод `.curry()` каррирует замыкания, связывает его с переданными в `.curry()` аргументами (аналог `.bind()` в JS)
- замыкания можно использовать внутри `case`: `switch(it) { case {it % 2 == 1}: return true; ... }`
- у класса `Closure` есть методы, позволяющие получить информацию о параметрах: `.getMaximumNumberOfParameters()`/`.getParameterTypes()`
- замыкания вполне могут быть ключами карты (и конечно значениями)
- GDK расширяет класс `java.io.File`, добавляет много методов, в которых используются замыкания: `.eachFile()`/`.eachLine()`/`.splitEachLine()`/etc.

#### Билдеры
- тип `groovy.util.BuilderSupport`
- используются для создания древовидных структур, делая ненужными множественные вызовы методов вроде `createNode`, `appendChild` или `setParent`
- могут быть использованы для создания предметно-ориентированных языков (domain-specific languages, DSLs)
- пример: `new groovy.xml.MarkupBuilder(); builder.authors{ ... }`
- транслирует имя метода в имя узла, параметры в аттрибуты этого узла, а замыкание рекурсивно повторяет это (я так думаю :) )
- билдеры:
  * `MarkupBuilder` - создание HTML/XML-документов
  * `NodeBuilder` - обобщенный
  * `ObjectGraphBuilder` - что-то связанное с JavaBean
  * `AntBuilder` - Ant-задачи
  * `SwingBuilder` - Swing-виджеты
- перенаправить вывод билдера в файл можно передав его конструктору объект `FileWriter`-а: `new groovy.xml.MarkupBuilder(new FileWriter('...'))`
- `MarkupBuilder` сам заменяет html entites (`& ---> &amp;`)
- доступ до узлов билдера удобно осуществлять через GPath (`company.dept.each{...}`). Обращение к аттрибутам: `dept.'@name'`
- `ObjectGraphBuilder`, в отличие от `NodeBuilder` создает не просто поля, а поля с типом предварительно определенного класса. Как-то приводит имя (первую букву в верхний регистр?) и создает нерекурсивно в плане типа
- пример на `AntBuilder` и большой пример на разные аспекты `SwingBuilder`
- расширив класс `groovy.util.BuilderSupport` можно создать свой собственный биллдер. Нужно реализовать самому 6 абстрактных методов: 4 перегруженных `createNode`, `setParent` и `nodeCompleted`. Приводится пример создания JSON-билдера

#### Работа с БД
- пакет `groovy.sql` на основе `JDBC`
- подключение: `import groovy.sql.Sqlconnection = Sql.newInstance("jdbc:mysql://localhost ...")`
- выполнение SQL-запросов - через `connection.execute '''...'''`. Тройные кавычки позволяют располагать запрос на нескольких строках
- по умолчанию можно выполнить только один запрос за раз (защита от инъекций). Можно это изменить, передав `allowMultiQueries=true` в `newInstance()`
- можно передавать и запросы с плейсхолдерами (`?`) + карты с параметрами: `String stmt = 'INSERT ... VALUES (?,?); connection.execute stmt, ['Bashar', 'Abdul']`
- метод `.execute()` возвращает булево значение, и есть еще `.executeUpdate()` - возвращает кол-во записей, обработанных при обновлении
- стандартное чтение из базы - метод `connection.rows()`, возвращает объект класса `groovy.sql.ResultSet`. Итерировать по нему можно через `while (resultSet.next())`
- альтернативные методы чтения вызывают замыкание на результате - `.query()` единожды, и `.eachRow()` - на каждой строке
- по результату `groovy.sql.ResultSet` можно получить метаданные о таблице, геттер `.metaData`/`.getMetaData()`. Это объект, содержит имя таблицы, кол-во записей и т.д.
- класс `DataSet` позволяет работать с базой без SQL-запросов. Получив его из `connection`-а (`dataset = connection.dataSet('employees')`) или создав вручную (`dataSet = new DataSet(connection,'employees')`), можно уже работать с данными как картами: `dataSet.add(firstName:'Alan',lastName:'Mitchell')`
- с `DataSet`-ом можно и читать данные, через методы `.rows()` или `.findAll{...}` (в последнем замыкание определяет фильтр)

#### Тестирование
- основные инструменты - встроенные `assert`-ы и JUnit (тоже идет из коробки)
- поддерживается как имитационное тестирование (mocking), так и тестирование с использованием заглушек (stubbing)
- `assert`-ы выбрасывают исключения. Они полезны при изучении языка или когда производительность некритична. Иначе лучше выносить тесты в отдельный класс
- базовый класс тестов `GroovTestCase` определен внутри `groovy.util`, т.е. импортируется по умолчанию. Тесты нужно наследовать от него. Стандартно содержит метод `setUp()` (и вероятно `tearDown()`)
- класс для объединения тестов - `groovy.util.GroovyTestSuite`. Вспомогательный класс `groovy.util.AllTestSuite` сканирует каталог на наличие файлов с тестами
- Груви позволяет интегрировать тесты с системами сборки Ant и Maven
- фиктивные объекты для тестирования (других) классов можно создавать через карты или класс `Expando`
- если же передавать фиктивные объекты в тестах явно не получается, можно воспользоваться механизмом заглушек или макетов: `import groovy.mock.interceptor.(Stub|Mock)For; new (Stub|Mock)For(<OrigClass>).demand.<method>{...}`. Заглушки отличаются от макетов тем, что в них порядок вызова методов неважен (?)
- можно использовать логгирование, наследуя тесты от `GroovyLogTestCase`, но из кода не совсем понятно как конкретно
- при помощи стороннего пакета Cobertura можно измерять покрытие тестами

#### Разное
- три шаблонатора Груви:
  * `SimpleTemplateEngine`: `println (new SimpleTemplateEngine().createTemplate(text).make(binding).toString())`, где `text` - GString в тройных кавычках с `$`, а `binding` - карта со значениями этих переменных из `text`. В шаблоне поддерживаются JSP-скриптлеты (`<%= new java.text. ... %>`)
  * `GStringTemplate` имеет в точности такие же методы, но более сложный (??? что-то про "шаблон  представлен изменяемым замыканием"). В примере в книге код шаблона (`text`) выносится в отдельный файл
  * `XmlTemplateEngine` - для создания XML, в книге не рассматривается
- что-то про работу с грувлетами и Tomcat для генерации динамических страниц
- классы `XmlParser` и `XmlSlurper` находятся в `groovy.util` и импортируются по умолчанию. Используются для парсинга и изменения XML-документов (билдеры же - для создания). `XmlSlurper` предназначен в основном для чтения, возвращает объекты `GPathResult` вместо `Node`, и чем-то там еще отличается
- классы для работы с XPath (язык запросов для XML): `import javax.xml.xpath.*`
- выполнение кода из командной строки: `groovy -e "<code>"`
- опции `-p`|`-n` используются для процессинга (текстовых) файлов из командной строки. `-i` похожа, но меняет файл "на месте" (in-place)
- класс `groovy.util.ConfigSlurper` импортируется по умолчанию и используется для создания XML-конфигов
- выполнение внешних процессов из Груви - прямо на строке с командой: `"ls -l".execute().text`
- пример с загрузкой файла (что? куда?) через классы `FileOutputStream`/`BufferedOutputStream`/`URL`
- класс `File` поддерживает много методов, таких как `.exists()`, `.mkdir()` или `.eachFileRecurse()` (рекурсивный обход каталога)
- пример с подсчетом числа вхождений слов в строке, через `(text =~ /\b[\w]+\b/).each{...}` и занесением их в карту (`[(<word>): ++N]`)
