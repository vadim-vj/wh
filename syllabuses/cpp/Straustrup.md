C++ Core Guidelines: <https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>. Выдержки из них приводятся в конце каждого раздела. Я выписываю только (малую) часть.

#### Основы
- язык делится на две части: *фундаментальные возможности языка* (типы, управляющие конструкции, и т.д.) и *компоненты стандартных библиотек* (контейнеры, операции ввода-вывода, и т.д.)
- стандартная библиотека сама реализована на C++ за очень небольшим исключением (напр., машинного кода для переключения контекста потока). Это говорит о достаточной эффективности языка для реализации любых задач системного программирования
- `int main() {}` - минимальная программа. Если `main()` нет, линкер падает с ошибкой. `main()` должна быть ровно одна (иначе ошибка компилятора, переопределение)
- комментарии, фигурные скобки, `#include <...>`, операторы, пространство имен стандартной библиотеки (`std`) + `using namespace std;`, объявление функций, типы, тип `void`
- литералы строк только в двойных кавычках, обратный слеш + символ (внутри строки) рассматриваются как единый (спец.)символ
- имена аргументов в объявлении функции могут быть опущены, но иногда их можно и указать, для читаемости программы. Для функций-членов имя класса является частью имени функции (напр., `String::operator[]`). Поддерживается перегрузка функций, вызовы разрешаются на стадии компиляции, при неоднозначности компилятор падает с ошибкой
- базовые типы. Размер - через `sizeof(<type>)`, в (как правило восьмибитных) байтах. Напр., `sizeof(int) == 4`, `sizeof(int*) == 8`
- тип литералов чисел определяется по десятичной точке. По умолчанию литерал десятичный, префиксы: `0b` - двоичный, `0x` - шестнадцатеричный, `0` - восьмеричный. В литералах допустимы одинарные кавычки как разделитель: `3.14159'26535'89...`/`0х3.243F'6А88'8...`
- логические (напр., `||`/`&&`/`!`) и побитовые (напр., `|`/`&`) операторы имеют символьное представление (`or`/`and`/`not`/`bitor`/`bitand`). Из операторов сравнения только `!=` имеет такую альтернативу (`not_eq`). Также в символьном виде могут быть записаны фигурные и квадратные скобки, а также символ решетки. Полный список: <https://en.cppreference.com/w/cpp/language/operator_alternative>
- логические операторы вычисляются по короткой цепи и возвращают `boolean` только для встроенных типов. Перегруженные для пользовательских типов, они могут возвращать приводимое к `boolean` значение и требуют вычисления обоих операндов (для передачи в пользовательскую функцию)
- оператор сравнения один: `==`
- в арифметических операциях допустимы операнды разных числовых типов, преобразования выполняются автоматически. Так, напр., `3 + 2.3` даст тип `double`. Автоматически же пройдут и преобразования при присваиваниях
- порядок вычисления выражений - слева направо, кроме присваиваний - они вычисляются справа налево. Порядок вычисления аргументов функции не определен
- три вида инициализации: `a = 1`, `a {1}`, `a = {1}`. Использование фигурных скобок (*списков инициализации*) предотвращает *сужающие преобразования*, напр., `double` в `int` (ошибка компилятора `-Wc++11-narrowing`). Но с `auto` можно использовать и `=`: не может быть никакого потенциально опасного преобразования типов. Но, если везде последовательно используется список инициализации, то можно юзать его и с `auto`
- `auto` можно использовать всегда, если не нужно специально указать тип (напр, `float` вместо `double`). Иногда тип предпочтительно указать явно для читаемости программы, напр., в большой области видимости. Использование `auto` особенно удобно в обобщенном программировании, где вывод типа труден для программиста
- области видимости уровня:
  * блока, ограничена фигурными скобками. Такие области существуют внутри функций или лямбд
  * класса, ограничена фигурными скобками объявления класса. Объявление такого объекта должно быть вне методов/лямбд/enum-ов этого класса
  * пространства имен. Объявление такого объекта должно быть вне функций/лямбд/классов/перечислений `enum class` этого пространства
  * глобальная, объявления вне любых конструкций
- могут существовать безымянные объекты: временные, и создаваемые оператором `new`
- объекты уничтожаются при выходе из области видимости. Объекты пространств имен уничтожаются по завершению программы. Члены уничтожаются при уничтожении объекта. Созданные оператором `new` объекты "живут" до вызова `delete`
- два типа неизменяемости:
  * `const` - "обещаю не изменять это значение". Используется главным образом для интерфейсов, для безопасной передачи ссылок и указателей в функции
  * `constexpr` - "вычисляется во время компиляции". Для определения констант и для повышения производительности
- функция должна быть объявлена как `constexpr <type> <name>(...) {...}` чтобы ее можно было использовать в присваивании constexpr-переменной. Такая функция должна быть достаточно простой, но может иметь аргументы, локальные переменные и циклы. Не может менять нелокальные переменные. Ее можно вызывать и с неконстантными аргументами, но тогда и результат не будет constexpr (это позволяет не определять 2 функции с разными модификаторами)
- constexpr требуется правилами языка в: объявлениях границ массивов, метках `case`, аргументах - значениях шаблонов (?). В остальных случаях не обязательны, но могут давать выигрыш в производительности
- размер массивов можно не указывать при инициализации списком (`int a[]{1, 2};`). При этом тип массива верхнего уровня заменять на `auto` нельзя (`error: 'a' declared as array of 'auto'`)
- обход массивов и списков инициализации можно выполнять через *цикл for для диапазона*: `for (auto& х: {10,21,32,43,54,65}) {...}`
- ссылка, в отличие от указателя, не может быть *перенацелена* (не может ссылаться на другой объект). Целевой объект ссылки задается при ее объявлении: `int& i = a;`. Разыменовывать ссылку не нужно: `i = b;`
- ссылки можно использовать для повышения производительности в диапазонных циклах `for` и при передаче аргументов в функцию, для избежания копирования. Вообще, передача константных ссылок в функции - стандартная парадигма C++, когда единственной целью является передача без копирования (а не изменение аргумента)
- нулевой указатель `nullptr` существует в единственном экземпляре. Проверка указателей в условиях (напр., `if (p) {...}`) неявно сравнивает аргумент с `nullptr`. Использование этого объекта предпочтительней `0` и `NULL`
- объявления переменных могут находится в любой точке кода
- в `if` допустимо несколько инструкций, напр.: `if (auto n  = v.size(); n!=O) {...}` (хотя здесь проверка и избыточна, код эквивалентен `if (auto n  = v.size(}) {...}`). Объявленные в проверке переменные доступны в обеих ветвях `if`
- `switch` стандартный, с `case` и `break`
- по дефолту присваивание по значению идет всегда, для всех типов, не только для базовых (в отличие от других языков). Для присваивания по ссылке нужно указать это явно, или использовать указатели (с разыменованием). Для всех типов, как базовых так и (корректно спроектированных) пользовательских, после присваивания `x = y` выполняется `x == y`
- получить неинициализированную ссылку (напр., `int& r2;`) нельзя - ошибка компилятора `error: declaration of reference variable 'r2' requires an initializer`. И что-то еще невнятно про отличие инициализации от присваивания
- советы:
  * функция должна выполнять единственную логическую операцию
  * используйте перегрузку, когда функции выполняют концептуально одинаковые задачи с разными типами
  * предпочитайте неизменяемые данные
  * объявляйте в каждом объявлении (только) одно имя
  * избегайте имен прописными буквами
  * предпочитайте инициализацию списками (`{}`) в объявлениях без `auto`
  * в `if` (и прочих) неявная проверка на `0` предпочтительней
  * используйте `unsigned` для работы с битами (и только для них?)
  * не объявляйте переменную до тех пор, пока у вас не будет значения для ее инициализации
  * не пишите в комментариях то, что очевидным образом выражено в коде

#### Пользовательские типы
- выделенные в *свободной (динамической) памяти* (*куче*) объекты (через оператор `new`) не зависят от области видимости, и продолжают существовать, пока не будут уничтожены явно (оператором `delete`)
- структуры - `struct Vector { double* elem; }`. Пример инициализации структуры через функцию с аргументом - неконстантной ссылкой: `void vector_init(Vector& v, int s) { v.elem = new douЬle[s]; }`
- для обращения к полям структуры через объект-значение используется оператор "точка" - `.`, а через указатель - оператор "стрелка" `->`
- классы аналогично. Реализацию методов можно давать прямо в объявлении. Конструктор - это функция-член с совпадающим с классом именем. Пример конструктора с инициализацией членов через списки: `Vector(int s) : elem{new double[s]}, sz{s} {}`. Члены классов, в отличие от структур, по умолчанию закрыты
- пример такого самописного вектора выше, это стандартная парадигма C++ для пользовательских типов - дескриптор (в нашем случае объект класса) фиксированного размера, ссылающийся на переменное количество данных в другом месте (напр., в куче)
- объединения хранят только один свой член одновременно: `union Value { int i; Node* p; }`. Распространен паттерн (*tagged union*, маркированное объединение), когда одно поле объединения хранит тип (строку), по которому можно выбрать, какое поле сейчас используется. Но лучше самому такое не реализовывать, потому что уже есть готовые `std::variant` и `std::holds_alternative`
- перечисления:
  * обычные: `enum Туре { ptr, num };`, обращение напрямую - `ptr`
  * `enum class Color { red, bluе, green }`, обращение: `Color::red`. У таких уже своя область видимости, и имена констант не обязаны быть уникальными на программу
- у этих двух типов перечислений есть еще отличия, вроде преобразований в/из `int`-а и перегрузки операторов для enum-а (он является полноценным пользовательским типом). Запись с `class` более современная и она предпочтительней, и вообще юзать enum-ы полезно

#### Модульность
- 
