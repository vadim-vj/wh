C++ Core Guidelines: <https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>. Выдержки из них приводятся в конце каждого раздела. Я выписываю только (малую) часть.

#### Основы
- язык делится на две части: *фундаментальные возможности языка* (типы, управляющие конструкции, и т.д.) и *компоненты стандартных библиотек* (контейнеры, операции ввода-вывода, и т.д.)
- стандартная библиотека сама реализована на C++ за очень небольшим исключением (напр., машинного кода для переключения контекста потока). Это говорит о достаточной эффективности языка для реализации любых задач системного программирования
- `int main() {}` - минимальная программа. Если `main()` нет, линкер падает с ошибкой. `main()` должна быть ровно одна (иначе ошибка компилятора, переопределение)
- комментарии, фигурные скобки, `#include <...>`, операторы, пространство имен стандартной библиотеки (`std`) + `using namespace std;`, объявление функций, типы, тип `void`
- литералы строк только в двойных кавычках, обратный слеш + символ (внутри строки) рассматриваются как единый (спец.)символ
- имена аргументов в объявлении функции могут быть опущены, но иногда их можно и указать, для читаемости программы. Для функций-членов имя класса является частью имени функции (напр., `String::operator[]`). Поддерживается перегрузка функций, вызовы разрешаются на стадии компиляции, при неоднозначности компилятор падает с ошибкой
- базовые типы. Размер - через `sizeof(<type>)`, в (как правило восьмибитных) байтах. Напр., `sizeof(int) == 4`, `sizeof(int*) == 8`
- тип литералов чисел определяется по десятичной точке. По умолчанию литерал десятичный, префиксы: `0b` - двоичный, `0x` - шестнадцатеричный, `0` - восьмеричный. В литералах допустимы одинарные кавычки как разделитель: `3.14159'26535'89...`/`0х3.243F'6А88'8...`
- логические (напр., `||`/`&&`/`!`) и побитовые (напр., `|`/`&`) операторы имеют символьное представление (`or`/`and`/`not`/`bitor`/`bitand`). Из операторов сравнения только `!=` имеет такую альтернативу (`not_eq`). Также в символьном виде могут быть записаны фигурные и квадратные скобки, а также символ решетки. Полный список: <https://en.cppreference.com/w/cpp/language/operator_alternative>
- логические операторы вычисляются по короткой цепи и возвращают `boolean` только для встроенных типов. Перегруженные для пользовательских типов, они могут возвращать приводимое к `boolean` значение и требуют вычисления обоих операндов (для передачи в пользовательскую функцию)
- оператор сравнения один: `==`
- в арифметических операциях допустимы операнды разных числовых типов, преобразования выполняются автоматически. Так, напр., `3 + 2.3` даст тип `double`. Автоматически же пройдут и преобразования при присваиваниях
- порядок вычисления выражений - слева направо, кроме присваиваний - они вычисляются справа налево. Порядок вычисления аргументов функции не определен
- три вида инициализации: `a = 1`, `a {1}`, `a = {1}`. Использование фигурных скобок (*списков инициализации*) предотвращает *сужающие преобразования*, напр., `double` в `int` (ошибка компилятора `-Wc++11-narrowing`). Но с `auto` можно использовать и `=`: не может быть никакого потенциально опасного преобразования типов. Но, если везде последовательно используется список инициализации, то можно юзать его и с `auto`
- `auto` можно использовать всегда, если не нужно специально указать тип (напр, `float` вместо `double`). Иногда тип предпочтительно указать явно для читаемости программы, напр., в большой области видимости. Использование `auto` особенно удобно в обобщенном программировании, где вывод типа труден для программиста
- области видимости уровня:
  * блока, ограничена фигурными скобками. Такие области существуют внутри функций или лямбд
  * класса, ограничена фигурными скобками объявления класса. Объявление такого объекта должно быть вне методов/лямбд/enum-ов этого класса
  * пространства имен. Объявление такого объекта должно быть вне функций/лямбд/классов/перечислений `enum class` этого пространства
  * глобальная, объявления вне любых конструкций
- могут существовать безымянные объекты: временные, и создаваемые оператором `new`
- объекты уничтожаются при выходе из области видимости. Объекты пространств имен уничтожаются по завершению программы. Члены уничтожаются при уничтожении объекта. Созданные оператором `new` объекты "живут" до вызова `delete`
- два типа неизменяемости:
  * `const` - "обещаю не изменять это значение". Используется главным образом для интерфейсов, для безопасной передачи ссылок и указателей в функции
  * `constexpr` - "вычисляется во время компиляции". Для определения констант и для повышения производительности
- функция должна быть объявлена как `constexpr <type> <name>(...) {...}` чтобы ее можно было использовать в присваивании constexpr-переменной. Такая функция должна быть достаточно простой, но может иметь аргументы, локальные переменные и циклы. Не может менять нелокальные переменные. Ее можно вызывать и с неконстантными аргументами, но тогда и результат не будет constexpr (это позволяет не определять 2 функции с разными модификаторами)
- constexpr требуется правилами языка в: объявлениях границ массивов, метках `case`, аргументах - значениях шаблонов (?). В остальных случаях не обязательны, но могут давать выигрыш в производительности
- размер массивов можно не указывать при инициализации списком (`int a[]{1, 2};`). При этом тип массива верхнего уровня заменять на `auto` нельзя (`error: 'a' declared as array of 'auto'`)
- обход массивов и списков инициализации можно выполнять через *цикл for для диапазона*: `for (auto& х: {10,21,32,43,54,65}) {...}`
- ссылка, в отличие от указателя, не может быть *перенацелена* (не может ссылаться на другой объект). Целевой объект ссылки задается при ее объявлении: `int& i = a;`. Разыменовывать ссылку не нужно: `i = b;`
- ссылки можно использовать для повышения производительности в диапазонных циклах `for` и при передаче аргументов в функцию, для избежания копирования. Вообще, передача константных ссылок в функции - стандартная парадигма C++, когда единственной целью является передача без копирования (а не изменение аргумента)
- нулевой указатель `nullptr` существует в единственном экземпляре. Проверка указателей в условиях (напр., `if (p) {...}`) неявно сравнивает аргумент с `nullptr`. Использование этого объекта предпочтительней `0` и `NULL`
- объявления переменных могут находится в любой точке кода
- в `if` допустимо несколько инструкций, напр.: `if (auto n  = v.size(); n!=O) {...}` (хотя здесь проверка и избыточна, код эквивалентен `if (auto n  = v.size(}) {...}`). Объявленные в проверке переменные доступны в обеих ветвях `if`
- `switch` стандартный, с `case` и `break`
- по дефолту присваивание по значению идет всегда, для всех типов, не только для базовых (в отличие от других языков). Для присваивания по ссылке нужно указать это явно, или использовать указатели (с разыменованием). Для всех типов, как базовых так и (корректно спроектированных) пользовательских, после присваивания `x = y` выполняется `x == y`
- получить неинициализированную ссылку (напр., `int& r2;`) нельзя - ошибка компилятора `error: declaration of reference variable 'r2' requires an initializer`. И что-то еще невнятно про отличие инициализации от присваивания
- советы:
  * функция должна выполнять единственную логическую операцию
  * используйте перегрузку, когда функции выполняют концептуально одинаковые задачи с разными типами
  * предпочитайте неизменяемые данные
  * объявляйте в каждом объявлении (только) одно имя
  * избегайте имен прописными буквами
  * предпочитайте инициализацию списками (`{}`) в объявлениях без `auto`
  * в `if` (и прочих) неявная проверка на `0` предпочтительней
  * используйте `unsigned` для работы с битами (и только для них?)
  * не объявляйте переменную до тех пор, пока у вас не будет значения для ее инициализации
  * не пишите в комментариях то, что очевидным образом выражено в коде

#### Пользовательские типы
- выделенные в *свободной (динамической) памяти* (*куче*) объекты (через оператор `new`) не зависят от области видимости, и продолжают существовать, пока не будут уничтожены явно (оператором `delete`)
- структуры - `struct Vector { double* elem; }`. Пример инициализации структуры через функцию с аргументом - неконстантной ссылкой: `void vector_init(Vector& v, int s) { v.elem = new douЬle[s]; }`
- для обращения к полям структуры через объект-значение используется оператор "точка" - `.`, а через указатель - оператор "стрелка" `->`
- классы аналогично. Реализацию методов можно давать прямо в объявлении. Конструктор - это функция-член с совпадающим с классом именем. Пример конструктора с инициализацией членов через списки: `Vector(int s) : elem{new double[s]}, sz{s} {}`. Члены классов, в отличие от структур, по умолчанию закрыты
- пример такого самописного вектора выше, это стандартная парадигма C++ для пользовательских типов - дескриптор (в нашем случае объект класса) фиксированного размера, ссылающийся на переменное количество данных в другом месте (напр., в куче)
- объединения хранят только один свой член одновременно: `union Value { int i; Node* p; }`. Распространен паттерн (*tagged union*, маркированное объединение), когда одно поле объединения хранит тип (строку), по которому можно выбрать, какое поле сейчас используется. Но лучше самому такое не реализовывать, потому что уже есть готовые `std::variant` и `std::holds_alternative`
- перечисления:
  * обычные: `enum Туре { ptr, num };`, обращение напрямую - `ptr`
  * `enum class Color { red, bluе, green }`, обращение: `Color::red`. У таких уже своя область видимости, и имена констант не обязаны быть уникальными на программу
- у этих двух типов перечислений есть еще отличия, вроде преобразований в/из `int`-а и перегрузки операторов для enum-а (он является полноценным пользовательским типом). Запись с `class` более современная и она предпочтительней, и вообще юзать enum-ы полезно

#### Модульность
- *объявление* определяет всё, что нужно для использования функции. *Определением* называет реализацию. Она может находится где-то "в другом месте", будь то функция/класс библиотеки или пользовательская
- C++ поддерживает *раздельную компиляцию* - когда пользовательский код видит только объявления типов и функций, а их реализация была скомпилирована ранее. Это уменьшает время компиляции и делает части программы логически независимыми
- включение файлов - через `#include`. В книге он использует кавычки для включения пользовательских файлов: `#include "Vector.h"`
- .cpp-файл (с включенными в него .h-заголовками) называется *единицей трансляции*
- недостатки `#include` для h-файлов:
  * включение в каждую единицу трансляции (долго и затратно)
  * порядок включения играет роль (чревато ошибками)
- описывает создание модуля: `module; export module Vector; export class Vector {...}` и `import Vector;`. Можно смешивать `import` и стандартный `#include`
- g++ v9.2.1 уже поддерживает модули, CLang тоже, CMake вот только пока требует кастомных функций подключения. Нужно потом как-нибудь потестить. Только вот VSCode пока не поддерживает, подсвечивает всё связанное с модулями как ошибку
- преимущества модулей:
  * компилируются один раз, а не в каждой единице трансляции
  * порядок не играет роли
  * `import` не является транзитивным (???), что-то про то, что разграничивается доступ другие импорты внутри модуля
- пространства имен, `::`, `using namespace <name>`. Используются в основном для организации крупных программных компонентов, типа библиотек
- создание пользовательских типов и алгоритмов, работающих с ними - один из главных инструментов предотвращения ошибок. Это упрощает программирование, увеличивает возможности компилятора по поиску ошибок. Создание механизмов обработки ошибок на ранних стадиях разработки - хорошая идея
- но есть и другие абстракции, помогающие в обработке ошибок. Одна из них - отделение точки обнаружения ошибки от точки ее обработки, механизм *исключений*
- стандартные `try`/`catch (out_of_range& e) { e.what(); }`/`throw out_of_range("...")` (зд. на примере `out_of_range` - тип из стандартной библиотеки, файл `<stdexcept>`). Метод `.what()` возвращает сообщение об ошибке. Ссылка в `catch` предотвращает копирование
- не злоупотребляйте блоками `try`: это усложняет программы и делает их менее удобочитаемыми. Лучше придерживаться концепции RAII (Resource Acquisition Is Initialization) - захват ресурса является инициализацией), когда все ресурсы, нужные для работы класса, получает конструктор, а деструктор их освобождает
- функции можно объявлять как `void user(int sz) noexcept`. Необработанные исключения в таких функциях приводят к вызову `std::terminate()` - третий тип обработки ошибок (см. ниже), в некоторых программах может быть неприемлем
- пишет об *инвариантах* - классах с проверкой условий (контрактами), как правило в конструкторе. Пример - выброс исключения `length_error` если в конструктор класса `Vector` пришло отрицательное значение длины. Это позволяет держать объекты классов всегда корректными (инвариантными). Такие же проверки (контракты) нужны и в операторе `[]`, для проверки индекса
- `throw` без аргументов внутри блока `catch` повторно сгенерирует то же исключение
- способы обработки ошибок:
  * возврат кодов. Приемлемо, когда ошибка - нормальное, ожидаемое явление, и когда вызывающая функция в состоянии обработать такую ошибку
  * исключения. Приемлемы, когда ошибки редки, когда вызывающая функция не может обработать ошибку, нет пути возврата кода (напр., конструкторы не возвращают значений), построение цепочки проверок накладно, или ошибка требует возврата большого кол-ва разнородной информация. И в других случаях, напр., когда нужно добавить выброс ошибки в одном модуле, но в других модулях нк заложены механизмы ее обработки. Или это был вызов callback-а, и вызывающая сторона вообще не знает о том, был ли он выполнен
  * аварийное завершение программы (функции типа `exit()`/`terminate()`/`abort()`. Когда восстановление после ошибки невозможно, или когда ошибка требует перезапуска программы/потока/компьютера
- предпочитайте исключения если непонятно, какой тип обработки использовать. Всегда предпочитайте RAII: код, переполненный `try`/`catch`-блоками, "зачастую просто является отражением худших аспектов стратегий обработки ошибок на основе кодов ошибок"
- контракты только в C++20. Макрос `assert()` (напр., `assert(p!=nullptr)`) выполняется только в отладочном режиме, его часто бывает достаточно. `static_assert()` делает проверки времени компиляции, может работать со всем, что `constexpr`, и может принимать вторым аргументом сообщение об ошибки (для обычного `assert` для этого нужно изворачиваться)
- передача значений в функции:
  * "маленькие" (эмпирическое правило - размер в 2-3 указателя) объекты по значению
  * "большие" - по (константной) ссылке. Вообще, передача по константной ссылке - хороший распространенный способ: он быстр и мало подвержен ошибкам
- поддерживаются аргументы по умолчанию
- возврат значений из функций:
  * "маленькие" - по значению
  * "большие" нелокальные объекты - по ссылке
  * "большие" локальные объекты - через конструктор перемещения (см. ниже). Возвращать ссылку на локальные объекты нельзя, и компиляторы, как правило, могут такую ситуацию отловить
  * в старых программах практиковалось динамическое создание (на куче, через `new`) объекта, возврат из функции указателя на него, и возложение ответственности за вызов `delete` на вызывающую функцию сторону. Такой подход считается устаревшим и использоваться не должен
- тип возвращаемого значения функции может быть `auto`, но нужно быть осторожным с этим (особенно в публичных контрактах): изменение реализации функции может привести к изменению типа ее возвращаемого значения
- из функции можно возвращать и агрегированные, напр., в структуру, данные. Вычитка их в локальные переменные имеет синтаксис с квадратными скобками, напр.: `auto [n, v] read entry(is);` или `for (auto& [key,value]: m) {...}` для библиотечного `map`. Это работает для любых классов без закрытых членов (напр., `complex<douЫe> z = {1,2}; auto [re,im] = z+2;`
- советы:
  * избегайте реализаций не-inline функций в заголовочных файлах
  * предпочитайте модули нового стандарта
  * используйте пространства имен
  * используйте `using namespace` для базовых библиотек (таких как `std`)
  * не помещайте `using namespace` в заголовочные файлы
  * предпочитайте исключения, если не ясно, какой механизм обработки ошибок использовать
  * предпочитайте RAII явным `try`/`catch`-блокам
  * предпочитайте для исключений пользовательские типы, создавайте систему обработки ошибок как можно раньше при проектировании
  * добавляйте `noexcept` функциям
  * проектируйте классы как инварианты: проверки и выброс исключений в конструкторах
  * не возвращайте значения из функции через параметры

#### Классы
- *конкретные* классы ведут себя полностью как встроенные типы. Часто являются дескрипторами ресурсов, хранящихся в динамической памяти
- пример класса (типа) `class` - классического "пользовательского арифметического типа", похожего на реализацию из std. Должен быть эффективным - простые операции должны быть встраиваемыми (inline)
- спецификатор `const` указывает, что функция не меняет вызывающий объект. Такой метод может быть на любых объектах, тогда как неконстантный - только на неконстантных
- конструктор без аргументов называется *конструктором по умолчанию*. Инициализация переменных-членов в конструкторе списком: `Vector_container(int s): v{s}` (более эффективна чем присваивание в теле; фигурные скобки могут быть заменены на круглые)
- перегружать операторы можно и функциями вне класса, если не требуется доступ до закрытых членов
- синтаксис операторов формируется языком. Поэтому, напр., нельзя определить унарный `/`. Также нельзя изменять операторы для встроенных типов
- деструктор: `~<ClassName>() {...}`, очистка ресурсов. Для массивов: `elem = new double[s]; delete[] elem;`
- *контейнером* называется объект, содержащий коллекцию элементов. Как правило, для них используется идиома RAII - вызов `new` в конструкторах и `delete`  в деструкторах. Это позволяет отказаться от (чреватого ошибками) выделения/удаления памяти в общем коде
- два метода инициализации контейнеров: конструктор со списком инициализации (`Vector(std::initializer_list<douЫe>);`) и добавление в конец (`void push_back(douЬle);`). В конструкторе можно воспользоваться библиотечной функцией `copy(lst.begin(),lst.end(),elem);` для заполнения предварительного созданного (через `new douЬle[lst.size()]`) хранилища
- использует `static_cast<int>(lst.size())` в примере выше для приведения типов, т.к. std хранит размеры списков инициализации (и вообще всех размеров и индексов) беззнаковые числа. Упоминает `const`/`reinterpret` cast-ы, рекомендует использовать их реже, и только на самом низком уровне системы
- *абстрактные* классы нельзя инстантиировать. Ключевого слова `abstract` нет, класс считается абстрактным, если содержит хотя бы одну чисто виртуальную функцию (`virtual ... = 0;`). Виртуальные (с модификатором `virtual`) методы *можно* переопределять в дочерних классах, а чисто виртуальные (с `= 0`) дочерние классы (пере)определять обязаны. Иногда базовые абстрактные классы называют *полиморфными типами*
- абстрактные классов часто не имеют конструктора (не известно, что инициализировать), но имеют виртуальный деструктор
- наследование через двоеточие - `class List container : puЫic Container`. При переопределении методов рекомендуется использование ключевого слова `override`
- компилятор заменяет имена виртуальных функций на адреса в vtbl - таблице виртуальных функций. Каждый класс с виртуальными функциями имеет такую таблицу. Механизм довольно быстрый, и использует памяти всего на пару указателей
- приводит пример иерархии классов - геометрических фигур, и функции, работающей с полиморфным вектором указателей на базовый класс: `void rotate_all(vector<Shape*>& v, int angle) {...}`. Везде довольно свободно использует сырые указатели, создание напрямую через `new`
- виртуальные деструкторы в примере выше необходимы: вся работа (в том числе удаление) идет через указатели на базовый класс
- иерархии классов предоставляют преимущества наследования: интерфейсов и реализации. Работа с ними идет, как правило, через указатели или ссылки
- обращение к специфичной для класса-потомка (в иерархии) функции: `if (Smiley*p = dynamic_cast<Smiley*>(ps))`. Если указатель на другой тип в иерархии, `dynamic_cast` вернет `nullptr`. Его можно использовать и для приведения к ссылочному типу, но может быть выброшено исключение `std::bad_cast`: `Smiley& r {dynamic_cast<Smiley&>(*ps));`. И всё же `dynamic_cast` стоит использовать пореже, напр., только в ситуациях как в примере выше - приведение типов в иерархиях
- во избежание утечек ресурсов, в полиморфном векторе можно воспользоваться умными указателями: `vector<unique_ptr<Shape>> eyes;`. Доп. преимуществом такого подхода будет то, что больше не нужно определять деструктор у производного класса (`Smiley`)
- советы:
  * в критических по производительности местах программы предпочитайте конкретные классы, не иерархии
  * делайте функцию членом только тогда, когда необходим непосредственный доступ к представлению класса
  * используйте свободные функции для симметричных операторов
  * указывайте `const`/`override` у методов
  * избегайте работы с "голыми" `new`/`delete`, предпочитайте `unique_ptr`/`shared_ptr`
  * используйте RAII, создавайте конструктор/деструктор парами
  * в своих контейнерных классах используйте списки инициализации для конструкторов
  * класс с виртуальной функцией должен иметь виртуальный деструктор
  * используйте `dynamic_cast`, если неизбежно приведение типов указателей/ссылок

#### Основные операции
- объект может быть скопирован или перемещен, когда: стоит справа от оператора присваивания, инициализирует другой объект, передается в/возвращается из функции, выступает в роли исключения
- четыре конструктора (обычный, по умолчанию, копирования (`X(const Х&)`) и перемещения(`Х (Х&&)`)) и два оператора присваивания (копирующее (`Х& operator=(const Х&)`) и перемещающее(`Х& operator=(X&&`)). Они, как правило, нужны если у класса есть деструктор, выполняющий нетривиальную задачу (освобождение памяти и блокировки)
- компилятор при оптимизации может отменять (аннулировать) копирование в инициализациях вида `Х х = make(value);` (copy elision)
- за исключением "обычного" конструктора, остальные генерируются компилятором по мере необходимости. Можно затребовать эту генерацию и явно: `... = default;`, но в таком случае остальные генерироваться неявно не будут
- если у класса есть член-указатель, он, как правило, указывает на что-то, что нужно удалять. Выполняемое по умолчанию почленное копирование в таком случае будет неправильным, и желательно указывать свои намерения, записывая операции копирования/перемещения. Также возможно, что класс с членом-указателем не должен удалять то, на что он ссылается, но и тогда, для читаемости программы, лучше явно записать copy/move операции
- (эмпирическое) "правило нуля" - определять либо все основные операции, либо ни одну из них. Это нужно для правильной автоматической генерации методов
- в дополнение к `= default` есть `= delete` - запрет автоматической генерации. Пример использования - запрет копирования в базовом классе: `Shape(const Shape&) = delete; Shape& operator=(const Shape&) = delete;` - запрет почленного копирования. Использование `= delete`-метода приводит к ошибке времени компиляции
- конструктор, получающий единственный аргумент, определяет операцию преобразования из типа аргумента, напр., в присваиваниях: `complex z1 = 3.14;`. Ключевое слово `explicit` у конструктора запрещает такое поведение
- в объявлении класса можно использовать *инициализатор члена по умолчанию*: `class complex { double re = 0; ... }`. Используется, если конструктор не задает значение
- копирующие операции: инициализация - `complex z2 {zl);`, присваивание - `zЗ = z2;`. По умолчанию выполняется почленное копирование
- для контейнеров (дескрипторов, хранящих указатель на ресурсы) почленное копирование это всегда катастрофа. Наличие деструктора у класса - это подсказка, что нужно реализовывать копирующие операции - вызывать `new <type>[]` в списке и в цикле присваивать значения
- хотя определение копирующих конструктора и присваивания решает ошибки с распределением памяти, не решаются проблемы производительности. Перемещающие операции помогают возвращать локальные объекты из функций. Локальная переменная будет являться *r-value* - тем, чему никто иной не может присвоить значение, что можно безопасно "украсть". При возврате из функции для нее будет вызван конструктор перемещения
- перемещение можно инициировать и явно, через `std::move()`. Она просто вернет r-ссылку на свой аргумент (и вызывает деструктор объекта?). После любого перемещения, явного и неявного, объект должен находиться в состоянии, которое позволяет выполнить деструктор - мы просто копируем свойства аргумента в свой объект, после чего зануляем в аргументе указатели и прочее. После перемещения объект использовать нельзя
- по стандарту компилятор должен использовать copy elision где только можно, поэтому перемещения вызываются не так уж часто. Но убрать всё невозможно, и поэтому перемещение всё же имеют решающее значение для производительности
- пример добавления объекта с запретом копирования в вектор: `thread t{heartbeat}; my_threads.push_back(std::move(t));`
- да трактовались одинаково, бинарные операторы лучше определять как свободные функции: `my_threads.push_back(std::move(t));`
- контейнеры желательно проектировать в стиле стандартной библиотеки - с методом `.size()` и итераторами `.begin()`/`.end()`, поддерживающими операторы `++`/`*`. Такая *модель итератора* позволит и использовать контейнеры в диапазонных циклах `for`: `for (auto& х : с) {...}`
- суффиксы литералов: `u` = `unsigned int`, `<int>s` - секунды (?), `"..."s` = `std::string` (вместо `const char[N]`). Есть еще несколько, определенных в `std::literals::`. Пример определения пользовательского литерала (`operator""i`, `1.23i`): `constexpr complex<double> operator""i(long double arg) { return {0,arg); }`
- функция `std::swap(а, Ь)` выполняет обмен как три операции перемещения, `tmp = а, а = Ь, Ь = tmp`. Ее используют стандартные функции типа `std::sort`. Если тип элемента дорогостоящ для копирования, лучше реализовать свою функцию `swap()`
- чтобы пользовательский тип можно было использовать в качестве ключа в хеш-таблицах (картах, `std::unordered_map<K, V>`), нужно определить `hash<X>`. Стандартная библиотека определяет его для многих типов, например для строк
- советы:
  * проектируйте конструкторы, операторы присваивания и деструктор как согласованный набор операций
  * соблюдайте "правило нуля"
  * используйте `explicit`
  * возвращайте контейнеры по значению (полагаясь на эффективное перемещение)
  * следуйте принципам проектирования контейнеров стандартной библиотеки

#### Шаблоны
- общий формат: `template<typename Т> class Vector {...}`. Определение использующих тип функций: `template<typename Т> Vector<T>::Vector(int s) {...}`
- *инстанциирование* или *спецификация* конкретным типом (`const Vector<string> vs`) происходит во время компиляции. Для каждого конкретного типа генерируется своя реализация. Накладных расходов нет, а проверки типов при компиляции гарантируют что созданный автоматически код такой же безопасный, как и написанный вручную
- вместо `typename` в угловых скобках можно указать предикат (*концепт*, см. ниже). Такой ограниченный тип называется *ограниченным аргументом*, а шаблон с таким аргументом - *ограниченным шаблоном*. Если `typename` это аналог квантора всеобщности "для любого T", то концепт - ограничение этого квантора - "для любого T, такого что"
- параметры шаблона - с указанием типа в угловых скобках: `template<typename Т, int N> struct Buffer {...}` (`constexpr`). С ними можно, например, задавать размер и, таким образом, создавать контейнеры без динамической памяти
- в C++17 есть автоматический вывод типов шаблона: вместо `pair<int,douЫe> р = (1,5.2);` можно писать `pair р = (1,5.2);`. В старых версиях - `auto р = make_pair(1,5.2);`. Также угловые скобки можно опускать при списочной инициализации контейнеров
- если есть несколько конструкторов шаблона, компилятор не всегда может сам вывести тип. В таком случае могут использоваться правила вывода, напр.: `template<typename Iter> Vector2(Iter,Iter) -> Vector2<typename Iter::value_type>;` (добавлять после объявления шаблона)
- шаблоном может быть и функция. Она может являться членом класса, но не виртуальным - компилятор не сможет сгенерировать vtbl в такой ситуации
- или объект с перегруженным оператором вызова `()` - *функтор*. Такие объекты часто используются для создания предикатов. Функторы, используемые для указания смысла ключевых операций общего алгоритма (например, `Less_than` для `count()`),часто называются *объектами стратегии* (policy objects)
- синтаксис лямбд: `[&] (int а) { return а<х; }`. Круглые скобки с аргументами опциональны. `[=x]` - захват по значению. `[&]`/`[=]` - захват всех локальных имен по ссылке/значению
- лямбды с типом параметра `auto` могут рассматриваться как обобщенные выражение, те же шаблоны. Использовать `auto` таким же образом в обычных функциях нельзя
- можно задавать переменные, зависящие от типа, напр.: `template <class Т> constexpr Т viscosity = 0.4;`. Пример использования: `auto vis2 = 2*viscosity<double>;`. Не совсем понятно, зачем это нужно. Как-то связано с концептами
- создание псевдонима типа: `using value_type = Т;`, `using size_t = unsigned int;`. В другой реализации `size_t` может отличаться, псевдонимы т.о. помогают писать переносимый код. Каждый контейнер стандартной библиотеки предоставляет для имени типа значений своих элементов псевдоним `value_type`. Это дает возможность получать тип из любого контейнера через `typename С::value_type` (сложный пример, [p.132]). `using ... =` может применяться и для каррирования типов шаблона
- `if` времени компиляции: `if constexpr(...)`. Пример: `if constexpr(is_pod<T>::value) {...} else {...}` (`is_pod<T>` - может ли этот тип быть тривиально копирован). Эта конструкция - не макрос, и не может нарушать обычные правила грамматики, типов и областей видимости
- советы:
  * отдельной компиляции шаблонов нет: включайте с помощью директивы `#include` определения шаблонов в каждую единицу трансляции, которая их использует (?)

#### Концепты и обобщенное программирование
- [p.136] вернуться позже или пропустить

#### Стандартная библиотека
- [p.156]
