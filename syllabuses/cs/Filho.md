# Фило В., Теоретический минимум по Computer Science. Все что нужно программисту и разработчику
- <https://www.piter.com/collection/all/product/teoreticheskiy-minimum-po-computer-science-vse-chto-nuzhno-programmistu-i-razrabotchiku>
- <https://code.energy/computer-science-distilled/>

Здесь книга часто используется только лишь как предметный указатель.

---
# Основы
---
## Идеи
---

### Блок-схемы

> *Блок-схема* - графическое представление алгоритма, (пошагового) метода решения задачи. Шаги изображаются в виде блоков, соединенных между собой линиями, указывающими направление последовательности. Как и псевдокод, это язык, способ описания/представления алгоритмов

1. Перечислите основные блоки и их назначение
   - *ограничитель* (Terminal; овал) - вход/выход во внешнюю среду, начало/останов
   - *действие* (Process; прямоугольник) - изменение данных
   - *вопрос*/*решение* (Decision; ромб) - выбор одной из нескольких ветвей выполнения
   - *ввод*/*вывод* (Input/Output; параллелограмм) - чтение или запись данных куда-л.
   - *функция* (Predefined Process; прямоугольник в доп. линиями) - именованная подпрограмма, определенна где-л.
   - *комментарий* (Comment; пунктирная линия с прямоугольной выноской) - любая доп. информация (напр., если текст не помещается в блоке)
   - *цикл* (Loop; пара прямоугольников со скошенными углами) - между ними располагаются повторяющиеся действия
   - *соединитель* (On-page Connector; кружок) - с цифрой внутри, соединяет разрыв линии и продолжает в другом месте
   - *соединительная линия* (Flowline/Arrowhead; линия со стрелкой) - указывает порядок действий

1. Для чего предназначен блок ... ? / Каким блоком описывается действие ... ?
   - см. пред. пункт

1. Для чего может быть использована блок-схема?
   - разработка и/или документирование простых процессов или программ (как пример - процесс редактирования страниц в Википедии)
   - визуализация процесса/программы, и, как следствие, упрощение понимания, что там происходит
   - поиск не самых очевидных моментов в алгоритме, таких как ошибки или узкие места (бутылочные горлышки)

1. На каком уровне детализации должны использоваться блок-схемы?
   - на высоком, они не должны использоваться для отображения кода и/или взаимодействующих частей программы. Для этого существует UML

1. Как обозначаются параллельные действия?
   - вход + перпендикулярная линия - параллельная ей линия + несколько перпендикулярных выходов

1. Как изобразить `switch` на блок-схеме?
   - ромб (напр, "Чему равно `i`") с одной выходящей линией, которая потом разветвляется на N выходов (как трезубец). Рядом с каждым выходом-стрелочкой указано значение `i`

1. Изобразите блок-схему алгоритма X
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Блок-схема>

---

### Псевдокод

> *Псевдокод* - компактный, зачастую неформальный язык описания алгоритмов, похожий на языки программирования, но опускающий детали. Предназначен для чтения человеком, а не машиной. Как и блок-схемы, это язык, способ описания/представления алгоритмов

1. Приведите пример инструкций псевдокода
   - `Set i to True`
   - `If i is divisible by 3`
   - `Read/Write i`
   - `While ... do`

1. В чем сходства и различия блок-схемы и псевдокода?
   - оба они представляют собой описание процессов/алгоритмов, но блок-схемы это описание графическое, а псевдокод - текстовое

1. Где используется псевдокод?
   - как и блок-схемы: в учебных материалах, в научно-технических публикациях, на начальной стадии разработки программ

1. Чему равно значение переменной после выполнения некоторого псевдокода?
   - ...

1. Напишите псевдокод для некоторого алгоритма
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Псевдокод_(язык_описания_алгоритмов)>

---

### Математические модели

> *Мат. модель* - это набор идей, которые описывают задачу и ее свойства с использованием математики. Математическое представление некоторой системы, позволяющее исследовать эту систему с использованием (как правило, мощного - в этом преимущество) математического аппарата

1. Постройте мат. модель площади прямоугольной фигуры
   - такая модель - это два уравнения (для площади и периметра), решить которые можно через подстановку одного в другое, получения квадратного уравнения, и нахождения его минимума/максимума. Задача `livestock-fence`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Математическая_модель>

---
## Логика
---

### Логические операторы

> *Логический оператор* или *логическая связка* - действие/операция над высказываниями - выражениями булевого типа. Служат для получения сложных логических выражений из более простых. Не-числовые (хотя в ЯП числа могут приводиться) - и операнды и результат имеют булев тип

1. Перечислите основные логические операторы
   - отрицание (Negation; `not`)
   - конъюнкция, Логическое "И" (Conjunction; `and`)
   - дизъюнкциия, Логическое "Или ("Disjunction; `or`)
   - строгая дизъюнкция, Исключающее "Или" (Exclusive disjunction; `xor`)
   - импликация (Implication; `if... then ...`)
   - эквиваленция, "Тогда и только тогда" (Biconditional; `if and only if`)

1. Как с этим в Python?
   - связки пишутся словами: `not`, `and`, `or`. Условие `if ...`. Исключающее "или" - через `!=`, `==` - эквиваленция

1. А в C++?
   - две эквивалентные формы записи: `!`/`not`, `&&`/`and`, `||`/`or`. Условие `if (...)`. `xor` ~ `!=`, `<=>` ~ `==`

1. Могут ли другие (не-bool) типы использоваться как логические операнды?
   - да. В некоторых языках программирования (например, в Си) вместо логического типа или одновременно с ним используются числовые типы. В этом случае считается, что отличное от нуля значение соответствует логической истине, а ноль — логической лжи

1. Как с этим в Python?
   - свободно используются, взаимозаменяемы
   - к `False` приводятся `None`, `0`, пустая строка и все пустые коллекции: `[]`, `{}`, `()`, а также объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно
   - связки `and`/`or` возвращают свои операнды, не булевы значения

1. А в C++?
   - неявно в `bool` могут преобразовываться числа (в том числе дробные), перечисления и указатели (в том числе литералы строк)
   - объекты могут преобразовываться, если определяют `::operator bool()`
   - связки `&&`/`||` возвращают булевы значения, не операнды
   - идиома `Safe bool` подразумевает объявление оператора `bool()` с ключевым словом `explicit`, чтобы объекты в выражениях случайно не приводились, например, к числам

1. Могут ли логические операторы применяться к битам?
   - да. Значение отдельного бита также можно рассматривать как логическое, если считать, что 1 означает "истинно", а 0 - "ложно". Это позволяет применять логические операции к отдельным битам, к битовым векторам покомпонентно и к числам в двоичном представлении поразрядно (побитовые логические операции)

1. Как с этим в Python?
   - сдвиги: `x << y`/`x >> y`, "и"/"или": `x & y`/`x | y`, дополнение: `~x`, "xor": `x ^ y`
   - эти уже словами не записываются

1. А в C++?
   - в точности такие же, как в Python

1. В какой момент вычисление логического выражения останавливается?
   - многие языки вычисляют логические связки по *короткой цепи*. Вычисление идет слева направо и останавливается, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

1. Как с этим в Python?
   - вычисления всегда идут по короткой цепи

1. А в C++?
   - по короткой цепи вычисления идут только для встроенных типов (то есть для built-in типов гарантирован и порядок вычисления операндов, и то, что второй может не вычисляться). Перегруженные операторы являются пользовательскими функциями, для них будут вычисляться оба аргумента, причем в неопределенном порядке

1. Запишите выражение X через предикаты и логические операторы
   - Пример: `if the pool is warm, I’ll swim`. Здесь `A = "the pool is warm"`, `B = "I swim"`, `A -> B = "if ... I'll ..."` (импликация)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

--- 

### Булева алгебра

> *Булева алгебра* - раздел математики, изучающий высказывания и операции над ними. Есть и формальное определение ("непустое множество с тремя операциями и выделенными значениями `true`/`false`")

1. Каковы приоритеты логических операторов?
   - скобки
   - `not`
   - `xor` / `<=>`
   - `and`
   - `or`
   - `if` (выполняется слева направо: `A -> B -> C`)

   Из-за того, что `!A == B` ~ `A != B` а операции `==`/`!=` имеют одинаковый приоритет, фактический приоритет `not` и `xor`/`<=>` неважен. В C++ `!` имеет приоритет выше `==`, в то время как в Python наоборот

1. Назовите основные аксиомы (свойства) булевых выражений
   - *коммутативность* - независимость результата бинарных операций (`and`/`or`) от порядка операндов: `A || B` ~ `B || A`
   - *ассоциативность* - независимость результата выражений с одинаковыми связками от расстановки скобок: `(A && B) && C` ~ `A && (B && C)   `
   - *дистрибутивность* - возможность раскрыть скобки: `(A || B) && C` ~ `A && C || A && C`. Дистрибутивность относительно логического    "или" (сложения) тоже работает, но особого смысла для нас не имеет
   - *законы де Моргана* - раскрытие скобок относительно отрицания. Связка меняется: `!(A && B)` ~ `!A || !B` и `!(A || B)` ~ `!A && !B`
   - еще довольно много, вроде *комплементности* (`A || !A` ~ `true`, `A && !A` ~ `false`), *инволютивности отрицания* (`!!A` ~ `A`), сложения/умножения на константы (`true`/`false`) и прочего

1. Как можно записать `if A: B else: C`/`if not A: B` по-другому?
   - через `A and B` (~ `if A: B`) и `A or C` (~ `else: C`)

1. Что такое противопоставление импликации?
   - запись `if`, в которой посыл и следствие меняются местами: `A -> B` ~ `!B -> !A`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Булева_алгебра>
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

---

### Таблицы истинности

> *Таблица истинности* - один из способов (табличный, наряду со словесным и аналитическим (через связки)) описания логической функции

1. Зачем может понадобится таблица истинности?
   - например, решить логическую задачу "в лоб". Сформулировав задачу в форме утверждений и логических связок, можно построить таблицу истинности и визуально найти все нужные случаи

1. Какие формы записи таких таблиц бывают?
   - для бинарных функций можно использовать квадратные таблицы: значения операндов расположить по строкам/столбцам, а значения функции в ячейках
   - универсальный способ - `N+1` столбцов и `2^N` строк со всеми комбинациями `true`/`false`. Последний столбец содержит значение функции

1. На сколько увеличивается таблица с добавлением новой переменной?
   - вдвое. Строк в ней `2^N`, так что `2^(N+1)` == `2 * 2^N`

1. Запишите таблицы истинности для `and`, `or`, `not`, `xor`
   - ...

1. Запишите таблицу истинности для импликации (`A -> B`)

   | A\B |  0  |  1  |
   | --: | --- | --- |
   |   0 |  1  |  1  |
   |   1 |  0  |  1  |

   Обратите внимание на ноль в левом нижнем углу (`1 -> 0`). Импликация как булева функция ложна лишь тогда, когда посылка истинна, а следствие ложно (`!A || B`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Таблица_истинности>

---

### Логика в вычислениях

> *Логический вентиль* - базовый элемент цифровой схемы, выполняющий элементарную логическую операцию. Интерпретирую результаты логических операций как биты, можно построить схемы преобразования чисел, например, двоичный сумматор (состоит из вентилей `and` и `xor`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логический_вентиль>

---
## Комбинаторика
---

### Правило умножения

> *Правило "и"* - если элемент A можно выбрать `N` способами, и при любом выборе A элемент B можно выбрать `M` способами, то пару (A, B) можно выбрать `N * M` способами. Примеры: игральные кубики - `N = 6`, `M = 6`, `N * M = 36`; `N` бросков монеты - `2 * 2 * 2 ...` (`N` раз) = `2 ^ N`

1. Сколько (максимально) попыток уйдет на подбор пин-кода в формате `A00`?
   - при фиксированном формате (1 + 2 / 2 + 1 / 1 + 1 + 1) - `26 x 100` = `2600`
   - при не-фиксированной позиции буквы/цифры - `(26 + 10) ^ 3` = `46656`
   - в общем случае, буквенно-цифровая (ASCII) последовательность из N символов имеет `36 ^ N` вариантов

1. Сколько чисел можно закодировать в N-ричной СС для числа длиной M?
   - `N` вариантов = основанию СС, умножается на себя `M` раз - `N ^ M`
   - например, в байте (`M = 8`) двоичной системы (`N = 2`) кодируется `N ^ M` = `2 ^ 8` = `256` чисел

1. I. Сколькими способами можно сформировать команду из 23 человек, подкидывая монету?
   - требует уточнения, что количество человек в команде не обязательно должно быть 23 (не обязательно заполнять все слоты)
   - аверс/реверс дают `N = 2`, кол-во бросков = кол-ву человек - `M = 23`, всего вариантов - `N ^ M` = `2 ^ 23` = `8388608`
   - упоминает вариант когда команда состоит из себя самого (хотя из условия такое не следует?)
   - крайние случаи: монета не выпала нужной стороной ни разу - `0` человек выбрано, монета выпадала всегда - `23` человека в команде

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Правило_умножения>

---

### Перестановки

> В комбинаторике *перестановка* - это упорядоченный набор элементов без повторений. Число возможных перестановок для `N` элементов - `N!`. `0!` == `1` - пустое множество можно упорядочить единственным способом.
> Первый элемент можно разместить `N` способами, остается `N - 1` свободных слотов. И так далее. Так получается факториал
> *Размещение* - это упорядоченное подмножество (размера `K`) из некоторого множества (размера `N`), по сути часть элементов перестановки. Количество возможных комбинаций - `N!/(N - K)!`. Фактически это "факториал", вычисляемый на интервале `(N-K, N]`, произведение всех чисел от `N - K + 1` до `N`

1. I. Задача о коммивояжере: найти кратчайший маршрут, позволяющий объехать `N` городов
   - строится квадратная матрица расстояний между городами
   - задача NP-полная, "решается" перебором всех перестановок городов, вычисления длины маршрута для каждой перестановки, и сравнением с текущим минимумом
   - уникальность города в перестановке гарантирует выполнение одного из условий задачи - отсутствия гамильтоновых циклов

1. Задача о мелодии: сколько всего возможных мелодий из 6ти нот (всего нот 13)?
   - здесь используется понятие размещения
   - количество комбинаций по `K = 6` из `N = 13` - `N!/(N - K)!` = `13!/7!` = `8*9*10*11*12*13` = `1 235 520`
   - в секундах это 343 часа, время неприемлемое

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Перестановка>
   - <https://ru.wikipedia.org/wiki/Размещение>

---

### Перестановки с повторениями

> Если часть элементов переставляемого множества одинаковы (повторяются), то их собственные взаимные перестановки не добавляют новых комбинаций (порядок не важен), и не должны учитываться. Для этого факториал делят на произведение факториалов кол-ва каждого повторяющегося элемента: `N!/(K1!K2!...)`. Так, например, в слове `CODEENERGY` букв `N = 10`, а буква `e` встречается в `K = 3` позициях. Общее количество перестановок - `N!/K!` = `10!/3!`

1. Задача о ДНК: сколько существует комбинаций в молекуле длиной 23, если 9 нуклеотидов должны быть A-T, а 14 - G-C?
   - `N = 23` - общее число нуклеотидов ("слотов"), `K1 = 9`, `K2 = 14` - "слоты", занятые одинаковыми элементами
   - общее число неповторяющихся перестановок - `N!/(K1!K2!)` = `23!/(9!14!)` = `817 190`
   - (хоть это и не указано в условии) каждая пара нуклеотидов может иметь 2 ориентации (напр., A-T/T-A). Так что получившееся число нужно еще домножить на кол-во способов выбора (по правилу умножения), на `2^23` (получится ~ 7 млрд.)

---

### Комбинации

> Объединение предыдущих пунктов. *Сочетание* или *комбинация* (здесь) - это размещение `K` элементов (`N!/(N - K)!`), у которого не важен порядок (`N!/K!`). Таким образом, получаем *бином* `(N K)` с числом комбинаций `N!/K!(N - K)!`. Это, например, кол-во комбинаций 6 карт из 13ти (без учета масти, порядок карт не важен). `(N K)` читается как "из N по K"

1. I. Задача о шахматных ферзях: сколькими способами можно произвольно расставить на доске 8 ферзей?
   - это не та знаменитая одноименная задача, а просто расчет кол-ва комбинаций
   - на доске `N = 64` клетки ("слота"), `K = 8` одинаковых ферзей ("элементов"), порядок их не важен
   - решение - `64!/(8!(64 - 8)!` ~ `4.4 млрд.`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Сочетание>

---

### Правило суммирования

> Для записи суммирования рядов используется символ большой греческой "сигма". Например, сумма первых пяти нечетных чисел - `[0...4] S(2i + 1)`
> Сумма первых `N` натуральных чисел равна `[1...N] Si` = `n(n + 1)/2` (формула Гаусса)

1. Задача о перелете: в ближайшие 30 дней нужно слетать в другой город, цена зависит от пары "день вылета - день возвращения". Сколько таких пар нужно перебрать, чтобы найти самую дешевую?
   - дата возвращения может быть равна дате отлета или позже, поэтому между первым (1) и последним (30) днем - 30 возможных пар
   - если брать "опорным" второй день, то между 2 и 30 таких пар уже 29, и так далее
   - таким образом, общее кол-во пар дней вылета-прилета - это сумма чисел от 1 до 30: `30(30 + 1)/2` = `465`
   - альтернативное решение - через сочетания `(N K)`, где `N = 30` и `K = 2`. Порядок не важен. `(30 2)` = 435, и + `30` - кол-во дней, когда дата вылета совпадает с датой прилета

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Ряд_из_натуральных_чисел>

---
## Вероятность
---

### Подсчет исходов

> (классическое определение) *Вероятностью* события называется отношение числа способов наступления события (числа элементарных событий, `n`) к общему числу возможных исходов `N`: `n/N`. Так, нечетных граней игрального кубика `n = 3`, а всего граней `N = 6`. Так что вероятность выпадения нечетной грани - `n/N` = `3/6` = `1/2`
> Такой подход работает потому, что вероятность наступления любого элементарного события ("благоприятного" исхода) одинакова

1. II. Снова набор команды из 23 человек путем подбрасывания монеты. Какова вероятность, что не возьмут никого?
   - граничный случай, 23 раза монета выпадала одной стороной
   - общее число вариантов - `N = 2^23`, и случай что никого не возьмут может произойти единственным способом (`n = 1`)
   - таким образом, вероятность `n/N` = `1/(2^23)`

1. Ссылки:
   - <https://ru.wikipedia.org/wiki/Вероятность#Классическое_определение>

---

### Независимые события

> Вероятности *независимых событий* перемножаются: `P = P1 * P2`. Так, например, одновременные бросок игрального кубика (`P1 = 1/6`) и монеты (`P2 = 1/2`) дадут вероятность выпадения "орла" + "6" `P = 1/6 * 1/2 = 1/12` ~ `8%`

1. Задача о резервном хранилище: что дешевле, один дорогой диск с вероятностью сбоя `P = 1/(10^9)` или несколько дешевых с `P = 1/2000` и ценой в 20% дорогого?
   - данные теряются когда все диски одновременно выходят из строя. Это независимые события, поэтому их вероятности перемножаются
   - уже 3 дешевых диска дадут вероятность сбоя в 8 раз ниже (`(1/2000)^3` = `1/(8 * 10^9)`), чем один дорогой
   - цена трех дешевых дисков при этом составит `3 * (0.2 * e)` = `0.6 *e`, то есть всего 60% от цены дорогого

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Вероятность#Независимость_событий>

---

### Несовместные события

> Два элементарных исхода (например, выпадение на кубике "4" и нечетного числа) являются *несовместимыми* (взаимно исключающими), если они не могут произойти одновременно. Таким образом, единственная их связь - `xor` ("либо"). Вероятности таких событий *складываются*: "A либо B" ~ `A xor B` = `P = P1 + P2`

1. Задача выбора подписки: провайдер предлагает три тарифа; известно, что бесплатный выбирают с вероятностью 70%, а два платных - с вероятностями 20% и 10%. Какова вероятность, что клиент подпишется на платный тариф?
   - несколько тарифов одновременно выбрать нельзя, поэтому события выбора - несовместные
   - а значит, они суммируются: `0.2 + 0.1` = `30%`

---

### Взаимодополняющие события

> Когда два несовместных события охватывают все возможные варианты, их называют *взаимодополняющими*. Сумма их вероятностей равна 100%. Пример - выпадение на кубике числа кратного и не кратного трем. `1/3 + 2/3` = `1`

1. Задача о защите замка. Каждая из пяти башен имеет вероятность 20% поразить врага. Каковы шансы его остановить?
   - мы ищем вероятность события "хотя бы одна башня попала"
   - события "башня поражает врага" не являются взаимодополняющими друг друга, они независимы, и их вероятности суммировать нельзя
   - событие "башня поражает врага" является взаимодополняющим для "башня промахнулась" (с `P = 1 - 0.2 = 0.8`)
   - вероятность события "все башни промахнулись" - произведение вероятностей независимых промахов каждой башни: `0.8^5` ~ `0.33`
   - и уже это последнее событие является взаимодополняющим для искомого. P("хотя бы одна башня попала") = `1 - 0.33` = `0.67`

1. Сcылки
   - <https://ru.wikipedia.org/wiki/Вероятность#Полная_вероятность_и_формула_Байеса>

---

### "Заблуждение игрока"

> Результаты предыдущих (независимых) событий никак не влияют на результат текущего. Десять раз подряд выпавший "орел" никак не увеличивает вероятность выпадения решки на одиннадцатом. Вероятность выигрыша в лотерее комбинации 1,2,3,4,5,6 ничуть не ниже, чем любой другой

---

### Более сложные вероятности

1. III. Снова набор команды из 23 человек путем подбрасывания монеты. Каковы шансы, что возьмут семь человек или меньше?
   - решается через биномиальное распределение, поиск его значений меньше семи: `B(23, 1/2) <= 7`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Биномиальное_распределение>
   - <https://ru.wikipedia.org/wiki/Принцип_Дирихле_(комбинаторика)>

---
# Вычислительная сложность
---

> *Обозначение* - `T(n)`, пример - сортировка колоды карт (`T(n) = n^2`). Можно вычислять, насколько возрастет время выполнения при увеличении числа карт в 2 раза - `T(2n)/T(n)` = `((2n)^2)/(n^2)` = `4`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Вычислительная_сложность>

---

## Надейтесь на лучшее, но готовьтесь к худшему

> Можно рассматривать *лучший* (напр., данные уже отсортированы), *средний* (данные в произвольном порядке) и *худший* (данные в обратном порядке) случаи. Худший случай - самый важный из всех, ориентироваться всегда нужно на него

---

## Оценка затрат времени

> *Временная сложность* - количество операций, требующихся алгоритму для набора входных данных размером `n`

1. Задача: (неустойчивая) сортировка выбором
   - рассматривается сам алгоритм, с вложенным циклом
   - внешний цикл - `N * (n - 1)` операций, где `N = 2 or 3` (присваивание, обмен, и опциональное сравнение индексов)
   - внутренний цикл выполняет `M * (n - 1)`, потом `M * (n - 2)` и т.д. операций, где `M = 2` (сравнение и присваивание). По формуле Гаусса это `n(n - 1)/2` = `(n^2 - n)/2`
   - отбросив константы и сложив, получим `T(n) = n^2 + n - 2`
   - проводит вычисления, из которых видно что с ростом `n` отношение `T(2n)/T(n)` стремится к `4`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Сортировка_выбором>

---

### Понимание роста затрат

> Самая быстрорастущая компонента в функции временной сложности называется *доминантным членом*. В предыдущем примере (сортировке выбором) это `n^2`

1. Задача об учетных карточках: насколько (по времени) затратнее отсортировать 10 коробок рассыпанных карточек, чем одну?
   - `T(10n)/T(n)` = `(10n)^2/n^2` = `100`
   - если использовать другую сортировку, например, "пузырьком", то для нее `T(n) = 0.5n^2 + 0.5n`. Но если для нее вычислить `T(10n)/T(n)`, то коэфф. `0.5` сократится, и будет получен тот же `10^2`
   - отсюда вывод, что константы не влияют на скорость роста, важен только доминантный член `n^2`
   - приводятся графики где видно, что с увеличением масштаба `n` функции `n^2`, `n^2 + n - 2` и `0.5n^2 + 0.5n` отличаются всё меньше

---

## Нотация "O большое"

> Через *O(n)* обозначаются классы функций временной сложности. Функция с доминантным членом, *растущим не быстрее* `n^2`,  обозначается как `O(n^2)`, и т.д.

[p.51] - график функций популярных классов сложности (в порядке увеличения скорости роста): `1`, `log(n)`, `n`, `n*log(n)`, `n^2`, `2^n`, `n!`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое>
   - <https://www.bigocheatsheet.com>

---

## Экспоненциальное время

> Такую временную сложность имеют алгоритмы с доминантой - *степенной функцией* (напр., `2^n`). Экспоненциальное время растет *так быстро*, что мы рассматриваем эти алгоритмы как невыполнимые

[p.51] - график сравнения функций сложности на меньшем масштабе: `n*log(n)`, `n^2`, `2^n`

> Аналогично, бесперспективными являются алгоритмы с факториальной сложностью (она растет еще быстрее). Эти классы сложности встречаются у *NP-полных* задач

1. Ссылки
   - <https://ru.wikipedia.org/wiki/NP-полная_задача>

---

## Оценка затрат памяти

> Мера рабочей области хранения, в которой нуждается алгоритм, называется *пространственной сложностью*. Ее анализ аналогичен временной. Часто приходится искать компромисс между этими двумя видами сложности

Пример - рассмотренная ранее сортировка выбором. В ней число используемых (вспомогательных) переменных не зависит от размера входных данных, поэтому ее пространственная сложность постоянна - `O(1)`

---
# Стратегия
---

## Итерация

1. Задача о списках рыб: объединить в сортированный список сортированные же списки морских и пресноводных рыб
   - один цикл, в котором из каждого списка берется первый элемент и сравнивается с первым элементов второго списка, после чего этот меньший элемент удаляется
   - граничные случаи - когда списки разной длины, и один уже пуст
   - количество проходов цикла равно длине более длинного списка, то есть его сложность `O(n)`

---

### Вложенные циклы и степенные множества

> *Степенное множество* - все подмножества коллекции объектов. Строится с использованием вложенных циклов

1. Задача об исследовании запахов: нужно построить множество всех комбинаций цветочных ароматов, если дано множество цветов F
   - начинаем с одного элемента - пустого множества, и на каждом шаге копируем все уже сгенерированные подмножества
   - дописываем в эту копию, в каждое подмножество, очередной цветок
   - объединяем копию с общим степенным множеством
   - добавление каждого цветка удваивает размер итогового степенного множества, т.е. сложность алгоритма - `O(2^n)`, экспоненциальная

Генерирование степенных множество похоже на генерацию таблиц истинности: каждый цветок - это логическая переменная, а `True`/`False` - входит он или не входит в подмножество

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Булеан>

---

## Рекурсия

> Рекурсивный алгоритм должен иметь *базовый случай*. Как правило это тогда, когда объем данных уже слишком мал, чтобы продолжать его сокращать

1. Числа Фибоначчи: сгенерировать последовательность, где каждое последующее число является суммой предыдущих
   - по определению, `fib(n) = fib(n - 1) + fib(n - 2)`
   - базовым случаем здесь будет `n <= 2` (`return 1`)

1. Задача: определить, является ли строка палиндромом
   - если первая и последняя буква не равны, вернуть `False`
   - иначе удалить первую и последнюю буквы и вызвать себя
   - базовый случай - пустое слово или слово из одной буквы

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Рекурсия>

---

### Рекурсия против итераций

> Рекурсивные алгоритмы могут выглядеть проще и изящнее, но это имеет вою цену - доп. затраты памяти и времени процессора на переключение контекста. Наглядно эта проблема демонстрируется на диаграммах - *деревьях рекурсивных вызовов*
> Рекурсивный алгоритм всегда можно переписать (возможно, в более громоздкой записи) в итеративном виде (`<!-- как? так ли это вообще?-->`)

1. Задача построения степенного множества рекурсивно
   - `<!-- вернуться позже, его подход непонятен -->`

---

## Полный перебор

1. I. Задача о лучшей сделке: найти в интервале времени пару дней, когда купив в один день и продав в другой, прибыль была бы максимальной
   - задача аналогична задаче о перелете (см. "Правила суммирования")
   - то есть решение методом грубой силы (перебором) потребует квадратичной сложности (`O(n^2)`)

1. I. Задача о рюкзаке: предметы обладают весом и ценой, а рюкзак имеет максимальную вместимость по весу. Нужно упаковать его так, чтобы стоимость выбранных предметов была максимальна
   - степенное множество предметов содержит все их возможные комбинации. Методом грубой силы можно перебрать их все и отсечь те, чей вес превышает вместимость рюкзака
   - одновременно с этим искать максимум по цене
   - т.к. идет перебор степенного множества, то сложность алгоритма экспоненциальная, `O(2^n)`
   - но т.к. некоторые комбинации предметов оставляют рюкзак полупустым, проверять следует не каждую. Хотя, вне зависимости от стратегии, задача о рюкзаке является NP-полной

1. Ссылки:
   - <https://ru.wikipedia.org/wiki/Задача_о_рюкзаке>

---

## Поиск (перебор) с возвратом

1. II. Задача о восьми ферзях: как разместить их на доске так, чтобы ни один из них не оказался под ударом других?
   - в задаче I было найдено число возможных размещений - более 4 млрд. Полный перебор нецелесообразен
   - кроме того, полный перебор будет просчитывать заведомо ненужные комбинации, например, когда первые размещенные два ферзя бьют друг друга. Более эффективный подход состоит в проверке только приемлемых позиций
   - при такой проверке мы, вероятно, уже на нескольких фигурах получим ситуацию, когда следующего ферзя разместить уже невозможно. В этом случае нужно будет *отойти назад* - вернуться к предыдущей позиции и продолжить поиск
   - поиск с возвратом лучше всего подходит для задач, где решением является последовательность вариантов, и выбор одного из них ограничивает выбор последующих. Ошибитесь как можно раньше, чтобы двигаться дальше

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Задача_о_восьми_ферзях>

---

## Эвристические алгоритмы

> Когда вариантов слишком много (даже, например, для поиска с возвратом), можно попробовать искать не оптимальное, но достаточно хорошее решение. *Эвристический метод*, или просто *эвристика*, - это метод, который приводит к решению, не гарантируя, что оно - лучшее или оптимальное. Пример - поиск без возврата

---

### "Жадные" алгоритмы

> Возврат на предыдущий шаг не происходит никогда, полная противоположность поиску с возвратом. На каждом шаге делается выбор и уже не подвергается сомнению

1. II. Задача о рюкзаке, "жадный" вариант - заполнение рюкзака самыми дорогими предметами
   - все вещи упорядочиваются по стоимости от больше к меньшей, и перебираются в цикле
   - если сумма текущего веса рюкзака + веса вещи всё еще меньше макс. вместимости, то вещь добавляется, иначе проверяем следующую (менее ценную)
   - такой алгоритм работает намного быстрее, но не дает никакой гарантии оптимальности

1. II. Задача о коммивояжере, "жадный" вариант - просто посещение всегда ближайшего города, пока не будут перебраны все города
   - `<!-- можно бы и написать код -->`

---

### Когда жадность побеждает силу

Иногда можно найти жадный алгоритм, дающий такое же решение, как и полный перебор

1. Задача об электрической цепи: как соединить все точки, чтобы длина соединений (проводов сети) была минимальной?
   - по сути, построение кратчайшего пути
   - выбираем ближайшую еще не соединенную точку; делаем "жадный" выбор
   - пишет, что такой подход будет оптимальным (почему?)

---

## Разделяй и властвуй

> При помощи этой стратегии особенно хорошо решаются задачи с *оптимальной подструктурой* - такие, которые легко делятся на подобные, но меньшие подзадачи

### Разделить и отсортировать

1. Сортировка слиянием
   - идея: делить массив пополам, рекурсивно сортировать половины, после чего сливать упорядоченные списки (алгоритм с линейной сложностью)
   - базовый случай рекурсии - массив из одного элемента, он всегда отсортирован

1. Сложность сортировки слиянием
   - на каждом шаге рекурсии выполняется разбиение пополам (`O(1)`), слияние сортированных списков (`O(n)`) и 2 рекурсивных вызова
   - последние вызываются: на шаге `2` - 2 раза (`2 * O(n/2) = O(n)`), на шаге `3` - 4 раза (`4 * O(n/4) = O(n)`), на шаге `x` - `2^x` раз (`2^x * O(n/2^x) = O(n)`)
   - таким образом, каждый шаг рекурсии имеет одинаковую (линейную) сложность, а алгоритм в целом - `x * O(n)`. Здесь `x` - число шагов алгоритма, не константа: при, например, удвоении размера списка, понадобится дополнительный шаг рекурсии, при увеличении в 4 раза - 2 шага, и т.д. Поэтому `x` не может быть прогнорирован
   - на каждом шаге рекурсии `x` функция работает со списком длиной `n/2^x`. Т.к. базовый случай рекурсии - это `n = 1`, то нужно решить уравнение `n/2^x = 1`, то есть найти зависимость `x(n)`, число шагов, за которое алгоритм достигнет базового случая
   - решением последнего уравнения является `x = log2(n)`, а общая сложность - `log(n) * O(n) = O(n * log(n))`

---

### Разделить и заключить сделку

1. II. Задача о лучшей сделке: то же условие, но решение с использованием подхода "разделяй и властвуй"
   - рекурсивный алгоритм, на каждом шаге мы ищем максимальную прибыль - разность между ценой продажи и покупки
   - базовый случай - список из одного элемента: тогда покупка и продажа идут в один день, и прибыль нулевая
   - на каждом шаге рекурсии список делится пополам, и возвращается максимум 3х кейсов: двух рекурсивных вызовов для каждой половины списка (`best_trade(former)`, `best_trade(latter)`) и разности `max(latter) - min(former)`
   - деление списка пополам на каждом шаге аналогично сортировке слиянием, так что сложность алгоритма здесь (в отличие от квадратичной при переборе грубой силой) - `O(n * log(n))`

---

### Разделить и упаковать

1. III. Задача о рюкзаке: то же условие, но решение с использованием подхода "разделяй и властвуй"
   - [p. 82], рекурсивный алгоритм `<!-- вернуться -->`

---

## Динамическое программирование

> *Динамическое программирование* - способ идентификации повторяющихся подзадач, чтобы можно было выполнять каждую из них только один раз. Применяется для задач с оптимальной подструктурой и перекрывающимися подзадачами

### Мемоизация
- Фибоначчи: число с каждого шага используется на двух следующих шагах. Чтобы на каждом из этих шагов не делать рекурсивный вызов, можно запомнить его в списке, в позиции `n`, и использовать кеш (возможно даже вообще без рекурсивных вызовов)
- предметов в рюкзаке: с применением подхода "разделяй и властвуй" строится рекурсивный алгоритм, часть операций которого дублируется в разных ветвях дерева рекурсивных вызовов. Эти операции можно закешировать `<!-- вернуться -->`

---

### Лучшая сделка снизу вверх
- используется подход, обратный движению от общего к частному: здесь накапливаются базовые случаи, которые потом соединяются в общий результат
- `<!-- сложный алгоритм, вернуться; код в ../tasks/best-trade -->`
- временная и пространственные сложности - линейные, `O(n)`, значительное улучшение по сравнению с перебором грубой силой (`O(n^2)`) и рекурсивным divide&conquer (`O(n * log(n))`)

---

## Ветви и границы

> *Задачи оптимизации* - задачи на поиск минимума/максимума
> *Метод ветвей и границ* используется в задачах оптимизации, когда решением является последовательность вариантов. Его цель состоит в том, чтобы выиграть время за счет быстрого обнаружения и отбрасывания плохих вариантов

### Верхние и нижние границы

> *Граница* устанавливает диапазон возможных значений. Бывает *верхней* и *нижней*. Примеры нижней границы: расстояние между двумя точками не может быть меньше расстояния по прямой; стоимость "жадной" упаковки рюкзака является нижней границей оптимальной прибыли (почему?)
> Метод удаления ограничений из задач называется *ослаблением*. Он часто используется для вычисления ограничений в задачах оптимизации

1. IV. Задача о рюкзаке, сыпучие материалы: можно насыпать в рюкзак сколько поместится
   - решается "жадным" способом: нужно просто насыпать материалы с самым высоким соотношением стоимости и веса
   - такое ослабление условий дает верхнюю границу оптимальной прибыли для более жесткой задачи (с неделимыми предметами)
   - `<!-- написать код -->`

---

### Ветви и границы в задаче о рюкзаке
- используется рекурсивный алгоритм упаковки (divide&conquer)
- вычисляются верхняя (`powdered_knapsack`) и нижняя (`greedy_knapsack`) границы оптимальной прибыли для каждой. Их вычисление быстрое, и оно позволяет отсечь лишние данные и ускорить алгоритм в общем. Выбирается подзадача с самыми многообещающими границами, и уже к ней применяется алгоритм с самого начала
- `<!-- вернуться и разобрать -->`

---

# Данные

> *Процедурные абстракции* - сокрытие сложности, деталей реализации алгоритмов, за вызовом процедур. Например, это `min()`/`max()` для списков в задаче о лучшей сделке
> *Абстракции данных* - сокрытие деталей процессов обработки данных
> *Тип данных* определяется набором операций, которые могут быть над этим типом выполнены. Примеры: строка, текстовый тип - преобразование регистра, добавление символов; булев тип - операции `AND`/`OR`/`XOR`/...; и т.д.
> *Абстрактный тип данных (АТД)* определяется только набором операций над ним, и ничего не утверждает о природе самих данных внутри. Пример - список: он может состоять из чисел или из строк, но набор операций (добавление/удаление элемента, доступ по индексу и т.д.) для всех один и тот же

* Преимущества использования АТД:
  - простота: опустив детали, можно сосредоточиться на главном - на алгоритмической составляющей
  - гибкость: взаимозаменяемость реализаций (при одном и том же интерфейсе)
  - повторное использование: как наших модулей, так и тех, что наши модули используют (напр., стандартного `Set`)
  - организация: реализации хранятся в своих модулях, и не смешиваются с интерфейсами
  - удобство: не нужно понимать, как модуль оперирует конкретным типом данных, можно просто использовать
  - устранение программных ошибок: в случае правильно работающего модуля не будет ошибок в собственном коде. В случае ошибки в модуле ее нужно устранить лишь единожды

## Общие абстракции

> *Примитивные типы данных* - типы со встроенной поддержкой в языке программирования, для них не нужны внешние модули. Примеры: целые числа и числа с плавающей точкой, булевы значения, строки

* *Стек (stack)* - принцип LIFO (Last-In First-Out, "последним пришел, первым вышел"):
  - минимуму две операции, `push(e)` и `pop()`
  - более совершенные реализации могут иметь и другие, типа получения количества элементов, или проверка наличия элемента
  - пример - операции в текстовом редакторе, `Ctrl+Z` - выталкивание из стека и возврат к пред. состоянию

* *Очередь (queue)* - противоположность стека, принцип FIFO (First-In, FirstOut, "первый пришел, первый вышел"):
  - берутся те элементы, которые находятся в очереди дольше всего
  - минимум две операции: `enqueue(e)` - добавление в конец, и `dequeue()` - удаление из начала
  - пример - список заказов у онлайн-сервиса доставки

* *Очередь с приоритетом (priority queue)* - аналог обычной очереди, только элементам в ней еще и присваивается приоритет
  - операции: `enqueue(e, p)`, `dequeue()`
  - примеры: очередь людей, ожидающих мед. помощи (экстренные случаи приоритетней); очередь процессов в ОС

* *Список (list)* - для работы с элементами в произвольном порядке
  - операции: `insert(n, e)` - вставка в позицию `n`, `remove(n)` - удаление из позиции `n`, `get(n)` - получение элемента в позиции `n`, `sort()` - сортировка, `slice(start, end)` - получение фрагмента списка, `reverse()` - обращение списка
  - пример - ссылки на часто запрашиваемые файлы в системе
  - стеку и очереди следует отдавать предпочтение, когда гибкость, предоставляемая списком, не нужна. Они проще и более предсказуемы

* *Сортированный список (sorted list)* бывает полезен, когда нужна постоянная упорядоченность элементов
  - в операциях `insert(e)` уже не получает номер позиции (она определяется автоматически), а `sort()` не нужен

* *Словарь (map)* используется для хранения соответствий между двумя объектами: ключом `key` и значением `value`
  - операции: `set(key,value)` - добавление, `delete(key)` - удаление, `get(key)` - получение значения по ключу
  - пример - `id` пользователя как ключ и полное имя как значение

* *Множество (set)* - неупорядоченная группа уникальных элементов
  - используется, когда неважен порядок следования элементов либо когда нужно обеспечить уникальность элементов в группе
  - операции: `add(e)` - добавление, `list()` - перечисление всех элементов, `delete(e)` - удаление

## Структуры

> Концепция *структуры данных* обратна АТД - она описывает как данные организованы в памяти. Таким образом, структуры обеспечивают *реализацию* абстракций данных. Выбор более удобной и быстрой реализации крайне важен для АТД

* *Массив (array)* выделяет непрерывный участок памяти и хранит в нем элементы *последовательно*
  - конец может обозначаться некоторым маркером, например, `null`
  - обращение к элементу `N` очень простое (*напрямую*), это просто обращение к ячейке по адресу `s + N*b` (где `b`- размер ячейки в байтах, `s` - адрес начала массива)
  - преимущества: просто программируются, обращение к элементам мгновенное
  - недостатки: выделение больших непрерывных участков памяти может быть нецелесообразно; при вставке в начало/конец смежных свободных ячеек памяти может не оказаться; для удаления/вставки в середину нужно сдвигать все элементы
  - наиболее полезен для реализации стека, однако он может также использоваться для списков и очередей

* *Связный список (linked list)* - цепочка ячеек, которые не обязательно должны храниться в смежных ячейках памяти
  - память выделяется по мере необходимости, и на нее не накладывается ограничений по расположению. Таким образом, размер списка ограничен только объемом имеющейся свободной памяти
  - каждая ячейка хранит указатель на следующую, `null`-указатель обозначает конец списка
  - преимущества: вставка/удаление в середину просты
  - недостатки: произвольный доступ (к элементу `n`) дорог - нужно пройти по всей цепочке; если известен адрес только одной ячейки, то возврат по списку назад или ее удаление сложны
  - используются для реализации стеков, списков и очередей

* *Двусвязный список (double linked list)* хранит еще и доп. указатель - на предыдущую ячейку
  - `prev`-указатель первого и `next`-указатель последнего элемента хранят значение `null`
  - преимущества: те же, что и у связного списка + легкое движение назад по списку / удаление ячейки
  - недостатки: всё так же нет произвольного доступа + два указателя требуют больше памяти и более сложного программного кода

Связные списки предпочтительнее массивов, когда:

- нужны быстрые операции вставки/удаления
- нужны операции вставки/удаления в середину
- не требуется произвольный доступ
- заранее не известно число элементов

Массивы предпочтительнее связных списков, когда:

- нужен произвольный доступ
- нужен быстрый доступ к произвольному элементу
- число элементов структуры не меняется в рантайме

* *Дерево* - похожи на связные списки (элементы не хранятся непрерывно в памяти), но не линейны, а ветвятся
  - ячейка называется *узлом*, указатель из нее на другую ячейку - *ребром*, а самая первая ячейка - *корневым узлом*. Все узлы, кроме корневого, имеют родителя, притом строго *одного*
  - узлы, не имеющие дочерних, называются *листьями*. *Путь* между двумя узлами определяется множеством узлов и ребер
  - *уровень узла* - это длина пути от него до корневого узла, *высота* дерева - уровень самого глубокого узла в дереве. Множество деревьев называется *лесом*
  - пример - дерево происхождения языков. Его листья - это современные языки

### Двоичное дерево поиска

> *Двоичное дерево поиска (binary search tree)*
  - особый тип дерева, поиск в нем выполняется особенно эффективно
  - узлы в двоичном дереве поиска могут иметь не более двух дочерних узлов
  - дочерние узлы слева от родителя должны быть меньше него, а справа - больше

* Поиск узла по значению:
  - сравниваем с текущим, если равен - возвращаем его
  - если значение больше текущего - берем правый дочерний узел, иначе левый
  - повторяем сравнение для дочерних узлов
  - если дочерних узлов не осталось, значит значение не найдено - его в дереве нет
  - `<!-- есть алгоритм на псевдокоде -->`

* Вставка узла:
  - ищем элемент по значению в дереве (см. выше)
  - когда указатель для перехода становится `null` (достигнут лист), вставляем новый узел, дочерний последнему
  - вставка слева или справа - в зависимости от значения последнего узла (листа)
  - `<!-- есть алгоритм на псевдокоде -->`

* Качество балансировки дерева
  - чем больше высота дерева, тем больше требуется переходов по ссылка (больше шагов, больше обращений к памяти)
  - хорошо сбалансированное дерево имеет минимальную высоту
  - если же, например, вставлять всегда значения, б*о*льшие предыдущих, то получится что-то вроде односвязного списка
  - процесс перестройки узлов в дереве называется *балансировкой*
  - балансировка - дорогостоящая операция, поскольку требует сортировки всех узлов. Сортировка от случая к случаю, после нескольких вставок и удалений, может быть разумной стратегией только для редко меняющихся деревьев

* *Алгоритм балансировки*
  - алгоритм рекурсивный, получает на вход сортированный список узлов
  - базовый случай - пустой список, возвращаем `null`
  - берем узел посередине (`middle`), и делаем его левым и правым узлами результаты рекурсивных вызовов для половин исходного списка слева и справа от `middle`
  - возвращаем этот средний узел `middle` - теперь он новое, сбалансированное бинарное дерево
  - `<!-- есть алгоритм на псевдокоде -->`

* Сложность
  - минимальная высота идеально сбалансированного бинарного дерева поиска равна `log2(n)`
  - худший случай балансировки - максимальная высота дерева - когда оно тождественно связанному списку, у каждого узла только один дочерний
  - в этом худшем случае поиск элемента будет занимать `O(n)`
  - в лучшем же - только `O(log(n))`. Очень хорошее время, поэтому BST часто выбирается для реализации словарей и множеств

* *Сбалансированные двоичные деревья (self-balancing binary tree)*
  - такие деревья, чьи процедуры вставки/удаления узлов гарантируют, что они останутся сбалансированными
  - *красно-черное дерево (red-black tree)* - окрашивает узлы красным либо черным цветом в зависимости от стратегии балансировки
  - *AVL-дерево(AVL tree)* - медленнее красно-черных при вставке/удалении, но быстрее при чтении (дает лучший баланс)

* *B-дерево (B-tree)*
  - применяются, т.к. данные часто считываются с дисков большими блоками
  - в таких деревьях узлы могут хранить более одного элемента и иметь более двух дочерних узлов

* *Двоичная куча (binary heap)*
  - особый тип двоичного дерева поиска, в котором можно мгновенно найти самый маленький (или самый большой) элемент
  - левый и правый дочерние узлы всё так же упорядочиваются слева направо, но родительский должен быть больше (меньше) их обоих
  - особенно полезна для реализации очередей с приоритетом
  - получения min (max) элемента имеет сложность `O(1)`, потому что он всегда является корневым узлом дерева
  - поиск и вставка узлов по-прежнему стоят `O(log n)`

* *Граф (graph)*
  - аналогичен дереву, но нет корневого узла
  - данные свободно организованы в виде узлов (вершин) и дуг (ребер) так, что любой узел может иметь произвольное число входящих и исходящих ребер
  - самая гибкая из структур данных. Подходит, например, для представления сетей (например, социальных - людей и их связей)

* *Хеш-таблица (hash table)*
  - позволяет находить элементы за постоянное время, `O(1)`
  - как и массив, требует большого непрерывного блока памяти, но элементы записываются не последовательно
  - *хеш-функция* получает данные для хранения и возвращает число, трактуемое как позиция элемента в памяти
  - *коллизия хеша* - возврат хеш-функцией одного и того же значения для разных данных. Для обхода коллизий можно, например, создать связный список, начинающийся с заданного адреса и хранящий элементы, дающие одинаковый хеш. Коллизии влекут за собой издержки процессорного времени и памяти, поэтому их желательно избегать
  - чем шире диапазон данных, выдаваемых хеш-функцией, тем мегьше вероятность коллизии. Поэтому желательно чтобы в хеш-таблице оставалось незанятым по крайней мере 50 % пространства
  - хеш-таблицы часто используются для реализации словарей и множеств, т.к. они дают лучшее время вставки/удаления, чем деревья. С другой стороны они требуют выделения очень больших участков непрерывной памяти

---

# Алгоритмы

## Сортировка

* *Сортировка вставками*
  - массив просматривается поэлементно, и на каждом шаге часть до текущего элемента уже отсортирована
  - просмотр начинается со второго элемента (индекс `1`)
  - в отсортированной части ищется позиция для вставки текущего элемент (`a <= current <= b`)
  - вставлять в нее можно как напрямую (через методы класса `list`), так и последовательным сдвигом всех элементов при поиске позиции для вставки
  - сложность алгоритма квадратичная, `O(n^2)`: в нем так же, как и в сортировке выбором, есть вложенный цикл
  - в *лучшем* же случае, когда большая часть массива упорядочена, эта сортировка имеет сложность `O(n)`, то есть показывает наилучшее среди всех время


* *Быстрая сортировка*
  - рекурсивный алгоритм, разделение на части базируется на выборе некоего (произвольного) *опорного* элемента
  - базовый случай - длина массива `1`, он уже упорядочен
  - на каждом шаге идет перебор массива в цикле, и формируется 3 подмассива: элементы, что меньше опорного, что равны и что больше
  - два рекурсивных вызова, и возврат простого объединения результатов: `qsort(<less>) + <equal> + qsort(<bigger>)`
  - есть еще in-place вариант алгоритма, он требует немного меньше памяти, но сложнее
  - сложность такая же, как у сортировки слиянием - `O(n * log(n))`

## Поиск

---

## На что обращать внимание

- задачи с упоминанием площади/периметра. Два уравнения, сводящиеся к одному квадратному, и поиску у того минимума и максимума. Пример - задача `livestock-fence`. В простейшем случае максимальной площадью из всех прямоугольников обладает квадрат
- уравнения (и другие мат. модели) не выражаются напрямую в коде, поэтому сначала на бумаге строятся рассуждения/уравнения как считать, и только потом по результатам преобразований пишется код
- задачи на естественном языке со словами вроде "если", "тогда, когда", "в случае": вычленять из текста утверждения (в виде коротких утверждений, напр., "сервер не работает", "вода теплая", "я плаваю") и обозначать их как логические переменные-высказывания (`A`, `B`, etc.). Слова вида "если", "буду", "когда" - превращать в логические операторы, напр., импликацию (и не забывать про "и", "или", "либо"). Переведя, таким образом, формулировку на естественном языке в предикат, упростить его, и найти все ответы (возможно построив таблицу истинности)
- всегда смотреть и проверять крайние случаи, граничные условия. Что будет, если кубик не выпал ни разу? Если кубик выпадал всегда? Если в данных нули / отрицательные числа / не ASCII-символы и т.д.
- при формулировке "от 1 до N" нужно учитывать, включается ли `N`, открыт ли интервал - `[1, N)` или `[1, N]`. Во втором случае в Python нужно использовать `range(n + 1)`. Ну и "от 1" означает `range(1, ...)`
- в вероятностных задачах с формулировкой "хотя бы один из ..." нужно искать вероятность "ни один из ... не ..." (произведение вероятностей взаимодополняющих событий). Пример - задача о защите замка

---

## Задачи

- [Наибольшее из трех чисел](../tasks/max-between-three)
- [Максимизация площади при фиксированном периметре](../tasks/livestock-fence)
- [При каких условиях отключится сервер?](../tasks/hot-server)
- [При каких условиях "хрупкая" БД будет работать?](../tasks/fragile-system)
- [Сколько комбинаций нужно для подбора PIN-кода](../tasks/cracking-the-code)
- [Задача коммивояжера](../tasks/travelling-salesman)
- [Сортировка выбором](../tasks/selection-sort)
- [Слияние упорядоченных списков](../tasks/merge-ordered-lists)
- [Исследование ароматов (построение степенного множества)](../tasks/power-set)
- [Рекурсивное построение степенного множества](../tasks/power-set-recursive)
- [Числа Фибоначчи](../tasks/fibonnacci-numbers)
- [Является ли слово палиндромом?](../tasks/check-if-palindrome)
- [Задача о восьми ферзях](../tasks/eight-queens-puzzle)
- [Задача о рюкзаке + с сыпучими материалами](../tasks/knapsack)
- [Задача о рюкзаке, "жадный" вариант](../tasks/knapsack-greedy)
- [Задача о рюкзаке, метод "разделяй и властвуй"](../tasks/knapsack-divide-and-conquer)
- [Сортировка слиянием](../tasks/merge-sort)
- [Золотое сечение методом последовательных приближений](../tasks/golden-ratio)
- [Квадратный корень методом последовательных приближений](../tasks/square-root)
- [Метод Ньютона](../tasks/newtons-method)
- [Задача о лучшей сделке + с мемоизацией](../tasks/best-trade)
- [Сортировка вставками](../tasks/insertion-sort)
- [Быстрая сортировка](../tasks/quick-sort)

---

- "FizzBuzz"
- leetcode 1342, уменьшение числа до нуля (какая у него сложность?)
- find all the roots of a quadratic equation `ax2+bx+c=0`
- find the Fibonacci series till `term≤1000`
- check if number is prime
- find the first 100 prime numbers
- find Armstrong number (?)
- find the factorial value of a number
- задача про яд в бутылках

