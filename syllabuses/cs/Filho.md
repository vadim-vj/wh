# Фило В., Теоретический минимум по Computer Science. Все что нужно программисту и разработчику
- <https://www.piter.com/collection/all/product/teoreticheskiy-minimum-po-computer-science-vse-chto-nuzhno-programmistu-i-razrabotchiku>
- <https://code.energy/computer-science-distilled/>

Здесь книга часто используется только лишь как предметный указатель.

---
# Основы
---
## Идеи
---

### Блок-схемы

> *Блок-схема* - графическое представление алгоритма, (пошагового) метода решения задачи. Шаги изображаются в виде блоков, соединенных между собой линиями, указывающими направление последовательности. Как и псевдокод, это язык, способ описания/представления алгоритмов

1. Перечислите основные блоки и их назначение
   - *ограничитель* (Terminal; овал) - вход/выход во внешнюю среду, начало/останов
   - *действие* (Process; прямоугольник) - изменение данных
   - *вопрос*/*решение* (Decision; ромб) - выбор одной из нескольких ветвей выполнения
   - *ввод*/*вывод* (Input/Output; параллелограмм) - чтение или запись данных куда-л.
   - *функция* (Predefined Process; прямоугольник в доп. линиями) - именованная подпрограмма, определенна где-л.
   - *комментарий* (Comment; пунктирная линия с прямоугольной выноской) - любая доп. информация (напр., если текст не помещается в блоке)
   - *цикл* (Loop; пара прямоугольников со скошенными углами) - между ними располагаются повторяющиеся действия
   - *соединитель* (On-page Connector; кружок) - с цифрой внутри, соединяет разрыв линии и продолжает в другом месте
   - *соединительная линия* (Flowline/Arrowhead; линия со стрелкой) - указывает порядок действий

1. Для чего предназначен блок ... ? / Каким блоком описывается действие ... ?
   - см. пред. пункт

1. Для чего может быть использована блок-схема?
   - разработка и/или документирование простых процессов или программ (как пример - процесс редактирования страниц в Википедии)
   - визуализация процесса/программы, и, как следствие, упрощение понимания, что там происходит
   - поиск не самых очевидных моментов в алгоритме, таких как ошибки или узкие места (бутылочные горлышки)

1. На каком уровне детализации должны использоваться блок-схемы?
   - на высоком, они не должны использоваться для отображения кода и/или взаимодействующих частей программы. Для этого существует UML

1. Как обозначаются параллельные действия?
   - вход + перпендикулярная линия - параллельная ей линия + несколько перпендикулярных выходов

1. Как изобразить `switch` на блок-схеме?
   - ромб (напр, "Чему равно `i`") с одной выходящей линией, которая потом разветвляется на N выходов (как трезубец). Рядом с каждым выходом-стрелочкой указано значение `i`

1. Изобразите блок-схему алгоритма X
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Блок-схема>

---

### Псевдокод

> *Псевдокод* - компактный, зачастую неформальный язык описания алгоритмов, похожий на языки программирования, но опускающий детали. Предназначен для чтения человеком, а не машиной. Как и блок-схемы, это язык, способ описания/представления алгоритмов

1. Приведите пример инструкций псевдокода
   - `Set i to True`
   - `If i is divisible by 3`
   - `Read/Write i`
   - `While ... do`

1. В чем сходства и различия блок-схемы и псевдокода?
   - оба они представляют собой описание процессов/алгоритмов, но блок-схемы это описание графическое, а псевдокод - текстовое

1. Где используется псевдокод?
   - как и блок-схемы: в учебных материалах, в научно-технических публикациях, на начальной стадии разработки программ

1. Чему равно значение переменной после выполнения некоторого псевдокода?
   - ...

1. Напишите псевдокод для некоторого алгоритма
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Псевдокод_(язык_описания_алгоритмов)>

---

### Математические модели

> *Мат. модель* - это набор идей, которые описывают задачу и ее свойства с использованием математики. Математическое представление некоторой системы, позволяющее исследовать эту систему с использованием (как правило, мощного - в этом преимущество) математического аппарата

1. Постройте мат. модель площади прямоугольной фигуры
   - такая модель - это два уравнения (для площади и периметра), решить которые можно через подстановку одного в другое, получения квадратного уравнения, и нахождения его минимума/максимума. Задача `livestock-fence`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Математическая_модель>

---
## Логика
---

### Логические операторы

> *Логический оператор* или *логическая связка* - действие/операция над высказываниями - выражениями булевого типа. Служат для получения сложных логических выражений из более простых. Не-числовые (хотя в ЯП числа могут приводиться) - и операнды и результат имеют булев тип

1. Перечислите основные логические операторы
   - отрицание (Negation; `not`)
   - конъюнкция, Логическое "И" (Conjunction; `and`)
   - дизъюнкциия, Логическое "Или ("Disjunction; `or`)
   - строгая дизъюнкция, Исключающее "Или" (Exclusive disjunction; `xor`)
   - импликация (Implication; `if... then ...`)
   - эквиваленция, "Тогда и только тогда" (Biconditional; `if and only if`)

1. Как с этим в Python?
   - связки пишутся словами: `not`, `and`, `or`. Условие `if ...`. Исключающее "или" - через `!=`, `==` - эквиваленция

1. А в C++?
   - две эквивалентные формы записи: `!`/`not`, `&&`/`and`, `||`/`or`. Условие `if (...)`. `xor` ~ `!=`, `<=>` ~ `==`

1. Могут ли другие (не-bool) типы использоваться как логические операнды?
   - да. В некоторых языках программирования (например, в Си) вместо логического типа или одновременно с ним используются числовые типы. В этом случае считается, что отличное от нуля значение соответствует логической истине, а ноль — логической лжи

1. Как с этим в Python?
   - свободно используются, взаимозаменяемы
   - к `False` приводятся `None`, `0`, пустая строка и все пустые коллекции: `[]`, `{}`, `()`, а также объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно
   - связки `and`/`or` возвращают свои операнды, не булевы значения

1. А в C++?
   - неявно в `bool` могут преобразовываться числа (в том числе дробные), перечисления и указатели (в том числе литералы строк)
   - объекты могут преобразовываться, если определяют `::operator bool()`
   - связки `&&`/`||` возвращают булевы значения, не операнды
   - идиома `Safe bool` подразумевает объявление оператора `bool()` с ключевым словом `explicit`, чтобы объекты в выражениях случайно не приводились, например, к числам

1. Могут ли логические операторы применяться к битам?
   - да. Значение отдельного бита также можно рассматривать как логическое, если считать, что 1 означает "истинно", а 0 - "ложно". Это позволяет применять логические операции к отдельным битам, к битовым векторам покомпонентно и к числам в двоичном представлении поразрядно (побитовые логические операции)

1. Как с этим в Python?
   - сдвиги: `x << y`/`x >> y`, "и"/"или": `x & y`/`x | y`, дополнение: `~x`, "xor": `x ^ y`
   - эти уже словами не записываются

1. А в C++?
   - в точности такие же, как в Python

1. В какой момент вычисление логического выражения останавливается?
   - многие языки вычисляют логические связки по *короткой цепи*. Вычисление идет слева направо и останавливается, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

1. Как с этим в Python?
   - вычисления всегда идут по короткой цепи

1. А в C++?
   - по короткой цепи вычисления идут только для встроенных типов (то есть для built-in типов гарантирован и порядок вычисления операндов, и то, что второй может не вычисляться). Перегруженные операторы являются пользовательскими функциями, для них будут вычисляться оба аргумента, причем в неопределенном порядке

1. Запишите выражение X через предикаты и логические операторы
   - Пример: `if the pool is warm, I’ll swim`. Здесь `A = "the pool is warm"`, `B = "I swim"`, `A -> B = "if ... I'll ..."` (импликация)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

--- 

### Булева алгебра

> *Булева алгебра* - раздел математики, изучающий высказывания и операции над ними. Есть и формальное определение ("непустое множество с тремя операциями и выделенными значениями `true`/`false`")

1. Каковы приоритеты логических операторов?
   - скобки
   - `not`
   - `xor` / `<=>`
   - `and`
   - `or`
   - `if` (выполняется слева направо: `A -> B -> C`)

   Из-за того, что `!A == B` ~ `A != B` а операции `==`/`!=` имеют одинаковый приоритет, фактический приоритет `not` и `xor`/`<=>` неважен. В C++ `!` имеет приоритет выше `==`, в то время как в Python наоборот

1. Назовите основные аксиомы (свойства) булевых выражений
   - *коммутативность* - независимость результата бинарных операций (`and`/`or`) от порядка операндов: `A || B` ~ `B || A`
   - *ассоциативность* - независимость результата выражений с одинаковыми связками от расстановки скобок: `(A && B) && C` ~ `A && (B && C)   `
   - *дистрибутивность* - возможность раскрыть скобки: `(A || B) && C` ~ `A && C || A && C`. Дистрибутивность относительно логического    "или" (сложения) тоже работает, но особого смысла для нас не имеет
   - *законы де Моргана* - раскрытие скобок относительно отрицания. Связка меняется: `!(A && B)` ~ `!A || !B` и `!(A || B)` ~ `!A && !B`
   - еще довольно много, вроде *комплементности* (`A || !A` ~ `true`, `A && !A` ~ `false`), *инволютивности отрицания* (`!!A` ~ `A`), сложения/умножения на константы (`true`/`false`) и прочего

1. Как можно записать `if A: B else: C`/`if not A: B` по-другому?
   - через `A and B` (~ `if A: B`) и `A or C` (~ `else: C`)

1. Что такое противопоставление импликации?
   - запись `if`, в которой посыл и следствие меняются местами: `A -> B` ~ `!B -> !A`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Булева_алгебра>
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

---

### Таблицы истинности

> *Таблица истинности* - один из способов (табличный, наряду со словесным и аналитическим (через связки)) описания логической функции

1. Зачем может понадобится таблица истинности?
   - например, решить логическую задачу "в лоб". Сформулировав задачу в форме утверждений и логических связок, можно построить таблицу истинности и визуально найти все нужные случаи

1. Какие формы записи таких таблиц бывают?
   - для бинарных функций можно использовать квадратные таблицы: значения операндов расположить по строкам/столбцам, а значения функции в ячейках
   - универсальный способ - `N+1` столбцов и `2^N` строк со всеми комбинациями `true`/`false`. Последний столбец содержит значение функции

1. На сколько увеличивается таблица с добавлением новой переменной?
   - вдвое. Строк в ней `2^N`, так что `2^(N+1)` == `2 * 2^N`

1. Запишите таблицы истинности для `and`, `or`, `not`, `xor`
   - ...

1. Запишите таблицу истинности для импликации (`A -> B`)

   | A\B |  0  |  1  |
   | --: | --- | --- |
   |   0 |  1  |  1  |
   |   1 |  0  |  1  |

   Обратите внимание на ноль в левом нижнем углу (`1 -> 0`). Импликация как булева функция ложна лишь тогда, когда посылка истинна, а следствие ложно (`!A || B`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Таблица_истинности>

---

### Логика в вычислениях

> *Логический вентиль* - базовый элемент цифровой схемы, выполняющий элементарную логическую операцию. Интерпретирую результаты логических операций как биты, можно построить схемы преобразования чисел, например, двоичный сумматор (состоит из вентилей `and` и `xor`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логический_вентиль>

---
## Комбинаторика
---

### Правило умножения

> *Правило "и"* - если элемент A можно выбрать `N` способами, и при любом выборе A элемент B можно выбрать `M` способами, то пару (A, B) можно выбрать `N * M` способами. Примеры: игральные кубики - `N = 6`, `M = 6`, `N * M = 36`; `N` бросков монеты - `2 * 2 * 2 ...` (`N` раз) = `2 ^ N`

1. Сколько (максимально) попыток уйдет на подбор пин-кода в формате `A00`?
   - при фиксированном формате (1 + 2 / 2 + 1 / 1 + 1 + 1) - `26 x 100` = `2600`
   - при не-фиксированной позиции буквы/цифры - `(26 + 10) ^ 3` = `46656`
   - в общем случае, буквенно-цифровая (ASCII) последовательность из N символов имеет `36 ^ N` вариантов

1. Сколько чисел можно закодировать в N-ричной СС для числа длиной M?
   - `N` вариантов = основанию СС, умножается на себя `M` раз - `N ^ M`
   - например, в байте (`M = 8`) двоичной системы (`N = 2`) кодируется `N ^ M` = `2 ^ 8` = `256` чисел

1. I. Сколькими способами можно сформировать команду из 23 человек, подкидывая монету?
   - требует уточнения, что количество человек в команде не обязательно должно быть 23 (не обязательно заполнять все слоты)
   - аверс/реверс дают `N = 2`, кол-во бросков = кол-ву человек - `M = 23`, всего вариантов - `N ^ M` = `2 ^ 23` = `8388608`
   - упоминает вариант когда команда состоит из себя самого (хотя из условия такое не следует?)
   - крайние случаи: монета не выпала нужной стороной ни разу - `0` человек выбрано, монета выпадала всегда - `23` человека в команде

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Правило_умножения>

---

### Перестановки

> В комбинаторике *перестановка* - это упорядоченный набор элементов без повторений. Число возможных перестановок для `N` элементов - `N!`. `0!` == `1` - пустое множество можно упорядочить единственным способом.
> Первый элемент можно разместить `N` способами, остается `N - 1` свободных слотов. И так далее. Так получается факториал
> *Размещение* - это упорядоченное подмножество (размера `K`) из некоторого множества (размера `N`), по сути часть элементов перестановки. Количество возможных комбинаций - `N!/(N - K)!`. Фактически это "факториал", вычисляемый на интервале `(N-K, N]`, произведение всех чисел от `N - K + 1` до `N`

1. I. Задача о коммивояжере: найти кратчайший маршрут, позволяющий объехать `N` городов
   - строится квадратная матрица расстояний между городами
   - задача NP-полная, "решается" перебором всех перестановок городов, вычисления длины маршрута для каждой перестановки, и сравнением с текущим минимумом
   - уникальность города в перестановке гарантирует выполнение одного из условий задачи - отсутствия гамильтоновых циклов

1. Задача о мелодии: сколько всего возможных мелодий из 6ти нот (всего нот 13)?
   - здесь используется понятие размещения
   - количество комбинаций по `K = 6` из `N = 13` - `N!/(N - K)!` = `13!/7!` = `8*9*10*11*12*13` = `1 235 520`
   - в секундах это 343 часа, время неприемлемое

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Перестановка>
   - <https://ru.wikipedia.org/wiki/Размещение>

---

### Перестановки с повторениями

> Если часть элементов переставляемого множества одинаковы (повторяются), то их собственные взаимные перестановки не добавляют новых комбинаций (порядок не важен), и не должны учитываться. Для этого факториал делят на произведение факториалов кол-ва каждого повторяющегося элемента: `N!/(K1!K2!...)`. Так, например, в слове `CODEENERGY` букв `N = 10`, а буква `e` встречается в `K = 3` позициях. Общее количество перестановок - `N!/K!` = `10!/3!`

1. Задача о ДНК: сколько существует комбинаций в молекуле длиной 23, если 9 нуклеотидов должны быть A-T, а 14 - G-C?
   - `N = 23` - общее число нуклеотидов ("слотов"), `K1 = 9`, `K2 = 14` - "слоты", занятые одинаковыми элементами
   - общее число неповторяющихся перестановок - `N!/(K1!K2!)` = `23!/(9!14!)` = `817 190`
   - (хоть это и не указано в условии) каждая пара нуклеотидов может иметь 2 ориентации (напр., A-T/T-A). Так что получившееся число нужно еще домножить на кол-во способов выбора (по правилу умножения), на `2^23` (получится ~ 7 млрд.)

---

### Комбинации

> Объединение предыдущих пунктов. *Сочетание* или *комбинация* (здесь) - это размещение `K` элементов (`N!/(N - K)!`), у которого не важен порядок (`N!/K!`). Таким образом, получаем *бином* `(N K)` с числом комбинаций `N!/K!(N - K)!`. Это, например, кол-во комбинаций 6 карт из 13ти (без учета масти, порядок карт не важен). `(N K)` читается как "из N по K"

1. I. Задача о шахматных ферзях: сколькими способами можно произвольно расставить на доске 8 ферзей?
   - это не та знаменитая одноименная задача, а просто расчет кол-ва комбинаций
   - на доске `N = 64` клетки ("слота"), `K = 8` одинаковых ферзей ("элементов"), порядок их не важен
   - решение - `64!/(8!(64 - 8)!` ~ `4.4 млрд.`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Сочетание>

---

### Правило суммирования

> Для записи суммирования рядов используется символ большой греческой "сигма". Например, сумма первых пяти нечетных чисел - `[0...4] S(2i + 1)`
> Сумма первых `N` натуральных чисел равна `[1...N] Si` = `n(n + 1)/2` (формула Гаусса)

1. Задача о перелете: в ближайшие 30 дней нужно слетать в другой город, цена зависит от пары "день вылета - день возвращения". Сколько таких пар нужно перебрать, чтобы найти самую дешевую?
   - дата возвращения может быть равна дате отлета или позже, поэтому между первым (1) и последним (30) днем - 30 возможных пар
   - если брать "опорным" второй день, то между 2 и 30 таких пар уже 29, и так далее
   - таким образом, общее кол-во пар дней вылета-прилета - это сумма чисел от 1 до 30: `30(30 + 1)/2` = `465`
   - альтернативное решение - через сочетания `(N K)`, где `N = 30` и `K = 2`. Порядок не важен. `(30 2)` = 435, и + `30` - кол-во дней, когда дата вылета совпадает с датой прилета

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Ряд_из_натуральных_чисел>

---
## Вероятность
---

### Подсчет исходов

> (классическое определение) *Вероятностью* события называется отношение числа способов наступления события (числа элементарных событий, `n`) к общему числу возможных исходов `N`: `n/N`. Так, нечетных граней игрального кубика `n = 3`, а всего граней `N = 6`. Так что вероятность выпадения нечетной грани - `n/N` = `3/6` = `1/2`
> Такой подход работает потому, что вероятность наступления любого элементарного события ("благоприятного" исхода) одинакова

1. II. Снова набор команды из 23 человек путем подбрасывания монеты. Какова вероятность, что не возьмут никого?
   - граничный случай, 23 раза монета выпадала одной стороной
   - общее число вариантов - `N = 2^23`, и случай что никого не возьмут может произойти единственным способом (`n = 1`)
   - таким образом, вероятность `n/N` = `1/(2^23)`

1. Ссылки:
   - <https://ru.wikipedia.org/wiki/Вероятность#Классическое_определение>

---

### Независимые события

> Вероятности *независимых событий* перемножаются: `P = P1 * P2`. Так, например, одновременные бросок игрального кубика (`P1 = 1/6`) и монеты (`P2 = 1/2`) дадут вероятность выпадения "орла" + "6" `P = 1/6 * 1/2 = 1/12` ~ `8%`

1. Задача о резервном хранилище: что дешевле, один дорогой диск с вероятностью сбоя `P = 1/(10^9)` или несколько дешевых с `P = 1/2000` и ценой в 20% дорогого?
   - данные теряются когда все диски одновременно выходят из строя. Это независимые события, поэтому их вероятности перемножаются
   - уже 3 дешевых диска дадут вероятность сбоя в 8 раз ниже (`(1/2000)^3` = `1/(8 * 10^9)`), чем один дорогой
   - цена трех дешевых дисков при этом составит `3 * (0.2 * e)` = `0.6 *e`, то есть всего 60% от цены дорогого

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Вероятность#Независимость_событий>

---

### Несовместные события

> Два элементарных исхода (например, выпадение на кубике "4" и нечетного числа) являются *несовместимыми* (взаимно исключающими), если они не могут произойти одновременно. Таким образом, единственная их связь - `xor` ("либо"). Вероятности таких событий *складываются*: "A либо B" ~ `A xor B` = `P = P1 + P2`

1. Задача выбора подписки: провайдер предлагает три тарифа; известно, что бесплатный выбирают с вероятностью 70%, а два платных - с вероятностями 20% и 10%. Какова вероятность, что клиент подпишется на платный тариф?
   - несколько тарифов одновременно выбрать нельзя, поэтому события выбора - несовместные
   - а значит, они суммируются: `0.2 + 0.1` = `30%`

---

### Взаимодополняющие события

> Когда два несовместных события охватывают все возможные варианты, их называют *взаимодополняющими*. Сумма их вероятностей равна 100%. Пример - выпадение на кубике числа кратного и не кратного трем. `1/3 + 2/3` = `1`

1. Задача о защите замка. Каждая из пяти башен имеет вероятность 20% поразить врага. Каковы шансы его остановить?
   - мы ищем вероятность события "хотя бы одна башня попала"
   - события "башня поражает врага" не являются взаимодополняющими друг друга, они независимы, и их вероятности суммировать нельзя
   - событие "башня поражает врага" является взаимодополняющим для "башня промахнулась" (с `P = 1 - 0.2 = 0.8`)
   - вероятность события "все башни промахнулись" - произведение вероятностей независимых промахов каждой башни: `0.8^5` ~ `0.33`
   - и уже это последнее событие является взаимодополняющим для искомого. P("хотя бы одна башня попала") = `1 - 0.33` = `0.67`

1. Сcылки
   - <https://ru.wikipedia.org/wiki/Вероятность#Полная_вероятность_и_формула_Байеса>

---

### "Заблуждение игрока"

> Результаты предыдущих (независимых) событий никак не влияют на результат текущего. Десять раз подряд выпавший "орел" никак не увеличивает вероятность выпадения решки на одиннадцатом. Вероятность выигрыша в лотерее комбинации 1,2,3,4,5,6 ничуть не ниже, чем любой другой

---

### Более сложные вероятности

1. III. Снова набор команды из 23 человек путем подбрасывания монеты. Каковы шансы, что возьмут семь человек или меньше?
   - решается через биномиальное распределение, поиск его значений меньше семи: `B(23, 1/2) <= 7`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Биномиальное_распределение>
   - <https://ru.wikipedia.org/wiki/Принцип_Дирихле_(комбинаторика)>

---
# Вычислительная сложность
---

> *Обозначение* - `T(n)`, пример - сортировка колоды карт (`T(n) = n^2`). Можно вычислять, насколько возрастет время выполнения при увеличении числа карт в 2 раза - `T(2n)/T(n)` = `((2n)^2)/(n^2)` = `4`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Вычислительная_сложность>

---

## Надейтесь на лучшее, но готовьтесь к худшему

> Можно рассматривать *лучший* (напр., данные уже отсортированы), *средний* (данные в произвольном порядке) и *худший* (данные в обратном порядке) случаи. Худший случай - самый важный из всех, ориентироваться всегда нужно на него

---

## Оценка затрат времени

> *Временная сложность* - количество операций, требующихся алгоритму для набора входных данных размером `n`

1. Задача: (неустойчивая) сортировка выбором
   - рассматривается сам алгоритм, с вложенным циклом
   - внешний цикл - `N * (n - 1)` операций, где `N = 2 or 3` (присваивание, обмен, и опциональное сравнение индексов)
   - внутренний цикл выполняет `M * (n - 1)`, потом `M * (n - 2)` и т.д. операций, где `M = 2` (сравнение и присваивание). По формуле Гаусса это `n(n - 1)/2` = `(n^2 - n)/2`
   - отбросив константы и сложив, получим `T(n) = n^2 + n - 2`
   - проводит вычисления, из которых видно что с ростом `n` отношение `T(2n)/T(n)` стремится к `4`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Сортировка_выбором>

---

### Понимание роста затрат

> Самая быстрорастущая компонента в функции временной сложности называется *доминантным членом*. В предыдущем примере (сортировке выбором) это `n^2`

1. Задача об учетных карточках: насколько (по времени) затратнее отсортировать 10 коробок рассыпанных карточек, чем одну?
   - `T(10n)/T(n)` = `(10n)^2/n^2` = `100`
   - если использовать другую сортировку, например, "пузырьком", то для нее `T(n) = 0.5n^2 + 0.5n`. Но если для нее вычислить `T(10n)/T(n)`, то коэфф. `0.5` сократится, и будет получен тот же `10^2`
   - отсюда вывод, что константы не влияют на скорость роста, важен только доминантный член `n^2`
   - приводятся графики где видно, что с увеличением масштаба `n` функции `n^2`, `n^2 + n - 2` и `0.5n^2 + 0.5n` отличаются всё меньше

---

## Нотация "O большое"

> Через *O(n)* обозначаются классы функций временной сложности. Функция с доминантным членом, *растущим не быстрее* `n^2`,  обозначается как `O(n^2)`, и т.д.

[p.51] - график функций популярных классов сложности (в порядке увеличения скорости роста): `1`, `log(n)`, `n`, `n*log(n)`, `n^2`, `2^n`, `n!`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое>
   - <https://www.bigocheatsheet.com>

---

## Экспоненциальное время

> Такую временную сложность имеют алгоритмы с доминантой - *степенной функцией* (напр., `2^n`). Экспоненциальное время растет *так быстро*, что мы рассматриваем эти алгоритмы как невыполнимые

[p.51] - график сравнения функций сложности на меньшем масштабе: `n*log(n)`, `n^2`, `2^n`

> Аналогично, бесперспективными являются алгоритмы с факториальной сложностью (она растет еще быстрее). Эти классы сложности встречаются у *NP-полных* задач

1. Ссылки
   - <https://ru.wikipedia.org/wiki/NP-полная_задача>

---

## Оценка затрат памяти

> Мера рабочей области хранения, в которой нуждается алгоритм, называется *пространственной сложностью*. Ее анализ аналогичен временной. Часто приходится искать компромисс между этими двумя видами сложности

Пример - рассмотренная ранее сортировка выбором. В ней число используемых (вспомогательных) переменных не зависит от размера входных данных, поэтому ее пространственная сложность постоянна - `O(1)`

---
# Стратегия
---

## Итерация

1. Задача о списках рыб: объединить в сортированный список сортированные же списки морских и пресноводных рыб
   - один цикл, в котором из каждого списка берется первый элемент и сравнивается с первым элементов второго списка, после чего этот меньший элемент удаляется
   - граничные случаи - когда списки разной длины, и один уже пуст
   - количество проходов цикла равно длине более длинного списка, то есть его сложность `O(n)`

---

### Вложенные циклы и степенные множества

> *Степенное множество* - все подмножества коллекции объектов. Строится с использованием вложенных циклов

1. Задача об исследовании запахов: нужно построить множество всех комбинаций цветочных ароматов, если дано множество цветов F
   - начинаем с одного элемента - пустого множества, и на каждом шаге копируем все уже сгенерированные подмножества
   - дописываем в эту копию, в каждое подмножество, очередной цветок
   - объединяем копию с общим степенным множеством
   - добавление каждого цветка удваивает размер итогового степенного множества, т.е. сложность алгоритма - `O(2^n)`, экспоненциальная

Генерирование степенных множество похоже на генерацию таблиц истинности: каждый цветок - это логическая переменная, а `True`/`False` - входит он или не входит в подмножество

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Булеан>

---

## Рекурсия

> Рекурсивный алгоритм должен иметь *базовый случай*. Как правило это тогда, когда объем данных уже слишком мал, чтобы продолжать его сокращать

1. Числа Фибоначчи: сгенерировать последовательность, где каждое последующее число является суммой предыдущих
   - по определению, `fib(n) = fib(n - 1) + fib(n - 2)`
   - базовым случаем здесь будет `n <= 2` (`return 1`)

1. Задача: определить, является ли строка палиндромом
   - если первая и последняя буква не равны, вернуть `False`
   - иначе удалить первую и последнюю буквы и вызвать себя
   - базовый случай - пустое слово или слово из одной буквы

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Рекурсия>

---

### Рекурсия против итераций

> Рекурсивные алгоритмы могут выглядеть проще и изящнее, но это имеет вою цену - доп. затраты памяти и времени процессора на переключение контекста. Наглядно эта проблема демонстрируется на диаграммах - *деревьях рекурсивных вызовов*
> Рекурсивный алгоритм всегда можно переписать (возможно, в более громоздкой записи) в итеративном виде (`<!-- как? так ли это вообще?-->`)

1. Задача построения степенного множества рекурсивно
   - `<!-- вернуться позже, его подход непонятен -->`

---

## Полный перебор

1. Задача о лучшей сделке: найти в интервале времени пару дней, когда купив в один день и продав в другой, прибыль была бы максимальной
   - задача аналогична задаче о перелете (см. "Правила суммирования")
   - то есть решение методом грубой силы (перебором) потребует квадратичной сложности (`O(n^2)`)

1. I. Задача о рюкзаке: предметы обладают весом и ценой, а рюкзак имеет максимальную вместимость по весу. Нужно упаковать его так, чтобы стоимость выбранных предметов была максимальна
   - степенное множество предметов содержит все их возможные комбинации. Методом грубой силы можно перебрать их все и отсечь те, чей вес превышает вместимость рюкзака
   - одновременно с этим искать максимум по цене
   - т.к. идет перебор степенного множества, то сложность алгоритма экспоненциальная, `O(2^n)`
   - но т.к. некоторые комбинации предметов оставляют рюкзак полупустым, проверять следует не каждую. Хотя, вне зависимости от стратегии, задача о рюкзаке является NP-полной

1. Ссылки:
   - <https://ru.wikipedia.org/wiki/Задача_о_рюкзаке>

---

## Поиск (перебор) с возвратом

1. II. Задача о восьми ферзях: как разместить их на доске так, чтобы ни один из них не оказался под ударом других?
   - в задаче I было найдено число возможных размещений - более 4 млрд. Полный перебор нецелесообразен
   - кроме того, полный перебор будет просчитывать заведомо ненужные комбинации, например, когда первые размещенные два ферзя бьют друг друга. Более эффективный подход состоит в проверке только приемлемых позиций
   - при такой проверке мы, вероятно, уже на нескольких фигурах получим ситуацию, когда следующего ферзя разместить уже невозможно. В этом случае нужно будет *отойти назад* - вернуться к предыдущей позиции и продолжить поиск
   - поиск с возвратом лучше всего подходит для задач, где решением является последовательность вариантов, и выбор одного из них ограничивает выбор последующих. Ошибитесь как можно раньше, чтобы двигаться дальше

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Задача_о_восьми_ферзях>

---

## Эвристические алгоритмы

> Когда вариантов слишком много (даже, например, для поиска с возвратом), можно попробовать искать не оптимальное, но достаточно хорошее решение. *Эвристический метод*, или просто *эвристика*, - это метод, который приводит к решению, не гарантируя, что оно - лучшее или оптимальное. Пример - поиск без возврата

---

### "Жадные" алгоритмы

> Возврат на предыдущий шаг не происходит никогда, полная противоположность поиску с возвратом. На каждом шаге делается выбор и уже не подвергается сомнению

1. I. Задача о рюкзаке, "жадный" вариант - заполнение рюкзака самыми дорогими предметами
   - все вещи упорядочиваются по стоимости от больше к меньшей, и перебираются в цикле
   - если сумма текущего веса рюкзака + веса вещи всё еще меньше макс. вместимости, то вещь добавляется, иначе проверяем следующую (менее ценную)
   - такой алгоритм работает намного быстрее, но не дает никакой гарантии оптимальности

1. II. Задача о коммивояжере, "жадный" вариант - просто посещение всегда ближайшего города, пока не будут перебраны все города
   - `<!-- можно бы и написать код -->`

---

### Когда жадность побеждает силу

Иногда можно найти жадный алгоритм, дающий такое же решение, как и полный перебор

1. Задача об электрической цепи: как соединить все точки, чтобы длина соединений (проводов сети) была минимальной?
   - по сути, построение кратчайшего пути
   - выбираем ближайшую еще не соединенную точку; делаем "жадный" выбор
   - пишет, что такой подход будет оптимальным (почему?)

---

## Разделяй и властвуй

> При помощи этой стратегии особенно хорошо решаются задачи с *оптимальной подструктурой* - такие, которые легко делятся на подобные, но меньшие подзадачи

---

### Разделить и отсортировать

1. Сортировка слиянием
   - можно поделить список на части, отсортировать их, и потом объединить (см. выше задачу о списках рыб (слиянии сортированных списков))
   - делить каждый блок можно до 1 элемента (уже отсортированный список), это приводит к рекурсивному алгоритму

---

## На что обращать внимание

- задачи с упоминанием площади/периметра. Два уравнения, сводящиеся к одному квадратному, и поиску у того минимума и максимума. Пример - задача `livestock-fence`. В простейшем случае максимальной площадью из всех прямоугольников обладает квадрат
- уравнения (и другие мат. модели) не выражаются напрямую в коде, поэтому сначала на бумаге строятся рассуждения/уравнения как считать, и только потом по результатам преобразований пишется код
- задачи на естественном языке со словами вроде "если", "тогда, когда", "в случае": вычленять из текста утверждения (в виде коротких утверждений, напр., "сервер не работает", "вода теплая", "я плаваю") и обозначать их как логические переменные-высказывания (`A`, `B`, etc.). Слова вида "если", "буду", "когда" - превращать в логические операторы, напр., импликацию (и не забывать про "и", "или", "либо"). Переведя, таким образом, формулировку на естественном языке в предикат, упростить его, и найти все ответы (возможно построив таблицу истинности)
- всегда смотреть и проверять крайние случаи, граничные условия. Что будет, если кубик не выпал ни разу? Если кубик выпадал всегда? Если в данных нули / отрицательные числа / не ASCII-символы и т.д.
- при формулировке "от 1 до N" нужно учитывать, включается ли `N`, открыт ли интервал - `[1, N)` или `[1, N]`. Во втором случае в Python нужно использовать `range(n + 1)`. Ну и "от 1" означает `range(1, ...)`
- в вероятностных задачах с формулировкой "хотя бы один из ..." нужно искать вероятность "ни один из ... не ..." (произведение вероятностей взаимодополняющих событий). Пример - задача о защите замка

---

## Задачи

- [Наибольшее из трех чисел](../tasks/max-between-three)
- [Максимизация площади при фиксированном периметре](../tasks/livestock-fence)
- [При каких условиях отключится сервер?](../tasks/hot-server)
- [При каких условиях "хрупкая" БД будет работать?](../tasks/fragile-system)
- [Сколько комбинаций нужно для подбора PIN-кода](../tasks/cracking-the-code)
- [Задача коммивояжера](../tasks/travelling-salesman)
- [Сортировка выбором](../tasks/selection-sort)
- [Слияние упорядоченных списков](../tasks/merge-ordered-lists)
- [Исследование ароматов (построение степенного множества)](../tasks/power-set)
- [Рекурсивное построение степенного множества](../tasks/power-set-recursive)
- [Числа Фибоначчи](../tasks/fibonnacci-numbers)
- [Является ли слово палиндромом?](../tasks/check-if-palindrome)
- [Задача о восьми ферзях](../tasks/eight-queens-puzzle)
- [Задача о рюкзаке](../tasks/knapsack)
- [Задача о рюкзаке, "жадный" вариант](../tasks/knapsack-greedy)
- [Сортировка слиянием](../tasks/merge-sort)
- [Золотое сечение методом последовательных приближений](../tasks/golden-ratio)
- [Квадратный корень методом последовательных приближений](../tasks/square-root)
- [Метод Ньютона](../tasks/newtons-method)

---

- "FizzBuzz"
- leetcode 1342, уменьшение числа до нуля (какая у него сложность?)
- find all the roots of a quadratic equation `ax2+bx+c=0`
- find the Fibonacci series till `term≤1000`
- check if number is prime
- find the first 100 prime numbers
- find Armstrong number (?)
- find the factorial value of a number
- задача про яд в бутылках

