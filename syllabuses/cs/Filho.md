### Фило В., Теоретический минимум по Computer Science. Все что нужно программисту и разработчику
<https://www.piter.com/collection/all/product/teoreticheskiy-minimum-po-computer-science-vse-chto-nuzhno-programmistu-i-razrabotchiku>

---

### Основы

#### Идеи
- *блок-схемы*: кружками обозначаются начало и конец, прямоугольниками инструкции и состояния, ромбами - принятие решений
- *псевдокод*, как и блок-схемы, выражает вычислительные процессы
- в *математических моделях* можно использовать различные инструменты, например, теорию графов, алгебру/уравнения и т.д.

#### Логика
- *операторы*: импликация, `AND`, `OR`, `XOR`, `NOT`
- *булева алгебра*, свойства выражений: ассоциативность, дистрибутивность, правила де Моргана
- *таблицы истинности* для N переменных
- *логические вентили*, пример построения двоичного сумматора на них (`AND` и `XOR`)

#### Комбинаторика
- *правило умножения* - общее количество перестановок равно произведению вариантов в каждой позиции (`n1 * n2 * ...`)
- *перестановки* - `n` элементов можно упорядочить `n!` способами. Задача коммивояжера. Кол-во перестановок `m` из `n`: `n!/(n - m)!`
- *перестановки без повторений*, `n!/r!` (где `r` - кол-во идентичных элементов) (?)
- *комбинации*, кол-во перестановок `m` из `n` без повторений - `n!/r!(n - m)!`
- *правило суммирования*, суммы рядов, запись "сигма большая" и формула Гаусса для натуральных чисел: `S = n(n + 1)/2`

#### Вероятность
- *количество возможных вариантов*, вероятность равна частному от числа способов наступления события и числа всех возможных исходов
- *независимые (совместные) события*, для них вероятность равна произведению вероятностей отдельных событий (см. пред. пункт)
- *несовместимые события*, их вероятность равна сумме отдельных вероятностей
- *взаимодополняющие события*, сумма их вероятностей равна единице
- *заблуждение игрока* - предыдущие события никак не влияют на результат следующего независимого события
- *более сложные вероятности*, напр., биномиальное распределение

### Вычислительная сложность
- *лучший случай* - когда для любого объема входящих данных требуется минимальное кол-во операций
- *худший случай* - когда максимальное
- *средний случай* - между ними
- всегда следует ориентироваться/рассчитывать на худший случай

#### Оценка затрат времени
