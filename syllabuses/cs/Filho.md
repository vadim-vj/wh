# Фило В., Теоретический минимум по Computer Science. Все что нужно программисту и разработчику
- <https://www.piter.com/collection/all/product/teoreticheskiy-minimum-po-computer-science-vse-chto-nuzhno-programmistu-i-razrabotchiku>
- <https://code.energy/computer-science-distilled/>

Здесь книга часто используется только лишь как предметный указатель.

---
## Идеи
---

### Блок-схемы

> *Блок-схема* - графическое представление алгоритма, (пошагового) метода решения задачи. Шаги изображаются в виде блоков, соединенных между собой линиями, указывающими направление последовательности. Как и псевдокод, это язык, способ описания/представления алгоритмов

1. Перечислите основные блоки и их назначение
   - *ограничитель* (Terminal; овал) - вход/выход во внешнюю среду, начало/останов
   - *действие* (Process; прямоугольник) - изменение данных
   - *вопрос*/*решение* (Decision; ромб) - выбор одной из нескольких ветвей выполнения
   - *ввод*/*вывод* (Input/Output; параллелограмм) - чтение или запись данных куда-л.
   - *функция* (Predefined Process; прямоугольник в доп. линиями) - именованная подпрограмма, определенна где-л.
   - *комментарий* (Comment; пунктирная линия с прямоугольной выноской) - любая доп. информация (напр., если текст не помещается в блоке)
   - *цикл* (Loop; пара прямоугольников со скошенными углами) - между ними располагаются повторяющиеся действия
   - *соединитель* (On-page Connector; кружок) - с цифрой внутри, соединяет разрыв линии и продолжает в другом месте
   - *соединительная линия* (Flowline/Arrowhead; линия со стрелкой) - указывает порядок действий

1. Для чего предназначен блок ... ? / Каким блоком описывается действие ... ?
   - см. пред. пункт

1. Для чего может быть использована блок-схема?
   - разработка и/или документирование простых процессов или программ (как пример - процесс редактирования страниц в Википедии)
   - визуализация процесса/программы, и, как следствие, упрощение понимания, что там происходит
   - поиск не самых очевидных моментов в алгоритме, таких как ошибки или узкие места (бутылочные горлышки)

1. На каком уровне детализации должны использоваться блок-схемы?
   - на высоком, они не должны использоваться для отображения кода и/или взаимодействующих частей программы. Для этого существует UML

1. Как обозначаются параллельные действия?
   - вход + перпендикулярная линия - параллельная ей линия + несколько перпендикулярных выходов

1. Как изобразить `switch` на блок-схеме?
   - ромб (напр, "Чему равно `i`") с одной выходящей линией, которая потом разветвляется на N выходов (как трезубец). Рядом с каждым выходом-стрелочкой указано значение `i`

1. Изобразите блок-схему алгоритма X
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Блок-схема>

---

### Псевдокод

> *Псевдокод* - компактный, зачастую неформальный язык описания алгоритмов, похожий на языки программирования, но опускающий детали. Предназначен для чтения человеком, а не машиной. Как и блок-схемы, это язык, способ описания/представления алгоритмов

1. Приведите пример инструкций псевдокода
   - `Set i to True`
   - `If i is divisible by 3`
   - `Read/Write i`
   - `While ... do`

1. В чем сходства и различия блок-схемы и псевдокода?
   - оба они представляют собой описание процессов/алгоритмов, но блок-схемы это описание графическое, а псевдокод - текстовое

1. Где используется псевдокод?
   - как и блок-схемы: в учебных материалах, в научно-технических публикациях, на начальной стадии разработки программ

1. Чему равно значение переменной после выполнения некоторого псевдокода?
   - ...

1. Напишите псевдокод для некоторого алгоритма
   - ...
   - пример - задача `max-between-three`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Псевдокод_(язык_описания_алгоритмов)>

---

### Математические модели

> *Мат. модель* - это набор идей, которые описывают задачу и ее свойства с использованием математики. Математическое представление некоторой системы, позволяющее исследовать эту систему с использованием (как правило, мощного - в этом преимущество) математического аппарата

1. Постройте мат. модель площади прямоугольной фигуры
   - такая модель - это два уравнения (для площади и периметра), решить которые можно через подстановку одного в другое, получения квадратного уравнения, и нахождения его минимума/максимума. Задача `livestock-fence`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Математическая_модель>

---
## Логика
---

### Логические операторы

> *Логический оператор* или *логическая связка* - действие/операция над высказываниями - выражениями булевого типа. Служат для получения сложных логических выражений из более простых. Не-числовые (хотя в ЯП числа могут приводиться) - и операнды и результат имеют булев тип

1. Перечислите основные логические операторы
   - отрицание (Negation; `not`)
   - конъюнкция, Логическое "И" (Conjunction; `and`)
   - дизъюнкциия, Логическое "Или ("Disjunction; `or`)
   - строгая дизъюнкция, Исключающее "Или" (Exclusive disjunction; `xor`)
   - импликация (Implication; `if... then ...`)
   - эквиваленция, "Тогда и только тогда" (Biconditional; `if and only if`)

1. Как с этим в Python?
   - связки пишутся словами: `not`, `and`, `or`. Условие `if ...`. Исключающее "или" - через `!=`, `==` - эквиваленция

1. А в C++?
   - две эквивалентные формы записи: `!`/`not`, `&&`/`and`, `||`/`or`. Условие `if (...)`. `xor` ~ `!=`, `<=>` ~ `==`

1. Могут ли другие (не-bool) типы использоваться как логические операнды?
   - да. В некоторых языках программирования (например, в Си) вместо логического типа или одновременно с ним используются числовые типы. В этом случае считается, что отличное от нуля значение соответствует логической истине, а ноль — логической лжи

1. Как с этим в Python?
   - свободно используются, взаимозаменяемы
   - к `False` приводятся `None`, `0`, пустая строка и все пустые коллекции: `[]`, `{}`, `()`, а также объекты с перегруженными методами    `__bool__()` или `__len()__`, возвращающими `False` или `0` соответственно
   - связки `and`/`or` возвращают свои операнды, не булевы значения

1. А в C++?
   - неявно в `bool` могут преобразовываться числа (в том числе дробные), перечисления и указатели (в том числе литералы строк)
   - объекты могут преобразовываться, если определяют `::operator bool()`
   - связки `&&`/`||` возвращают булевы значения, не операнды
   - идиома `Safe bool` подразумевает объявление оператора `bool()` с ключевым словом `explicit`, чтобы объекты в выражениях случайно не приводились, например, к числам

1. Могут ли логические операторы применяться к битам?
   - да. Значение отдельного бита также можно рассматривать как логическое, если считать, что 1 означает "истинно", а 0 - "ложно". Это позволяет применять логические операции к отдельным битам, к битовым векторам покомпонентно и к числам в двоичном представлении поразрядно (побитовые логические операции)

1. Как с этим в Python?
   - сдвиги: `x << y`/`x >> y`, "и"/"или": `x & y`/`x | y`, дополнение: `~x`, "xor": `x ^ y`
   - эти уже словами не записываются

1. А в C++?
   - в точности такие же, как в Python

1. В какой момент вычисление логического выражения останавливается?
   - многие языки вычисляют логические связки по *короткой цепи*. Вычисление идет слева направо и останавливается, когда вычислено достаточно, чтобы знать значение всего выражения: `false && (anything)`, `true || (anything)`. В этих случаях `(anything)` не вычисляется

1. Как с этим в Python?
   - вычисления всегда идут по короткой цепи

1. А в C++?
   - по короткой цепи вычисления идут только для встроенных типов (то есть для built-in типов гарантирован и порядок вычисления операндов, и то, что второй может не вычисляться). Перегруженные операторы являются пользовательскими функциями, для них будут вычисляться оба аргумента, причем в неопределенном порядке

1. Запишите выражение X через предикаты и логические операторы
   - Пример: `if the pool is warm, I’ll swim`. Здесь `A = "the pool is warm"`, `B = "I swim"`, `A -> B = "if ... I'll ..."` (импликация)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

--- 

### Булева алгебра

> *Булева алгебра* - раздел математики, изучающий высказывания и операции над ними. Есть и формальное определение ("непустое множество с тремя операциями и выделенными значениями `true`/`false`")

1. Каковы приоритеты логических операторов?
   - скобки
   - `not`
   - `xor` / `<=>`
   - `and`
   - `or`
   - `if` (выполняется слева направо: `A -> B -> C`)

   Из-за того, что `!A == B` ~ `A != B` а операции `==`/`!=` имеют одинаковый приоритет, фактический приоритет `not` и `xor`/`<=>` неважен. В C++ `!` имеет приоритет выше `==`, в то время как в Python наоборот

1. Назовите основные аксиомы (свойства) булевых выражений
   - *коммутативность* - независимость результата бинарных операций (`and`/`or`) от порядка операндов: `A || B` ~ `B || A`
   - *ассоциативность* - независимость результата выражений с одинаковыми связками от расстановки скобок: `(A && B) && C` ~ `A && (B && C)   `
   - *дистрибутивность* - возможность раскрыть скобки: `(A || B) && C` ~ `A && C || A && C`. Дистрибутивность относительно логического    "или" (сложения) тоже работает, но особого смысла для нас не имеет
   - *законы де Моргана* - раскрытие скобок относительно отрицания. Связка меняется: `!(A && B)` ~ `!A || !B` и `!(A || B)` ~ `!A && !B`
   - еще довольно много, вроде *комплементности* (`A || !A` ~ `true`, `A && !A` ~ `false`), *инволютивности отрицания* (`!!A` ~ `A`), сложения/умножения на константы (`true`/`false`) и прочего

1. Как можно записать `if A: B else: C`/`if not A: B` по-другому?
   - через `A and B` (~ `if A: B`) и `A or C` (~ `else: C`)

1. Что такое противопоставление импликации?
   - запись `if`, в которой посыл и следствие меняются местами: `A -> B` ~ `!B -> !A`

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Булева_алгебра>
   - <https://ru.wikipedia.org/wiki/Логическая_операция>

---

### Таблицы истинности

> *Таблица истинности* - один из способов (табличный, наряду со словесным и аналитическим (через связки)) описания логической функции

1. Зачем может понадобится таблица истинности?
   - например, решить логическую задачу "в лоб". Сформулировав задачу в форме утверждений и логических связок, можно построить таблицу истинности и визуально найти все нужные случаи

1. Какие формы записи таких таблиц бывают?
   - для бинарных функций можно использовать квадратные таблицы: значения операндов расположить по строкам/столбцам, а значения функции в ячейках
   - универсальный способ - `N+1` столбцов и `2^N` строк со всеми комбинациями `true`/`false`. Последний столбец содержит значение функции

1. На сколько увеличивается таблица с добавлением новой переменной?
   - вдвое. Строк в ней `2^N`, так что `2^(N+1)` == `2 * 2^N`

1. Запишите таблицы истинности для `and`, `or`, `not`, `xor`
   - ...

1. Запишите таблицу истинности для импликации (`A -> B`)

    A \ B |  0  |  1
   ------ | --- | ---
       0  |  1  |  1
       1  |  0  |  1

   Единственно отличие от очевидной таблицы эквивалентности (равенства) - единица в правом верхнем углу (`0 -> 1`). Импликация как булева функция ложна лишь тогда, когда посылка истинна, а следствие ложно (`!A || B`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Таблица_истинности>

---

#### Логика в вычислениях

> *Логический вентиль* - базовый элемент цифровой схемы, выполняющий элементарную логическую операцию. Интерпретирую результаты логических операций как биты, можно построить схемы преобразования чисел, например, двоичный сумматор (состоит из вентилей `and` и `xor`)

1. Ссылки
   - <https://ru.wikipedia.org/wiki/Логический_вентиль>

---
## Комбинаторика
---

### Правило умножения

---

## На что обращать внимание
- задачи с упоминанием площади/периметра. Два уравнения, сводящиеся к одному квадратному, и поиску у того минимума и максимума. Пример - задача `livestock-fence`. В простейшем случае максимальной площадью из всех прямоугольников обладает квадрат
- уравнения (и другие мат. модели) не выражаются напрямую в коде, поэтому сначала на бумаге строятся рассуждения/уравнения как считать, и только потом по результатам преобразований пишется код
- задачи на естественном языке со словами вроде "если", "тогда, когда", "в случае": вычленять из текста утверждения (в виде коротких утверждений, напр., "сервер не работает", "вода теплая", "я плаваю") и обозначать их как логические переменные-высказывания (`A`, `B`, etc.). Слова вида "если", "буду", "когда" - превращать в логические операторы, напр., импликацию (и не забывать про "и", "или", "либо"). Переведя, таким образом, формулировку на естественном языке в предикат, упростить его, и найти все ответы (возможно построив таблицу истинности)

---

## Задачи
- [Наибольшее из трех чисел](../tasks/max-between-three)
- [Максимизация площади при фиксированном периметре](../tasks/livestock-fence)
- [При каких условиях отключится сервер?](../tasks/hot-server)
- [При каких условиях "хрупкая" БД будет работать?](../tasks/fragile-system)

---

- "FizzBuzz"
- find all the roots of a quadratic equation `ax2+bx+c=0`
- find the Fibonacci series till `term≤1000`
- check if number is prime
- find the first 100 prime numbers
- find Armstrong number (?)
- find the factorial value of a number

